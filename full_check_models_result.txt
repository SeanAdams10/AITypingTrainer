models\category.py: error: Source file found twice under different module names: "AITypingTrainer.models.category" and "models.category"
models\category.py: note: See https://mypy.readthedocs.io/en/stable/running_mypy.html#mapping-file-paths-to-modules for more info
models\category.py: note: Common resolutions include: a) adding `__init__.py` somewhere, b) using `--explicit-package-bases` or adjusting MYPYPATH
Found 1 error in 1 file (errors prevented further checking)
models\__init__.py:1:1: D212 [*] Multi-line docstring summary should start at the first line
  |
1 | / """
2 | | Models package for AI Typing Trainer.
3 | |
4 | | This package contains all the data models and related functionality.
5 | | """
  | |___^ D212
6 |
7 |   # Import key modules to make them available at the package level
  |
  = help: Remove whitespace after opening quotes

models\category.py:1:1: D205 1 blank line required between summary line and description
  |
1 | / """
2 | | Category data model.
3 | | Defines the structure and validation for a category.
4 | | """
  | |___^ D205
5 |
6 |   from __future__ import annotations
  |
  = help: Insert single blank line

models\category.py:1:1: D212 [*] Multi-line docstring summary should start at the first line
  |
1 | / """
2 | | Category data model.
3 | | Defines the structure and validation for a category.
4 | | """
  | |___^ D212
5 |
6 |   from __future__ import annotations
  |
  = help: Remove whitespace after opening quotes

models\category.py:57:9: D102 Missing docstring in public method
   |
55 |     @model_validator(mode="before")
56 |     @classmethod
57 |     def ensure_category_id(cls, values: dict) -> dict:
   |         ^^^^^^^^^^^^^^^^^^ D102
58 |         if not values.get("category_id"):
59 |             values["category_id"] = str(uuid4())
   |

models\category_manager.py:1:1: D205 1 blank line required between summary line and description
  |
1 | / """
2 | | Category Manager for CRUD operations.
3 | | Handles all DB access for categories.
4 | | """
  | |___^ D205
5 |
6 |   from typing import List, Optional
  |
  = help: Insert single blank line

models\category_manager.py:1:1: D212 [*] Multi-line docstring summary should start at the first line
  |
1 | / """
2 | | Category Manager for CRUD operations.
3 | | Handles all DB access for categories.
4 | | """
  | |___^ D212
5 |
6 |   from typing import List, Optional
  |
  = help: Remove whitespace after opening quotes

models\category_manager.py:19:9: D107 Missing docstring in `__init__`
   |
17 |     """
18 |
19 |     def __init__(self, message: str = "Category validation failed") -> None:
   |         ^^^^^^^^ D107
20 |         self.message = message
21 |         super().__init__(self.message)
   |

models\category_manager.py:31:9: D107 Missing docstring in `__init__`
   |
29 |     """
30 |
31 |     def __init__(self, message: str = "Category not found") -> None:
   |         ^^^^^^^^ D107
32 |         self.message = message
33 |         super().__init__(self.message)
   |

models\category_manager.py:37:5: D200 One-line docstring should fit on one line
   |
36 |   class CategoryManager:
37 | /     """
38 | |     Manager for CRUD operations on Category, using DatabaseManager for DB access.
39 | |     """
   | |_______^ D200
40 |
41 |       def __init__(self, db_manager: DatabaseManager) -> None:
   |
   = help: Reformat to one line

models\category_manager.py:37:5: D212 [*] Multi-line docstring summary should start at the first line
   |
36 |   class CategoryManager:
37 | /     """
38 | |     Manager for CRUD operations on Category, using DatabaseManager for DB access.
39 | |     """
   | |_______^ D212
40 |
41 |       def __init__(self, db_manager: DatabaseManager) -> None:
   |
   = help: Remove whitespace after opening quotes

models\category_manager.py:42:9: D200 One-line docstring should fit on one line
   |
41 |       def __init__(self, db_manager: DatabaseManager) -> None:
42 | /         """
43 | |         Initialize CategoryManager with a DatabaseManager instance.
44 | |         """
   | |___________^ D200
45 |           self.db_manager: DatabaseManager = db_manager
   |
   = help: Reformat to one line

models\category_manager.py:42:9: D212 [*] Multi-line docstring summary should start at the first line
   |
41 |       def __init__(self, db_manager: DatabaseManager) -> None:
42 | /         """
43 | |         Initialize CategoryManager with a DatabaseManager instance.
44 | |         """
   | |___________^ D212
45 |           self.db_manager: DatabaseManager = db_manager
   |
   = help: Remove whitespace after opening quotes

models\category_manager.py:50:9: D205 1 blank line required between summary line and description
   |
48 |           self, category_name: str, category_id: Optional[str] = None
49 |       ) -> None:
50 | /         """
51 | |         Validate category name for database uniqueness.
52 | |         This complements the Pydantic model's format validation.
53 | |
54 | |         Args:
55 | |             category_name: The category name to validate.
56 | |             category_id: The ID of the category being updated, if any.
57 | |
58 | |         Raises:
59 | |             CategoryValidationError: If the name is not unique.
60 | |         """
   | |___________^ D205
61 |           query = "SELECT 1 FROM categories WHERE category_name = ?"
62 |           params = [category_name]
   |
   = help: Insert single blank line

models\category_manager.py:50:9: D212 [*] Multi-line docstring summary should start at the first line
   |
48 |           self, category_name: str, category_id: Optional[str] = None
49 |       ) -> None:
50 | /         """
51 | |         Validate category name for database uniqueness.
52 | |         This complements the Pydantic model's format validation.
53 | |
54 | |         Args:
55 | |             category_name: The category name to validate.
56 | |             category_id: The ID of the category being updated, if any.
57 | |
58 | |         Raises:
59 | |             CategoryValidationError: If the name is not unique.
60 | |         """
   | |___________^ D212
61 |           query = "SELECT 1 FROM categories WHERE category_name = ?"
62 |           params = [category_name]
   |
   = help: Remove whitespace after opening quotes

models\category_manager.py:72:9: D205 1 blank line required between summary line and description
   |
71 |       def get_category_by_id(self, category_id: str) -> Category:
72 | /         """
73 | |         Retrieve a single category by ID.
74 | |         Args:
75 | |             category_id: The ID of the category to retrieve.
76 | |         Returns:
77 | |             Category: The category with the specified ID.
78 | |         Raises:
79 | |             CategoryNotFound: If no category exists with the specified ID.
80 | |         """
   | |___________^ D205
81 |           row = self.db_manager.execute(
82 |               "SELECT category_id, category_name FROM categories WHERE category_id = ?",
   |
   = help: Insert single blank line

models\category_manager.py:72:9: D212 [*] Multi-line docstring summary should start at the first line
   |
71 |       def get_category_by_id(self, category_id: str) -> Category:
72 | /         """
73 | |         Retrieve a single category by ID.
74 | |         Args:
75 | |             category_id: The ID of the category to retrieve.
76 | |         Returns:
77 | |             Category: The category with the specified ID.
78 | |         Raises:
79 | |             CategoryNotFound: If no category exists with the specified ID.
80 | |         """
   | |___________^ D212
81 |           row = self.db_manager.execute(
82 |               "SELECT category_id, category_name FROM categories WHERE category_id = ?",
   |
   = help: Remove whitespace after opening quotes

models\category_manager.py:74:9: D410 [*] Missing blank line after section ("Args")
   |
72 |         """
73 |         Retrieve a single category by ID.
74 |         Args:
   |         ^^^^ D410
75 |             category_id: The ID of the category to retrieve.
76 |         Returns:
   |
   = help: Add blank line after "Args"

models\category_manager.py:74:9: D411 [*] Missing blank line before section ("Args")
   |
72 |         """
73 |         Retrieve a single category by ID.
74 |         Args:
   |         ^^^^ D411
75 |             category_id: The ID of the category to retrieve.
76 |         Returns:
   |
   = help: Add blank line before "Args"

models\category_manager.py:76:9: D410 [*] Missing blank line after section ("Returns")
   |
74 |         Args:
75 |             category_id: The ID of the category to retrieve.
76 |         Returns:
   |         ^^^^^^^ D410
77 |             Category: The category with the specified ID.
78 |         Raises:
   |
   = help: Add blank line after "Returns"

models\category_manager.py:76:9: D411 [*] Missing blank line before section ("Returns")
   |
74 |         Args:
75 |             category_id: The ID of the category to retrieve.
76 |         Returns:
   |         ^^^^^^^ D411
77 |             Category: The category with the specified ID.
78 |         Raises:
   |
   = help: Add blank line before "Returns"

models\category_manager.py:78:9: D411 [*] Missing blank line before section ("Raises")
   |
76 |         Returns:
77 |             Category: The category with the specified ID.
78 |         Raises:
   |         ^^^^^^ D411
79 |             CategoryNotFound: If no category exists with the specified ID.
80 |         """
   |
   = help: Add blank line before "Raises"

models\category_manager.py:90:9: D205 1 blank line required between summary line and description
    |
 89 |       def get_category_by_name(self, category_name: str) -> Category:
 90 | /         """
 91 | |         Retrieve a single category by name.
 92 | |         Args:
 93 | |             category_name: The name of the category to retrieve.
 94 | |         Returns:
 95 | |             Category: The category with the specified name.
 96 | |         Raises:
 97 | |             CategoryNotFound: If no category exists with the specified name.
 98 | |         """
    | |___________^ D205
 99 |           row = self.db_manager.execute(
100 |               "SELECT category_id, category_name FROM categories WHERE category_name = ?",
    |
    = help: Insert single blank line

models\category_manager.py:90:9: D212 [*] Multi-line docstring summary should start at the first line
    |
 89 |       def get_category_by_name(self, category_name: str) -> Category:
 90 | /         """
 91 | |         Retrieve a single category by name.
 92 | |         Args:
 93 | |             category_name: The name of the category to retrieve.
 94 | |         Returns:
 95 | |             Category: The category with the specified name.
 96 | |         Raises:
 97 | |             CategoryNotFound: If no category exists with the specified name.
 98 | |         """
    | |___________^ D212
 99 |           row = self.db_manager.execute(
100 |               "SELECT category_id, category_name FROM categories WHERE category_name = ?",
    |
    = help: Remove whitespace after opening quotes

models\category_manager.py:92:9: D410 [*] Missing blank line after section ("Args")
   |
90 |         """
91 |         Retrieve a single category by name.
92 |         Args:
   |         ^^^^ D410
93 |             category_name: The name of the category to retrieve.
94 |         Returns:
   |
   = help: Add blank line after "Args"

models\category_manager.py:92:9: D411 [*] Missing blank line before section ("Args")
   |
90 |         """
91 |         Retrieve a single category by name.
92 |         Args:
   |         ^^^^ D411
93 |             category_name: The name of the category to retrieve.
94 |         Returns:
   |
   = help: Add blank line before "Args"

models\category_manager.py:94:9: D410 [*] Missing blank line after section ("Returns")
   |
92 |         Args:
93 |             category_name: The name of the category to retrieve.
94 |         Returns:
   |         ^^^^^^^ D410
95 |             Category: The category with the specified name.
96 |         Raises:
   |
   = help: Add blank line after "Returns"

models\category_manager.py:94:9: D411 [*] Missing blank line before section ("Returns")
   |
92 |         Args:
93 |             category_name: The name of the category to retrieve.
94 |         Returns:
   |         ^^^^^^^ D411
95 |             Category: The category with the specified name.
96 |         Raises:
   |
   = help: Add blank line before "Returns"

models\category_manager.py:96:9: D411 [*] Missing blank line before section ("Raises")
   |
94 |         Returns:
95 |             Category: The category with the specified name.
96 |         Raises:
   |         ^^^^^^ D411
97 |             CategoryNotFound: If no category exists with the specified name.
98 |         """
   |
   = help: Add blank line before "Raises"

models\category_manager.py:108:9: D205 1 blank line required between summary line and description
    |
107 |       def list_all_categories(self) -> List[Category]:
108 | /         """
109 | |         List all categories in the database.
110 | |         Returns:
111 | |             List[Category]: All categories, ordered by name.
112 | |         """
    | |___________^ D205
113 |           rows = self.db_manager.execute(
114 |               "SELECT category_id, category_name FROM categories ORDER BY category_name"
    |
    = help: Insert single blank line

models\category_manager.py:108:9: D212 [*] Multi-line docstring summary should start at the first line
    |
107 |       def list_all_categories(self) -> List[Category]:
108 | /         """
109 | |         List all categories in the database.
110 | |         Returns:
111 | |             List[Category]: All categories, ordered by name.
112 | |         """
    | |___________^ D212
113 |           rows = self.db_manager.execute(
114 |               "SELECT category_id, category_name FROM categories ORDER BY category_name"
    |
    = help: Remove whitespace after opening quotes

models\category_manager.py:110:9: D411 [*] Missing blank line before section ("Returns")
    |
108 |         """
109 |         List all categories in the database.
110 |         Returns:
    |         ^^^^^^^ D411
111 |             List[Category]: All categories, ordered by name.
112 |         """
    |
    = help: Add blank line before "Returns"

models\category_manager.py:125:9: D205 1 blank line required between summary line and description
    |
124 |       def save_category(self, category: Category) -> bool:
125 | /         """
126 | |         Insert or update a category in the DB. Returns True if successful.
127 | |         Args:
128 | |             category: The Category object to save.
129 | |         Returns:
130 | |             True if the category was inserted or updated successfully.
131 | |         Raises:
132 | |             CategoryValidationError: If the category name is not unique.
133 | |             ValueError: If validation fails (e.g., invalid data).
134 | |             DatabaseError: If a database operation fails.
135 | |         """
    | |___________^ D205
136 |           # Explicitly validate uniqueness before DB operation
137 |           self._validate_name_uniqueness(category.category_name, category.category_id)
    |
    = help: Insert single blank line

models\category_manager.py:125:9: D212 [*] Multi-line docstring summary should start at the first line
    |
124 |       def save_category(self, category: Category) -> bool:
125 | /         """
126 | |         Insert or update a category in the DB. Returns True if successful.
127 | |         Args:
128 | |             category: The Category object to save.
129 | |         Returns:
130 | |             True if the category was inserted or updated successfully.
131 | |         Raises:
132 | |             CategoryValidationError: If the category name is not unique.
133 | |             ValueError: If validation fails (e.g., invalid data).
134 | |             DatabaseError: If a database operation fails.
135 | |         """
    | |___________^ D212
136 |           # Explicitly validate uniqueness before DB operation
137 |           self._validate_name_uniqueness(category.category_name, category.category_id)
    |
    = help: Remove whitespace after opening quotes

models\category_manager.py:127:9: D410 [*] Missing blank line after section ("Args")
    |
125 |         """
126 |         Insert or update a category in the DB. Returns True if successful.
127 |         Args:
    |         ^^^^ D410
128 |             category: The Category object to save.
129 |         Returns:
    |
    = help: Add blank line after "Args"

models\category_manager.py:127:9: D411 [*] Missing blank line before section ("Args")
    |
125 |         """
126 |         Insert or update a category in the DB. Returns True if successful.
127 |         Args:
    |         ^^^^ D411
128 |             category: The Category object to save.
129 |         Returns:
    |
    = help: Add blank line before "Args"

models\category_manager.py:129:9: D410 [*] Missing blank line after section ("Returns")
    |
127 |         Args:
128 |             category: The Category object to save.
129 |         Returns:
    |         ^^^^^^^ D410
130 |             True if the category was inserted or updated successfully.
131 |         Raises:
    |
    = help: Add blank line after "Returns"

models\category_manager.py:129:9: D411 [*] Missing blank line before section ("Returns")
    |
127 |         Args:
128 |             category: The Category object to save.
129 |         Returns:
    |         ^^^^^^^ D411
130 |             True if the category was inserted or updated successfully.
131 |         Raises:
    |
    = help: Add blank line before "Returns"

models\category_manager.py:131:9: D411 [*] Missing blank line before section ("Raises")
    |
129 |         Returns:
130 |             True if the category was inserted or updated successfully.
131 |         Raises:
    |         ^^^^^^ D411
132 |             CategoryValidationError: If the category name is not unique.
133 |             ValueError: If validation fails (e.g., invalid data).
    |
    = help: Add blank line before "Raises"

models\category_manager.py:164:9: D212 [*] Multi-line docstring summary should start at the first line
    |
163 |       def delete_category_by_id(self, category_id: str) -> bool:
164 | /         """
165 | |         Delete a category by its ID.
166 | |
167 | |         Returns:
168 | |             bool: True if deleted, False if not found.
169 | |
170 | |         Note:
171 | |             Cascades to delete associated snippets and snippet_parts if DB schema
172 | |             supports it.
173 | |         """
    | |___________^ D212
174 |           # Ensure the category exists
175 |           if not self.db_manager.execute(
    |
    = help: Remove whitespace after opening quotes

models\category_manager.py:187:9: D212 [*] Multi-line docstring summary should start at the first line
    |
186 |       def delete_category(self, category_id: str) -> bool:
187 | /         """
188 | |         Delete a category by its ID.
189 | |
190 | |         This is an alias for delete_category_by_id for test compatibility.
191 | |         """
    | |___________^ D212
192 |           return self.delete_category_by_id(category_id)
    |
    = help: Remove whitespace after opening quotes

models\category_manager.py:195:9: D205 1 blank line required between summary line and description
    |
194 |       def delete_all_categories(self) -> bool:
195 | /         """
196 | |         Delete all categories from the database.
197 | |         Returns True if any were deleted, False if already empty.
198 | |         """
    | |___________^ D205
199 |           count = self.db_manager.execute("SELECT COUNT(*) FROM categories").fetchone()[0]
200 |           self.db_manager.execute("DELETE FROM categories")
    |
    = help: Insert single blank line

models\category_manager.py:195:9: D212 [*] Multi-line docstring summary should start at the first line
    |
194 |       def delete_all_categories(self) -> bool:
195 | /         """
196 | |         Delete all categories from the database.
197 | |         Returns True if any were deleted, False if already empty.
198 | |         """
    | |___________^ D212
199 |           count = self.db_manager.execute("SELECT COUNT(*) FROM categories").fetchone()[0]
200 |           self.db_manager.execute("DELETE FROM categories")
    |
    = help: Remove whitespace after opening quotes

models\category_manager.py:204:9: D212 [*] Multi-line docstring summary should start at the first line
    |
203 |       def create_dynamic_category(self) -> str:
204 | /         """
205 | |         Create or retrieve a category named 'Custom Snippets' for dynamic content.
206 | |         
207 | |         This method ensures that a standard category exists for dynamic and custom
208 | |         snippets generated by the application. If the category already exists,
209 | |         it returns the existing category's ID. If not, it creates the category
210 | |         and returns the new ID.
211 | |         
212 | |         Returns:
213 | |             str: The category_id of the 'Custom Snippets' category
214 | |             
215 | |         Raises:
216 | |             CategoryValidationError: If there are validation issues
217 | |             DatabaseError: If database operations fail
218 | |         """
    | |___________^ D212
219 |           category_name = "Custom Snippets"
220 |           try:
    |
    = help: Remove whitespace after opening quotes

models\dynamic_content_manager.py:1:1: D205 1 blank line required between summary line and description
  |
1 | / """
2 | | Dynamic Content Manager for generating typing practice content.
3 | | Handles different generation modes (NGramOnly, WordsOnly, Mixed)
4 | | for customizable practice.
5 | | """
  | |___^ D205
6 |
7 |   import random
  |
  = help: Insert single blank line

models\dynamic_content_manager.py:1:1: D212 [*] Multi-line docstring summary should start at the first line
  |
1 | / """
2 | | Dynamic Content Manager for generating typing practice content.
3 | | Handles different generation modes (NGramOnly, WordsOnly, Mixed)
4 | | for customizable practice.
5 | | """
  | |___^ D212
6 |
7 |   import random
  |
  = help: Remove whitespace after opening quotes

models\dynamic_content_manager.py:23:5: D205 1 blank line required between summary line and description
   |
22 |   class DynamicContentManager:
23 | /     """
24 | |     Manager for generating dynamic typing practice content based on
25 | |     specified parameters.
26 | |
27 | |     Supports different content generation modes:
28 | |     - NGramOnly: Uses only the specified ngrams
29 | |     - WordsOnly: Uses words containing the specified ngrams and in-scope keys
30 | |     - Mixed: Combination of both ngram sequences and words
31 | |     """
   | |_______^ D205
32 |
33 |       def __init__(
   |
   = help: Insert single blank line

models\dynamic_content_manager.py:23:5: D212 [*] Multi-line docstring summary should start at the first line
   |
22 |   class DynamicContentManager:
23 | /     """
24 | |     Manager for generating dynamic typing practice content based on
25 | |     specified parameters.
26 | |
27 | |     Supports different content generation modes:
28 | |     - NGramOnly: Uses only the specified ngrams
29 | |     - WordsOnly: Uses words containing the specified ngrams and in-scope keys
30 | |     - Mixed: Combination of both ngram sequences and words
31 | |     """
   | |_______^ D212
32 |
33 |       def __init__(
   |
   = help: Remove whitespace after opening quotes

models\dynamic_content_manager.py:41:9: D212 [*] Multi-line docstring summary should start at the first line
   |
39 |           llm_service: Optional[LLMNgramService] = None,
40 |       ) -> None:
41 | /         """
42 | |         Initialize the DynamicContentManager with customizable parameters.
43 | |
44 | |         Args:
45 | |             in_scope_keys: List of characters (keyboard keys) that are allowed
46 | |                 in generated content
47 | |             practice_length: Maximum length of generated content (1-1000 characters)
48 | |             ngram_focus_list: List of ngrams to focus on in the generated content
49 | |             mode: Content generation mode (NGramOnly, WordsOnly, or Mixed)
50 | |             llm_service: Optional LLMNgramService instance for word generation
51 | |         """
   | |___________^ D212
52 |           self.in_scope_keys: List[str] = in_scope_keys or []
53 |           self._set_practice_length(practice_length)
   |
   = help: Remove whitespace after opening quotes

models\dynamic_content_manager.py:142:9: D205 1 blank line required between summary line and description
    |
141 |       def _generate_words_content(self, max_length: int, delimiter: str) -> str:
142 | /         """
143 | |         Generate content using words that contain the focus ngrams
144 | |         and only use in-scope keys.
145 | |         Requires the LLM service.
146 | |         """
    | |___________^ D205
147 |           if not self.llm_service:
148 |               return ""
    |
    = help: Insert single blank line

models\dynamic_content_manager.py:142:9: D212 [*] Multi-line docstring summary should start at the first line
    |
141 |       def _generate_words_content(self, max_length: int, delimiter: str) -> str:
142 | /         """
143 | |         Generate content using words that contain the focus ngrams
144 | |         and only use in-scope keys.
145 | |         Requires the LLM service.
146 | |         """
    | |___________^ D212
147 |           if not self.llm_service:
148 |               return ""
    |
    = help: Remove whitespace after opening quotes

models\dynamic_content_manager.py:247:9: D212 [*] Multi-line docstring summary should start at the first line
    |
246 |       def generate_content(self, delimiter: str = " ") -> str:
247 | /         """
248 | |         Generate typing practice content based on the configured parameters.
249 | |
250 | |         Args:
251 | |             delimiter: String to use between ngrams/words (default: space)
252 | |
253 | |         Returns:
254 | |             Generated practice content string
255 | |
256 | |         Raises:
257 | |             ValueError: If required parameters are missing or invalid
258 | |         """
    | |___________^ D212
259 |           self._validate_requirements()
    |
    = help: Remove whitespace after opening quotes

models\dynamic_content_service.py:1:1: D205 1 blank line required between summary line and description
  |
1 | / """
2 | | Dynamic Content Service for generating typing practice content.
3 | | Handles different generation modes (NGramOnly, WordsOnly, Mixed)
4 | | for customizable practice.
5 | | """
  | |___^ D205
6 |
7 |   import random
  |
  = help: Insert single blank line

models\dynamic_content_service.py:1:1: D212 [*] Multi-line docstring summary should start at the first line
  |
1 | / """
2 | | Dynamic Content Service for generating typing practice content.
3 | | Handles different generation modes (NGramOnly, WordsOnly, Mixed)
4 | | for customizable practice.
5 | | """
  | |___^ D212
6 |
7 |   import random
  |
  = help: Remove whitespace after opening quotes

models\dynamic_content_service.py:25:5: D205 1 blank line required between summary line and description
   |
24 |   class DynamicContentService:
25 | /     """
26 | |     Service for generating dynamic typing practice content based on
27 | |     specified parameters.
28 | |
29 | |     Supports different content generation modes:
30 | |     - NGramOnly: Uses only the specified ngrams
31 | |     - WordsOnly: Uses words containing the specified ngrams and in-scope keys
32 | |     - Mixed: Combination of both ngram sequences and words
33 | |     """
   | |_______^ D205
34 |
35 |       def __init__(
   |
   = help: Insert single blank line

models\dynamic_content_service.py:25:5: D212 [*] Multi-line docstring summary should start at the first line
   |
24 |   class DynamicContentService:
25 | /     """
26 | |     Service for generating dynamic typing practice content based on
27 | |     specified parameters.
28 | |
29 | |     Supports different content generation modes:
30 | |     - NGramOnly: Uses only the specified ngrams
31 | |     - WordsOnly: Uses words containing the specified ngrams and in-scope keys
32 | |     - Mixed: Combination of both ngram sequences and words
33 | |     """
   | |_______^ D212
34 |
35 |       def __init__(
   |
   = help: Remove whitespace after opening quotes

models\dynamic_content_service.py:43:9: D212 [*] Multi-line docstring summary should start at the first line
   |
41 |           llm_service: Optional[LLMNgramService] = None,
42 |       ) -> None:
43 | /         """
44 | |         Initialize the DynamicContentService with customizable parameters.
45 | |
46 | |         Args:
47 | |             in_scope_keys: List of characters (keyboard keys) that are allowed
48 | |                 in generated content
49 | |             practice_length: Maximum length of generated content (1-1000 characters)
50 | |             ngram_focus_list: List of ngrams to focus on in the generated content
51 | |             mode: Content generation mode (NGramOnly, WordsOnly, or Mixed)
52 | |             llm_service: Optional LLMNgramService instance for word generation
53 | |         """
   | |___________^ D212
54 |           self.in_scope_keys: List[str] = in_scope_keys or []
55 |           self._set_practice_length(practice_length)
   |
   = help: Remove whitespace after opening quotes

models\dynamic_content_service.py:144:9: D205 1 blank line required between summary line and description
    |
143 |       def _generate_words_content(self, max_length: int, delimiter: str) -> str:
144 | /         """
145 | |         Generate content using words that contain the focus ngrams
146 | |         and only use in-scope keys.
147 | |         Requires the LLM service.
148 | |         """
    | |___________^ D205
149 |           if not self.llm_service:
150 |               raise ValueError("LLM service is required for word generation")
    |
    = help: Insert single blank line

models\dynamic_content_service.py:144:9: D212 [*] Multi-line docstring summary should start at the first line
    |
143 |       def _generate_words_content(self, max_length: int, delimiter: str) -> str:
144 | /         """
145 | |         Generate content using words that contain the focus ngrams
146 | |         and only use in-scope keys.
147 | |         Requires the LLM service.
148 | |         """
    | |___________^ D212
149 |           if not self.llm_service:
150 |               raise ValueError("LLM service is required for word generation")
    |
    = help: Remove whitespace after opening quotes

models\dynamic_content_service.py:249:9: D212 [*] Multi-line docstring summary should start at the first line
    |
248 |       def generate_content(self, delimiter: str = " ") -> str:
249 | /         """
250 | |         Generate typing practice content based on the configured parameters.
251 | |
252 | |         Args:
253 | |             delimiter: String to use between ngrams/words (default: space)
254 | |
255 | |         Returns:
256 | |             Generated practice content string
257 | |
258 | |         Raises:
259 | |             ValueError: If required parameters are missing or invalid
260 | |         """
    | |___________^ D212
261 |           self._validate_requirements()
    |
    = help: Remove whitespace after opening quotes

models\dynamic_content_service.py:271:9: D205 1 blank line required between summary line and description
    |
270 |       def ensure_dynamic_snippet_id(self, category_manager: CategoryManager, snippet_manager: SnippetManager) -> str:
271 | /         """
272 | |         Ensure a valid dynamic snippet_id exists by coordinating with
273 | |         CategoryManager and SnippetManager.
274 | |
275 | |         This method:
276 | |         1. Uses CategoryManager.create_dynamic_category() to get the
277 | |            "Custom Snippets" category_id
278 | |         2. Uses SnippetManager.create_dynamic_snippet() to get or create a
279 | |            dynamic snippet
280 | |         3. Returns the snippet_id for use in typing drills
281 | |
282 | |         Args:
283 | |             category_manager: CategoryManager instance for category operations
284 | |             snippet_manager: SnippetManager instance for snippet operations
285 | |
286 | |         Returns:
287 | |             str: The snippet_id of the dynamic snippet that can be used in
288 | |             typing drills
289 | |
290 | |         Raises:
291 | |             Exception: If category or snippet creation fails
292 | |         """
    | |___________^ D205
293 |           try:
294 |               # Step 1: Ensure "Custom Snippets" category exists and get its ID
    |
    = help: Insert single blank line

models\dynamic_content_service.py:271:9: D212 [*] Multi-line docstring summary should start at the first line
    |
270 |       def ensure_dynamic_snippet_id(self, category_manager: CategoryManager, snippet_manager: SnippetManager) -> str:
271 | /         """
272 | |         Ensure a valid dynamic snippet_id exists by coordinating with
273 | |         CategoryManager and SnippetManager.
274 | |
275 | |         This method:
276 | |         1. Uses CategoryManager.create_dynamic_category() to get the
277 | |            "Custom Snippets" category_id
278 | |         2. Uses SnippetManager.create_dynamic_snippet() to get or create a
279 | |            dynamic snippet
280 | |         3. Returns the snippet_id for use in typing drills
281 | |
282 | |         Args:
283 | |             category_manager: CategoryManager instance for category operations
284 | |             snippet_manager: SnippetManager instance for snippet operations
285 | |
286 | |         Returns:
287 | |             str: The snippet_id of the dynamic snippet that can be used in
288 | |             typing drills
289 | |
290 | |         Raises:
291 | |             Exception: If category or snippet creation fails
292 | |         """
    | |___________^ D212
293 |           try:
294 |               # Step 1: Ensure "Custom Snippets" category exists and get its ID
    |
    = help: Remove whitespace after opening quotes

models\keyboard.py:1:1: D205 1 blank line required between summary line and description
  |
1 | / """
2 | | Keyboard data model.
3 | | Defines the structure and validation for a keyboard.
4 | | """
  | |___^ D205
5 |
6 |   from __future__ import annotations
  |
  = help: Insert single blank line

models\keyboard.py:1:1: D212 [*] Multi-line docstring summary should start at the first line
  |
1 | / """
2 | | Keyboard data model.
3 | | Defines the structure and validation for a keyboard.
4 | | """
  | |___^ D212
5 |
6 |   from __future__ import annotations
  |
  = help: Remove whitespace after opening quotes

models\keyboard.py:15:5: D205 1 blank line required between summary line and description
   |
14 |   class Keyboard(BaseModel):
15 | /     """Keyboard data model with validation.
16 | |     Attributes:
17 | |         keyboard_id: Unique identifier for the keyboard (UUID string).
18 | |         user_id: UUID string, foreign key to user table.
19 | |         keyboard_name: Name of the keyboard (ASCII, 1-64 chars).
20 | |         target_ms_per_keystroke: Target milliseconds per keystroke for speed goal
21 | |         (integer).
22 | |     """
   | |_______^ D205
23 |
24 |       keyboard_id: str | None = None
   |
   = help: Insert single blank line

models\keyboard.py:16:5: D411 [*] Missing blank line before section ("Attributes")
   |
14 | class Keyboard(BaseModel):
15 |     """Keyboard data model with validation.
16 |     Attributes:
   |     ^^^^^^^^^^ D411
17 |         keyboard_id: Unique identifier for the keyboard (UUID string).
18 |         user_id: UUID string, foreign key to user table.
   |
   = help: Add blank line before "Attributes"

models\keyboard.py:33:9: D102 Missing docstring in public method
   |
31 |     @field_validator("keyboard_name")
32 |     @classmethod
33 |     def validate_keyboard_name(cls, v: str) -> str:
   |         ^^^^^^^^^^^^^^^^^^^^^^ D102
34 |         if not v or not v.strip():
35 |             raise ValueError("Keyboard name cannot be blank.")
   |

models\keyboard.py:45:9: D102 Missing docstring in public method
   |
43 |     @field_validator("target_ms_per_keystroke")
44 |     @classmethod
45 |     def validate_target_ms_per_keystroke(cls, v: int) -> int:
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
46 |         if v is None:
47 |             raise ValueError("Target milliseconds per keystroke cannot be None.")
   |

models\keyboard.py:58:9: D102 Missing docstring in public method
   |
56 |     @model_validator(mode="before")
57 |     @classmethod
58 |     def ensure_keyboard_id(cls, values: dict) -> dict:
   |         ^^^^^^^^^^^^^^^^^^ D102
59 |         if not values.get("keyboard_id"):
60 |             values["keyboard_id"] = str(uuid4())
   |

models\keyboard.py:65:9: D102 Missing docstring in public method
   |
63 |     @field_validator("keyboard_id")
64 |     @classmethod
65 |     def validate_keyboard_id(cls, v: str) -> str:
   |         ^^^^^^^^^^^^^^^^^^^^ D102
66 |         if not v:
67 |             raise ValueError("keyboard_id must not be empty")
   |

models\keyboard.py:76:9: D102 Missing docstring in public method
   |
74 |     @field_validator("user_id")
75 |     @classmethod
76 |     def validate_user_id(cls, v: str) -> str:
   |         ^^^^^^^^^^^^^^^^ D102
77 |         if not v:
78 |             raise ValueError("user_id must not be empty")
   |

models\keyboard.py:85:9: D102 Missing docstring in public method
   |
83 |         return v
84 |
85 |     def to_dict(self) -> Dict[str, Any]:
   |         ^^^^^^^ D102
86 |         return self.dict()
   |

models\keyboard.py:89:9: D102 Missing docstring in public method
   |
88 |     @classmethod
89 |     def from_dict(cls, d: Dict[str, Any]) -> "Keyboard":
   |         ^^^^^^^^^ D102
90 |         allowed = set(cls.model_fields.keys())
91 |         extra = set(d.keys()) - allowed
   |

models\keyboard_manager.py:1:1: D205 1 blank line required between summary line and description
  |
1 | / """
2 | | Keyboard Manager for CRUD operations.
3 | | Handles all DB access for keyboards.
4 | | """
  | |___^ D205
5 |
6 |   from typing import List, Optional
  |
  = help: Insert single blank line

models\keyboard_manager.py:1:1: D212 [*] Multi-line docstring summary should start at the first line
  |
1 | / """
2 | | Keyboard Manager for CRUD operations.
3 | | Handles all DB access for keyboards.
4 | | """
  | |___^ D212
5 |
6 |   from typing import List, Optional
  |
  = help: Remove whitespace after opening quotes

models\keyboard_manager.py:12:7: D101 Missing docstring in public class
   |
12 | class KeyboardValidationError(Exception):
   |       ^^^^^^^^^^^^^^^^^^^^^^^ D101
13 |     def __init__(self, message: str = "Keyboard validation failed") -> None:
14 |         self.message = message
   |

models\keyboard_manager.py:13:9: D107 Missing docstring in `__init__`
   |
12 | class KeyboardValidationError(Exception):
13 |     def __init__(self, message: str = "Keyboard validation failed") -> None:
   |         ^^^^^^^^ D107
14 |         self.message = message
15 |         super().__init__(self.message)
   |

models\keyboard_manager.py:18:7: D101 Missing docstring in public class
   |
18 | class KeyboardNotFound(Exception):
   |       ^^^^^^^^^^^^^^^^ D101
19 |     def __init__(self, message: str = "Keyboard not found") -> None:
20 |         self.message = message
   |

models\keyboard_manager.py:19:9: D107 Missing docstring in `__init__`
   |
18 | class KeyboardNotFound(Exception):
19 |     def __init__(self, message: str = "Keyboard not found") -> None:
   |         ^^^^^^^^ D107
20 |         self.message = message
21 |         super().__init__(self.message)
   |

models\keyboard_manager.py:24:7: D101 Missing docstring in public class
   |
24 | class KeyboardManager:
   |       ^^^^^^^^^^^^^^^ D101
25 |     def __init__(self, db_manager: DatabaseManager) -> None:
26 |         self.db_manager: DatabaseManager = db_manager
   |

models\keyboard_manager.py:25:9: D107 Missing docstring in `__init__`
   |
24 | class KeyboardManager:
25 |     def __init__(self, db_manager: DatabaseManager) -> None:
   |         ^^^^^^^^ D107
26 |         self.db_manager: DatabaseManager = db_manager
   |

models\keyboard_manager.py:41:9: D102 Missing docstring in public method
   |
39 |             )
40 |
41 |     def get_keyboard_by_id(self, keyboard_id: str) -> Keyboard:
   |         ^^^^^^^^^^^^^^^^^^ D102
42 |         row = self.db_manager.execute(
43 |             """
   |

models\keyboard_manager.py:59:9: D102 Missing docstring in public method
   |
57 |         )
58 |
59 |     def list_keyboards_for_user(self, user_id: str) -> List[Keyboard]:
   |         ^^^^^^^^^^^^^^^^^^^^^^^ D102
60 |         rows = self.db_manager.execute(
61 |             """
   |

models\keyboard_manager.py:78:9: D102 Missing docstring in public method
   |
76 |         ]
77 |
78 |     def save_keyboard(self, keyboard: Keyboard) -> bool:
   |         ^^^^^^^^^^^^^ D102
79 |         self._validate_name_uniqueness(
80 |             keyboard.keyboard_name, keyboard.user_id, keyboard.keyboard_id
   |

models\keyboard_manager.py:128:9: D102 Missing docstring in public method
    |
126 |         return True
127 |
128 |     def delete_keyboard_by_id(self, keyboard_id: str) -> bool:
    |         ^^^^^^^^^^^^^^^^^^^^^ D102
129 |         if not self.db_manager.execute(
130 |             "SELECT 1 FROM keyboards WHERE keyboard_id = ?",
    |

models\keyboard_manager.py:140:9: D102 Missing docstring in public method
    |
138 |         return True
139 |
140 |     def delete_keyboard(self, keyboard_id: str) -> bool:
    |         ^^^^^^^^^^^^^^^ D102
141 |         return self.delete_keyboard_by_id(keyboard_id)
    |

models\keyboard_manager.py:143:9: D102 Missing docstring in public method
    |
141 |         return self.delete_keyboard_by_id(keyboard_id)
142 |
143 |     def delete_all_keyboards(self) -> bool:
    |         ^^^^^^^^^^^^^^^^^^^^ D102
144 |         count = self.db_manager.execute("SELECT COUNT(*) FROM keyboards").fetchone()[0]
145 |         self.db_manager.execute("DELETE FROM keyboards")
    |

models\keystroke.py:1:1: D200 One-line docstring should fit on one line
  |
1 | / """
2 | | Keystroke model for tracking keystrokes during practice sessions.
3 | | """
  | |___^ D200
4 |
5 |   import datetime
  |
  = help: Reformat to one line

models\keystroke.py:1:1: D212 [*] Multi-line docstring summary should start at the first line
  |
1 | / """
2 | | Keystroke model for tracking keystrokes during practice sessions.
3 | | """
  | |___^ D212
4 |
5 |   import datetime
  |
  = help: Remove whitespace after opening quotes

models\keystroke.py:18:5: D200 One-line docstring should fit on one line
   |
17 |   class Keystroke(BaseModel):
18 | /     """
19 | |     Pydantic model for tracking individual keystrokes in practice sessions.
20 | |     """
   | |_______^ D200
21 |
22 |       session_id: Optional[str] = None
   |
   = help: Reformat to one line

models\keystroke.py:18:5: D212 [*] Multi-line docstring summary should start at the first line
   |
17 |   class Keystroke(BaseModel):
18 | /     """
19 | |     Pydantic model for tracking individual keystrokes in practice sessions.
20 | |     """
   | |_______^ D212
21 |
22 |       session_id: Optional[str] = None
   |
   = help: Remove whitespace after opening quotes

models\keystroke.py:166:9: D212 [*] Multi-line docstring summary should start at the first line
    |
164 |       @classmethod
165 |       def delete_all_keystrokes(cls, db: DatabaseManager) -> bool:
166 | /         """
167 | |         Delete all keystrokes from the database.
168 | |
169 | |         This will clear the session_keystrokes table.
170 | |
171 | |         Args:
172 | |             db: DatabaseManager instance to use for the operation
173 | |
174 | |         Returns:
175 | |             bool: True if successful, False otherwise
176 | |         """
    | |___________^ D212
177 |           try:
178 |               logger.info("Deleting all keystrokes from database")
    |
    = help: Remove whitespace after opening quotes

models\keystroke_manager.py:1:1: D100 Missing docstring in public module
models\keystroke_manager.py:8:5: D200 One-line docstring should fit on one line
   |
 7 |   class KeystrokeManager:
 8 | /     """
 9 | |     Manager class for handling keystroke operations in the database.
10 | |     """
   | |_______^ D200
11 |
12 |       def __init__(self, db_manager: Optional[DatabaseManager] = None) -> None:
   |
   = help: Reformat to one line

models\keystroke_manager.py:8:5: D212 [*] Multi-line docstring summary should start at the first line
   |
 7 |   class KeystrokeManager:
 8 | /     """
 9 | |     Manager class for handling keystroke operations in the database.
10 | |     """
   | |_______^ D212
11 |
12 |       def __init__(self, db_manager: Optional[DatabaseManager] = None) -> None:
   |
   = help: Remove whitespace after opening quotes

models\keystroke_manager.py:12:9: D107 Missing docstring in `__init__`
   |
10 |     """
11 |
12 |     def __init__(self, db_manager: Optional[DatabaseManager] = None) -> None:
   |         ^^^^^^^^ D107
13 |         self.db_manager = db_manager or DatabaseManager()
14 |         self.keystroke_list: List[Keystroke] = []
   |

models\keystroke_manager.py:17:9: D200 One-line docstring should fit on one line
   |
16 |       def add_keystroke(self, keystroke: Keystroke) -> None:
17 | /         """
18 | |         Add a single keystroke to the in-memory list.
19 | |         """
   | |___________^ D200
20 |           self.keystroke_list.append(keystroke)
   |
   = help: Reformat to one line

models\keystroke_manager.py:17:9: D212 [*] Multi-line docstring summary should start at the first line
   |
16 |       def add_keystroke(self, keystroke: Keystroke) -> None:
17 | /         """
18 | |         Add a single keystroke to the in-memory list.
19 | |         """
   | |___________^ D212
20 |           self.keystroke_list.append(keystroke)
   |
   = help: Remove whitespace after opening quotes

models\keystroke_manager.py:23:9: D200 One-line docstring should fit on one line
   |
22 |       def get_keystrokes_for_session(self, session_id: str) -> List[Keystroke]:
23 | /         """
24 | |         Populate keystroke_list with all keystrokes for a session from the DB.
25 | |         """
   | |___________^ D200
26 |           self.keystroke_list = Keystroke.get_for_session(session_id)
27 |           return self.keystroke_list
   |
   = help: Reformat to one line

models\keystroke_manager.py:23:9: D212 [*] Multi-line docstring summary should start at the first line
   |
22 |       def get_keystrokes_for_session(self, session_id: str) -> List[Keystroke]:
23 | /         """
24 | |         Populate keystroke_list with all keystrokes for a session from the DB.
25 | |         """
   | |___________^ D212
26 |           self.keystroke_list = Keystroke.get_for_session(session_id)
27 |           return self.keystroke_list
   |
   = help: Remove whitespace after opening quotes

models\keystroke_manager.py:30:9: D205 1 blank line required between summary line and description
   |
29 |       def save_keystrokes(self) -> bool:
30 | /         """
31 | |         Save all keystrokes in the in-memory list to the database.
32 | |         Returns True if all are saved successfully, False otherwise.
33 | |         """
   | |___________^ D205
34 |           try:
35 |               if not self.keystroke_list:
   |
   = help: Insert single blank line

models\keystroke_manager.py:30:9: D212 [*] Multi-line docstring summary should start at the first line
   |
29 |       def save_keystrokes(self) -> bool:
30 | /         """
31 | |         Save all keystrokes in the in-memory list to the database.
32 | |         Returns True if all are saved successfully, False otherwise.
33 | |         """
   | |___________^ D212
34 |           try:
35 |               if not self.keystroke_list:
   |
   = help: Remove whitespace after opening quotes

models\keystroke_manager.py:78:9: D212 [*] Multi-line docstring summary should start at the first line
   |
77 |       def delete_keystrokes_by_session(self, session_id: str) -> bool:
78 | /         """
79 | |         Delete all keystrokes for a given session ID.
80 | |
81 | |         Args:
82 | |             session_id: UUID string of the session to delete keystrokes for
83 | |
84 | |         Returns:
85 | |             bool: True if successful, False otherwise
86 | |         """
   | |___________^ D212
87 |           try:
88 |               self.db_manager.execute(
   |
   = help: Remove whitespace after opening quotes

models\keystroke_manager.py:104:9: D205 1 blank line required between summary line and description
    |
103 |       def delete_all_keystrokes(self) -> bool:
104 | /         """
105 | |         Delete all keystrokes from the session_keystrokes table.
106 | |         Returns True if successful, False otherwise.
107 | |         """
    | |___________^ D205
108 |           try:
109 |               self.db_manager.execute("DELETE FROM session_keystrokes")
    |
    = help: Insert single blank line

models\keystroke_manager.py:104:9: D212 [*] Multi-line docstring summary should start at the first line
    |
103 |       def delete_all_keystrokes(self) -> bool:
104 | /         """
105 | |         Delete all keystrokes from the session_keystrokes table.
106 | |         Returns True if successful, False otherwise.
107 | |         """
    | |___________^ D212
108 |           try:
109 |               self.db_manager.execute("DELETE FROM session_keystrokes")
    |
    = help: Remove whitespace after opening quotes

models\keystroke_manager.py:116:9: D212 [*] Multi-line docstring summary should start at the first line
    |
115 |       def count_keystrokes_per_session(self, session_id: str) -> int:
116 | /         """
117 | |         Count the number of keystrokes for a specific session.
118 | |
119 | |         Args:
120 | |             session_id: The ID of the session to count keystrokes for (UUID string)
121 | |
122 | |         Returns:
123 | |             int: The number of keystrokes for the session, or 0 if an error occurs
124 | |         """
    | |___________^ D212
125 |           try:
126 |               result = self.db_manager.fetchone(
    |
    = help: Remove whitespace after opening quotes

models\library.py:1:1: D205 1 blank line required between summary line and description
  |
1 | / """
2 | | Library models and manager for Snippets Library (categories, snippets, snippet parts).
3 | | Implements all CRUD, validation, and business logic for the Snippets Library.
4 | | """
  | |___^ D205
5 |
6 |   # Standard library imports
  |
  = help: Insert single blank line

models\library.py:1:1: D212 [*] Multi-line docstring summary should start at the first line
  |
1 | / """
2 | | Library models and manager for Snippets Library (categories, snippets, snippet parts).
3 | | Implements all CRUD, validation, and business logic for the Snippets Library.
4 | | """
  | |___^ D212
5 |
6 |   # Standard library imports
  |
  = help: Remove whitespace after opening quotes

models\library.py:24:5: D205 1 blank line required between summary line and description
   |
23 |   class LibraryManager:
24 | /     """
25 | |     Manages categories and snippets for the Snippets Library using the new
26 | |     models and managers.
27 | |     All DB operations are parameterized. Validation is enforced via Pydantic and
28 | |     explicit checks.
29 | |     """
   | |_______^ D205
30 |
31 |       def __init__(self, db_manager: DatabaseManager) -> None:
   |
   = help: Insert single blank line

models\library.py:24:5: D212 [*] Multi-line docstring summary should start at the first line
   |
23 |   class LibraryManager:
24 | /     """
25 | |     Manages categories and snippets for the Snippets Library using the new
26 | |     models and managers.
27 | |     All DB operations are parameterized. Validation is enforced via Pydantic and
28 | |     explicit checks.
29 | |     """
   | |_______^ D212
30 |
31 |       def __init__(self, db_manager: DatabaseManager) -> None:
   |
   = help: Remove whitespace after opening quotes

models\library.py:31:9: D107 Missing docstring in `__init__`
   |
29 |     """
30 |
31 |     def __init__(self, db_manager: DatabaseManager) -> None:
   |         ^^^^^^^^ D107
32 |         self.db = db_manager
33 |         self.category_manager = CategoryManager(db_manager)
   |

models\library.py:42:9: D212 [*] Multi-line docstring summary should start at the first line
   |
41 |       def create_category(self, name: str) -> str:
42 | /         """
43 | |         Create a new category with the given name.
44 | |
45 | |         Args:
46 | |             name: The name of the category to create
47 | |
48 | |         Returns:
49 | |             str: The ID of the created category
50 | |
51 | |         Raises:
52 | |             CategoryValidationError: If the category name is invalid
53 | |         """
   | |___________^ D212
54 |           category = Category(category_name=name, description="")
55 |           self.category_manager.save_category(category)
   |
   = help: Remove whitespace after opening quotes

models\library.py:60:9: D102 Missing docstring in public method
   |
58 |         return str(category.category_id)
59 |
60 |     def rename_category(self, category_id: str, new_name: str) -> None:
   |         ^^^^^^^^^^^^^^^ D102
61 |         try:
62 |             category = self.category_manager.get_category_by_id(category_id)
   |

models\library.py:68:9: D102 Missing docstring in public method
   |
66 |             raise
67 |
68 |     def delete_category(self, category_id: str) -> bool:
   |         ^^^^^^^^^^^^^^^ D102
69 |         try:
70 |             return self.category_manager.delete_category_by_id(category_id)
   |

models\library.py:75:9: D102 Missing docstring in public method
   |
74 |     # SNIPPET CRUD
75 |     def list_snippets(self, category_id: str) -> List[Snippet]:
   |         ^^^^^^^^^^^^^ D102
76 |         return self.snippet_manager.list_snippets_by_category(category_id)
   |

models\library.py:79:9: D212 [*] Multi-line docstring summary should start at the first line
   |
78 |       def create_snippet(self, category_id: str, name: str, content: str) -> str:
79 | /         """
80 | |         Create a new snippet in the specified category.
81 | |
82 | |         Args:
83 | |             category_id: The ID of the category to create the snippet in
84 | |             name: The name of the snippet
85 | |             content: The content of the snippet
86 | |
87 | |         Returns:
88 | |             str: The ID of the created snippet
89 | |
90 | |         Raises:
91 | |             ValueError: If the category doesn't exist or snippet creation fails
92 | |             DatabaseError: If there's an error saving the snippet
93 | |         """
   | |___________^ D212
94 |           try:
95 |               # Verify category exists first
   |
   = help: Remove whitespace after opening quotes

models\library.py:124:9: D212 [*] Multi-line docstring summary should start at the first line
    |
122 |           category_id: Optional[str] = None,
123 |       ) -> None:
124 | /         """
125 | |         Edit an existing snippet.
126 | |
127 | |         Args:
128 | |             snippet_id: The ID of the snippet to edit
129 | |             snippet_name: New name for the snippet
130 | |             content: New content for the snippet
131 | |             category_id: Optional new category ID for the snippet
132 | |
133 | |         Raises:
134 | |             ValueError: If the snippet with the given ID doesn't exist
135 | |             DatabaseError: If there's an error saving the snippet
136 | |             Exception: For other unexpected errors
137 | |         """
    | |___________^ D212
138 |           snippet = self.snippet_manager.get_snippet_by_id(snippet_id)
139 |           if snippet is None:
    |
    = help: Remove whitespace after opening quotes

models\llm_ngram_service.py:1:1: D100 Missing docstring in public module
models\llm_ngram_service.py:14:7: D101 Missing docstring in public class
   |
14 | class LLMMissingAPIKeyError(Exception):
   |       ^^^^^^^^^^^^^^^^^^^^^ D101
15 |     pass
   |

models\llm_ngram_service.py:19:5: D212 [*] Multi-line docstring summary should start at the first line
   |
18 |   class LLMNgramService:
19 | /     """
20 | |     Service for generating words containing specified n-grams using an LLM (OpenAI).
21 | |
22 | |     Updates:
23 | |     - API key argument now optional; if omitted and allow_env=True, resolves from environment
24 | |       variables in priority order: OPENAI_API_KEY, OpenAPI_Key, OPENAI_API_TOKEN.
25 | |     - Reuses a single OpenAI client instance (instead of recreating in get_words_with_ngrams_2).
26 | |     - Optional validation (list models) can be enabled via validate=True.
27 | |     """
   | |_______^ D212
28 |
29 |       def __init__(
   |
   = help: Remove whitespace after opening quotes

models\llm_ngram_service.py:29:9: D107 Missing docstring in `__init__`
   |
27 |     """
28 |
29 |     def __init__(
   |         ^^^^^^^^ D107
30 |         self,
31 |         api_key: Optional[str] = None,
   |

models\llm_ngram_service.py:85:9: D202 [*] No blank lines allowed after function docstring (found 1)
   |
83 |         self, ngram_str: str, allowed_chars_str: str, max_length: int
84 |     ) -> str:
85 |         """Load prompt template from file and format it with parameters."""
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D202
86 |
87 |         target_word_count: int = int(max_length / 5)
   |
   = help: Remove blank line(s) after function docstring

models\ngram.py:1:1: D100 Missing docstring in public module
models\ngram.py:27:7: D101 Missing docstring in public class
   |
27 | class SpeedMode(str, Enum):
   |       ^^^^^^^^^ D101
28 |     RAW = "raw"
29 |     NET = "net"
   |

models\ngram.py:32:7: D101 Missing docstring in public class
   |
32 | class NGramType(str, Enum):
   |       ^^^^^^^^^ D101
33 |     CLEAN = "clean"
34 |     ERROR_LAST_CHAR = "error_last_char"
   |

models\ngram.py:37:7: D101 Missing docstring in public class
   |
37 | class SpeedNGram(BaseModel):
   |       ^^^^^^^^^^ D101
38 |     id: uuid.UUID
39 |     session_id: uuid.UUID
   |

models\ngram.py:69:7: D101 Missing docstring in public class
   |
69 | class ErrorNGram(BaseModel):
   |       ^^^^^^^^^^ D101
70 |     id: uuid.UUID
71 |     session_id: uuid.UUID
   |

models\ngram.py:107:5: D103 Missing docstring in public function
    |
107 | def validate_ngram_size(size: int) -> bool:
    |     ^^^^^^^^^^^^^^^^^^^ D103
108 |     return MIN_NGRAM_SIZE <= size <= MAX_NGRAM_SIZE
    |

models\ngram.py:111:5: D103 Missing docstring in public function
    |
111 | def is_valid_ngram_text(text: str) -> bool:
    |     ^^^^^^^^^^^^^^^^^^^ D103
112 |     return (not has_sequence_separators(text)) and validate_ngram_size(len(text))
    |

models\ngram_analytics_service.py:1:1: D212 [*] Multi-line docstring summary should start at the first line
   |
 1 | / """
 2 | | NGramAnalyticsService for advanced n-gram performance analysis.
 3 | |
 4 | | This module provides comprehensive analytics for n-gram performance including:
 5 | | - Decaying average calculations for recent performance weighting
 6 | | - Performance summaries with historical tracking
 7 | | - Heatmap data generation for visualization
 8 | | - Migration of analytics methods from NGramManager
 9 | | """
   | |___^ D212
10 |
11 |   import logging
   |
   = help: Remove whitespace after opening quotes

models\ngram_analytics_service.py:11:1: I001 [*] Import block is un-sorted or un-formatted
   |
 9 |   """
10 |
11 | / import logging
12 | | import traceback
13 | | from dataclasses import dataclass
14 | | from datetime import datetime
15 | | from math import log
16 | | from typing import Dict, List, Optional, TYPE_CHECKING, Union
17 | |
18 | | from pydantic import BaseModel, Field
19 | |
20 | | from db.database_manager import DatabaseManager
21 | | from helpers.debug_util import DebugUtil
22 | | from models.ngram_manager import NGramManager
   | |_____________________________________________^ I001
23 |
24 |   if TYPE_CHECKING:  # Only for type hints to avoid circular imports at runtime
   |
   = help: Organize imports

models\ngram_analytics_service.py:25:5: I001 [*] Import block is un-sorted or un-formatted
   |
24 |   if TYPE_CHECKING:  # Only for type hints to avoid circular imports at runtime
25 | /     from models.session import Session
26 | |     from models.keystroke import Keystroke
   | |__________________________________________^ I001
27 |
28 |   logger = logging.getLogger(__name__)
   |
   = help: Organize imports

models\ngram_analytics_service.py:32:5: D212 [*] Multi-line docstring summary should start at the first line
   |
31 |   class DecayingAverageCalculator:
32 | /     """
33 | |     Calculator for decaying average with exponential weighting.
34 | |
35 | |     Implements an ELO-like system where more recent measurements
36 | |     have exponentially higher weights than older ones.
37 | |     """
   | |_______^ D212
38 |
39 |       def __init__(self, decay_factor: float = 0.9, max_samples: int = 20) -> None:
   |
   = help: Remove whitespace after opening quotes

models\ngram_analytics_service.py:40:9: D212 [*] Multi-line docstring summary should start at the first line
   |
39 |       def __init__(self, decay_factor: float = 0.9, max_samples: int = 20) -> None:
40 | /         """
41 | |         Initialize the decaying average calculator.
42 | |
43 | |         Args:
44 | |             decay_factor: Exponential decay factor (0.0 to 1.0). Higher values
45 | |                          give more weight to recent measurements.
46 | |             max_samples: Maximum number of most recent samples to consider.
47 | |         """
   | |___________^ D212
48 |           self.decay_factor = decay_factor
49 |           self.max_samples = max_samples
   |
   = help: Remove whitespace after opening quotes

models\ngram_analytics_service.py:52:9: D212 [*] Multi-line docstring summary should start at the first line
   |
51 |       def calculate_decaying_average(self, values: List[float], timestamps: List[datetime]) -> float:
52 | /         """
53 | |         Calculate decaying average with exponential weighting.
54 | |
55 | |         More recent values receive exponentially higher weights according to:
56 | |         weight = decay_factor ^ (days_ago)
57 | |
58 | |         Args:
59 | |             values: List of measurement values
60 | |             timestamps: List of corresponding timestamps (must match values length)
61 | |
62 | |         Returns:
63 | |             Weighted average with recent values weighted more heavily
64 | |         """
   | |___________^ D212
65 |           if not values or not timestamps:
66 |               return 0.0
   |
   = help: Remove whitespace after opening quotes

models\ngram_analytics_service.py:168:5: D212 [*] Multi-line docstring summary should start at the first line
    |
167 |   class NGramAnalyticsService:
168 | /     """
169 | |     Service for advanced n-gram performance analytics.
170 | |
171 | |     Provides comprehensive analytics including decaying averages,
172 | |     performance summaries, heatmap data, and historical tracking.
173 | |
174 | |     """
    | |_______^ D212
175 |
176 |       def __init__(self, db: Optional[DatabaseManager], ngram_manager: Optional[NGramManager]) -> None:
    |
    = help: Remove whitespace after opening quotes

models\ngram_analytics_service.py:177:9: D205 1 blank line required between summary line and description
    |
176 |       def __init__(self, db: Optional[DatabaseManager], ngram_manager: Optional[NGramManager]) -> None:
177 | /         """
178 | |         Initialize the NGramAnalyticsService with database and
179 | |         n-gram manager dependencies.
180 | |         """
    | |___________^ D205
181 |           self.db = db
182 |           self.ngram_manager = ngram_manager
    |
    = help: Insert single blank line

models\ngram_analytics_service.py:177:9: D212 [*] Multi-line docstring summary should start at the first line
    |
176 |       def __init__(self, db: Optional[DatabaseManager], ngram_manager: Optional[NGramManager]) -> None:
177 | /         """
178 | |         Initialize the NGramAnalyticsService with database and
179 | |         n-gram manager dependencies.
180 | |         """
    | |___________^ D212
181 |           self.db = db
182 |           self.ngram_manager = ngram_manager
    |
    = help: Remove whitespace after opening quotes

models\ngram_analytics_service.py:189:9: D417 Missing argument description in the docstring for `process_end_of_session`: `save_session_first`
    |
187 |         return
188 |
189 |     def process_end_of_session(
    |         ^^^^^^^^^^^^^^^^^^^^^^ D417
190 |         self,
191 |         session: "Session",
    |

models\ngram_analytics_service.py:195:9: D212 [*] Multi-line docstring summary should start at the first line
    |
193 |           save_session_first: bool = True,
194 |       ) -> Dict[str, Union[int, bool, str]]:
195 | /         """
196 | |         Orchestrate end-of-session persistence and analytics in strict order.
197 | |
198 | |         Steps:
199 | |         1) Save session
200 | |         2) Save keystrokes
201 | |         3) Generate and persist n-grams
202 | |         4) Summarize session n-grams (populate session_ngram_summary)
203 | |         5) Update speed summaries for the specific session (curr and hist)
204 | |
205 | |         Args:
206 | |             session: Session model instance with populated fields
207 | |             keystrokes_input: list of keystroke dicts or Keystroke objects to persist
208 | |
209 | |         Returns:
210 | |             Dict summary with counts and success flags
211 | |
212 | |         Raises:
213 | |             Exception: If any step fails, the exception is propagated
214 | |         """
    | |___________^ D212
215 |           # Local imports to avoid circular dependencies
216 |           from models.keystroke import Keystroke
    |
    = help: Remove whitespace after opening quotes

models\ngram_analytics_service.py:295:9: D212 [*] Multi-line docstring summary should start at the first line
    |
294 |       def refresh_speed_summaries(self, user_id: str, keyboard_id: str) -> int:
295 | /         """
296 | |         Refresh current and historical n-gram speed summaries for a user/keyboard.
297 | |
298 | |         Note: Current implementation processes pending sessions globally via
299 | |         summarize_session_ngrams(). This satisfies test expectations by ensuring
300 | |         summaries are updated; future refinement can scope by user/keyboard.
301 | |
302 | |         Args:
303 | |             user_id: The user ID to refresh (currently informational)
304 | |             keyboard_id: The keyboard ID to refresh (currently informational)
305 | |
306 | |         Returns:
307 | |             Number of summary rows inserted into session_ngram_summary during run.
308 | |         """
    | |___________^ D212
309 |           # Reuse existing summarization pipeline which updates summary tables.
310 |           try:
    |
    = help: Remove whitespace after opening quotes

models\ngram_analytics_service.py:324:9: D212 [*] Multi-line docstring summary should start at the first line
    |
322 |           self, user_id: str, keyboard_id: str, ngram_text: Optional[str] = None
323 |       ) -> List[NGramHistoricalData]:
324 | /         """
325 | |         Retrieve historical performance data for n-grams.
326 | |
327 | |         Args:
328 | |             user_id: User ID to get history for
329 | |             keyboard_id: Keyboard ID to get history for
330 | |             ngram_text: Optional filter for specific n-gram text
331 | |
332 | |         Returns:
333 | |             List of NGramHistoricalData objects sorted by measurement date
334 | |         """
    | |___________^ D212
335 |           if not self.db:
336 |               logger.warning("No database connection for history retrieval")
    |
    = help: Remove whitespace after opening quotes

models\ngram_analytics_service.py:405:9: D212 [*] Multi-line docstring summary should start at the first line
    |
403 |           sort_order: str = "decaying_average_ms desc",
404 |       ) -> List[NGramHeatmapData]:
405 | /         """
406 | |         Get heatmap data for n-gram performance visualization.
407 | |
408 | |         Args:
409 | |             user_id: User ID to get data for
410 | |             keyboard_id: Keyboard ID to get data for
411 | |             target_speed_ms: Optional target speed override
412 | |             ngram_size_filter: Optional filter for specific n-gram size
413 | |             exclude_successful: Whether to exclude n-grams meeting target
414 | |             sort_order: Sort order ("worst_to_best" or "best_to_worst")
415 | |
416 | |         Returns:
417 | |             List of NGramHeatmapData objects for visualization
418 | |         """
    | |___________^ D212
419 |           if not self.db:
420 |               return []
    |
    = help: Remove whitespace after opening quotes

models\ngram_analytics_service.py:534:9: D212 [*] Multi-line docstring summary should start at the first line
    |
532 |           self, user_id: str, keyboard_id: str, time_window_days: int = 30
533 |       ) -> Dict[str, List[NGramHistoricalData]]:
534 | /         """
535 | |         Get historical performance trends for n-grams.
536 | |
537 | |         Analyzes how the decaying average performance has changed over time
538 | |         by calculating weighted averages at different time points.
539 | |
540 | |         Args:
541 | |             user_id: User ID to get trends for
542 | |             keyboard_id: Keyboard ID to get trends for
543 | |             time_window_days: Number of days to look back
544 | |
545 | |         Returns:
546 | |             Dictionary mapping n-gram text to list of historical data points
547 | |         """
    | |___________^ D212
548 |           if not self.db:
549 |               return {}
    |
    = help: Remove whitespace after opening quotes

models\ngram_analytics_service.py:657:9: D417 Missing argument descriptions in the docstring for `slowest_n`: `focus_on_speed_target`, `min_occurrences`
    |
655 |             return {}
656 |
657 |     def slowest_n(
    |         ^^^^^^^^^ D417
658 |         self,
659 |         n: int,
    |

models\ngram_analytics_service.py:668:9: D212 [*] Multi-line docstring summary should start at the first line
    |
666 |           focus_on_speed_target: bool = False,
667 |       ) -> List[NGramStats]:
668 | /         """
669 | |         Find the n slowest n-grams by average speed.
670 | |
671 | |         This method was moved from NGramManager to NGramAnalyticsService
672 | |         for better organization of analytics functionality.
673 | |
674 | |         Args:
675 | |             n: Number of n-grams to return
676 | |             keyboard_id: The ID of the keyboard to filter by
677 | |             user_id: The ID of the user to filter by
678 | |             ngram_sizes: List of n-gram sizes to include (default is 2-20)
679 | |             lookback_distance: Number of most recent sessions to consider
680 | |             included_keys: List of characters to filter n-grams by (only n-grams
681 | |                          containing exclusively these characters will be returned)
682 | |
683 | |         Returns:
684 | |             List of NGramStats objects sorted by speed (slowest first)
685 | |         """
    | |___________^ D212
686 |           if n <= 0:
687 |               return []
    |
    = help: Remove whitespace after opening quotes

models\ngram_analytics_service.py:764:9: D212 [*] Multi-line docstring summary should start at the first line
    |
762 |           included_keys: Optional[List[str]] = None,
763 |       ) -> List[NGramStats]:
764 | /         """
765 | |         Find the n most error-prone n-grams by error count.
766 | |
767 | |         This method was moved from NGramManager to NGramAnalyticsService
768 | |         for better organization of analytics functionality.
769 | |
770 | |         Args:
771 | |             n: Number of n-grams to return
772 | |             keyboard_id: The ID of the keyboard to filter by
773 | |             user_id: The ID of the user to filter by
774 | |             ngram_sizes: List of n-gram sizes to include (default is 2-20)
775 | |             lookback_distance: Number of most recent sessions to consider
776 | |             included_keys: List of characters to filter n-grams by (only n-grams
777 | |                          containing exclusively these characters will be returned)
778 | |
779 | |         Returns:
780 | |             List of NGramStats objects sorted by error count (highest first)
781 | |         """
    | |___________^ D212
782 |           if n <= 0:
783 |               return []
    |
    = help: Remove whitespace after opening quotes

models\ngram_analytics_service.py:848:9: D212 [*] Multi-line docstring summary should start at the first line
    |
847 |       def summarize_session_ngrams(self) -> int:
848 | /         """
849 | |         Summarize session ngram performance for all sessions not yet in session_ngram_summary.
850 | |
851 | |         Uses complex CTEs to aggregate data from session_ngram_speed, session_ngram_errors,
852 | |         and session_keystrokes tables, then inserts the results into session_ngram_summary.
853 | |
854 | |         Returns:
855 | |             Number of records inserted into session_ngram_summary
856 | |
857 | |         Raises:
858 | |             DatabaseError: If the database operation fails
859 | |         """
    | |___________^ D212
860 |           logger.info("Starting SummarizeSessionNgrams process")
    |
    = help: Remove whitespace after opening quotes

models\ngram_analytics_service.py:1016:9: D212 [*] Multi-line docstring summary should start at the first line
     |
1015 |       def add_speed_summary_for_session(self, session_id: str) -> dict:
1016 | /         """
1017 | |         Update performance summary for a specific session using decaying average calculation.
1018 | |
1019 | |         Uses the last 20 sessions (including the given session) to calculate decaying averages
1020 | |         and updates both ngram_speed_summary_curr (merge) and ngram_speed_summary_hist (insert).
1021 | |
1022 | |         Args:
1023 | |             session_id: The session ID to process
1024 | |
1025 | |         Returns:
1026 | |             Dictionary with counts of updated and inserted records
1027 | |
1028 | |         Raises:
1029 | |             DatabaseError: If the database operation fails
1030 | |         """
     | |___________^ D212
1031 |           logger.info(f"Starting AddSpeedSummaryForSession for session: {session_id}")
     |
     = help: Remove whitespace after opening quotes

models\ngram_analytics_service.py:1250:9: D212 [*] Multi-line docstring summary should start at the first line
     |
1249 |       def catchup_speed_summary(self) -> dict:
1250 | /         """
1251 | |         Process all sessions from oldest to newest to catch up speed summaries.
1252 | |
1253 | |         Queries all sessions in chronological order and calls AddSpeedSummaryForSession
1254 | |         for each one, logging progress and record counts.
1255 | |
1256 | |         Returns:
1257 | |             Dictionary with total counts and processing summary
1258 | |
1259 | |         Raises:
1260 | |             DatabaseError: If the database operation fails
1261 | |         """
     | |___________^ D212
1262 |           logger.info("Starting CatchupSpeedSummary process")
     |
     = help: Remove whitespace after opening quotes

models\ngram_analytics_service.py:1349:9: D205 1 blank line required between summary line and description
     |
1348 |       def delete_all_analytics_data(self) -> bool:
1349 | /         """
1350 | |         Delete all analytics data from ngram_speed_hist, ngram_speed_summary_curr,
1351 | |         ngram_speed_summary_hist, and session_ngram_summary tables.
1352 | |
1353 | |         This will clear all derived analytics data but preserve the raw ngram data
1354 | |         in session_ngram_speed and session_ngram_errors.
1355 | |
1356 | |         Returns:
1357 | |             bool: True if successful, False otherwise
1358 | |         """
     | |___________^ D205
1359 |           try:
1360 |               if self.db is None:
     |
     = help: Insert single blank line

models\ngram_analytics_service.py:1349:9: D212 [*] Multi-line docstring summary should start at the first line
     |
1348 |       def delete_all_analytics_data(self) -> bool:
1349 | /         """
1350 | |         Delete all analytics data from ngram_speed_hist, ngram_speed_summary_curr,
1351 | |         ngram_speed_summary_hist, and session_ngram_summary tables.
1352 | |
1353 | |         This will clear all derived analytics data but preserve the raw ngram data
1354 | |         in session_ngram_speed and session_ngram_errors.
1355 | |
1356 | |         Returns:
1357 | |             bool: True if successful, False otherwise
1358 | |         """
     | |___________^ D212
1359 |           try:
1360 |               if self.db is None:
     |
     = help: Remove whitespace after opening quotes

models\ngram_analytics_service.py:1379:9: D212 [*] Multi-line docstring summary should start at the first line
     |
1378 |       def delete_all_session_summaries(self) -> bool:
1379 | /         """
1380 | |         Delete all data from session_ngram_summary table.
1381 | |
1382 | |         Returns:
1383 | |             bool: True if successful, False otherwise
1384 | |         """
     | |___________^ D212
1385 |           try:
1386 |               if self.db is None:
     |
     = help: Remove whitespace after opening quotes

models\ngram_manager.py:1:1: D100 Missing docstring in public module
models\ngram_manager.py:28:5: D212 [*] Multi-line docstring summary should start at the first line
   |
27 |   class NGramManager:
28 | /     """
29 | |     Implementation-agnostic n-gram extractor/classifier per Prompts/ngram.md.
30 | |
31 | |     Responsibilities:
32 | |     - Extract n-gram windows from expected text (respecting separators)
33 | |     - Classify each window as Clean, Error-last, or Ignored
34 | |     - Compute durations using Section 6 rules with start-of-sequence gross-up
35 | |     - Return SpeedNGram and ErrorNGram objects
36 | |     - Provide persistence helpers to store results to DB per Prompts/ngram.md
37 | |     """
   | |_______^ D212
38 |
39 |       def __init__(self, db_manager: Optional[DBExecutor] = None) -> None:
   |
   = help: Remove whitespace after opening quotes

models\session.py:1:1: D212 [*] Multi-line docstring summary should start at the first line
  |
1 | / """
2 | | Session module for backward compatibility with older tests.
3 | |
4 | | This module provides the Session class that was previously part of
5 | | the ngram_analyzer module but has been moved as part of the refactoring.
6 | | """
  | |___^ D212
7 |
8 |   from __future__ import annotations
  |
  = help: Remove whitespace after opening quotes

models\session.py:18:5: D205 1 blank line required between summary line and description
   |
17 |   class Session(BaseModel):
18 | /     """
19 | |     Pydantic model for a typing practice session, matching the practice_sessions table.
20 | |     All fields are validated and session_id is a UUID string.
21 | |     """
   | |_______^ D205
22 |
23 |       session_id: str = Field(default_factory=lambda: str(uuid.uuid4()))
   |
   = help: Insert single blank line

models\session.py:18:5: D212 [*] Multi-line docstring summary should start at the first line
   |
17 |   class Session(BaseModel):
18 | /     """
19 | |     Pydantic model for a typing practice session, matching the practice_sessions table.
20 | |     All fields are validated and session_id is a UUID string.
21 | |     """
   | |_______^ D212
22 |
23 |       session_id: str = Field(default_factory=lambda: str(uuid.uuid4()))
   |
   = help: Remove whitespace after opening quotes

models\session.py:42:9: D102 Missing docstring in public method
   |
40 |     @field_validator("session_id", "snippet_id", "user_id", "keyboard_id")
41 |     @classmethod
42 |     def validate_uuid(cls, v: str) -> str:
   |         ^^^^^^^^^^^^^ D102
43 |         uuid.UUID(v)
44 |         return v
   |

models\session.py:48:9: D102 Missing docstring in public method
   |
46 |     @field_validator("snippet_index_start", "snippet_index_end")
47 |     @classmethod
48 |     def validate_indices(cls, v: int) -> int:
   |         ^^^^^^^^^^^^^^^^ D102
49 |         if v < 0:
50 |             raise ValueError("Indices must be >= 0")
   |

models\session.py:54:9: D102 Missing docstring in public method
   |
53 |     @model_validator(mode="after")
54 |     def check_indices_and_times(self) -> "Session":
   |         ^^^^^^^^^^^^^^^^^^^^^^^ D102
55 |         if self.snippet_index_end <= self.snippet_index_start:
56 |             raise ValueError("snippet_index_end must be > snippet_index_start")
   |

models\session.py:64:9: D102 Missing docstring in public method
   |
63 |     @property
64 |     def expected_chars(self) -> int:
   |         ^^^^^^^^^^^^^^ D102
65 |         return self.snippet_index_end - self.snippet_index_start
   |

models\session.py:68:9: D102 Missing docstring in public method
   |
67 |     @property
68 |     def total_time(self) -> float:
   |         ^^^^^^^^^^ D102
69 |         return (self.end_time - self.start_time).total_seconds()
   |

models\session.py:72:9: D102 Missing docstring in public method
   |
71 |     @property
72 |     def efficiency(self) -> float:
   |         ^^^^^^^^^^ D102
73 |         if self.expected_chars == 0:
74 |             return 0.0
   |

models\session.py:78:9: D102 Missing docstring in public method
   |
77 |     @property
78 |     def correctness(self) -> float:
   |         ^^^^^^^^^^^ D102
79 |         if self.actual_chars == 0:
80 |             return 0.0
   |

models\session.py:84:9: D102 Missing docstring in public method
   |
83 |     @property
84 |     def accuracy(self) -> float:
   |         ^^^^^^^^ D102
85 |         if self.expected_chars == 0:
86 |             return 0.0
   |

models\session.py:90:9: D102 Missing docstring in public method
   |
89 |     @property
90 |     def session_cpm(self) -> float:
   |         ^^^^^^^^^^^ D102
91 |         if self.total_time == 0:
92 |             return 0.0
   |

models\session.py:96:9: D102 Missing docstring in public method
   |
95 |     @property
96 |     def session_wpm(self) -> float:
   |         ^^^^^^^^^^^ D102
97 |         if self.total_time == 0:
98 |             return 0.0
   |

models\session.py:102:9: D102 Missing docstring in public method
    |
101 |     @property
102 |     def ms_per_keystroke(self) -> float:
    |         ^^^^^^^^^^^^^^^^ D102
103 |         if self.expected_chars == 0 or self.total_time == 0:
104 |             return 0.0
    |

models\session.py:107:9: D102 Missing docstring in public method
    |
105 |         return (self.total_time * 1000.0) / self.expected_chars
106 |
107 |     def to_dict(self) -> Dict[str, Any]:
    |         ^^^^^^^ D102
108 |         return self.dict()
    |

models\session.py:111:9: D102 Missing docstring in public method
    |
110 |     @classmethod
111 |     def from_dict(cls, d: Dict[str, Any]) -> "Session":
    |         ^^^^^^^^^ D102
112 |         # Create a copy of the input dictionary to avoid modifying the original
113 |         data = d.copy()
    |

models\session.py:133:9: D200 One-line docstring should fit on one line
    |
132 |       def get_summary(self) -> str:
133 | /         """
134 | |         Return a summary of the session (business logic only).
135 | |         """
    | |___________^ D200
136 |           return (
137 |               f"Session {self.session_id} for snippet {self.snippet_id} "
    |
    = help: Reformat to one line

models\session.py:133:9: D212 [*] Multi-line docstring summary should start at the first line
    |
132 |       def get_summary(self) -> str:
133 | /         """
134 | |         Return a summary of the session (business logic only).
135 | |         """
    | |___________^ D212
136 |           return (
137 |               f"Session {self.session_id} for snippet {self.snippet_id} "
    |
    = help: Remove whitespace after opening quotes

models\session_manager.py:1:1: D100 Missing docstring in public module
models\session_manager.py:22:5: D205 1 blank line required between summary line and description
   |
21 |   class SessionManager:
22 | /     """
23 | |     Manages all database and aggregation operations for Session objects.
24 | |     Delegates all DB operations to DatabaseManager and handles only exceptions
25 | |     from exceptions.py.
26 | |     All session_id values are UUID strings.
27 | |     """
   | |_______^ D205
28 |
29 |       def __init__(self, db_manager: DatabaseManager) -> None:
   |
   = help: Insert single blank line

models\session_manager.py:22:5: D212 [*] Multi-line docstring summary should start at the first line
   |
21 |   class SessionManager:
22 | /     """
23 | |     Manages all database and aggregation operations for Session objects.
24 | |     Delegates all DB operations to DatabaseManager and handles only exceptions
25 | |     from exceptions.py.
26 | |     All session_id values are UUID strings.
27 | |     """
   | |_______^ D212
28 |
29 |       def __init__(self, db_manager: DatabaseManager) -> None:
   |
   = help: Remove whitespace after opening quotes

models\session_manager.py:29:9: D107 Missing docstring in `__init__`
   |
27 |     """
28 |
29 |     def __init__(self, db_manager: DatabaseManager) -> None:
   |         ^^^^^^^^ D107
30 |         self.db_manager = db_manager
31 |         self.debug_util = DebugUtil()
   |

models\session_manager.py:33:9: D102 Missing docstring in public method
   |
31 |         self.debug_util = DebugUtil()
32 |
33 |     def get_session_by_id(self, session_id: str) -> Optional[Session]:
   |         ^^^^^^^^^^^^^^^^^ D102
34 |         try:
35 |             row = self.db_manager.execute(
   |

models\session_manager.py:77:9: D102 Missing docstring in public method
   |
75 |             raise
76 |
77 |     def list_sessions_for_snippet(self, snippet_id: str) -> List[Session]:
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^ D102
78 |         try:
79 |             rows = self.db_manager.execute(
   |

models\session_manager.py:124:9: D205 1 blank line required between summary line and description
    |
123 |       def save_session(self, session: Session) -> str:
124 | /         """
125 | |         Save a Session object to the database. If a session with the same
126 | |         session_id exists, update it; otherwise, insert a new record.
127 | |         Returns the session_id.
128 | |         """
    | |___________^ D205
129 |           try:
130 |               row = self.db_manager.execute(
    |
    = help: Insert single blank line

models\session_manager.py:124:9: D212 [*] Multi-line docstring summary should start at the first line
    |
123 |       def save_session(self, session: Session) -> str:
124 | /         """
125 | |         Save a Session object to the database. If a session with the same
126 | |         session_id exists, update it; otherwise, insert a new record.
127 | |         Returns the session_id.
128 | |         """
    | |___________^ D212
129 |           try:
130 |               row = self.db_manager.execute(
    |
    = help: Remove whitespace after opening quotes

models\session_manager.py:211:9: D200 One-line docstring should fit on one line
    |
210 |       def delete_session_by_id(self, session_id: str) -> bool:
211 | /         """
212 | |         Delete a session by its session_id. Returns True if deleted, False if not found.
213 | |         """
    | |___________^ D200
214 |           try:
215 |               result = self.db_manager.execute(
    |
    = help: Reformat to one line

models\session_manager.py:211:9: D212 [*] Multi-line docstring summary should start at the first line
    |
210 |       def delete_session_by_id(self, session_id: str) -> bool:
211 | /         """
212 | |         Delete a session by its session_id. Returns True if deleted, False if not found.
213 | |         """
    | |___________^ D212
214 |           try:
215 |               result = self.db_manager.execute(
    |
    = help: Remove whitespace after opening quotes

models\session_manager.py:234:9: D205 1 blank line required between summary line and description
    |
233 |       def delete_all(self) -> bool:
234 | /         """
235 | |         Delete all keystrokes and ngrams before deleting all sessions.
236 | |         Only deletes sessions if both keystroke and ngram deletions succeed.
237 | |         Returns True if all deletions succeed, False otherwise.
238 | |         """
    | |___________^ D205
239 |           from models.keystroke_manager import KeystrokeManager
240 |           from models.ngram_manager import NGramManager
    |
    = help: Insert single blank line

models\session_manager.py:234:9: D212 [*] Multi-line docstring summary should start at the first line
    |
233 |       def delete_all(self) -> bool:
234 | /         """
235 | |         Delete all keystrokes and ngrams before deleting all sessions.
236 | |         Only deletes sessions if both keystroke and ngram deletions succeed.
237 | |         Returns True if all deletions succeed, False otherwise.
238 | |         """
    | |___________^ D212
239 |           from models.keystroke_manager import KeystrokeManager
240 |           from models.ngram_manager import NGramManager
    |
    = help: Remove whitespace after opening quotes

models\session_manager.py:285:9: D205 1 blank line required between summary line and description
    |
284 |       def get_latest_session_for_keyboard(self, keyboard_id: str) -> Optional[Session]:
285 | /         """
286 | |         Returns the most recent session for the given keyboard_id across all snippets.
287 | |         Returns None if no sessions found for this keyboard.
288 | |         """
    | |___________^ D205
289 |           try:
290 |               row = self.db_manager.fetchone(
    |
    = help: Insert single blank line

models\session_manager.py:285:9: D212 [*] Multi-line docstring summary should start at the first line
    |
284 |       def get_latest_session_for_keyboard(self, keyboard_id: str) -> Optional[Session]:
285 | /         """
286 | |         Returns the most recent session for the given keyboard_id across all snippets.
287 | |         Returns None if no sessions found for this keyboard.
288 | |         """
    | |___________^ D212
289 |           try:
290 |               row = self.db_manager.fetchone(
    |
    = help: Remove whitespace after opening quotes

models\session_manager.py:338:9: D205 1 blank line required between summary line and description
    |
337 |       def get_next_position(self, snippet_id: str) -> int:
338 | /         """
339 | |         Returns the next start index for a session on the given snippet.
340 | |         - If no previous sessions: returns 0
341 | |         - If last session ended at or beyond snippet length: returns 0
342 | |         - Otherwise: returns last session's snippet_index_end
343 | |         """
    | |___________^ D205
344 |           # Get all sessions for this snippet, most recent first
345 |           sessions = self.list_sessions_for_snippet(snippet_id)
    |
    = help: Insert single blank line

models\session_manager.py:338:9: D212 [*] Multi-line docstring summary should start at the first line
    |
337 |       def get_next_position(self, snippet_id: str) -> int:
338 | /         """
339 | |         Returns the next start index for a session on the given snippet.
340 | |         - If no previous sessions: returns 0
341 | |         - If last session ended at or beyond snippet length: returns 0
342 | |         - Otherwise: returns last session's snippet_index_end
343 | |         """
    | |___________^ D212
344 |           # Get all sessions for this snippet, most recent first
345 |           sessions = self.list_sessions_for_snippet(snippet_id)
    |
    = help: Remove whitespace after opening quotes

models\session_manager.py:338:9: D415 First line should end with a period, question mark, or exclamation point
    |
337 |       def get_next_position(self, snippet_id: str) -> int:
338 | /         """
339 | |         Returns the next start index for a session on the given snippet.
340 | |         - If no previous sessions: returns 0
341 | |         - If last session ended at or beyond snippet length: returns 0
342 | |         - Otherwise: returns last session's snippet_index_end
343 | |         """
    | |___________^ D415
344 |           # Get all sessions for this snippet, most recent first
345 |           sessions = self.list_sessions_for_snippet(snippet_id)
    |
    = help: Add closing punctuation

models\setting.py:1:1: D205 1 blank line required between summary line and description
  |
1 | / """
2 | | Setting data model.
3 | | Defines the structure and validation for a setting.
4 | | """
  | |___^ D205
5 |
6 |   from __future__ import annotations
  |
  = help: Insert single blank line

models\setting.py:1:1: D212 [*] Multi-line docstring summary should start at the first line
  |
1 | / """
2 | | Setting data model.
3 | | Defines the structure and validation for a setting.
4 | | """
  | |___^ D212
5 |
6 |   from __future__ import annotations
  |
  = help: Remove whitespace after opening quotes

models\setting.py:22:9: D107 Missing docstring in `__init__`
   |
20 |     """
21 |
22 |     def __init__(self, message: str = "Setting validation failed") -> None:
   |         ^^^^^^^^ D107
23 |         self.message = message
24 |         super().__init__(self.message)
   |

models\setting.py:34:9: D107 Missing docstring in `__init__`
   |
32 |     """
33 |
34 |     def __init__(self, message: str = "Setting not found") -> None:
   |         ^^^^^^^^ D107
35 |         self.message = message
36 |         super().__init__(self.message)
   |

models\setting_manager.py:1:1: D205 1 blank line required between summary line and description
  |
1 | / """
2 | | Setting Manager for CRUD operations.
3 | | Handles all DB access for settings.
4 | | """
  | |___^ D205
5 |
6 |   import datetime
  |
  = help: Insert single blank line

models\setting_manager.py:1:1: D212 [*] Multi-line docstring summary should start at the first line
  |
1 | / """
2 | | Setting Manager for CRUD operations.
3 | | Handles all DB access for settings.
4 | | """
  | |___^ D212
5 |
6 |   import datetime
  |
  = help: Remove whitespace after opening quotes

models\setting_manager.py:15:5: D200 One-line docstring should fit on one line
   |
14 |   class SettingManager:
15 | /     """
16 | |     Manager for CRUD operations on Setting, using DatabaseManager for DB access.
17 | |     """
   | |_______^ D200
18 |
19 |       def __init__(self, db_manager: DatabaseManager) -> None:
   |
   = help: Reformat to one line

models\setting_manager.py:15:5: D212 [*] Multi-line docstring summary should start at the first line
   |
14 |   class SettingManager:
15 | /     """
16 | |     Manager for CRUD operations on Setting, using DatabaseManager for DB access.
17 | |     """
   | |_______^ D212
18 |
19 |       def __init__(self, db_manager: DatabaseManager) -> None:
   |
   = help: Remove whitespace after opening quotes

models\setting_manager.py:20:9: D200 One-line docstring should fit on one line
   |
19 |       def __init__(self, db_manager: DatabaseManager) -> None:
20 | /         """
21 | |         Initialize SettingManager with a DatabaseManager instance.
22 | |         """
   | |___________^ D200
23 |           self.db_manager: DatabaseManager = db_manager
   |
   = help: Reformat to one line

models\setting_manager.py:20:9: D212 [*] Multi-line docstring summary should start at the first line
   |
19 |       def __init__(self, db_manager: DatabaseManager) -> None:
20 | /         """
21 | |         Initialize SettingManager with a DatabaseManager instance.
22 | |         """
   | |___________^ D212
23 |           self.db_manager: DatabaseManager = db_manager
   |
   = help: Remove whitespace after opening quotes

models\setting_manager.py:31:9: D205 1 blank line required between summary line and description
   |
29 |           setting_id: Optional[str] = None
30 |       ) -> None:
31 | /         """
32 | |         Validate setting for database uniqueness.
33 | |         This ensures there is only one setting per entity per type.
34 | |
35 | |         Args:
36 | |             setting_type_id: The setting type ID to validate.
37 | |             related_entity_id: The entity ID to validate.
38 | |             setting_id: The ID of the setting being updated, if any.
39 | |
40 | |         Raises:
41 | |             SettingValidationError: If the combination is not unique.
42 | |         """
   | |___________^ D205
43 |           query = "SELECT 1 FROM settings WHERE setting_type_id = ? AND related_entity_id = ?"
44 |           params = [setting_type_id, related_entity_id]
   |
   = help: Insert single blank line

models\setting_manager.py:31:9: D212 [*] Multi-line docstring summary should start at the first line
   |
29 |           setting_id: Optional[str] = None
30 |       ) -> None:
31 | /         """
32 | |         Validate setting for database uniqueness.
33 | |         This ensures there is only one setting per entity per type.
34 | |
35 | |         Args:
36 | |             setting_type_id: The setting type ID to validate.
37 | |             related_entity_id: The entity ID to validate.
38 | |             setting_id: The ID of the setting being updated, if any.
39 | |
40 | |         Raises:
41 | |             SettingValidationError: If the combination is not unique.
42 | |         """
   | |___________^ D212
43 |           query = "SELECT 1 FROM settings WHERE setting_type_id = ? AND related_entity_id = ?"
44 |           params = [setting_type_id, related_entity_id]
   |
   = help: Remove whitespace after opening quotes

models\setting_manager.py:61:9: D205 1 blank line required between summary line and description
   |
59 |           default_value: Optional[str] = None
60 |       ) -> Setting:
61 | /         """
62 | |         Retrieve a single setting by type ID and related entity ID.
63 | |         If the setting doesn't exist and a default value is provided, returns a new setting with the default.
64 | |
65 | |         Args:
66 | |             setting_type_id: The type ID of the setting to retrieve.
67 | |             related_entity_id: The related entity ID of the setting to retrieve.
68 | |             default_value: Default value to use if the setting doesn't exist.
69 | |
70 | |         Returns:
71 | |             Setting: The retrieved or newly created setting.
72 | |
73 | |         Raises:
74 | |             SettingNotFound: If no setting exists with the specified IDs and no default is provided.
75 | |         """
   | |___________^ D205
76 |           row = self.db_manager.execute(
77 |               """
   |
   = help: Insert single blank line

models\setting_manager.py:61:9: D212 [*] Multi-line docstring summary should start at the first line
   |
59 |           default_value: Optional[str] = None
60 |       ) -> Setting:
61 | /         """
62 | |         Retrieve a single setting by type ID and related entity ID.
63 | |         If the setting doesn't exist and a default value is provided, returns a new setting with the default.
64 | |
65 | |         Args:
66 | |             setting_type_id: The type ID of the setting to retrieve.
67 | |             related_entity_id: The related entity ID of the setting to retrieve.
68 | |             default_value: Default value to use if the setting doesn't exist.
69 | |
70 | |         Returns:
71 | |             Setting: The retrieved or newly created setting.
72 | |
73 | |         Raises:
74 | |             SettingNotFound: If no setting exists with the specified IDs and no default is provided.
75 | |         """
   | |___________^ D212
76 |           row = self.db_manager.execute(
77 |               """
   |
   = help: Remove whitespace after opening quotes

models\setting_manager.py:111:9: D212 [*] Multi-line docstring summary should start at the first line
    |
110 |       def list_settings(self, related_entity_id: str) -> List[Setting]:
111 | /         """
112 | |         List all settings for a specific entity.
113 | |
114 | |         Args:
115 | |             related_entity_id: The entity ID to retrieve settings for.
116 | |
117 | |         Returns:
118 | |             List[Setting]: All settings for the specified entity.
119 | |         """
    | |___________^ D212
120 |           rows = self.db_manager.execute(
121 |               """
    |
    = help: Remove whitespace after opening quotes

models\setting_manager.py:141:9: D205 1 blank line required between summary line and description
    |
140 |       def save_setting(self, setting: Setting) -> bool:
141 | /         """
142 | |         Insert or update a setting in the DB. Returns True if successful.
143 | |         Also creates an entry in the settings_history table.
144 | |
145 | |         Args:
146 | |             setting: The Setting object to save.
147 | |
148 | |         Returns:
149 | |             True if the setting was inserted or updated successfully.
150 | |
151 | |         Raises:
152 | |             SettingValidationError: If the setting is not unique.
153 | |             ValueError: If validation fails (e.g., invalid data).
154 | |         """
    | |___________^ D205
155 |           # Ensure the updated_at timestamp is current
156 |           setting.updated_at = datetime.datetime.now().isoformat()
    |
    = help: Insert single blank line

models\setting_manager.py:141:9: D212 [*] Multi-line docstring summary should start at the first line
    |
140 |       def save_setting(self, setting: Setting) -> bool:
141 | /         """
142 | |         Insert or update a setting in the DB. Returns True if successful.
143 | |         Also creates an entry in the settings_history table.
144 | |
145 | |         Args:
146 | |             setting: The Setting object to save.
147 | |
148 | |         Returns:
149 | |             True if the setting was inserted or updated successfully.
150 | |
151 | |         Raises:
152 | |             SettingValidationError: If the setting is not unique.
153 | |             ValueError: If validation fails (e.g., invalid data).
154 | |         """
    | |___________^ D212
155 |           # Ensure the updated_at timestamp is current
156 |           setting.updated_at = datetime.datetime.now().isoformat()
    |
    = help: Remove whitespace after opening quotes

models\setting_manager.py:185:9: D212 [*] Multi-line docstring summary should start at the first line
    |
184 |       def _add_history_entry(self, setting: Setting) -> None:
185 | /         """
186 | |         Add an entry to the settings_history table.
187 | |
188 | |         Args:
189 | |             setting: The setting that was changed.
190 | |         """
    | |___________^ D212
191 |           history_id = str(uuid4())
192 |           self.db_manager.execute(
    |
    = help: Remove whitespace after opening quotes

models\setting_manager.py:251:9: D212 [*] Multi-line docstring summary should start at the first line
    |
250 |       def delete_setting(self, setting_type_id: str, related_entity_id: str) -> bool:
251 | /         """
252 | |         Delete a setting by its type ID and related entity ID.
253 | |
254 | |         Args:
255 | |             setting_type_id: The type ID of the setting to delete.
256 | |             related_entity_id: The related entity ID of the setting to delete.
257 | |
258 | |         Returns:
259 | |             bool: True if deleted, False if not found.
260 | |         """
    | |___________^ D212
261 |           # First get the setting to record in history
262 |           try:
    |
    = help: Remove whitespace after opening quotes

models\setting_manager.py:281:9: D212 [*] Multi-line docstring summary should start at the first line
    |
280 |       def delete_all_settings(self, related_entity_id: str) -> bool:
281 | /         """
282 | |         Delete all settings for a specific entity.
283 | |
284 | |         Args:
285 | |             related_entity_id: The entity ID to delete settings for.
286 | |
287 | |         Returns:
288 | |             bool: True if any were deleted, False if none were found.
289 | |         """
    | |___________^ D212
290 |           # Get all settings for this entity first
291 |           settings = self.list_settings(related_entity_id)
    |
    = help: Remove whitespace after opening quotes

models\snippet.py:1:1: D200 One-line docstring should fit on one line
  |
1 | / """
2 | | Snippet Pydantic model and validation logic.
3 | | """
  | |___^ D200
4 |
5 |   from __future__ import annotations
  |
  = help: Reformat to one line

models\snippet.py:1:1: D212 [*] Multi-line docstring summary should start at the first line
  |
1 | / """
2 | | Snippet Pydantic model and validation logic.
3 | | """
  | |___^ D212
4 |
5 |   from __future__ import annotations
  |
  = help: Remove whitespace after opening quotes

models\snippet.py:120:9: D102 Missing docstring in public method
    |
118 |     @model_validator(mode="before")
119 |     @classmethod
120 |     def ensure_snippet_id(cls, values: dict) -> dict:
    |         ^^^^^^^^^^^^^^^^^ D102
121 |         if not values.get("snippet_id"):
122 |             values["snippet_id"] = str(uuid4())
    |

models\snippet.py:127:9: D102 Missing docstring in public method
    |
125 |     @field_validator("snippet_id", "category_id", mode="before")
126 |     @classmethod
127 |     def validate_ids(cls, v: str) -> str:
    |         ^^^^^^^^^^^^ D102
128 |         if not v:
129 |             raise ValueError("ID must not be empty")
    |

models\snippet.py:138:9: D102 Missing docstring in public method
    |
136 |     @field_validator("snippet_name", mode="before")
137 |     @classmethod
138 |     def validate_snippet_name(cls, v: str) -> str:
    |         ^^^^^^^^^^^^^^^^^^^^^ D102
139 |         v = validate_non_empty(v)
140 |         v = validate_ascii_only(v)
    |

models\snippet.py:148:9: D102 Missing docstring in public method
    |
146 |     @field_validator("content", mode="before")
147 |     @classmethod
148 |     def validate_content(cls, v: str) -> str:
    |         ^^^^^^^^^^^^^^^^ D102
149 |         v = validate_non_empty(v)
150 |         v = validate_ascii_only(v)
    |

models\snippet.py:156:9: D102 Missing docstring in public method
    |
154 |         return v
155 |
156 |     def to_dict(self) -> Dict[str, Any]:
    |         ^^^^^^^ D102
157 |         return self.dict()
    |

models\snippet.py:160:9: D102 Missing docstring in public method
    |
159 |     @classmethod
160 |     def from_dict(cls, d: Dict[str, Any]) -> "Snippet":
    |         ^^^^^^^^^ D102
161 |         allowed = set(cls.__fields__.keys())
162 |         extra = set(d.keys()) - allowed
    |

models\snippet_manager.py:1:1: D205 1 blank line required between summary line and description
  |
1 | / """
2 | | SnippetManager: Class for managing snippets in the database.
3 | | Provides methods for CRUD operations on snippets, utilizing the Snippet Pydantic model.
4 | | """
  | |___^ D205
5 |
6 |   import logging
  |
  = help: Insert single blank line

models\snippet_manager.py:1:1: D212 [*] Multi-line docstring summary should start at the first line
  |
1 | / """
2 | | SnippetManager: Class for managing snippets in the database.
3 | | Provides methods for CRUD operations on snippets, utilizing the Snippet Pydantic model.
4 | | """
  | |___^ D212
5 |
6 |   import logging
  |
  = help: Remove whitespace after opening quotes

models\snippet_manager.py:61:9: D212 [*] Multi-line docstring summary should start at the first line
   |
60 |       def save_snippet(self, snippet: Snippet) -> bool:
61 | /         """
62 | |         Insert or update a snippet in the DB. Returns True if successful.
63 | |
64 | |         Args:
65 | |             snippet: The Snippet object to save.
66 | |
67 | |         Returns:
68 | |             True if the snippet was inserted or updated successfully.
69 | |
70 | |         Raises:
71 | |             ValueError: If validation fails (e.g., duplicate name, invalid data).
72 | |             DatabaseError: If a database operation fails.
73 | |         """
   | |___________^ D212
74 |           exists = self.db.execute(
75 |               "SELECT 1 FROM snippets WHERE snippet_id = ?", (snippet.snippet_id,)
   |
   = help: Remove whitespace after opening quotes

models\snippet_manager.py:326:9: D212 [*] Multi-line docstring summary should start at the first line
    |
325 |       def create_dynamic_snippet(self, category_id: str) -> Snippet:
326 | /         """
327 | |         Creates or retrieves a dynamic snippet with preset content.
328 | |         
329 | |         Checks if a dynamic snippet named "Dynamic Exercises" already exists in the 
330 | |         specified category. If it exists, returns the existing snippet. If not, 
331 | |         creates a new dynamic snippet and returns it.
332 | |         
333 | |         Args:
334 | |             category_id: The UUID of the category to create/find the snippet in
335 | |             
336 | |         Returns:
337 | |             Snippet object for the dynamic exercises snippet
338 | |             
339 | |         Raises:
340 | |             DatabaseError: If database operations fail
341 | |         """
    | |___________^ D212
342 |           snippet_name = "Dynamic Exercises"
    |
    = help: Remove whitespace after opening quotes

models\snippet_manager.py:383:9: D205 1 blank line required between summary line and description
    |
382 |       def get_starting_index(self, snippet_id: str, user_id: str, keyboard_id: str) -> int:
383 | /         """
384 | |         Returns the next starting index for a snippet for a given user and keyboard.
385 | |         Looks up the latest practice_session for this snippet, user, and keyboard,
386 | |         and returns the maximum snippet_index_end typed so far + 1.
387 | |         If no session exists, returns 0.
388 | |         If the index is >= snippet length - 1, returns 0 (wraps around).
389 | |         """
    | |___________^ D205
390 |           snippet = self.get_snippet_by_id(snippet_id)
391 |           if not snippet:
    |
    = help: Insert single blank line

models\snippet_manager.py:383:9: D212 [*] Multi-line docstring summary should start at the first line
    |
382 |       def get_starting_index(self, snippet_id: str, user_id: str, keyboard_id: str) -> int:
383 | /         """
384 | |         Returns the next starting index for a snippet for a given user and keyboard.
385 | |         Looks up the latest practice_session for this snippet, user, and keyboard,
386 | |         and returns the maximum snippet_index_end typed so far + 1.
387 | |         If no session exists, returns 0.
388 | |         If the index is >= snippet length - 1, returns 0 (wraps around).
389 | |         """
    | |___________^ D212
390 |           snippet = self.get_snippet_by_id(snippet_id)
391 |           if not snippet:
    |
    = help: Remove whitespace after opening quotes

models\user.py:1:1: D205 1 blank line required between summary line and description
  |
1 | / """
2 | | User data model.
3 | | Defines the structure and validation for a user.
4 | | """
  | |___^ D205
5 |
6 |   from __future__ import annotations
  |
  = help: Insert single blank line

models\user.py:1:1: D212 [*] Multi-line docstring summary should start at the first line
  |
1 | / """
2 | | User data model.
3 | | Defines the structure and validation for a user.
4 | | """
  | |___^ D212
5 |
6 |   from __future__ import annotations
  |
  = help: Remove whitespace after opening quotes

models\user.py:37:9: D301 Use `r"""` if any backslashes in a docstring
   |
35 |       @classmethod
36 |       def validate_name_format(cls, v: str) -> str:
37 | /         """Validate name format.
38 | |
39 | |         Names must:
40 | |         - Not be empty or whitespace only
41 | |         - Be 1-64 characters long
42 | |         - Be ASCII-only
43 | |         - Not contain control characters (\n, \t, etc.)
44 | |         - Only contain letters, spaces, hyphens, and apostrophes
45 | |         - Not start or end with a space, hyphen, or apostrophe
46 | |         - Not contain consecutive spaces, hyphens, or apostrophes
47 | |
48 | |         Args:
49 | |             v: The name to validate
50 | |
51 | |         Returns:
52 | |             The validated and stripped name
53 | |
54 | |         Raises:
55 | |             ValueError: If the name is invalid
56 | |         """
   | |___________^ D301
57 |           if not v or not v.strip():
58 |               raise ValueError("Name cannot be blank.")
   |
   = help: Add `r` prefix

models\user.py:93:9: D102 Missing docstring in public method
   |
91 |     @field_validator("email_address")
92 |     @classmethod
93 |     def validate_email(cls, v: str) -> str:
   |         ^^^^^^^^^^^^^^ D102
94 |         if not v or not v.strip():
95 |             raise ValueError("Email address cannot be blank.")
   |

models\user.py:183:9: D102 Missing docstring in public method
    |
181 |     @model_validator(mode="before")
182 |     @classmethod
183 |     def ensure_user_id(cls, values: dict) -> dict:
    |         ^^^^^^^^^^^^^^ D102
184 |         # Only generate a default UUID if user_id is None (not provided)
185 |         # NOT if it's an empty string (explicitly provided as empty)
    |

models\user.py:192:9: D102 Missing docstring in public method
    |
190 |     @field_validator("user_id")
191 |     @classmethod
192 |     def validate_user_id(cls, v: str) -> str:
    |         ^^^^^^^^^^^^^^^^ D102
193 |         if not v:
194 |             raise ValueError("user_id must not be empty")
    |

models\user.py:201:9: D102 Missing docstring in public method
    |
199 |         return v
200 |
201 |     def to_dict(self) -> Dict[str, Any]:
    |         ^^^^^^^ D102
202 |         return self.dict()
    |

models\user.py:205:9: D102 Missing docstring in public method
    |
204 |     @classmethod
205 |     def from_dict(cls, d: Dict[str, Any]) -> "User":
    |         ^^^^^^^^^ D102
206 |         allowed = set(cls.model_fields.keys())
207 |         extra = set(d.keys()) - allowed
    |

models\user_manager.py:1:1: D205 1 blank line required between summary line and description
  |
1 | / """
2 | | User Manager for CRUD operations.
3 | | Handles all DB access for users.
4 | | """
  | |___^ D205
5 |
6 |   from typing import List, Optional
  |
  = help: Insert single blank line

models\user_manager.py:1:1: D212 [*] Multi-line docstring summary should start at the first line
  |
1 | / """
2 | | User Manager for CRUD operations.
3 | | Handles all DB access for users.
4 | | """
  | |___^ D212
5 |
6 |   from typing import List, Optional
  |
  = help: Remove whitespace after opening quotes

models\user_manager.py:12:7: D101 Missing docstring in public class
   |
12 | class UserValidationError(Exception):
   |       ^^^^^^^^^^^^^^^^^^^ D101
13 |     def __init__(self, message: str = "User validation failed") -> None:
14 |         self.message = message
   |

models\user_manager.py:13:9: D107 Missing docstring in `__init__`
   |
12 | class UserValidationError(Exception):
13 |     def __init__(self, message: str = "User validation failed") -> None:
   |         ^^^^^^^^ D107
14 |         self.message = message
15 |         super().__init__(self.message)
   |

models\user_manager.py:18:7: D101 Missing docstring in public class
   |
18 | class UserNotFound(Exception):
   |       ^^^^^^^^^^^^ D101
19 |     def __init__(self, message: str = "User not found") -> None:
20 |         self.message = message
   |

models\user_manager.py:19:9: D107 Missing docstring in `__init__`
   |
18 | class UserNotFound(Exception):
19 |     def __init__(self, message: str = "User not found") -> None:
   |         ^^^^^^^^ D107
20 |         self.message = message
21 |         super().__init__(self.message)
   |

models\user_manager.py:24:7: D101 Missing docstring in public class
   |
24 | class UserManager:
   |       ^^^^^^^^^^^ D101
25 |     def __init__(self, db_manager: DatabaseManager) -> None:
26 |         self.db_manager: DatabaseManager = db_manager
   |

models\user_manager.py:25:9: D107 Missing docstring in `__init__`
   |
24 | class UserManager:
25 |     def __init__(self, db_manager: DatabaseManager) -> None:
   |         ^^^^^^^^ D107
26 |         self.db_manager: DatabaseManager = db_manager
   |

models\user_manager.py:39:9: D102 Missing docstring in public method
   |
37 |             raise UserValidationError(f"Email address '{email_address}' must be unique.")
38 |
39 |     def get_user_by_id(self, user_id: str) -> User:
   |         ^^^^^^^^^^^^^^ D102
40 |         row = self.db_manager.fetchone(
41 |             "SELECT user_id, first_name, surname, email_address FROM users WHERE user_id = ?",
   |

models\user_manager.py:53:9: D102 Missing docstring in public method
   |
51 |         )
52 |
53 |     def get_user_by_email(self, email_address: str) -> User:
   |         ^^^^^^^^^^^^^^^^^ D102
54 |         # Use case-insensitive comparison for email retrieval
55 |         query = (
   |

models\user_manager.py:69:9: D102 Missing docstring in public method
   |
67 |         )
68 |
69 |     def list_all_users(self) -> List[User]:
   |         ^^^^^^^^^^^^^^ D102
70 |         query = (
71 |             "SELECT user_id, first_name, surname, email_address FROM users "
   |

models\user_manager.py:85:9: D102 Missing docstring in public method
   |
83 |         ]
84 |
85 |     def save_user(self, user: User) -> bool:
   |         ^^^^^^^^^ D102
86 |         self._validate_email_uniqueness(user.email_address, user.user_id)
87 |         if self.__user_exists(user.user_id):
   |

models\user_manager.py:112:9: D102 Missing docstring in public method
    |
110 |         return True
111 |
112 |     def delete_user_by_id(self, user_id: str) -> bool:
    |         ^^^^^^^^^^^^^^^^^ D102
113 |         if not self.db_manager.fetchone(
114 |             "SELECT 1 FROM users WHERE user_id = ?",
    |

models\user_manager.py:124:9: D102 Missing docstring in public method
    |
122 |         return True
123 |
124 |     def delete_user(self, user_id: str) -> bool:
    |         ^^^^^^^^^^^ D102
125 |         return self.delete_user_by_id(user_id)
    |

models\user_manager.py:127:9: D102 Missing docstring in public method
    |
125 |         return self.delete_user_by_id(user_id)
126 |
127 |     def delete_all_users(self) -> bool:
    |         ^^^^^^^^^^^^^^^^ D102
128 |         count_result = self.db_manager.fetchone("SELECT COUNT(*) FROM users")
129 |         # Handle different result structures safely
    |

Found 246 errors.
[*] 109 fixable with the `--fix` option (14 hidden fixes can be enabled with the `--unsafe-fixes` option).
AiTypingApp.py:1:1: D212 [*] Multi-line docstring summary should start at the first line
   |
 1 | / """
 2 | | AI Typing Trainer Application Entry Point.
 3 | |
 4 | | This module serves as the main entry point for the AI Typing Trainer application.
 5 | | It handles:
 6 | | - Displaying a splash screen during startup
 7 | | - Starting and verifying the GraphQL API server
 8 | | - Starting and verifying the web server
 9 | | - Launching both desktop UI and web UI main menus
10 | |
11 | | All operations follow robust error handling with clear user feedback.
12 | | """
   | |___^ D212
13 |
14 |   import os
   |
   = help: Remove whitespace after opening quotes

AiTypingApp.py:59:9: D212 [*] Multi-line docstring summary should start at the first line
   |
57 |           npm_command: Optional[List[str]] = None,
58 |       ) -> None:
59 | /         """
60 | |         Initialize the server worker.
61 | |
62 | |         Args:
63 | |             server_type: Type of server ("api" or "web")
64 | |             script_path: Path to the Python script to run (for API server)
65 | |             cwd: Current working directory for the process
66 | |             npm_command: Command to run for npm-based servers (for web server)
67 | |         """
   | |___________^ D212
68 |           super().__init__()
69 |           self.server_type = server_type
   |
   = help: Remove whitespace after opening quotes

AiTypingApp.py:183:5: D205 1 blank line required between summary line and description
    |
182 |   class SplashScreen(QDialog):
183 | /     """
184 | |     Splash screen dialog that displays during application startup.
185 | |     Shows status updates while servers are being initialized.
186 | |     """
    | |_______^ D205
187 |
188 |       def __init__(self) -> None:
    |
    = help: Insert single blank line

AiTypingApp.py:183:5: D212 [*] Multi-line docstring summary should start at the first line
    |
182 |   class SplashScreen(QDialog):
183 | /     """
184 | |     Splash screen dialog that displays during application startup.
185 | |     Shows status updates while servers are being initialized.
186 | |     """
    | |_______^ D212
187 |
188 |       def __init__(self) -> None:
    |
    = help: Remove whitespace after opening quotes

AiTypingApp.py:389:5: D205 1 blank line required between summary line and description
    |
388 |   class AiTypingApp:
389 | /     """
390 | |     Main application class for AI Typing Trainer.
391 | |     Handles application startup, server initialization, and UI display.
392 | |     """
    | |_______^ D205
393 |
394 |       def __init__(self) -> None:
    |
    = help: Insert single blank line

AiTypingApp.py:389:5: D212 [*] Multi-line docstring summary should start at the first line
    |
388 |   class AiTypingApp:
389 | /     """
390 | |     Main application class for AI Typing Trainer.
391 | |     Handles application startup, server initialization, and UI display.
392 | |     """
    | |_______^ D212
393 |
394 |       def __init__(self) -> None:
    |
    = help: Remove whitespace after opening quotes

AiTypingApp.py:408:9: D212 [*] Multi-line docstring summary should start at the first line
    |
407 |       def start(self) -> int:
408 | /         """
409 | |         Start the application.
410 | |
411 | |         Returns:
412 | |             int: Application exit code
413 | |         """
    | |___________^ D212
414 |           # Show splash screen
415 |           splash = SplashScreen()
    |
    = help: Remove whitespace after opening quotes

Spikes\hit_aws_aurora.py:1:1: D100 Missing docstring in public module
Spikes\simple_hit_aws.py:1:1: D100 Missing docstring in public module
__init__.py:1:1: D104 Missing docstring in public package
ai_typing.py:1:1: D100 Missing docstring in public module
ai_typing.py:61:9: D200 One-line docstring should fit on one line
   |
60 |       def update_status(self, msg: str) -> None:
61 | /         """
62 | |         Update the splash screen status label.
63 | |         """
   | |___________^ D200
64 |           self.label.setText(msg)
65 |           QtWidgets.QApplication.processEvents()
   |
   = help: Reformat to one line

ai_typing.py:61:9: D212 [*] Multi-line docstring summary should start at the first line
   |
60 |       def update_status(self, msg: str) -> None:
61 | /         """
62 | |         Update the splash screen status label.
63 | |         """
   | |___________^ D212
64 |           self.label.setText(msg)
65 |           QtWidgets.QApplication.processEvents()
   |
   = help: Remove whitespace after opening quotes

ai_typing.py:68:9: D200 One-line docstring should fit on one line
   |
67 |       def close_splash(self) -> None:
68 | /         """
69 | |         Close the splash screen.
70 | |         """
   | |___________^ D200
71 |           self.close()
   |
   = help: Reformat to one line

ai_typing.py:68:9: D212 [*] Multi-line docstring summary should start at the first line
   |
67 |       def close_splash(self) -> None:
68 | /         """
69 | |         Close the splash screen.
70 | |         """
   | |___________^ D212
71 |           self.close()
   |
   = help: Remove whitespace after opening quotes

ai_typing.py:75:5: D200 One-line docstring should fit on one line
   |
74 |   def start_backend() -> subprocess.Popen[bytes]:
75 | /     """
76 | |     Start the backend server using the current Python interpreter.
77 | |     """
   | |_______^ D200
78 |       # Use sys.executable for correct Python interpreter
79 |       return subprocess.Popen(
   |
   = help: Reformat to one line

ai_typing.py:75:5: D212 [*] Multi-line docstring summary should start at the first line
   |
74 |   def start_backend() -> subprocess.Popen[bytes]:
75 | /     """
76 | |     Start the backend server using the current Python interpreter.
77 | |     """
   | |_______^ D212
78 |       # Use sys.executable for correct Python interpreter
79 |       return subprocess.Popen(
   |
   = help: Remove whitespace after opening quotes

ai_typing.py:120:5: D200 One-line docstring should fit on one line
    |
119 |   def launch_desktop_ui() -> None:
120 | /     """
121 | |     Launch the desktop UI as a subprocess.
122 | |     """
    | |_______^ D200
123 |       subprocess.Popen(
124 |           [sys.executable, DESKTOP_UI_SCRIPT],
    |
    = help: Reformat to one line

ai_typing.py:120:5: D212 [*] Multi-line docstring summary should start at the first line
    |
119 |   def launch_desktop_ui() -> None:
120 | /     """
121 | |     Launch the desktop UI as a subprocess.
122 | |     """
    | |_______^ D212
123 |       subprocess.Popen(
124 |           [sys.executable, DESKTOP_UI_SCRIPT],
    |
    = help: Remove whitespace after opening quotes

api\__init__.py:1:1: D104 Missing docstring in public package
api\category_api.py:1:1: D100 Missing docstring in public module
api\category_api.py:1:1: I001 [*] Import block is un-sorted or un-formatted
  |
1 | / from typing import Dict, List, Tuple, Union, Any
2 | |
3 | | from flask import Blueprint, jsonify, request, Response
4 | | from pydantic import BaseModel, ValidationError
5 | |
6 | | from db.database_manager import DatabaseManager
7 | | from models.category import CategoryManager
  | |___________________________________________^ I001
  |
  = help: Organize imports

api\category_api.py:1:20: F401 [*] `typing.Dict` imported but unused
  |
1 | from typing import Dict, List, Tuple, Union, Any
  |                    ^^^^ F401
2 |
3 | from flask import Blueprint, jsonify, request, Response
  |
  = help: Remove unused import

api\category_api.py:1:26: F401 [*] `typing.List` imported but unused
  |
1 | from typing import Dict, List, Tuple, Union, Any
  |                          ^^^^ F401
2 |
3 | from flask import Blueprint, jsonify, request, Response
  |
  = help: Remove unused import

api\category_api.py:1:46: F401 [*] `typing.Any` imported but unused
  |
1 | from typing import Dict, List, Tuple, Union, Any
  |                                              ^^^ F401
2 |
3 | from flask import Blueprint, jsonify, request, Response
  |
  = help: Remove unused import

api\category_api.py:10:7: D101 Missing docstring in public class
   |
10 | class CategoryCreateRequest(BaseModel):
   |       ^^^^^^^^^^^^^^^^^^^^^ D101
11 |     category_name: str
   |

api\category_api.py:14:7: D101 Missing docstring in public class
   |
14 | class CategoryRenameRequest(BaseModel):
   |       ^^^^^^^^^^^^^^^^^^^^^ D101
15 |     category_name: str
   |

api\category_api.py:18:5: D103 Missing docstring in public function
   |
18 | def create_category_api() -> Blueprint:
   |     ^^^^^^^^^^^^^^^^^^^ D103
19 |     category_api = Blueprint("category_api", __name__)
   |

api\category_graphql.py:1:1: D212 [*] Multi-line docstring summary should start at the first line
  |
1 | / """
2 | | GraphQL API for Category operations using Graphene and Flask.
3 | |
4 | | This module provides a GraphQL interface for managing categories in the application,
5 | | with endpoints for querying, creating, updating, and deleting categories.
6 | | """
  | |___^ D212
7 |
8 |   # Standard library imports
  |
  = help: Remove whitespace after opening quotes

api\category_graphql.py:45:41: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `_info`
   |
43 |     category = Field(CategoryType, category_id=Int(name="categoryId", required=True))
44 |
45 |     def resolve_categories(self, _info: Any) -> TypedList[Category]:
   |                                         ^^^ ANN401
46 |         """
47 |         Resolve all categories.
   |

api\category_graphql.py:46:9: D212 [*] Multi-line docstring summary should start at the first line
   |
45 |       def resolve_categories(self, _info: Any) -> TypedList[Category]:
46 | /         """
47 | |         Resolve all categories.
48 | |
49 | |         Args:
50 | |             _info: GraphQL resolver info (unused but required by GraphQL)
51 | |
52 | |         Returns:
53 | |             List of category models
54 | |         """
   | |___________^ D212
55 |           return CategoryManager.list_categories()
   |
   = help: Remove whitespace after opening quotes

api\category_graphql.py:57:39: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `_info`
   |
55 |         return CategoryManager.list_categories()
56 |
57 |     def resolve_category(self, _info: Any, category_id: int) -> Optional[Category]:
   |                                       ^^^ ANN401
58 |         """
59 |         Resolve a specific category by ID.
   |

api\category_graphql.py:58:9: D212 [*] Multi-line docstring summary should start at the first line
   |
57 |       def resolve_category(self, _info: Any, category_id: int) -> Optional[Category]:
58 | /         """
59 | |         Resolve a specific category by ID.
60 | |
61 | |         Args:
62 | |             _info: GraphQL resolver info (unused but required by GraphQL)
63 | |             category_id: The ID of the category to fetch
64 | |
65 | |         Returns:
66 | |             The category model if found, None otherwise
67 | |         """
   | |___________^ D212
68 |           try:
69 |               return CategoryManager.get_category(category_id)
   |
   = help: Remove whitespace after opening quotes

api\category_graphql.py:80:11: D106 Missing docstring in public nested class
   |
78 |     """
79 |
80 |     class Arguments:
   |           ^^^^^^^^^ D106
81 |         category_name = String(required=True, name="categoryName")
   |

api\category_graphql.py:85:29: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `_info`
   |
83 |     category = Field(lambda: CategoryType)
84 |
85 |     def mutate(self, _info: Any, category_name: str) -> "CreateCategory":
   |                             ^^^ ANN401
86 |         """
87 |         Create a new category with the provided name.
   |

api\category_graphql.py:86:9: D212 [*] Multi-line docstring summary should start at the first line
    |
 85 |       def mutate(self, _info: Any, category_name: str) -> "CreateCategory":
 86 | /         """
 87 | |         Create a new category with the provided name.
 88 | |
 89 | |         Args:
 90 | |             _info: GraphQL resolver info (unused but required by GraphQL)
 91 | |             category_name: The name for the new category
 92 | |
 93 | |         Returns:
 94 | |             CreateCategory: The mutation result with the created category
 95 | |
 96 | |         Raises:
 97 | |             GraphQLError: If validation fails or an error occurs
 98 | |         """
    | |___________^ D212
 99 |           try:
100 |               cat = CategoryManager.create_category(category_name)
    |
    = help: Remove whitespace after opening quotes

api\category_graphql.py:105:13: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
    |
103 |         except (CategoryValidationError, ValueError) as e:
104 |             # Graphene will convert this to a proper GraphQL error
105 |             raise Exception(str(e))
    |             ^^^^^^^^^^^^^^^^^^^^^^^ B904
    |

api\category_graphql.py:114:11: D106 Missing docstring in public nested class
    |
112 |     """
113 |
114 |     class Arguments:
    |           ^^^^^^^^^ D106
115 |         category_id = Int(required=True, name="categoryId")
116 |         category_name = String(required=True, name="categoryName")
    |

api\category_graphql.py:121:22: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `_info`
    |
120 |     def mutate(
121 |         self, _info: Any, category_id: int, category_name: str
    |                      ^^^ ANN401
122 |     ) -> "UpdateCategory":
123 |         """
    |

api\category_graphql.py:123:9: D212 [*] Multi-line docstring summary should start at the first line
    |
121 |           self, _info: Any, category_id: int, category_name: str
122 |       ) -> "UpdateCategory":
123 | /         """
124 | |         Update an existing category with the provided name.
125 | |
126 | |         Args:
127 | |             _info: GraphQL resolver info (unused but required by GraphQL)
128 | |             category_id: The ID of the category to update
129 | |             category_name: The new name for the category
130 | |
131 | |         Returns:
132 | |             UpdateCategory: The mutation result with the updated category
133 | |
134 | |         Raises:
135 | |             GraphQLError: If validation fails or the category is not found
136 | |         """
    | |___________^ D212
137 |           try:
138 |               cat = CategoryManager.rename_category(category_id, category_name)
    |
    = help: Remove whitespace after opening quotes

api\category_graphql.py:143:13: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
    |
141 |         except (CategoryValidationError, CategoryNotFound, ValueError) as e:
142 |             # Graphene will convert this to a proper GraphQL error
143 |             raise Exception(str(e))
    |             ^^^^^^^^^^^^^^^^^^^^^^^ B904
    |

api\category_graphql.py:152:11: D106 Missing docstring in public nested class
    |
150 |     """
151 |
152 |     class Arguments:
    |           ^^^^^^^^^ D106
153 |         category_id = Int(required=True, name="categoryId")
    |

api\category_graphql.py:157:29: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `_info`
    |
155 |     ok = Boolean()
156 |
157 |     def mutate(self, _info: Any, category_id: int) -> "DeleteCategory":
    |                             ^^^ ANN401
158 |         """
159 |         Delete a category by ID.
    |

api\category_graphql.py:158:9: D212 [*] Multi-line docstring summary should start at the first line
    |
157 |       def mutate(self, _info: Any, category_id: int) -> "DeleteCategory":
158 | /         """
159 | |         Delete a category by ID.
160 | |
161 | |         Args:
162 | |             _info: GraphQL resolver info (unused but required by GraphQL)
163 | |             category_id: The ID of the category to delete
164 | |
165 | |         Returns:
166 | |             DeleteCategory: The mutation result with ok=True if successful
167 | |
168 | |         Raises:
169 | |             GraphQLError: If the category is not found
170 | |         """
    | |___________^ D212
171 |           try:
172 |               CategoryManager.delete_category(category_id)
    |
    = help: Remove whitespace after opening quotes

api\category_graphql.py:177:13: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
    |
175 |         except CategoryNotFound as e:
176 |             # Graphene will convert this to a proper GraphQL error
177 |             raise Exception(str(e))
    |             ^^^^^^^^^^^^^^^^^^^^^^^ B904
    |

api\category_graphql.py:200:5: D212 [*] Multi-line docstring summary should start at the first line
    |
198 |   @category_graphql.route("/graphql", methods=["POST"])
199 |   def graphql_api() -> Response:
200 | /     """
201 | |     GraphQL API endpoint for category operations.
202 | |
203 | |     Handles GraphQL queries and mutations and returns formatted JSON responses.
204 | |
205 | |     Returns:
206 | |         Response: JSON response with GraphQL execution result
207 | |     """
    | |_______^ D212
208 |       data = request.get_json() or {}
209 |       query = data.get("query", "")
    |
    = help: Remove whitespace after opening quotes

api\dbviewer_api.py:1:1: D415 First line should end with a period, question mark, or exclamation point
   |
 1 | / """Database Viewer API Module
 2 | |
 3 | | Provides REST API endpoints for the Database Viewer functionality:
 4 | | - Listing available database tables
 5 | | - Retrieving table data with pagination, sorting, and filtering
 6 | | - Exporting table data to CSV
 7 | |
 8 | | All endpoints are read-only and ensure proper validation and error handling.
 9 | | """
   | |___^ D415
10 |
11 |   from io import StringIO
   |
   = help: Add closing punctuation

api\dbviewer_api.py:34:5: ANN201 Missing return type annotation for public function `list_tables`
   |
33 | @dbviewer_api.route("/tables", methods=["GET"])
34 | def list_tables():
   |     ^^^^^^^^^^^ ANN201
35 |     """List all available database tables."""
36 |     try:
   |
   = help: Add return type annotation

api\dbviewer_api.py:52:5: ANN201 Missing return type annotation for public function `get_table_data`
   |
51 | @dbviewer_api.route("/table", methods=["GET"])
52 | def get_table_data():
   |     ^^^^^^^^^^^^^^ ANN201
53 |     """Get table data with pagination, sorting, and filtering.
   |
   = help: Add return type annotation

api\dbviewer_api.py:101:5: ANN201 Missing return type annotation for public function `export_table_to_csv`
    |
100 | @dbviewer_api.route("/export", methods=["GET"])
101 | def export_table_to_csv():
    |     ^^^^^^^^^^^^^^^^^^^ ANN201
102 |     """Export table data to CSV format.
    |
    = help: Add return type annotation

api\keystroke_api.py:1:1: D100 Missing docstring in public module
api\keystroke_api.py:8:1: E402 Module level import not at top of file
  |
6 | keystroke_api = Blueprint("keystroke_api", __name__)
7 |
8 | from typing import Optional
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
  |

api\keystroke_api.py:11:7: D101 Missing docstring in public class
   |
11 | class KeystrokeCreateModel(BaseModel):
   |       ^^^^^^^^^^^^^^^^^^^^ D101
12 |     session_id: int
13 |     keystroke_id: Optional[int] = None
   |

api\keystroke_api.py:22:5: ANN201 Missing return type annotation for public function `api_record_keystroke`
   |
21 | @keystroke_api.route("/api/keystrokes", methods=["POST"])
22 | def api_record_keystroke():
   |     ^^^^^^^^^^^^^^^^^^^^ ANN201
23 |     import sys
   |
   = help: Add return type annotation

api\keystroke_api.py:22:5: D103 Missing docstring in public function
   |
21 | @keystroke_api.route("/api/keystrokes", methods=["POST"])
22 | def api_record_keystroke():
   |     ^^^^^^^^^^^^^^^^^^^^ D103
23 |     import sys
   |

api\keystroke_api.py:71:5: ANN201 Missing return type annotation for public function `api_list_keystrokes`
   |
70 | @keystroke_api.route("/api/keystrokes", methods=["GET"])
71 | def api_list_keystrokes():
   |     ^^^^^^^^^^^^^^^^^^^ ANN201
72 |     session_id = request.args.get("session_id")
73 |     if not session_id:
   |
   = help: Add return type annotation

api\keystroke_api.py:71:5: D103 Missing docstring in public function
   |
70 | @keystroke_api.route("/api/keystrokes", methods=["GET"])
71 | def api_list_keystrokes():
   |     ^^^^^^^^^^^^^^^^^^^ D103
72 |     session_id = request.args.get("session_id")
73 |     if not session_id:
   |

api\library_graphql.py:1:1: D205 1 blank line required between summary line and description
  |
1 | / """
2 | | GraphQL API for the Snippets Library (categories, snippets, snippet parts).
3 | | All logic is routed through LibraryManager in models/library.py.
4 | | """
  | |___^ D205
5 |
6 |   import graphene
  |
  = help: Insert single blank line

api\library_graphql.py:1:1: D212 [*] Multi-line docstring summary should start at the first line
  |
1 | / """
2 | | GraphQL API for the Snippets Library (categories, snippets, snippet parts).
3 | | All logic is routed through LibraryManager in models/library.py.
4 | | """
  | |___^ D212
5 |
6 |   import graphene
  |
  = help: Remove whitespace after opening quotes

api\library_graphql.py:18:5: ANN201 Missing return type annotation for public function `get_library_manager`
   |
18 | def get_library_manager():
   |     ^^^^^^^^^^^^^^^^^^^ ANN201
19 |     # Dependency injection for testability
20 |     db_manager = getattr(g, "db_manager", None)
   |
   = help: Add return type annotation

api\library_graphql.py:18:5: D103 Missing docstring in public function
   |
18 | def get_library_manager():
   |     ^^^^^^^^^^^^^^^^^^^ D103
19 |     # Dependency injection for testability
20 |     db_manager = getattr(g, "db_manager", None)
   |

api\library_graphql.py:26:7: D101 Missing docstring in public class
   |
26 | class CategoryType(graphene.ObjectType):
   |       ^^^^^^^^^^^^ D101
27 |     category_id = Int()
28 |     category_name = String()
   |

api\library_graphql.py:31:7: D101 Missing docstring in public class
   |
31 | class SnippetType(graphene.ObjectType):
   |       ^^^^^^^^^^^ D101
32 |     snippet_id = Int()
33 |     category_id = Int()
   |

api\library_graphql.py:38:7: D101 Missing docstring in public class
   |
38 | class SnippetPartType(graphene.ObjectType):
   |       ^^^^^^^^^^^^^^^ D101
39 |     part_id = Int()
40 |     snippet_id = Int()
   |

api\library_graphql.py:46:7: D101 Missing docstring in public class
   |
45 | # QUERIES
46 | class Query(ObjectType):
   |       ^^^^^ D101
47 |     categories = List(CategoryType)
48 |     snippets = List(SnippetType, category_id=Int(required=True))
   |

api\library_graphql.py:52:9: ANN201 Missing return type annotation for public function `resolve_categories`
   |
50 |     snippet_parts = List(SnippetPartType, snippet_id=Int(required=True))
51 |
52 |     def resolve_categories(self, info):
   |         ^^^^^^^^^^^^^^^^^^ ANN201
53 |         mgr = get_library_manager()
54 |         return mgr.list_categories()
   |
   = help: Add return type annotation

api\library_graphql.py:52:9: D102 Missing docstring in public method
   |
50 |     snippet_parts = List(SnippetPartType, snippet_id=Int(required=True))
51 |
52 |     def resolve_categories(self, info):
   |         ^^^^^^^^^^^^^^^^^^ D102
53 |         mgr = get_library_manager()
54 |         return mgr.list_categories()
   |

api\library_graphql.py:52:34: ANN001 Missing type annotation for function argument `info`
   |
50 |     snippet_parts = List(SnippetPartType, snippet_id=Int(required=True))
51 |
52 |     def resolve_categories(self, info):
   |                                  ^^^^ ANN001
53 |         mgr = get_library_manager()
54 |         return mgr.list_categories()
   |

api\library_graphql.py:56:9: ANN201 Missing return type annotation for public function `resolve_snippets`
   |
54 |         return mgr.list_categories()
55 |
56 |     def resolve_snippets(self, info, category_id):
   |         ^^^^^^^^^^^^^^^^ ANN201
57 |         mgr = get_library_manager()
58 |         return mgr.list_snippets(category_id)
   |
   = help: Add return type annotation

api\library_graphql.py:56:9: D102 Missing docstring in public method
   |
54 |         return mgr.list_categories()
55 |
56 |     def resolve_snippets(self, info, category_id):
   |         ^^^^^^^^^^^^^^^^ D102
57 |         mgr = get_library_manager()
58 |         return mgr.list_snippets(category_id)
   |

api\library_graphql.py:56:32: ANN001 Missing type annotation for function argument `info`
   |
54 |         return mgr.list_categories()
55 |
56 |     def resolve_snippets(self, info, category_id):
   |                                ^^^^ ANN001
57 |         mgr = get_library_manager()
58 |         return mgr.list_snippets(category_id)
   |

api\library_graphql.py:56:38: ANN001 Missing type annotation for function argument `category_id`
   |
54 |         return mgr.list_categories()
55 |
56 |     def resolve_snippets(self, info, category_id):
   |                                      ^^^^^^^^^^^ ANN001
57 |         mgr = get_library_manager()
58 |         return mgr.list_snippets(category_id)
   |

api\library_graphql.py:60:9: ANN201 Missing return type annotation for public function `resolve_snippet`
   |
58 |         return mgr.list_snippets(category_id)
59 |
60 |     def resolve_snippet(self, info, snippet_id):
   |         ^^^^^^^^^^^^^^^ ANN201
61 |         mgr = get_library_manager()
62 |         snippets = mgr.list_snippets(-1)  # Dummy call to get type
   |
   = help: Add return type annotation

api\library_graphql.py:60:9: D102 Missing docstring in public method
   |
58 |         return mgr.list_snippets(category_id)
59 |
60 |     def resolve_snippet(self, info, snippet_id):
   |         ^^^^^^^^^^^^^^^ D102
61 |         mgr = get_library_manager()
62 |         snippets = mgr.list_snippets(-1)  # Dummy call to get type
   |

api\library_graphql.py:60:31: ANN001 Missing type annotation for function argument `info`
   |
58 |         return mgr.list_snippets(category_id)
59 |
60 |     def resolve_snippet(self, info, snippet_id):
   |                               ^^^^ ANN001
61 |         mgr = get_library_manager()
62 |         snippets = mgr.list_snippets(-1)  # Dummy call to get type
   |

api\library_graphql.py:60:37: ANN001 Missing type annotation for function argument `snippet_id`
   |
58 |         return mgr.list_snippets(category_id)
59 |
60 |     def resolve_snippet(self, info, snippet_id):
   |                                     ^^^^^^^^^^ ANN001
61 |         mgr = get_library_manager()
62 |         snippets = mgr.list_snippets(-1)  # Dummy call to get type
   |

api\library_graphql.py:68:9: ANN201 Missing return type annotation for public function `resolve_snippet_parts`
   |
66 |         return None
67 |
68 |     def resolve_snippet_parts(self, info, snippet_id):
   |         ^^^^^^^^^^^^^^^^^^^^^ ANN201
69 |         mgr = get_library_manager()
70 |         return mgr.list_parts(snippet_id)
   |
   = help: Add return type annotation

api\library_graphql.py:68:9: D102 Missing docstring in public method
   |
66 |         return None
67 |
68 |     def resolve_snippet_parts(self, info, snippet_id):
   |         ^^^^^^^^^^^^^^^^^^^^^ D102
69 |         mgr = get_library_manager()
70 |         return mgr.list_parts(snippet_id)
   |

api\library_graphql.py:68:37: ANN001 Missing type annotation for function argument `info`
   |
66 |         return None
67 |
68 |     def resolve_snippet_parts(self, info, snippet_id):
   |                                     ^^^^ ANN001
69 |         mgr = get_library_manager()
70 |         return mgr.list_parts(snippet_id)
   |

api\library_graphql.py:68:43: ANN001 Missing type annotation for function argument `snippet_id`
   |
66 |         return None
67 |
68 |     def resolve_snippet_parts(self, info, snippet_id):
   |                                           ^^^^^^^^^^ ANN001
69 |         mgr = get_library_manager()
70 |         return mgr.list_parts(snippet_id)
   |

api\library_graphql.py:74:7: D101 Missing docstring in public class
   |
73 | # MUTATIONS
74 | class CreateCategory(Mutation):
   |       ^^^^^^^^^^^^^^ D101
75 |     class Arguments:
76 |         category_name = String(required=True)
   |

api\library_graphql.py:75:11: D106 Missing docstring in public nested class
   |
73 | # MUTATIONS
74 | class CreateCategory(Mutation):
75 |     class Arguments:
   |           ^^^^^^^^^ D106
76 |         category_name = String(required=True)
   |

api\library_graphql.py:82:9: ANN201 Missing return type annotation for public function `mutate`
   |
80 |     error = String()
81 |
82 |     def mutate(self, info, category_name):
   |         ^^^^^^ ANN201
83 |         mgr = get_library_manager()
84 |         try:
   |
   = help: Add return type annotation

api\library_graphql.py:82:9: D102 Missing docstring in public method
   |
80 |     error = String()
81 |
82 |     def mutate(self, info, category_name):
   |         ^^^^^^ D102
83 |         mgr = get_library_manager()
84 |         try:
   |

api\library_graphql.py:82:22: ANN001 Missing type annotation for function argument `info`
   |
80 |     error = String()
81 |
82 |     def mutate(self, info, category_name):
   |                      ^^^^ ANN001
83 |         mgr = get_library_manager()
84 |         try:
   |

api\library_graphql.py:82:28: ANN001 Missing type annotation for function argument `category_name`
   |
80 |     error = String()
81 |
82 |     def mutate(self, info, category_name):
   |                            ^^^^^^^^^^^^^ ANN001
83 |         mgr = get_library_manager()
84 |         try:
   |

api\library_graphql.py:93:7: D101 Missing docstring in public class
   |
93 | class RenameCategory(Mutation):
   |       ^^^^^^^^^^^^^^ D101
94 |     class Arguments:
95 |         category_id = Int(required=True)
   |

api\library_graphql.py:94:11: D106 Missing docstring in public nested class
   |
93 | class RenameCategory(Mutation):
94 |     class Arguments:
   |           ^^^^^^^^^ D106
95 |         category_id = Int(required=True)
96 |         category_name = String(required=True)
   |

api\library_graphql.py:101:9: ANN201 Missing return type annotation for public function `mutate`
    |
 99 |     error = String()
100 |
101 |     def mutate(self, info, category_id, category_name):
    |         ^^^^^^ ANN201
102 |         mgr = get_library_manager()
103 |         try:
    |
    = help: Add return type annotation

api\library_graphql.py:101:9: D102 Missing docstring in public method
    |
 99 |     error = String()
100 |
101 |     def mutate(self, info, category_id, category_name):
    |         ^^^^^^ D102
102 |         mgr = get_library_manager()
103 |         try:
    |

api\library_graphql.py:101:22: ANN001 Missing type annotation for function argument `info`
    |
 99 |     error = String()
100 |
101 |     def mutate(self, info, category_id, category_name):
    |                      ^^^^ ANN001
102 |         mgr = get_library_manager()
103 |         try:
    |

api\library_graphql.py:101:28: ANN001 Missing type annotation for function argument `category_id`
    |
 99 |     error = String()
100 |
101 |     def mutate(self, info, category_id, category_name):
    |                            ^^^^^^^^^^^ ANN001
102 |         mgr = get_library_manager()
103 |         try:
    |

api\library_graphql.py:101:41: ANN001 Missing type annotation for function argument `category_name`
    |
 99 |     error = String()
100 |
101 |     def mutate(self, info, category_id, category_name):
    |                                         ^^^^^^^^^^^^^ ANN001
102 |         mgr = get_library_manager()
103 |         try:
    |

api\library_graphql.py:110:7: D101 Missing docstring in public class
    |
110 | class DeleteCategory(Mutation):
    |       ^^^^^^^^^^^^^^ D101
111 |     class Arguments:
112 |         category_id = Int(required=True)
    |

api\library_graphql.py:111:11: D106 Missing docstring in public nested class
    |
110 | class DeleteCategory(Mutation):
111 |     class Arguments:
    |           ^^^^^^^^^ D106
112 |         category_id = Int(required=True)
    |

api\library_graphql.py:117:9: ANN201 Missing return type annotation for public function `mutate`
    |
115 |     error = String()
116 |
117 |     def mutate(self, info, category_id):
    |         ^^^^^^ ANN201
118 |         mgr = get_library_manager()
119 |         try:
    |
    = help: Add return type annotation

api\library_graphql.py:117:9: D102 Missing docstring in public method
    |
115 |     error = String()
116 |
117 |     def mutate(self, info, category_id):
    |         ^^^^^^ D102
118 |         mgr = get_library_manager()
119 |         try:
    |

api\library_graphql.py:117:22: ANN001 Missing type annotation for function argument `info`
    |
115 |     error = String()
116 |
117 |     def mutate(self, info, category_id):
    |                      ^^^^ ANN001
118 |         mgr = get_library_manager()
119 |         try:
    |

api\library_graphql.py:117:28: ANN001 Missing type annotation for function argument `category_id`
    |
115 |     error = String()
116 |
117 |     def mutate(self, info, category_id):
    |                            ^^^^^^^^^^^ ANN001
118 |         mgr = get_library_manager()
119 |         try:
    |

api\library_graphql.py:126:7: D101 Missing docstring in public class
    |
126 | class CreateSnippet(Mutation):
    |       ^^^^^^^^^^^^^ D101
127 |     class Arguments:
128 |         category_id = Int(required=True)
    |

api\library_graphql.py:127:11: D106 Missing docstring in public nested class
    |
126 | class CreateSnippet(Mutation):
127 |     class Arguments:
    |           ^^^^^^^^^ D106
128 |         category_id = Int(required=True)
129 |         snippet_name = String(required=True)
    |

api\library_graphql.py:136:9: ANN201 Missing return type annotation for public function `mutate`
    |
134 |     error = String()
135 |
136 |     def mutate(self, info, category_id, snippet_name, content):
    |         ^^^^^^ ANN201
137 |         mgr = get_library_manager()
138 |         try:
    |
    = help: Add return type annotation

api\library_graphql.py:136:9: D102 Missing docstring in public method
    |
134 |     error = String()
135 |
136 |     def mutate(self, info, category_id, snippet_name, content):
    |         ^^^^^^ D102
137 |         mgr = get_library_manager()
138 |         try:
    |

api\library_graphql.py:136:22: ANN001 Missing type annotation for function argument `info`
    |
134 |     error = String()
135 |
136 |     def mutate(self, info, category_id, snippet_name, content):
    |                      ^^^^ ANN001
137 |         mgr = get_library_manager()
138 |         try:
    |

api\library_graphql.py:136:28: ANN001 Missing type annotation for function argument `category_id`
    |
134 |     error = String()
135 |
136 |     def mutate(self, info, category_id, snippet_name, content):
    |                            ^^^^^^^^^^^ ANN001
137 |         mgr = get_library_manager()
138 |         try:
    |

api\library_graphql.py:136:41: ANN001 Missing type annotation for function argument `snippet_name`
    |
134 |     error = String()
135 |
136 |     def mutate(self, info, category_id, snippet_name, content):
    |                                         ^^^^^^^^^^^^ ANN001
137 |         mgr = get_library_manager()
138 |         try:
    |

api\library_graphql.py:136:55: ANN001 Missing type annotation for function argument `content`
    |
134 |     error = String()
135 |
136 |     def mutate(self, info, category_id, snippet_name, content):
    |                                                       ^^^^^^^ ANN001
137 |         mgr = get_library_manager()
138 |         try:
    |

api\library_graphql.py:147:7: D101 Missing docstring in public class
    |
147 | class EditSnippet(Mutation):
    |       ^^^^^^^^^^^ D101
148 |     class Arguments:
149 |         snippet_id = Int(required=True)
    |

api\library_graphql.py:148:11: D106 Missing docstring in public nested class
    |
147 | class EditSnippet(Mutation):
148 |     class Arguments:
    |           ^^^^^^^^^ D106
149 |         snippet_id = Int(required=True)
150 |         snippet_name = String(required=True)
    |

api\library_graphql.py:157:9: ANN201 Missing return type annotation for public function `mutate`
    |
155 |     error = String()
156 |
157 |     def mutate(self, info, snippet_id, snippet_name, content, category_id=None):
    |         ^^^^^^ ANN201
158 |         mgr = get_library_manager()
159 |         try:
    |
    = help: Add return type annotation

api\library_graphql.py:157:9: D102 Missing docstring in public method
    |
155 |     error = String()
156 |
157 |     def mutate(self, info, snippet_id, snippet_name, content, category_id=None):
    |         ^^^^^^ D102
158 |         mgr = get_library_manager()
159 |         try:
    |

api\library_graphql.py:157:22: ANN001 Missing type annotation for function argument `info`
    |
155 |     error = String()
156 |
157 |     def mutate(self, info, snippet_id, snippet_name, content, category_id=None):
    |                      ^^^^ ANN001
158 |         mgr = get_library_manager()
159 |         try:
    |

api\library_graphql.py:157:28: ANN001 Missing type annotation for function argument `snippet_id`
    |
155 |     error = String()
156 |
157 |     def mutate(self, info, snippet_id, snippet_name, content, category_id=None):
    |                            ^^^^^^^^^^ ANN001
158 |         mgr = get_library_manager()
159 |         try:
    |

api\library_graphql.py:157:40: ANN001 Missing type annotation for function argument `snippet_name`
    |
155 |     error = String()
156 |
157 |     def mutate(self, info, snippet_id, snippet_name, content, category_id=None):
    |                                        ^^^^^^^^^^^^ ANN001
158 |         mgr = get_library_manager()
159 |         try:
    |

api\library_graphql.py:157:54: ANN001 Missing type annotation for function argument `content`
    |
155 |     error = String()
156 |
157 |     def mutate(self, info, snippet_id, snippet_name, content, category_id=None):
    |                                                      ^^^^^^^ ANN001
158 |         mgr = get_library_manager()
159 |         try:
    |

api\library_graphql.py:157:63: ANN001 Missing type annotation for function argument `category_id`
    |
155 |     error = String()
156 |
157 |     def mutate(self, info, snippet_id, snippet_name, content, category_id=None):
    |                                                               ^^^^^^^^^^^ ANN001
158 |         mgr = get_library_manager()
159 |         try:
    |

api\library_graphql.py:166:7: D101 Missing docstring in public class
    |
166 | class DeleteSnippet(Mutation):
    |       ^^^^^^^^^^^^^ D101
167 |     class Arguments:
168 |         snippet_id = Int(required=True)
    |

api\library_graphql.py:167:11: D106 Missing docstring in public nested class
    |
166 | class DeleteSnippet(Mutation):
167 |     class Arguments:
    |           ^^^^^^^^^ D106
168 |         snippet_id = Int(required=True)
    |

api\library_graphql.py:173:9: ANN201 Missing return type annotation for public function `mutate`
    |
171 |     error = String()
172 |
173 |     def mutate(self, info, snippet_id):
    |         ^^^^^^ ANN201
174 |         mgr = get_library_manager()
175 |         try:
    |
    = help: Add return type annotation

api\library_graphql.py:173:9: D102 Missing docstring in public method
    |
171 |     error = String()
172 |
173 |     def mutate(self, info, snippet_id):
    |         ^^^^^^ D102
174 |         mgr = get_library_manager()
175 |         try:
    |

api\library_graphql.py:173:22: ANN001 Missing type annotation for function argument `info`
    |
171 |     error = String()
172 |
173 |     def mutate(self, info, snippet_id):
    |                      ^^^^ ANN001
174 |         mgr = get_library_manager()
175 |         try:
    |

api\library_graphql.py:173:28: ANN001 Missing type annotation for function argument `snippet_id`
    |
171 |     error = String()
172 |
173 |     def mutate(self, info, snippet_id):
    |                            ^^^^^^^^^^ ANN001
174 |         mgr = get_library_manager()
175 |         try:
    |

api\library_graphql.py:182:7: D101 Missing docstring in public class
    |
182 | class Mutation(ObjectType):
    |       ^^^^^^^^ D101
183 |     create_category = CreateCategory.Field()
184 |     rename_category = RenameCategory.Field()
    |

api\library_graphql.py:195:5: ANN201 Missing return type annotation for public function `graphql_api`
    |
194 | @library_graphql.route("/", methods=["POST", "GET"])
195 | def graphql_api():
    |     ^^^^^^^^^^^ ANN201
196 |     data = request.get_json()
197 |     result = schema.execute(
    |
    = help: Add return type annotation

api\library_graphql.py:195:5: D103 Missing docstring in public function
    |
194 | @library_graphql.route("/", methods=["POST", "GET"])
195 | def graphql_api():
    |     ^^^^^^^^^^^ D103
196 |     data = request.get_json()
197 |     result = schema.execute(
    |

api\run_library_api.py:1:1: D200 One-line docstring should fit on one line
  |
1 | / """
2 | | Entrypoint to run the Snippets Library GraphQL API as a Flask app.
3 | | """
  | |___^ D200
4 |
5 |   import os
  |
  = help: Reformat to one line

api\run_library_api.py:1:1: D212 [*] Multi-line docstring summary should start at the first line
  |
1 | / """
2 | | Entrypoint to run the Snippets Library GraphQL API as a Flask app.
3 | | """
  | |___^ D212
4 |
5 |   import os
  |
  = help: Remove whitespace after opening quotes

api\run_library_api.py:26:5: ANN201 Missing return type annotation for public function `init_db`
   |
25 | # Initialize database tables on startup
26 | def init_db():
   |     ^^^^^^^ ANN201
27 |     """Initialize database tables"""
28 |     print("Initializing database tables...")
   |
   = help: Add return type annotation: `None`

api\run_library_api.py:27:5: D415 First line should end with a period, question mark, or exclamation point
   |
25 | # Initialize database tables on startup
26 | def init_db():
27 |     """Initialize database tables"""
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D415
28 |     print("Initializing database tables...")
29 |     db_path = app.config["DATABASE"]
   |
   = help: Add closing punctuation

api\session_api.py:1:1: D100 Missing docstring in public module
api\session_api.py:9:7: D101 Missing docstring in public class
   |
 9 | class PracticeSessionCreateModel(BaseModel):
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^ D101
10 |     snippet_id: int
11 |     snippet_index_start: int = Field(ge=0)
   |

api\session_api.py:16:5: ANN201 Missing return type annotation for public function `api_create_session`
   |
15 | @session_api.route("/api/sessions", methods=["POST"])
16 | def api_create_session():
   |     ^^^^^^^^^^^^^^^^^^ ANN201
17 |     try:
18 |         data = request.get_json()
   |
   = help: Add return type annotation

api\session_api.py:16:5: D103 Missing docstring in public function
   |
15 | @session_api.route("/api/sessions", methods=["POST"])
16 | def api_create_session():
   |     ^^^^^^^^^^^^^^^^^^ D103
17 |     try:
18 |         data = request.get_json()
   |

api\session_api.py:34:5: ANN201 Missing return type annotation for public function `api_get_session_info`
   |
33 | @session_api.route("/api/session/info", methods=["GET"])
34 | def api_get_session_info():
   |     ^^^^^^^^^^^^^^^^^^^^ ANN201
35 |     """Get last session indices and snippet length for a snippet_id."""
36 |     snippet_id = request.args.get("snippet_id", type=int)
   |
   = help: Add return type annotation

api\session_api.py:48:5: ANN201 Missing return type annotation for public function `api_get_session`
   |
47 | @session_api.route("/api/sessions/<session_id>", methods=["GET"])
48 | def api_get_session(session_id):
   |     ^^^^^^^^^^^^^^^ ANN201
49 |     session = Session.get_by_id(session_id)
50 |     if not session:
   |
   = help: Add return type annotation

api\session_api.py:48:5: D103 Missing docstring in public function
   |
47 | @session_api.route("/api/sessions/<session_id>", methods=["GET"])
48 | def api_get_session(session_id):
   |     ^^^^^^^^^^^^^^^ D103
49 |     session = Session.get_by_id(session_id)
50 |     if not session:
   |

api\session_api.py:48:21: ANN001 Missing type annotation for function argument `session_id`
   |
47 | @session_api.route("/api/sessions/<session_id>", methods=["GET"])
48 | def api_get_session(session_id):
   |                     ^^^^^^^^^^ ANN001
49 |     session = Session.get_by_id(session_id)
50 |     if not session:
   |

api\session_api.py:56:5: ANN201 Missing return type annotation for public function `api_update_session`
   |
55 | @session_api.route("/api/sessions/<session_id>", methods=["PUT"])
56 | def api_update_session(session_id):
   |     ^^^^^^^^^^^^^^^^^^ ANN201
57 |     session = Session.get_by_id(session_id)
58 |     if not session:
   |
   = help: Add return type annotation

api\session_api.py:56:5: D103 Missing docstring in public function
   |
55 | @session_api.route("/api/sessions/<session_id>", methods=["PUT"])
56 | def api_update_session(session_id):
   |     ^^^^^^^^^^^^^^^^^^ D103
57 |     session = Session.get_by_id(session_id)
58 |     if not session:
   |

api\session_api.py:56:24: ANN001 Missing type annotation for function argument `session_id`
   |
55 | @session_api.route("/api/sessions/<session_id>", methods=["PUT"])
56 | def api_update_session(session_id):
   |                        ^^^^^^^^^^ ANN001
57 |     session = Session.get_by_id(session_id)
58 |     if not session:
   |

api\snippet_api.py:19:5: ANN201 Missing return type annotation for public function `get_snippet`
   |
18 | @snippet_api.route("/api/snippets/<int:snippet_id>", methods=["GET"])
19 | def get_snippet(snippet_id: int):
   |     ^^^^^^^^^^^ ANN201
20 |     """Get a single snippet by ID.
   |
   = help: Add return type annotation

api\snippet_api.py:50:5: ANN201 Missing return type annotation for public function `api_get_snippets`
   |
49 | @snippet_api.route("/api/snippets", methods=["GET"])
50 | def api_get_snippets():
   |     ^^^^^^^^^^^^^^^^ ANN201
51 |     """Get all snippets for a specific category.
   |
   = help: Add return type annotation

api\snippet_api.py:87:5: ANN201 Missing return type annotation for public function `api_create_practice_snippet`
   |
86 | @snippet_api.route("/api/create-practice-snippet", methods=["POST"])
87 | def api_create_practice_snippet():
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
88 |     """Create a new practice snippet using the PracticeGenerator.
   |
   = help: Add return type annotation

api\snippet_api.py:107:5: ANN201 Missing return type annotation for public function `create_snippet`
    |
106 | @snippet_api.route("/api/snippets", methods=["POST"])
107 | def create_snippet():
    |     ^^^^^^^^^^^^^^ ANN201
108 |     """Create a new snippet.
    |
    = help: Add return type annotation

api\snippet_api.py:200:5: ANN201 Missing return type annotation for public function `edit_snippet`
    |
199 | @snippet_api.route("/api/snippets/<int:snippet_id>", methods=["PUT"])
200 | def edit_snippet(snippet_id: int):
    |     ^^^^^^^^^^^^ ANN201
201 |     """Update an existing snippet.
    |
    = help: Add return type annotation

api\snippet_api.py:253:5: ANN201 Missing return type annotation for public function `delete_snippet`
    |
252 | @snippet_api.route("/api/snippets/<int:snippet_id>", methods=["DELETE"])
253 | def delete_snippet(snippet_id: int):
    |     ^^^^^^^^^^^^^^ ANN201
254 |     """Delete a snippet by ID.
    |
    = help: Add return type annotation

api\unified_graphql.py:1:1: D212 [*] Multi-line docstring summary should start at the first line
  |
1 | / """
2 | | Unified GraphQL API combining snippet and category operations.
3 | |
4 | | This module provides a single GraphQL schema and endpoint that serves
5 | | both snippet and category operations through a unified interface.
6 | | """
  | |___^ D212
7 |
8 |   # Standard library imports
  |
  = help: Remove whitespace after opening quotes

api\unified_graphql.py:39:5: D205 1 blank line required between summary line and description
   |
37 |   # Utility to get snippet manager from app context
38 |   def get_snippet_manager() -> SnippetManager:
39 | /     """
40 | |     Get the SnippetManager instance from Flask context.
41 | |     Checks both g object and app.config for the manager.
42 | |     Returns:
43 | |         SnippetManager: The snippet manager instance
44 | |     Raises:
45 | |         RuntimeError: If no snippet manager is found
46 | |     """
   | |_______^ D205
47 |       if hasattr(g, "snippet_manager"):
48 |           return cast(SnippetManager, g.snippet_manager)
   |
   = help: Insert single blank line

api\unified_graphql.py:39:5: D212 [*] Multi-line docstring summary should start at the first line
   |
37 |   # Utility to get snippet manager from app context
38 |   def get_snippet_manager() -> SnippetManager:
39 | /     """
40 | |     Get the SnippetManager instance from Flask context.
41 | |     Checks both g object and app.config for the manager.
42 | |     Returns:
43 | |         SnippetManager: The snippet manager instance
44 | |     Raises:
45 | |         RuntimeError: If no snippet manager is found
46 | |     """
   | |_______^ D212
47 |       if hasattr(g, "snippet_manager"):
48 |           return cast(SnippetManager, g.snippet_manager)
   |
   = help: Remove whitespace after opening quotes

api\unified_graphql.py:39:5: D415 First line should end with a period, question mark, or exclamation point
   |
37 |   # Utility to get snippet manager from app context
38 |   def get_snippet_manager() -> SnippetManager:
39 | /     """
40 | |     Get the SnippetManager instance from Flask context.
41 | |     Checks both g object and app.config for the manager.
42 | |     Returns:
43 | |         SnippetManager: The snippet manager instance
44 | |     Raises:
45 | |         RuntimeError: If no snippet manager is found
46 | |     """
   | |_______^ D415
47 |       if hasattr(g, "snippet_manager"):
48 |           return cast(SnippetManager, g.snippet_manager)
   |
   = help: Add closing punctuation

api\unified_graphql.py:42:5: D411 [*] Missing blank line before section ("Returns")
   |
40 |     Get the SnippetManager instance from Flask context.
41 |     Checks both g object and app.config for the manager.
42 |     Returns:
   |     ^^^^^^^ D411
43 |         SnippetManager: The snippet manager instance
44 |     Raises:
   |
   = help: Add blank line before "Returns"

api\unified_graphql.py:58:5: D205 1 blank line required between summary line and description
   |
57 |   def get_db_manager() -> DatabaseManager:
58 | /     """
59 | |     Get the DatabaseManager instance from Flask context or app config.
60 | |     Returns:
61 | |         DatabaseManager: The database manager instance
62 | |     Raises:
63 | |         RuntimeError: If no db manager is found
64 | |     """
   | |_______^ D205
65 |       if hasattr(g, "db_manager"):
66 |           return g.db_manager
   |
   = help: Insert single blank line

api\unified_graphql.py:58:5: D212 [*] Multi-line docstring summary should start at the first line
   |
57 |   def get_db_manager() -> DatabaseManager:
58 | /     """
59 | |     Get the DatabaseManager instance from Flask context or app config.
60 | |     Returns:
61 | |         DatabaseManager: The database manager instance
62 | |     Raises:
63 | |         RuntimeError: If no db manager is found
64 | |     """
   | |_______^ D212
65 |       if hasattr(g, "db_manager"):
66 |           return g.db_manager
   |
   = help: Remove whitespace after opening quotes

api\unified_graphql.py:58:5: D415 First line should end with a period, question mark, or exclamation point
   |
57 |   def get_db_manager() -> DatabaseManager:
58 | /     """
59 | |     Get the DatabaseManager instance from Flask context or app config.
60 | |     Returns:
61 | |         DatabaseManager: The database manager instance
62 | |     Raises:
63 | |         RuntimeError: If no db manager is found
64 | |     """
   | |_______^ D415
65 |       if hasattr(g, "db_manager"):
66 |           return g.db_manager
   |
   = help: Add closing punctuation

api\unified_graphql.py:60:5: D411 [*] Missing blank line before section ("Returns")
   |
58 |     """
59 |     Get the DatabaseManager instance from Flask context or app config.
60 |     Returns:
   |     ^^^^^^^ D411
61 |         DatabaseManager: The database manager instance
62 |     Raises:
   |
   = help: Add blank line before "Returns"

api\unified_graphql.py:78:5: D212 [*] Multi-line docstring summary should start at the first line
   |
77 |   class SnippetType(graphene.ObjectType):  # type: ignore
78 | /     """
79 | |     GraphQL type for snippet model.
80 | |
81 | |     Defines the fields that can be queried for a snippet.
82 | |     """
   | |_______^ D212
83 |
84 |       snippet_id = Int(name="snippetId")
   |
   = help: Remove whitespace after opening quotes

api\unified_graphql.py:100:5: D212 [*] Multi-line docstring summary should start at the first line
    |
 99 |   class CreateSnippet(Mutation):  # type: ignore
100 | /     """
101 | |     Mutation to create a new snippet.
102 | |
103 | |         Handles the creation of a new snippet with the provided data.
104 | |     """
    | |_______^ D212
105 |
106 |       class Arguments:
    |
    = help: Remove whitespace after opening quotes

api\unified_graphql.py:106:11: D106 Missing docstring in public nested class
    |
104 |     """
105 |
106 |     class Arguments:
    |           ^^^^^^^^^ D106
107 |         category_id = Int(required=True, name="categoryId")
108 |         snippet_name = String(required=True, name="snippetName")
    |

api\unified_graphql.py:114:22: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `_info`
    |
113 |     def mutate(
114 |         self, _info: Any, category_id: int, snippet_name: str, content: str
    |                      ^^^ ANN401
115 |     ) -> CreateSnippetOutput:
116 |         """Create a new snippet with the provided data."""
    |

api\unified_graphql.py:144:5: D212 [*] Multi-line docstring summary should start at the first line
    |
143 |   class EditSnippet(Mutation):  # type: ignore
144 | /     """
145 | |     Mutation to edit an existing snippet.
146 | |
147 | |     Handles updating an existing snippet with new name and/or content.
148 | |     Validates the input and returns the updated snippet.
149 | |     """
    | |_______^ D212
150 |
151 |       class Arguments:
    |
    = help: Remove whitespace after opening quotes

api\unified_graphql.py:151:11: D106 Missing docstring in public nested class
    |
149 |     """
150 |
151 |     class Arguments:
    |           ^^^^^^^^^ D106
152 |         snippet_id = Int(required=True, name="snippetId")
153 |         snippet_name = String(name="snippetName")
    |

api\unified_graphql.py:160:16: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `_info`
    |
158 |     def mutate(
159 |         self,
160 |         _info: Any,
    |                ^^^ ANN401
161 |         snippet_id: int,
162 |         snippet_name: Optional[str] = None,
    |

api\unified_graphql.py:193:5: D212 [*] Multi-line docstring summary should start at the first line
    |
192 |   class DeleteSnippet(Mutation):  # type: ignore
193 | /     """
194 | |     Mutation to delete a snippet.
195 | |
196 | |     Handles removing an existing snippet from the database.
197 | |     Returns a boolean indicator of success.
198 | |     """
    | |_______^ D212
199 |
200 |       class Arguments:
    |
    = help: Remove whitespace after opening quotes

api\unified_graphql.py:200:11: D106 Missing docstring in public nested class
    |
198 |     """
199 |
200 |     class Arguments:
    |           ^^^^^^^^^ D106
201 |         snippet_id = Int(required=True, name="snippetId")
    |

api\unified_graphql.py:205:29: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `_info`
    |
203 |     Output = DeleteSnippetOutput
204 |
205 |     def mutate(self, _info: Any, snippet_id: int) -> DeleteSnippetOutput:
    |                             ^^^ ANN401
206 |         """Delete a snippet by ID."""
207 |         try:
    |

api\unified_graphql.py:240:5: D212 [*] Multi-line docstring summary should start at the first line
    |
239 |   class CreateCategory(Mutation):  # type: ignore
240 | /     """
241 | |     Mutation to create a new category.
242 | |
243 | |     Handles the creation of a new category with the provided name.
244 | |     Validates the input and returns the created category.
245 | |     """
    | |_______^ D212
246 |
247 |       class Arguments:
    |
    = help: Remove whitespace after opening quotes

api\unified_graphql.py:247:11: D106 Missing docstring in public nested class
    |
245 |     """
246 |
247 |     class Arguments:
    |           ^^^^^^^^^ D106
248 |         category_name = String(required=True, name="categoryName")
    |

api\unified_graphql.py:252:29: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `_info`
    |
250 |     Output = CreateCategoryOutput
251 |
252 |     def mutate(self, _info: Any, category_name: str) -> CreateCategoryOutput:
    |                             ^^^ ANN401
253 |         """Create a new category with the provided name."""
254 |         try:
    |

api\unified_graphql.py:277:5: D212 [*] Multi-line docstring summary should start at the first line
    |
276 |   class UpdateCategory(Mutation):  # type: ignore
277 | /     """
278 | |     Mutation to update an existing category.
279 | |
280 | |     Handles renaming an existing category with the provided name.
281 | |     Validates the input and returns the updated category.
282 | |     """
    | |_______^ D212
283 |
284 |       class Arguments:
    |
    = help: Remove whitespace after opening quotes

api\unified_graphql.py:284:11: D106 Missing docstring in public nested class
    |
282 |     """
283 |
284 |     class Arguments:
    |           ^^^^^^^^^ D106
285 |         category_id = Int(required=True, name="categoryId")
286 |         category_name = String(required=True, name="categoryName")
    |

api\unified_graphql.py:291:22: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `_info`
    |
290 |     def mutate(
291 |         self, _info: Any, category_id: int, category_name: str
    |                      ^^^ ANN401
292 |     ) -> UpdateCategoryOutput:
293 |         """Update an existing category with the provided name."""
    |

api\unified_graphql.py:317:5: D212 [*] Multi-line docstring summary should start at the first line
    |
316 |   class DeleteCategory(Mutation):  # type: ignore
317 | /     """
318 | |     Mutation to delete a category.
319 | |
320 | |     Handles removing an existing category from the database.
321 | |     Also cascades deletion to related snippets.
322 | |     Returns a boolean indicator of success.
323 | |     """
    | |_______^ D212
324 |
325 |       class Arguments:
    |
    = help: Remove whitespace after opening quotes

api\unified_graphql.py:325:11: D106 Missing docstring in public nested class
    |
323 |     """
324 |
325 |     class Arguments:
    |           ^^^^^^^^^ D106
326 |         category_id = Int(required=True, name="categoryId")
    |

api\unified_graphql.py:330:29: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `_info`
    |
328 |     Output = DeleteCategoryOutput
329 |
330 |     def mutate(self, _info: Any, category_id: int) -> DeleteCategoryOutput:
    |                             ^^^ ANN401
331 |         """Delete a category by ID."""
332 |         try:
    |

api\unified_graphql.py:347:5: D212 [*] Multi-line docstring summary should start at the first line
    |
346 |   class Query(graphene.ObjectType):  # type: ignore
347 | /     """
348 | |     Unified GraphQL query type combining all entity queries.
349 | |
350 | |     Provides query fields for both snippets and categories,
351 | |     with resolver methods for each field.
352 | |     """
    | |_______^ D212
353 |
354 |       # Snippet queries
    |
    = help: Remove whitespace after opening quotes

api\unified_graphql.py:362:39: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `_info`
    |
360 |     category = Field(CategoryType, category_id=Int(required=True, name="categoryId"))
361 |
362 |     def resolve_snippets(self, _info: Any, category_id: int) -> TypedList[SnippetModel]:
    |                                       ^^^ ANN401
363 |         """Resolve all snippets for a given category."""
364 |         manager = get_snippet_manager()
    |

api\unified_graphql.py:367:38: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `_info`
    |
365 |         return manager.list_snippets(category_id)
366 |
367 |     def resolve_snippet(self, _info: Any, snippet_id: int) -> Optional[SnippetModel]:
    |                                      ^^^ ANN401
368 |         """Resolve a specific snippet by ID."""
369 |         try:
    |

api\unified_graphql.py:375:41: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `_info`
    |
373 |             return None
374 |
375 |     def resolve_categories(self, _info: Any) -> TypedList[Category]:
    |                                         ^^^ ANN401
376 |         """Resolve all categories."""
377 |         db_manager = get_db_manager()
    |

api\unified_graphql.py:381:39: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `_info`
    |
379 |         return cat_mgr.list_categories()
380 |
381 |     def resolve_category(self, _info: Any, category_id: int) -> Optional[Category]:
    |                                       ^^^ ANN401
382 |         """Resolve a specific category by ID."""
383 |         try:
    |

api\unified_graphql.py:392:5: D212 [*] Multi-line docstring summary should start at the first line
    |
391 |   class Mutations(graphene.ObjectType):  # type: ignore
392 | /     """
393 | |     Unified GraphQL mutation type combining all entity mutations.
394 | |
395 | |     Contains all available mutations for snippets and categories.
396 | |     """
    | |_______^ D212
397 |
398 |       # Snippet mutations
    |
    = help: Remove whitespace after opening quotes

api\unified_graphql.py:418:5: D212 [*] Multi-line docstring summary should start at the first line
    |
416 |   @unified_graphql.route("/graphql", methods=["POST"])
417 |   def graphql_api() -> Response:
418 | /     """
419 | |     Unified GraphQL API endpoint for all operations.
420 | |
421 | |     Handles GraphQL queries and mutations for both snippets and categories,
422 | |     returning formatted JSON responses.
423 | |
424 | |     Returns:
425 | |         Response: JSON response with GraphQL execution result
426 | |     """
    | |_______^ D212
427 |       data = request.get_json() or {}
428 |       query = data.get("query", "")
    |
    = help: Remove whitespace after opening quotes

check_db_schema.py:6:5: ANN201 Missing return type annotation for public function `check_schema`
  |
6 | def check_schema(db_path: str):
  |     ^^^^^^^^^^^^ ANN201
7 |     """Check the database schema."""
8 |     conn = sqlite3.connect(db_path)
  |
  = help: Add return type annotation: `None`

conftest.py:1:1: D100 Missing docstring in public module
db\__init__.py:1:1: D104 Missing docstring in public package
db\database_manager.py:1:1: D205 1 blank line required between summary line and description
   |
 1 | / """
 2 | | Central database manager for project-wide use.
 3 | | Provides connection, query, and schema management with specific exception handling.
 4 | | Supports both local SQLite and cloud AWS Aurora PostgreSQL connections.
 5 | |
 6 | | This is the unified database manager implementation used throughout the application.
 7 | | All other database manager imports should use this class via relative imports.
 8 | | """
   | |___^ D205
 9 |
10 |   import enum
   |
   = help: Insert single blank line

db\database_manager.py:1:1: D212 [*] Multi-line docstring summary should start at the first line
   |
 1 | / """
 2 | | Central database manager for project-wide use.
 3 | | Provides connection, query, and schema management with specific exception handling.
 4 | | Supports both local SQLite and cloud AWS Aurora PostgreSQL connections.
 5 | |
 6 | | This is the unified database manager implementation used throughout the application.
 7 | | All other database manager imports should use this class via relative imports.
 8 | | """
   | |___^ D212
 9 |
10 |   import enum
   |
   = help: Remove whitespace after opening quotes

db\database_manager.py:86:9: D102 Missing docstring in public method
   |
84 |     """Minimal DB-API cursor protocol used by DatabaseManager."""
85 |
86 |     def execute(self, query: str, params: Tuple[object, ...] = ...) -> Self: ...
   |         ^^^^^^^ D102
87 |
88 |     def executemany(self, query: str, seq_of_params: Iterable[Tuple[object, ...]]) -> Self: ...
   |

db\database_manager.py:88:9: D102 Missing docstring in public method
   |
86 |     def execute(self, query: str, params: Tuple[object, ...] = ...) -> Self: ...
87 |
88 |     def executemany(self, query: str, seq_of_params: Iterable[Tuple[object, ...]]) -> Self: ...
   |         ^^^^^^^^^^^ D102
89 |
90 |     def fetchone(self) -> Optional[Union[Dict[str, Any], Tuple[Any, ...]]]: ...
   |

db\database_manager.py:90:9: D102 Missing docstring in public method
   |
88 |     def executemany(self, query: str, seq_of_params: Iterable[Tuple[object, ...]]) -> Self: ...
89 |
90 |     def fetchone(self) -> Optional[Union[Dict[str, Any], Tuple[Any, ...]]]: ...
   |         ^^^^^^^^ D102
91 |
92 |     def fetchall(self) -> List[Union[Dict[str, Any], Tuple[Any, ...]]]: ...
   |

db\database_manager.py:92:9: D102 Missing docstring in public method
   |
90 |     def fetchone(self) -> Optional[Union[Dict[str, Any], Tuple[Any, ...]]]: ...
91 |
92 |     def fetchall(self) -> List[Union[Dict[str, Any], Tuple[Any, ...]]]: ...
   |         ^^^^^^^^ D102
93 |
94 |     def fetchmany(self, size: int = ...) -> List[Union[Dict[str, Any], Tuple[Any, ...]]]: ...
   |

db\database_manager.py:94:9: D102 Missing docstring in public method
   |
92 |     def fetchall(self) -> List[Union[Dict[str, Any], Tuple[Any, ...]]]: ...
93 |
94 |     def fetchmany(self, size: int = ...) -> List[Union[Dict[str, Any], Tuple[Any, ...]]]: ...
   |         ^^^^^^^^^ D102
95 |
96 |     def close(self) -> None: ...
   |

db\database_manager.py:96:9: D102 Missing docstring in public method
   |
94 |     def fetchmany(self, size: int = ...) -> List[Union[Dict[str, Any], Tuple[Any, ...]]]: ...
95 |
96 |     def close(self) -> None: ...
   |         ^^^^^ D102
97 |
98 |     # PostgreSQL-specifics used in bulk COPY
   |

db\database_manager.py:99:9: D102 Missing docstring in public method
    |
 98 |     # PostgreSQL-specifics used in bulk COPY
 99 |     def copy_from(
    |         ^^^^^^^^^ D102
100 |         self,
101 |         file: TextIO,
    |

db\database_manager.py:110:9: D102 Missing docstring in public method
    |
108 |     # Optional attribute for column metadata
109 |     @property
110 |     def description(self) -> Optional[Sequence[Sequence[Any]]]: ...
    |         ^^^^^^^^^^^ D102
    |

db\database_manager.py:130:5: D212 [*] Multi-line docstring summary should start at the first line
    |
129 |   class DatabaseManager:
130 | /     """
131 | |     Centralized manager for database connections and operations.
132 | |
133 | |     Handles connection management, query execution, schema initialization, and
134 | |     exception translation for the Typing Trainer application. All database access
135 | |     should be performed through this class to ensure consistent error handling and
136 | |     schema management.
137 | |
138 | |     Supports both local SQLite and cloud AWS Aurora PostgreSQL connections.
139 | |     """
    | |_______^ D212
140 |
141 |       def table_exists(self, table_name: str) -> bool:
    |
    = help: Remove whitespace after opening quotes

db\database_manager.py:142:9: D205 1 blank line required between summary line and description
    |
141 |       def table_exists(self, table_name: str) -> bool:
142 | /         """
143 | |         Check if a table exists in the database (backend-agnostic).
144 | |         Args:
145 | |             table_name: Name of the table to check
146 | |         Returns:
147 | |             True if the table exists, False otherwise
148 | |         """
    | |___________^ D205
149 |           if self.is_postgres:
150 |               query = (
    |
    = help: Insert single blank line

db\database_manager.py:142:9: D212 [*] Multi-line docstring summary should start at the first line
    |
141 |       def table_exists(self, table_name: str) -> bool:
142 | /         """
143 | |         Check if a table exists in the database (backend-agnostic).
144 | |         Args:
145 | |             table_name: Name of the table to check
146 | |         Returns:
147 | |             True if the table exists, False otherwise
148 | |         """
    | |___________^ D212
149 |           if self.is_postgres:
150 |               query = (
    |
    = help: Remove whitespace after opening quotes

db\database_manager.py:142:9: D415 First line should end with a period, question mark, or exclamation point
    |
141 |       def table_exists(self, table_name: str) -> bool:
142 | /         """
143 | |         Check if a table exists in the database (backend-agnostic).
144 | |         Args:
145 | |             table_name: Name of the table to check
146 | |         Returns:
147 | |             True if the table exists, False otherwise
148 | |         """
    | |___________^ D415
149 |           if self.is_postgres:
150 |               query = (
    |
    = help: Add closing punctuation

db\database_manager.py:144:9: D411 [*] Missing blank line before section ("Args")
    |
142 |         """
143 |         Check if a table exists in the database (backend-agnostic).
144 |         Args:
    |         ^^^^ D411
145 |             table_name: Name of the table to check
146 |         Returns:
    |
    = help: Add blank line before "Args"

db\database_manager.py:163:9: D205 1 blank line required between summary line and description
    |
162 |       def list_tables(self) -> List[str]:
163 | /         """
164 | |         Return a list of all user table names in the database, backend-agnostic.
165 | |         Returns:
166 | |             A list of table names as strings
167 | |         """
    | |___________^ D205
168 |           if self.is_postgres:
169 |               # For PostgreSQL, use information_schema
    |
    = help: Insert single blank line

db\database_manager.py:163:9: D212 [*] Multi-line docstring summary should start at the first line
    |
162 |       def list_tables(self) -> List[str]:
163 | /         """
164 | |         Return a list of all user table names in the database, backend-agnostic.
165 | |         Returns:
166 | |             A list of table names as strings
167 | |         """
    | |___________^ D212
168 |           if self.is_postgres:
169 |               # For PostgreSQL, use information_schema
    |
    = help: Remove whitespace after opening quotes

db\database_manager.py:163:9: D415 First line should end with a period, question mark, or exclamation point
    |
162 |       def list_tables(self) -> List[str]:
163 | /         """
164 | |         Return a list of all user table names in the database, backend-agnostic.
165 | |         Returns:
166 | |             A list of table names as strings
167 | |         """
    | |___________^ D415
168 |           if self.is_postgres:
169 |               # For PostgreSQL, use information_schema
    |
    = help: Add closing punctuation

db\database_manager.py:165:9: D411 [*] Missing blank line before section ("Returns")
    |
163 |         """
164 |         Return a list of all user table names in the database, backend-agnostic.
165 |         Returns:
    |         ^^^^^^^ D411
166 |             A list of table names as strings
167 |         """
    |
    = help: Add blank line before "Returns"

db\database_manager.py:199:9: D212 [*] Multi-line docstring summary should start at the first line
    |
197 |           debug_util: Optional[object] = None,
198 |       ) -> None:
199 | /         """
200 | |         Initialize a DatabaseManager with the specified connection type and parameters.
201 | |
202 | |         Args:
203 | |             db_path: Path to SQLite database file or ":memory:" for in-memory database.
204 | |                     If None, creates an in-memory database.
205 | |                     Only used when connection_type is LOCAL.
206 | |             connection_type: Whether to use local SQLite or cloud Aurora PostgreSQL.
207 | |             debug_util: Optional DebugUtil instance for handling debug output.
208 | |
209 | |         Raises:
210 | |             DBConnectionError: If the database connection cannot be established.
211 | |             ImportError: If cloud dependencies are not available when cloud connection
212 | |                 is requested.
213 | |         """
    | |___________^ D212
214 |           self.connection_type = connection_type
215 |           self.db_path: str = db_path or ":memory:"
    |
    = help: Remove whitespace after opening quotes

db\database_manager.py:239:9: D212 [*] Multi-line docstring summary should start at the first line
    |
238 |       def _connect_sqlite(self) -> None:
239 | /         """
240 | |         Establish connection to a local SQLite database.
241 | |
242 | |         Raises:
243 | |             DBConnectionError: If the database connection cannot be established.
244 | |         """
    | |___________^ D212
245 |           try:
246 |               self._conn = sqlite3.connect(self.db_path)
    |
    = help: Remove whitespace after opening quotes

db\database_manager.py:257:9: D212 [*] Multi-line docstring summary should start at the first line
    |
256 |       def _connect_aurora(self) -> None:
257 | /         """
258 | |         Establish connection to AWS Aurora PostgreSQL.
259 | |
260 | |         Raises:
261 | |             DBConnectionError: If the database connection cannot be established.
262 | |         """
    | |___________^ D212
263 |           try:
264 |               # Get secrets from AWS Secrets Manager
    |
    = help: Remove whitespace after opening quotes

db\database_manager.py:332:9: D212 [*] Multi-line docstring summary should start at the first line
    |
331 |       def close(self) -> None:
332 | /         """
333 | |         Close the SQLite database connection.
334 | |
335 | |         Raises:
336 | |             DBConnectionError: If closing the connection fails.
337 | |         """
    | |___________^ D212
338 |           try:
339 |               self._conn.close()
    |
    = help: Remove whitespace after opening quotes

db\database_manager.py:349:9: D212 [*] Multi-line docstring summary should start at the first line
    |
348 |       def _get_cursor(self) -> CursorProtocol:
349 | /         """
350 | |         Get a cursor from the database connection.
351 | |
352 | |         Returns:
353 | |             A database cursor (either sqlite3.Cursor or psycopg2 cursor).
354 | |
355 | |         Raises:
356 | |             DBConnectionError: If the database connection is not established.
357 | |         """
    | |___________^ D212
358 |           if not self._conn:
359 |               raise DBConnectionError("Database connection is not established")
    |
    = help: Remove whitespace after opening quotes

db\database_manager.py:363:9: D205 1 blank line required between summary line and description
    |
362 |       def _execute_ddl(self, query: str) -> None:
363 | /         """
364 | |         Execute DDL (Data Definition Language) statements consistently across both
365 | |         SQLite and PostgreSQL connections using a cursor-based approach.
366 | |
367 | |         Args:
368 | |             query: SQL DDL statement to execute
369 | |
370 | |         Raises:
371 | |             Various database exceptions depending on the error type
372 | |         """
    | |___________^ D205
373 |           cursor = self._conn.cursor()
374 |           cursor.execute(query)
    |
    = help: Insert single blank line

db\database_manager.py:363:9: D212 [*] Multi-line docstring summary should start at the first line
    |
362 |       def _execute_ddl(self, query: str) -> None:
363 | /         """
364 | |         Execute DDL (Data Definition Language) statements consistently across both
365 | |         SQLite and PostgreSQL connections using a cursor-based approach.
366 | |
367 | |         Args:
368 | |             query: SQL DDL statement to execute
369 | |
370 | |         Raises:
371 | |             Various database exceptions depending on the error type
372 | |         """
    | |___________^ D212
373 |           cursor = self._conn.cursor()
374 |           cursor.execute(query)
    |
    = help: Remove whitespace after opening quotes

db\database_manager.py:379:9: D212 [*] Multi-line docstring summary should start at the first line
    |
378 |       def _qualify_schema_in_query(self, query: str) -> str:
379 | /         """
380 | |         Prepare queries for PostgreSQL execution.
381 | |
382 | |         Since the connection is configured with search_path=typing,public,
383 | |         unqualified table names will automatically resolve to the typing schema.
384 | |         This method only handles placeholder conversion and minimal DDL qualification
385 | |         where explicit schema specification is required.
386 | |         """
    | |___________^ D212
387 |           # Convert SQLite-style placeholders to PostgreSQL-style
388 |           if "?" in query:
    |
    = help: Remove whitespace after opening quotes

db\database_manager.py:482:9: D212 [*] Multi-line docstring summary should start at the first line
    |
481 |       def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
482 | /         """
483 | |         Execute a SQL query with parameters and commit immediately.
484 | |
485 | |         Args:
486 | |             query: SQL query string (parameterized)
487 | |             params: Query parameters
488 | |
489 | |         Returns:
490 | |             Database cursor object
491 | |
492 | |         Raises:
493 | |             DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
494 | |             ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
495 | |         """
    | |___________^ D212
496 |           try:
497 |               cursor: CursorProtocol = self._get_cursor()
    |
    = help: Remove whitespace after opening quotes

db\database_manager.py:525:13: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
    |
523 |                 self._debug_message(f" Rollback failed: {rollback_exc}")
524 |             self._translate_and_raise(e)
525 |             raise AssertionError("unreachable")
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ B904
526 |
527 |     def execute_many(
    |

db\database_manager.py:615:13: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
    |
613 |                 self._debug_message(f" Rollback failed: {rollback_exc}")
614 |             self._translate_and_raise(e)
615 |             raise AssertionError("unreachable")
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ B904
616 |
617 |     # --- Bulk helper methods for execute_many ---
    |

db\database_manager.py:682:9: D301 Use `r"""` if any backslashes in a docstring
    |
680 |           params_list: List[Tuple[object, ...]],
681 |       ) -> CursorProtocol:
682 | /         """Use ``COPY FROM STDIN`` for fast ingestion of INSERT-like data on Postgres.
683 | |
684 | |         - Backend: PostgreSQL only. Requires that the active connection has the
685 | |           search_path set (handled during connection) and the table exists in the
686 | |           configured schema.
687 | |         - Statement: must be an ``INSERT INTO <table>(cols...) VALUES (...)``-style
688 | |           statement. We parse table and columns, and stream data as TSV with ``\n``
689 | |           line terminators, ``\t`` separators, and ``\\N`` for NULLs.
690 | |         - Data sanitation: tabs/newlines in values are replaced with spaces.
691 | |         - Commit: commits when the statement is non-SELECT.
692 | |         - Errors: raises ``DatabaseTypeError`` for incompatible statements or length
693 | |           mismatches; backend errors are handled by caller via ``_translate_and_raise``.
694 | |         """
    | |___________^ D301
695 |           import io
696 |           import re
    |
    = help: Add `r` prefix

db\database_manager.py:753:9: D212 [*] Multi-line docstring summary should start at the first line
    |
752 |       def fetchone(self, query: str, params: Tuple[Any, ...] = ()) -> Optional[Dict[str, Any]]:
753 | /         """
754 | |         Execute a SQL query and fetch a single result.
755 | |
756 | |         Args:
757 | |             query: SQL query string (parameterized)
758 | |             params: Query parameters
759 | |
760 | |         Returns:
761 | |             Dict representing fetched row, or None if no results
762 | |             Both SQLite and PostgreSQL results are returned as dictionaries with col names as keys
763 | |
764 | |         Raises:
765 | |             DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
766 | |             ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
767 | |         """
    | |___________^ D212
768 |           cursor = self.execute(query, params)
769 |           result = cursor.fetchone()
    |
    = help: Remove whitespace after opening quotes

db\database_manager.py:788:9: D212 [*] Multi-line docstring summary should start at the first line
    |
786 |           self, query: str, params: Tuple[Any, ...] = (), size: int = 1
787 |       ) -> List[Dict[str, Any]]:
788 | /         """
789 | |         Execute a SQL query and fetch multiple results.
790 | |
791 | |         Args:
792 | |             query: SQL query string (parameterized)
793 | |             params: Query parameters
794 | |             size: Number of rows to fetch
795 | |
796 | |         Returns:
797 | |             List of Dict representing fetched rows
798 | |             Both SQLite and PostgreSQL results are returned as dictionaries with col names as keys
799 | |
800 | |         Raises:
801 | |             DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
802 | |             ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
803 | |         """
    | |___________^ D212
804 |           cursor = self.execute(query, params)
805 |           results = cursor.fetchmany(size)
    |
    = help: Remove whitespace after opening quotes

db\database_manager.py:818:9: D212 [*] Multi-line docstring summary should start at the first line
    |
817 |       def fetchall(self, query: str, params: Tuple[Any, ...] = ()) -> List[Dict[str, Any]]:
818 | /         """
819 | |         Execute a query and return all rows as a list.
820 | |
821 | |         Args:
822 | |             query: SQL query string (parameterized)
823 | |             params: Query parameters
824 | |
825 | |         Returns:
826 | |             A list of dictionaries, with each dictionary representing a row
827 | |             Both SQLite and PostgreSQL results are returned as dictionaries with col names as keys
828 | |
829 | |         Raises:
830 | |             DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
831 | |             ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
832 | |         """
    | |___________^ D212
833 |           cursor = self.execute(query, params)
834 |           results = cursor.fetchall()
    |
    = help: Remove whitespace after opening quotes

db\database_manager.py:1136:9: D205 1 blank line required between summary line and description
     |
1135 |       def _create_keyboards_table(self) -> None:
1136 | /         """Create the keyboards table with UUID primary key and user_id foreign key
1137 | |         if it does not exist.
1138 | |         """
     | |___________^ D205
1139 |           self._execute_ddl(
1140 |               """
     |
     = help: Insert single blank line

db\database_manager.py:1194:9: D205 1 blank line required between summary line and description
     |
1193 |       def init_tables(self) -> None:
1194 | /         """Initialize all database tables by creating them if they do not exist.
1195 | |         This includes core tables for categories, snippets, session data, users,
1196 | |         keyboards, and settings.
1197 | |         """
     | |___________^ D205
1198 |           self._create_categories_table()
1199 |           self._create_words_table()
     |
     = help: Insert single blank line

db\database_manager.py:1214:9: D212 [*] Multi-line docstring summary should start at the first line
     |
1213 |       def __enter__(self) -> "DatabaseManager":
1214 | /         """
1215 | |         Context manager protocol support.
1216 | |
1217 | |         Returns:
1218 | |             Self for using in with statements.
1219 | |         """
     | |___________^ D212
1220 |           return self
     |
     = help: Remove whitespace after opening quotes

db\database_manager.py:1228:9: D200 One-line docstring should fit on one line
     |
1226 |           exc_tb: object,
1227 |       ) -> None:
1228 | /         """
1229 | |         Context manager protocol support - close connection when exiting context.
1230 | |         """
     | |___________^ D200
1231 |           self.close()
     |
     = help: Reformat to one line

db\database_manager.py:1228:9: D212 [*] Multi-line docstring summary should start at the first line
     |
1226 |           exc_tb: object,
1227 |       ) -> None:
1228 | /         """
1229 | |         Context manager protocol support - close connection when exiting context.
1230 | |         """
     | |___________^ D212
1231 |           self.close()
     |
     = help: Remove whitespace after opening quotes

db\exceptions.py:1:1: D200 One-line docstring should fit on one line
  |
1 | / """
2 | | Custom database exceptions for the AI Typing Trainer application.
3 | | """
  | |___^ D200
  |
  = help: Reformat to one line

db\exceptions.py:1:1: D212 [*] Multi-line docstring summary should start at the first line
  |
1 | / """
2 | | Custom database exceptions for the AI Typing Trainer application.
3 | | """
  | |___^ D212
  |
  = help: Remove whitespace after opening quotes

db\interfaces.py:19:9: D102 Missing docstring in public method
   |
17 |     """
18 |
19 |     def execute(self, query: str, params: Tuple[object, ...] = ()) -> object:
   |         ^^^^^^^ D102
20 |         ...
   |

db\interfaces.py:23:9: D102 Missing docstring in public method
   |
22 |     @property
23 |     def execute_many_supported(self) -> bool:
   |         ^^^^^^^^^^^^^^^^^^^^^^ D102
24 |         ...
   |

db\interfaces.py:26:9: D102 Missing docstring in public method
   |
24 |         ...
25 |
26 |     def execute_many(self, query: str, params_seq: Iterable[Tuple[object, ...]]) -> object:
   |         ^^^^^^^^^^^^ D102
27 |         ...
   |

db\migrations\check_snippet_parts_count.py:1:1: D100 Missing docstring in public module
db\migrations\check_snippet_parts_count.py:3:1: I001 [*] Import block is un-sorted or un-formatted
   |
 1 |   #!/usr/bin/env python
 2 |
 3 | / import boto3
 4 | | import psycopg2
 5 | | import sqlite3
 6 | | import sys
 7 | | import os
 8 | | import logging
   | |______________^ I001
 9 |
10 |   # Configure logging
   |
   = help: Organize imports

db\migrations\check_snippet_parts_count.py:24:5: ANN201 Missing return type annotation for public function `get_aurora_connection`
   |
22 | SCHEMA_NAME = "typing"
23 |
24 | def get_aurora_connection():
   |     ^^^^^^^^^^^^^^^^^^^^^ ANN201
25 |     """Get a connection to AWS Aurora PostgreSQL."""
26 |     try:
   |
   = help: Add return type annotation

db\migrations\check_snippet_parts_count.py:64:5: ANN201 Missing return type annotation for public function `get_sqlite_connection`
   |
62 |         raise
63 |
64 | def get_sqlite_connection(db_path):
   |     ^^^^^^^^^^^^^^^^^^^^^ ANN201
65 |     """Get a connection to SQLite database."""
66 |     try:
   |
   = help: Add return type annotation

db\migrations\check_snippet_parts_count.py:64:27: ANN001 Missing type annotation for function argument `db_path`
   |
62 |         raise
63 |
64 | def get_sqlite_connection(db_path):
   |                           ^^^^^^^ ANN001
65 |     """Get a connection to SQLite database."""
66 |     try:
   |

db\migrations\check_snippet_parts_count.py:73:5: ANN201 Missing return type annotation for public function `main`
   |
71 |         raise
72 |
73 | def main():
   |     ^^^^ ANN201
74 |     """Main entry point for checking snippet_parts row counts."""
75 |     if len(sys.argv) != 2:
   |
   = help: Add return type annotation: `int | None`

db\migrations\migrate_snippet_parts.py:2:1: D205 1 blank line required between summary line and description
   |
 1 |   #!/usr/bin/env python3
 2 | / """
 3 | | Migration script specifically focused on migrating the snippet_parts table
 4 | | from SQLite to AWS Aurora PostgreSQL.
 5 | |
 6 | | This script:
 7 | | 1. Extracts the snippet_parts schema from SQLite
 8 | | 2. Drops and recreates the table in Aurora with identical schema
 9 | | 3. Migrates rows one by one
10 | | 4. Verifies each row after insertion
11 | | 5. Alerts on any failures
12 | | """
   | |___^ D205
13 |
14 |   import argparse
   |
   = help: Insert single blank line

db\migrations\migrate_snippet_parts.py:2:1: D212 [*] Multi-line docstring summary should start at the first line
   |
 1 |   #!/usr/bin/env python3
 2 | / """
 3 | | Migration script specifically focused on migrating the snippet_parts table
 4 | | from SQLite to AWS Aurora PostgreSQL.
 5 | |
 6 | | This script:
 7 | | 1. Extracts the snippet_parts schema from SQLite
 8 | | 2. Drops and recreates the table in Aurora with identical schema
 9 | | 3. Migrates rows one by one
10 | | 4. Verifies each row after insertion
11 | | 5. Alerts on any failures
12 | | """
   | |___^ D212
13 |
14 |   import argparse
   |
   = help: Remove whitespace after opening quotes

db\migrations\migrate_snippet_parts.py:14:1: I001 [*] Import block is un-sorted or un-formatted
   |
12 |   """
13 |
14 | / import argparse
15 | | import boto3
16 | | import logging
17 | | import os
18 | | import psycopg2
19 | | import sqlite3
20 | | import sys
21 | | import traceback
22 | | import uuid
   | |___________^ I001
23 |
24 |   # Configure logging with both console and file output
   |
   = help: Organize imports

db\migrations\migrate_snippet_parts.py:21:8: F401 [*] `traceback` imported but unused
   |
19 | import sqlite3
20 | import sys
21 | import traceback
   |        ^^^^^^^^^ F401
22 | import uuid
   |
   = help: Remove unused import: `traceback`

db\migrations\migrate_snippet_parts.py:45:5: ANN201 Missing return type annotation for public function `get_aurora_connection`
   |
43 | SCHEMA_NAME = "typing"
44 |
45 | def get_aurora_connection():
   |     ^^^^^^^^^^^^^^^^^^^^^ ANN201
46 |     """Connect to AWS Aurora using credentials from Secrets Manager."""
47 |     try:
   |
   = help: Add return type annotation

db\migrations\migrate_snippet_parts.py:82:121: E501 Line too long (121 > 120)
   |
80 |             logger.error(f"Failed to connect to Aurora database: {e}")
81 |             logger.error(
82 |                 f"Connection details: host={cfg['host']}, port={cfg['port']}, db={cfg['dbname']}, user={cfg['username']}"
   |                                                                                                                         ^ E501
83 |             )
84 |             raise
   |

db\migrations\migrate_snippet_parts.py:93:5: ANN201 Missing return type annotation for public function `get_sqlite_connection`
   |
93 | def get_sqlite_connection(db_path):
   |     ^^^^^^^^^^^^^^^^^^^^^ ANN201
94 |     """Connect to SQLite database."""
95 |     if not os.path.exists(db_path):
   |
   = help: Add return type annotation

db\migrations\migrate_snippet_parts.py:93:27: ANN001 Missing type annotation for function argument `db_path`
   |
93 | def get_sqlite_connection(db_path):
   |                           ^^^^^^^ ANN001
94 |     """Connect to SQLite database."""
95 |     if not os.path.exists(db_path):
   |

db\migrations\migrate_snippet_parts.py:102:5: ANN201 Missing return type annotation for public function `get_sqlite_schema`
    |
102 | def get_sqlite_schema(conn):
    |     ^^^^^^^^^^^^^^^^^ ANN201
103 |     """Get the snippet_parts table schema from SQLite."""
104 |     cursor = conn.cursor()
    |
    = help: Add return type annotation

db\migrations\migrate_snippet_parts.py:102:23: ANN001 Missing type annotation for function argument `conn`
    |
102 | def get_sqlite_schema(conn):
    |                       ^^^^ ANN001
103 |     """Get the snippet_parts table schema from SQLite."""
104 |     cursor = conn.cursor()
    |

db\migrations\migrate_snippet_parts.py:115:5: ANN201 Missing return type annotation for public function `recreate_aurora_snippet_parts_table`
    |
115 | def recreate_aurora_snippet_parts_table(conn):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
116 |     """Drop and recreate the snippet_parts table in Aurora with PostgreSQL-compatible syntax."""
117 |     cursor = conn.cursor()
    |
    = help: Add return type annotation: `None`

db\migrations\migrate_snippet_parts.py:115:41: ANN001 Missing type annotation for function argument `conn`
    |
115 | def recreate_aurora_snippet_parts_table(conn):
    |                                         ^^^^ ANN001
116 |     """Drop and recreate the snippet_parts table in Aurora with PostgreSQL-compatible syntax."""
117 |     cursor = conn.cursor()
    |

db\migrations\migrate_snippet_parts.py:145:5: ANN201 Missing return type annotation for public function `row_to_dict`
    |
145 | def row_to_dict(cursor, row):
    |     ^^^^^^^^^^^ ANN201
146 |     """Convert a row tuple to a dictionary with column names as keys."""
147 |     return {col[0]: row[idx] for idx, col in enumerate(cursor.description)}
    |
    = help: Add return type annotation

db\migrations\migrate_snippet_parts.py:145:17: ANN001 Missing type annotation for function argument `cursor`
    |
145 | def row_to_dict(cursor, row):
    |                 ^^^^^^ ANN001
146 |     """Convert a row tuple to a dictionary with column names as keys."""
147 |     return {col[0]: row[idx] for idx, col in enumerate(cursor.description)}
    |

db\migrations\migrate_snippet_parts.py:145:25: ANN001 Missing type annotation for function argument `row`
    |
145 | def row_to_dict(cursor, row):
    |                         ^^^ ANN001
146 |     """Convert a row tuple to a dictionary with column names as keys."""
147 |     return {col[0]: row[idx] for idx, col in enumerate(cursor.description)}
    |

db\migrations\migrate_snippet_parts.py:150:5: ANN201 Missing return type annotation for public function `get_all_snippet_parts_rows`
    |
150 | def get_all_snippet_parts_rows(conn):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
151 |     """Get all rows from the snippet_parts table in SQLite."""
152 |     cursor = conn.cursor()
    |
    = help: Add return type annotation

db\migrations\migrate_snippet_parts.py:150:32: ANN001 Missing type annotation for function argument `conn`
    |
150 | def get_all_snippet_parts_rows(conn):
    |                                ^^^^ ANN001
151 |     """Get all rows from the snippet_parts table in SQLite."""
152 |     cursor = conn.cursor()
    |

db\migrations\migrate_snippet_parts.py:170:5: ANN201 Missing return type annotation for public function `migrate_and_verify_rows`
    |
170 | def migrate_and_verify_rows(sqlite_conn, aurora_conn):
    |     ^^^^^^^^^^^^^^^^^^^^^^^ ANN201
171 |     """Migrate rows from SQLite to Aurora one by one, verifying each after insertion."""
172 |     rows, columns = get_all_snippet_parts_rows(sqlite_conn)
    |
    = help: Add return type annotation

db\migrations\migrate_snippet_parts.py:170:29: ANN001 Missing type annotation for function argument `sqlite_conn`
    |
170 | def migrate_and_verify_rows(sqlite_conn, aurora_conn):
    |                             ^^^^^^^^^^^ ANN001
171 |     """Migrate rows from SQLite to Aurora one by one, verifying each after insertion."""
172 |     rows, columns = get_all_snippet_parts_rows(sqlite_conn)
    |

db\migrations\migrate_snippet_parts.py:170:42: ANN001 Missing type annotation for function argument `aurora_conn`
    |
170 | def migrate_and_verify_rows(sqlite_conn, aurora_conn):
    |                                          ^^^^^^^^^^^ ANN001
171 |     """Migrate rows from SQLite to Aurora one by one, verifying each after insertion."""
172 |     rows, columns = get_all_snippet_parts_rows(sqlite_conn)
    |

db\migrations\migrate_snippet_parts.py:238:121: E501 Line too long (129 > 120)
    |
237 |                     if sqlite_val != aurora_val:
238 |                         logger.error(f"Row {i+1}/{len(rows)} mismatch in column {col}: SQLite={sqlite_val}, Aurora={aurora_val}")
    |                                                                                                                         ^^^^^^^^^ E501
239 |                         match = False
    |

db\migrations\migrate_snippet_parts.py:269:5: ANN201 Missing return type annotation for public function `verify_only`
    |
269 | def verify_only(sqlite_conn, aurora_conn):
    |     ^^^^^^^^^^^ ANN201
270 |     """Check and compare row counts between SQLite and Aurora without migration."""
271 |     # SQLite count
    |
    = help: Add return type annotation

db\migrations\migrate_snippet_parts.py:269:17: ANN001 Missing type annotation for function argument `sqlite_conn`
    |
269 | def verify_only(sqlite_conn, aurora_conn):
    |                 ^^^^^^^^^^^ ANN001
270 |     """Check and compare row counts between SQLite and Aurora without migration."""
271 |     # SQLite count
    |

db\migrations\migrate_snippet_parts.py:269:30: ANN001 Missing type annotation for function argument `aurora_conn`
    |
269 | def verify_only(sqlite_conn, aurora_conn):
    |                              ^^^^^^^^^^^ ANN001
270 |     """Check and compare row counts between SQLite and Aurora without migration."""
271 |     # SQLite count
    |

db\migrations\migrate_snippet_parts.py:295:5: ANN201 Missing return type annotation for public function `main`
    |
295 | def main():
    |     ^^^^ ANN201
296 |     """Main entry point for the snippet_parts migration script."""
297 |     parser = argparse.ArgumentParser(description="Migrate snippet_parts table from SQLite to AWS Aurora")
    |
    = help: Add return type annotation: `int | None`

db\migrations\migrate_snippet_parts.py:299:121: E501 Line too long (121 > 120)
    |
297 |     parser = argparse.ArgumentParser(description="Migrate snippet_parts table from SQLite to AWS Aurora")
298 |     parser.add_argument("--db-path", required=True, help="Path to SQLite database")
299 |     parser.add_argument("--verify-only", action="store_true", help="Only verify row counts without performing migration")
    |                                                                                                                         ^ E501
300 |     args = parser.parse_args()
    |

db\migrations\migrate_sqlite_to_aurora.py:2:1: D212 [*] Multi-line docstring summary should start at the first line
   |
 1 |   #!/usr/bin/env python3
 2 | / """
 3 | | Migration script to move data from local SQLite database to AWS Aurora.
 4 | |
 5 | | This script connects to AWS Aurora using AWS Secrets Manager credentials,
 6 | | creates all necessary tables in Aurora with PostgreSQL compatible syntax,
 7 | | and copies all data from the local SQLite database to Aurora.
 8 | | """
   | |___^ D212
 9 |
10 |   import argparse
   |
   = help: Remove whitespace after opening quotes

db\migrations\migrate_sqlite_to_aurora.py:36:5: ANN201 Missing return type annotation for public function `get_aurora_connection`
   |
36 | def get_aurora_connection():
   |     ^^^^^^^^^^^^^^^^^^^^^ ANN201
37 |     """Connect to AWS Aurora using credentials from Secrets Manager."""
38 |     try:
   |
   = help: Add return type annotation

db\migrations\migrate_sqlite_to_aurora.py:73:121: E501 Line too long (121 > 120)
   |
71 |             logger.error(f"Failed to connect to Aurora database: {e}")
72 |             logger.error(
73 |                 f"Connection details: host={cfg['host']}, port={cfg['port']}, db={cfg['dbname']}, user={cfg['username']}"
   |                                                                                                                         ^ E501
74 |             )
75 |             raise
   |

db\migrations\migrate_sqlite_to_aurora.py:84:5: ANN201 Missing return type annotation for public function `get_sqlite_connection`
   |
84 | def get_sqlite_connection(db_path):
   |     ^^^^^^^^^^^^^^^^^^^^^ ANN201
85 |     """Connect to SQLite database."""
86 |     try:
   |
   = help: Add return type annotation

db\migrations\migrate_sqlite_to_aurora.py:84:27: ANN001 Missing type annotation for function argument `db_path`
   |
84 | def get_sqlite_connection(db_path):
   |                           ^^^^^^^ ANN001
85 |     """Connect to SQLite database."""
86 |     try:
   |

db\migrations\migrate_sqlite_to_aurora.py:95:5: ANN201 Missing return type annotation for public function `ensure_schema_exists`
   |
95 | def ensure_schema_exists(conn):
   |     ^^^^^^^^^^^^^^^^^^^^ ANN201
96 |     """Create the schema if it doesn't exist."""
97 |     cursor = conn.cursor()
   |
   = help: Add return type annotation: `None`

db\migrations\migrate_sqlite_to_aurora.py:95:26: ANN001 Missing type annotation for function argument `conn`
   |
95 | def ensure_schema_exists(conn):
   |                          ^^^^ ANN001
96 |     """Create the schema if it doesn't exist."""
97 |     cursor = conn.cursor()
   |

db\migrations\migrate_sqlite_to_aurora.py:103:5: ANN201 Missing return type annotation for public function `create_aurora_tables`
    |
103 | def create_aurora_tables(conn):
    |     ^^^^^^^^^^^^^^^^^^^^ ANN201
104 |     """Create all required tables in Aurora."""
105 |     cursor = conn.cursor()
    |
    = help: Add return type annotation: `None`

db\migrations\migrate_sqlite_to_aurora.py:103:26: ANN001 Missing type annotation for function argument `conn`
    |
103 | def create_aurora_tables(conn):
    |                          ^^^^ ANN001
104 |     """Create all required tables in Aurora."""
105 |     cursor = conn.cursor()
    |

db\migrations\migrate_sqlite_to_aurora.py:268:5: ANN201 Missing return type annotation for public function `copy_table_data`
    |
268 | def copy_table_data(sqlite_conn, aurora_conn, table_name, debug=False):
    |     ^^^^^^^^^^^^^^^ ANN201
269 |     """Copy data from SQLite table to Aurora table."""
270 |     sqlite_cursor = sqlite_conn.cursor()
    |
    = help: Add return type annotation

db\migrations\migrate_sqlite_to_aurora.py:268:21: ANN001 Missing type annotation for function argument `sqlite_conn`
    |
268 | def copy_table_data(sqlite_conn, aurora_conn, table_name, debug=False):
    |                     ^^^^^^^^^^^ ANN001
269 |     """Copy data from SQLite table to Aurora table."""
270 |     sqlite_cursor = sqlite_conn.cursor()
    |

db\migrations\migrate_sqlite_to_aurora.py:268:34: ANN001 Missing type annotation for function argument `aurora_conn`
    |
268 | def copy_table_data(sqlite_conn, aurora_conn, table_name, debug=False):
    |                                  ^^^^^^^^^^^ ANN001
269 |     """Copy data from SQLite table to Aurora table."""
270 |     sqlite_cursor = sqlite_conn.cursor()
    |

db\migrations\migrate_sqlite_to_aurora.py:268:47: ANN001 Missing type annotation for function argument `table_name`
    |
268 | def copy_table_data(sqlite_conn, aurora_conn, table_name, debug=False):
    |                                               ^^^^^^^^^^ ANN001
269 |     """Copy data from SQLite table to Aurora table."""
270 |     sqlite_cursor = sqlite_conn.cursor()
    |

db\migrations\migrate_sqlite_to_aurora.py:268:59: ANN001 Missing type annotation for function argument `debug`
    |
268 | def copy_table_data(sqlite_conn, aurora_conn, table_name, debug=False):
    |                                                           ^^^^^ ANN001
269 |     """Copy data from SQLite table to Aurora table."""
270 |     sqlite_cursor = sqlite_conn.cursor()
    |

db\migrations\migrate_sqlite_to_aurora.py:287:57: B905 [*] `zip()` without an explicit `strict=` parameter
    |
285 |         if debug:
286 |             logger.info(f"Table {table_name} structure: {column_names}")
287 |             logger.info(f"Sample row from SQLite: {dict(zip(column_names, rows[0]))}")
    |                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^ B905
288 |
289 |         # Build the INSERT statement for Aurora
    |
    = help: Add explicit value for parameter `strict=`

db\migrations\migrate_sqlite_to_aurora.py:336:5: ANN201 Missing return type annotation for public function `migrate_single_table`
    |
336 | def migrate_single_table(sqlite_conn, aurora_conn, table_name):
    |     ^^^^^^^^^^^^^^^^^^^^ ANN201
337 |     """Migrate just a single table with debug info."""
338 |     logger.info(f"Starting focused migration of table: {table_name}")
    |
    = help: Add return type annotation

db\migrations\migrate_sqlite_to_aurora.py:336:26: ANN001 Missing type annotation for function argument `sqlite_conn`
    |
336 | def migrate_single_table(sqlite_conn, aurora_conn, table_name):
    |                          ^^^^^^^^^^^ ANN001
337 |     """Migrate just a single table with debug info."""
338 |     logger.info(f"Starting focused migration of table: {table_name}")
    |

db\migrations\migrate_sqlite_to_aurora.py:336:39: ANN001 Missing type annotation for function argument `aurora_conn`
    |
336 | def migrate_single_table(sqlite_conn, aurora_conn, table_name):
    |                                       ^^^^^^^^^^^ ANN001
337 |     """Migrate just a single table with debug info."""
338 |     logger.info(f"Starting focused migration of table: {table_name}")
    |

db\migrations\migrate_sqlite_to_aurora.py:336:52: ANN001 Missing type annotation for function argument `table_name`
    |
336 | def migrate_single_table(sqlite_conn, aurora_conn, table_name):
    |                                                    ^^^^^^^^^^ ANN001
337 |     """Migrate just a single table with debug info."""
338 |     logger.info(f"Starting focused migration of table: {table_name}")
    |

db\migrations\migrate_sqlite_to_aurora.py:363:5: ANN201 Missing return type annotation for public function `fix_snippet_parts`
    |
363 | def fix_snippet_parts(sqlite_conn, aurora_conn):
    |     ^^^^^^^^^^^^^^^^^ ANN201
364 |     """Special handler for snippet_parts table to fix NULL primary key issue."""
365 |     logger.info("Using special handler for snippet_parts table")
    |
    = help: Add return type annotation: `None`

db\migrations\migrate_sqlite_to_aurora.py:363:23: ANN001 Missing type annotation for function argument `sqlite_conn`
    |
363 | def fix_snippet_parts(sqlite_conn, aurora_conn):
    |                       ^^^^^^^^^^^ ANN001
364 |     """Special handler for snippet_parts table to fix NULL primary key issue."""
365 |     logger.info("Using special handler for snippet_parts table")
    |

db\migrations\migrate_sqlite_to_aurora.py:363:36: ANN001 Missing type annotation for function argument `aurora_conn`
    |
363 | def fix_snippet_parts(sqlite_conn, aurora_conn):
    |                                    ^^^^^^^^^^^ ANN001
364 |     """Special handler for snippet_parts table to fix NULL primary key issue."""
365 |     logger.info("Using special handler for snippet_parts table")
    |

db\migrations\migrate_sqlite_to_aurora.py:425:121: E501 Line too long (125 > 120)
    |
423 |                     import uuid
424 |                     row_values[0] = str(uuid.uuid4())
425 |                     logger.info(f"Generated new part_id {row_values[0]} for snippet_id {row_values[1]} part {row_values[2]}")
    |                                                                                                                         ^^^^^ E501
426 |
427 |                 # Ensure content isn't too long
    |

db\migrations\migrate_sqlite_to_aurora.py:472:5: ANN201 Missing return type annotation for public function `migrate_data`
    |
472 | def migrate_data(sqlite_conn, aurora_conn):
    |     ^^^^^^^^^^^^ ANN201
473 |     """Copy all data from SQLite to Aurora in correct order respecting foreign keys."""
    |
    = help: Add return type annotation

db\migrations\migrate_sqlite_to_aurora.py:472:18: ANN001 Missing type annotation for function argument `sqlite_conn`
    |
472 | def migrate_data(sqlite_conn, aurora_conn):
    |                  ^^^^^^^^^^^ ANN001
473 |     """Copy all data from SQLite to Aurora in correct order respecting foreign keys."""
    |

db\migrations\migrate_sqlite_to_aurora.py:472:31: ANN001 Missing type annotation for function argument `aurora_conn`
    |
472 | def migrate_data(sqlite_conn, aurora_conn):
    |                               ^^^^^^^^^^^ ANN001
473 |     """Copy all data from SQLite to Aurora in correct order respecting foreign keys."""
    |

db\migrations\migrate_sqlite_to_aurora.py:473:5: D202 [*] No blank lines allowed after function docstring (found 1)
    |
472 | def migrate_data(sqlite_conn, aurora_conn):
473 |     """Copy all data from SQLite to Aurora in correct order respecting foreign keys."""
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D202
474 |
475 |     # Define tables in the order they should be migrated (respecting foreign keys)
    |
    = help: Remove blank line(s) after function docstring

db\migrations\migrate_sqlite_to_aurora.py:500:5: ANN201 Missing return type annotation for public function `get_sqlite_table_list`
    |
500 | def get_sqlite_table_list(conn):
    |     ^^^^^^^^^^^^^^^^^^^^^ ANN201
501 |     """Get list of tables from SQLite database."""
502 |     cursor = conn.cursor()
    |
    = help: Add return type annotation

db\migrations\migrate_sqlite_to_aurora.py:500:27: ANN001 Missing type annotation for function argument `conn`
    |
500 | def get_sqlite_table_list(conn):
    |                           ^^^^ ANN001
501 |     """Get list of tables from SQLite database."""
502 |     cursor = conn.cursor()
    |

db\migrations\migrate_sqlite_to_aurora.py:509:5: ANN201 Missing return type annotation for public function `get_aurora_table_list`
    |
509 | def get_aurora_table_list(conn):
    |     ^^^^^^^^^^^^^^^^^^^^^ ANN201
510 |     """Get list of tables from Aurora database."""
511 |     cursor = conn.cursor()
    |
    = help: Add return type annotation

db\migrations\migrate_sqlite_to_aurora.py:509:27: ANN001 Missing type annotation for function argument `conn`
    |
509 | def get_aurora_table_list(conn):
    |                           ^^^^ ANN001
510 |     """Get list of tables from Aurora database."""
511 |     cursor = conn.cursor()
    |

db\migrations\migrate_sqlite_to_aurora.py:520:5: ANN201 Missing return type annotation for public function `get_row_counts`
    |
520 | def get_row_counts(conn, table_list, is_sqlite=True):
    |     ^^^^^^^^^^^^^^ ANN201
521 |     """Get row counts for all tables."""
522 |     counts = {}
    |
    = help: Add return type annotation

db\migrations\migrate_sqlite_to_aurora.py:520:20: ANN001 Missing type annotation for function argument `conn`
    |
520 | def get_row_counts(conn, table_list, is_sqlite=True):
    |                    ^^^^ ANN001
521 |     """Get row counts for all tables."""
522 |     counts = {}
    |

db\migrations\migrate_sqlite_to_aurora.py:520:26: ANN001 Missing type annotation for function argument `table_list`
    |
520 | def get_row_counts(conn, table_list, is_sqlite=True):
    |                          ^^^^^^^^^^ ANN001
521 |     """Get row counts for all tables."""
522 |     counts = {}
    |

db\migrations\migrate_sqlite_to_aurora.py:520:38: ANN001 Missing type annotation for function argument `is_sqlite`
    |
520 | def get_row_counts(conn, table_list, is_sqlite=True):
    |                                      ^^^^^^^^^ ANN001
521 |     """Get row counts for all tables."""
522 |     counts = {}
    |

db\migrations\migrate_sqlite_to_aurora.py:543:5: ANN201 Missing return type annotation for public function `verify_migration`
    |
543 | def verify_migration(sqlite_conn, aurora_conn, expected_tables):
    |     ^^^^^^^^^^^^^^^^ ANN201
544 |     """Verify the migration by comparing tables and row counts."""
545 |     logger.info("Verifying migration...")
    |
    = help: Add return type annotation

db\migrations\migrate_sqlite_to_aurora.py:543:22: ANN001 Missing type annotation for function argument `sqlite_conn`
    |
543 | def verify_migration(sqlite_conn, aurora_conn, expected_tables):
    |                      ^^^^^^^^^^^ ANN001
544 |     """Verify the migration by comparing tables and row counts."""
545 |     logger.info("Verifying migration...")
    |

db\migrations\migrate_sqlite_to_aurora.py:543:35: ANN001 Missing type annotation for function argument `aurora_conn`
    |
543 | def verify_migration(sqlite_conn, aurora_conn, expected_tables):
    |                                   ^^^^^^^^^^^ ANN001
544 |     """Verify the migration by comparing tables and row counts."""
545 |     logger.info("Verifying migration...")
    |

db\migrations\migrate_sqlite_to_aurora.py:543:48: ANN001 Missing type annotation for function argument `expected_tables`
    |
543 | def verify_migration(sqlite_conn, aurora_conn, expected_tables):
    |                                                ^^^^^^^^^^^^^^^ ANN001
544 |     """Verify the migration by comparing tables and row counts."""
545 |     logger.info("Verifying migration...")
    |

db\migrations\migrate_sqlite_to_aurora.py:593:5: ANN201 Missing return type annotation for public function `main`
    |
593 | def main():
    |     ^^^^ ANN201
594 |     """Main entry point for migration script."""
595 |     parser = argparse.ArgumentParser(description="Migrate SQLite database to AWS Aurora")
    |
    = help: Add return type annotation: `int | None`

desktop_ui\__init__.py:1:1: D104 Missing docstring in public package
desktop_ui\_snippet_main.py:1:1: D200 One-line docstring should fit on one line
  |
1 | / """
2 | | Temporary file to add main entry point to snippet_scaffold.py
3 | | """
  | |___^ D200
4 |
5 |   MAIN_CODE = """
  |
  = help: Reformat to one line

desktop_ui\_snippet_main.py:1:1: D212 [*] Multi-line docstring summary should start at the first line
  |
1 | / """
2 | | Temporary file to add main entry point to snippet_scaffold.py
3 | | """
  | |___^ D212
4 |
5 |   MAIN_CODE = """
  |
  = help: Remove whitespace after opening quotes

desktop_ui\_snippet_main.py:1:1: D415 First line should end with a period, question mark, or exclamation point
  |
1 | / """
2 | | Temporary file to add main entry point to snippet_scaffold.py
3 | | """
  | |___^ D415
4 |
5 |   MAIN_CODE = """
  |
  = help: Add closing punctuation

desktop_ui\api_key_dialog.py:1:1: D212 [*] Multi-line docstring summary should start at the first line
  |
1 | / """
2 | | API Key Configuration Dialog.
3 | |
4 | | This module provides a dialog for configuring API keys for external services,
5 | | with secure storage and retrieval functionality.
6 | | """
  | |___^ D212
7 |
8 |   import base64
  |
  = help: Remove whitespace after opening quotes

desktop_ui\api_key_dialog.py:45:5: D212 [*] Multi-line docstring summary should start at the first line
   |
44 |   class APIKeyDialog(QDialog):
45 | /     """
46 | |     Dialog for configuring API keys with secure storage.
47 | |
48 | |     This dialog allows users to:
49 | |     - Enter their API keys
50 | |     - Save keys securely to disk
51 | |     - Retrieve previously saved keys
52 | |
53 | |     The keys are stored in an encrypted file using Fernet symmetric encryption.
54 | |     A machine-specific salt is used to enhance security.
55 | |     """
   | |_______^ D212
56 |
57 |       def __init__(self, parent: Optional[QDialog] = None) -> None:
   |
   = help: Remove whitespace after opening quotes

desktop_ui\api_key_dialog.py:57:9: D107 Missing docstring in `__init__`
   |
55 |     """
56 |
57 |     def __init__(self, parent: Optional[QDialog] = None) -> None:
   |         ^^^^^^^^ D107
58 |         super().__init__(parent)
59 |         self.setWindowTitle("API Key Configuration")
   |

desktop_ui\api_key_dialog.py:200:9: D212 [*] Multi-line docstring summary should start at the first line
    |
199 |       def get_user_env_var(self, var_name: str) -> Optional[str]:
200 | /         """
201 | |         Reads the value of a user-level environment variable from the Windows Registry.
202 | |
203 | |         Args:
204 | |             var_name: Name of the environment variable
205 | |
206 | |         Returns:
207 | |             The value as a string, or None if not set
208 | |         """
    | |___________^ D212
209 |           if not sys.platform == "win32":
210 |               return os.environ.get(var_name)
    |
    = help: Remove whitespace after opening quotes

desktop_ui\api_key_dialog.py:337:16: B025 try-except block with duplicate exception `Exception`
    |
335 |             self.accept()
336 |
337 |         except Exception as e:
    |                ^^^^^^^^^ B025
338 |             QMessageBox.critical(self, "Save Error", f"Failed to save API key: {str(e)}")
    |

desktop_ui\api_key_dialog.py:341:9: D212 [*] Multi-line docstring summary should start at the first line
    |
340 |       def _get_encryption_key(self) -> bytes:
341 | /         """
342 | |         Generate an encryption key based on machine-specific data.
343 | |
344 | |         This creates a deterministic but secure key based on:
345 | |         - A salt file stored in the config directory
346 | |         - Machine-specific information
347 | |
348 | |         Returns:
349 | |             bytes: A 32-byte key for Fernet encryption
350 | |         """
    | |___________^ D212
351 |           if not CRYPTOGRAPHY_AVAILABLE:
352 |               raise ImportError("Cryptography package is not available")
    |
    = help: Remove whitespace after opening quotes

desktop_ui\api_key_dialog.py:390:9: D205 1 blank line required between summary line and description
    |
389 |       def _set_permanent_environment_variable(self, var_name: str, var_value: str) -> None:
390 | /         """
391 | |                 Set a permanent environment variable for the current user's profile.
392 | |         {{ ... }}
393 | |                 Args:
394 | |                     var_name: Name of the environment variable
395 | |                     var_value: Value to set
396 | |         """
    | |___________^ D205
397 |           try:
398 |               if sys.platform == "win32":
    |
    = help: Insert single blank line

desktop_ui\api_key_dialog.py:390:9: D212 [*] Multi-line docstring summary should start at the first line
    |
389 |       def _set_permanent_environment_variable(self, var_name: str, var_value: str) -> None:
390 | /         """
391 | |                 Set a permanent environment variable for the current user's profile.
392 | |         {{ ... }}
393 | |                 Args:
394 | |                     var_name: Name of the environment variable
395 | |                     var_value: Value to set
396 | |         """
    | |___________^ D212
397 |           try:
398 |               if sys.platform == "win32":
    |
    = help: Remove whitespace after opening quotes

desktop_ui\api_key_dialog.py:390:9: D415 First line should end with a period, question mark, or exclamation point
    |
389 |       def _set_permanent_environment_variable(self, var_name: str, var_value: str) -> None:
390 | /         """
391 | |                 Set a permanent environment variable for the current user's profile.
392 | |         {{ ... }}
393 | |                 Args:
394 | |                     var_name: Name of the environment variable
395 | |                     var_value: Value to set
396 | |         """
    | |___________^ D415
397 |           try:
398 |               if sys.platform == "win32":
    |
    = help: Add closing punctuation

desktop_ui\api_key_dialog.py:393:17: D214 [*] Section is over-indented ("Args")
    |
391 |                 Set a permanent environment variable for the current user's profile.
392 |         {{ ... }}
393 |                 Args:
    |                 ^^^^ D214
394 |                     var_name: Name of the environment variable
395 |                     var_value: Value to set
    |
    = help: Remove over-indentation from "Args"

desktop_ui\api_key_dialog.py:393:17: D411 [*] Missing blank line before section ("Args")
    |
391 |                 Set a permanent environment variable for the current user's profile.
392 |         {{ ... }}
393 |                 Args:
    |                 ^^^^ D411
394 |                     var_name: Name of the environment variable
395 |                     var_value: Value to set
    |
    = help: Add blank line before "Args"

desktop_ui\api_key_dialog.py:479:9: D212 [*] Multi-line docstring summary should start at the first line
    |
477 |           cls, parent: Optional[QDialog] = None, key_type: str = "openai"
478 |       ) -> Optional[str]:
479 | /         """
480 | |         Class method to get an API key, showing the dialog if needed.
481 | |
482 | |         Args:
483 | |             parent: Parent widget
484 | |             key_type: The type of API key to retrieve (e.g., "openai")
485 | |
486 | |         Returns:
487 | |             Optional[str]: The API key if available, None otherwise
488 | |         """
    | |___________^ D212
489 |           # First check for the OpenAPI_Key environment variable
490 |           if key_type == "openai":
    |
    = help: Remove whitespace after opening quotes

desktop_ui\api_server_manager.py:1:1: D212 [*] Multi-line docstring summary should start at the first line
  |
1 | / """
2 | | API Server Manager for Desktop UI
3 | |
4 | | This module provides functionality to check if the GraphQL API server
5 | | is running and automatically start it if needed.
6 | | """
  | |___^ D212
7 |
8 |   import os
  |
  = help: Remove whitespace after opening quotes

desktop_ui\api_server_manager.py:1:1: D415 First line should end with a period, question mark, or exclamation point
  |
1 | / """
2 | | API Server Manager for Desktop UI
3 | |
4 | | This module provides functionality to check if the GraphQL API server
5 | | is running and automatically start it if needed.
6 | | """
  | |___^ D415
7 |
8 |   import os
  |
  = help: Add closing punctuation

desktop_ui\api_server_manager.py:18:5: D212 [*] Multi-line docstring summary should start at the first line
   |
17 |   class APIServerManager:
18 | /     """
19 | |     Manages the Flask GraphQL API server for the desktop UI.
20 | |
21 | |     This class provides methods to check if the server is running,
22 | |     start it if needed, and shut it down.
23 | |     """
   | |_______^ D212
24 |
25 |       def __init__(self) -> None:
   |
   = help: Remove whitespace after opening quotes

desktop_ui\api_server_manager.py:32:9: D212 [*] Multi-line docstring summary should start at the first line
   |
31 |       def _get_server_script_path(self) -> str:
32 | /         """
33 | |         Get the absolute path to the API server script.
34 | |
35 | |         Returns:
36 | |             str: Absolute path to the run_library_api.py script
37 | |         """
   | |___________^ D212
38 |           # Get the directory of the current file
39 |           current_dir = os.path.dirname(os.path.abspath(__file__))
   |
   = help: Remove whitespace after opening quotes

desktop_ui\api_server_manager.py:45:9: D212 [*] Multi-line docstring summary should start at the first line
   |
44 |       def is_server_running(self) -> bool:
45 | /         """
46 | |         Check if the GraphQL API server is already running.
47 | |
48 | |         Returns:
49 | |             bool: True if server is running, False otherwise
50 | |         """
   | |___________^ D212
51 |           try:
52 |               # Try to connect to the server
   |
   = help: Remove whitespace after opening quotes

desktop_ui\api_server_manager.py:54:13: F841 Local variable `response` is assigned to but never used
   |
52 |             # Try to connect to the server
53 |             # Even if we get a 400 error (method not allowed), it means the server is running
54 |             response = requests.get(self._api_url, timeout=2)
   |             ^^^^^^^^ F841
55 |             return True
56 |         except requests.exceptions.ConnectionError:
   |
   = help: Remove assignment to unused variable `response`

desktop_ui\api_server_manager.py:67:9: D212 [*] Multi-line docstring summary should start at the first line
   |
66 |       def start_server(self) -> bool:
67 | /         """
68 | |         Start the GraphQL API server as a background process.
69 | |
70 | |         Returns:
71 | |             bool: True if server was started successfully, False otherwise
72 | |         """
   | |___________^ D212
73 |           try:
74 |               # Check if python is in PATH
   |
   = help: Remove whitespace after opening quotes

desktop_ui\api_server_manager.py:96:9: D212 [*] Multi-line docstring summary should start at the first line
    |
 95 |       def ensure_server_running(self) -> bool:
 96 | /         """
 97 | |         Ensure the GraphQL API server is running, starting it if needed.
 98 | |
 99 | |         Returns:
100 | |             bool: True if server is running or was started successfully, False otherwise
101 | |         """
    | |___________^ D212
102 |           if self.is_server_running():
103 |               return True
    |
    = help: Remove whitespace after opening quotes

desktop_ui\api_server_manager.py:108:9: D200 One-line docstring should fit on one line
    |
107 |       def shutdown_server(self) -> None:
108 | /         """
109 | |         Shutdown the server if it was started by this manager.
110 | |         """
    | |___________^ D200
111 |           if self._server_process:
112 |               try:
    |
    = help: Reformat to one line

desktop_ui\api_server_manager.py:108:9: D212 [*] Multi-line docstring summary should start at the first line
    |
107 |       def shutdown_server(self) -> None:
108 | /         """
109 | |         Shutdown the server if it was started by this manager.
110 | |         """
    | |___________^ D212
111 |           if self._server_process:
112 |               try:
    |
    = help: Remove whitespace after opening quotes

desktop_ui\category_model_tester.py:1:1: D205 1 blank line required between summary line and description
   |
 1 | / """
 2 | | Category Model Tester UI
 3 | | -----------------------
 4 | | A simple PySide6-based desktop UI for directly testing the Category object model (Category, CategoryManager).
 5 | |
 6 | | - List all categories
 7 | | - Add a new category
 8 | | - Rename a category
 9 | | - Delete a category (with cascade warning)
10 | | - Show validation and error messages
11 | |
12 | | Bypasses API and service layers; interacts directly with CategoryManager and DatabaseManager.
13 | |
14 | | Author: Cascade AI
15 | | """
   | |___^ D205
16 |
17 |   import os
   |
   = help: Insert single blank line

desktop_ui\category_model_tester.py:1:1: D212 [*] Multi-line docstring summary should start at the first line
   |
 1 | / """
 2 | | Category Model Tester UI
 3 | | -----------------------
 4 | | A simple PySide6-based desktop UI for directly testing the Category object model (Category, CategoryManager).
 5 | |
 6 | | - List all categories
 7 | | - Add a new category
 8 | | - Rename a category
 9 | | - Delete a category (with cascade warning)
10 | | - Show validation and error messages
11 | |
12 | | Bypasses API and service layers; interacts directly with CategoryManager and DatabaseManager.
13 | |
14 | | Author: Cascade AI
15 | | """
   | |___^ D212
16 |
17 |   import os
   |
   = help: Remove whitespace after opening quotes

desktop_ui\category_model_tester.py:1:1: D415 First line should end with a period, question mark, or exclamation point
   |
 1 | / """
 2 | | Category Model Tester UI
 3 | | -----------------------
 4 | | A simple PySide6-based desktop UI for directly testing the Category object model (Category, CategoryManager).
 5 | |
 6 | | - List all categories
 7 | | - Add a new category
 8 | | - Rename a category
 9 | | - Delete a category (with cascade warning)
10 | | - Show validation and error messages
11 | |
12 | | Bypasses API and service layers; interacts directly with CategoryManager and DatabaseManager.
13 | |
14 | | Author: Cascade AI
15 | | """
   | |___^ D415
16 |
17 |   import os
   |
   = help: Add closing punctuation

desktop_ui\category_model_tester.py:42:5: D200 One-line docstring should fit on one line
   |
41 |   class CategoryModelTester(QWidget):
42 | /     """
43 | |     Simple UI to test CategoryManager CRUD and validation logic.
44 | |     """
   | |_______^ D200
45 |
46 |       def __init__(self) -> None:
   |
   = help: Reformat to one line

desktop_ui\category_model_tester.py:42:5: D212 [*] Multi-line docstring summary should start at the first line
   |
41 |   class CategoryModelTester(QWidget):
42 | /     """
43 | |     Simple UI to test CategoryManager CRUD and validation logic.
44 | |     """
   | |_______^ D212
45 |
46 |       def __init__(self) -> None:
   |
   = help: Remove whitespace after opening quotes

desktop_ui\category_model_tester.py:46:9: D107 Missing docstring in `__init__`
   |
44 |     """
45 |
46 |     def __init__(self) -> None:
   |         ^^^^^^^^ D107
47 |         super().__init__()
48 |         self.setWindowTitle("Category Model Tester")
   |

desktop_ui\category_model_tester.py:56:9: D102 Missing docstring in public method
   |
54 |         self.refresh_categories()
55 |
56 |     def init_ui(self) -> None:
   |         ^^^^^^^ D102
57 |         layout = QVBoxLayout()
   |

desktop_ui\category_model_tester.py:84:9: D102 Missing docstring in public method
   |
82 |         self.btn_delete.clicked.connect(self.delete_category)
83 |
84 |     def refresh_categories(self) -> None:
   |         ^^^^^^^^^^^^^^^^^^ D102
85 |         self.list_widget.clear()
86 |         try:
   |

desktop_ui\category_model_tester.py:93:9: D102 Missing docstring in public method
   |
91 |             self.set_status(f"Error loading categories: {e}")
92 |
93 |     def add_category(self) -> None:
   |         ^^^^^^^^^^^^ D102
94 |         name, ok = QInputDialog.getText(self, "Add Category", "Enter category name:")
95 |         if ok and name:
   |

desktop_ui\category_model_tester.py:105:9: D102 Missing docstring in public method
    |
103 |                 self.set_status(f"Error: {e}")
104 |
105 |     def get_selected_category_id(self) -> Optional[str]:
    |         ^^^^^^^^^^^^^^^^^^^^^^^^ D102
106 |         item = self.list_widget.currentItem()
107 |         if not item:
    |

desktop_ui\category_model_tester.py:117:9: D102 Missing docstring in public method
    |
115 |             return None
116 |
117 |     def rename_category(self) -> None:
    |         ^^^^^^^^^^^^^^^ D102
118 |         cat_id = self.get_selected_category_id()
119 |         if cat_id is None:
    |

desktop_ui\category_model_tester.py:134:9: D102 Missing docstring in public method
    |
132 |                 self.set_status(f"Error: {e}")
133 |
134 |     def delete_category(self) -> None:
    |         ^^^^^^^^^^^^^^^ D102
135 |         cat_id = self.get_selected_category_id()
136 |         if cat_id is None:
    |

desktop_ui\category_model_tester.py:155:9: D102 Missing docstring in public method
    |
153 |                 self.set_status(f"Error: {e}")
154 |
155 |     def set_status(self, msg: str, error: bool = True) -> None:
    |         ^^^^^^^^^^ D102
156 |         self.status_label.setText(msg)
157 |         if error:
    |

desktop_ui\category_model_tester.py:163:5: D103 Missing docstring in public function
    |
163 | def main() -> None:
    |     ^^^^ D103
164 |     app = QApplication(sys.argv)
165 |     tester = CategoryModelTester()
    |

desktop_ui\cleanup_data_dialog.py:1:1: D212 [*] Multi-line docstring summary should start at the first line
   |
 1 | / """
 2 | | CleanupDataDialog UI for managing data cleanup and regeneration operations.
 3 | |
 4 | | This dialog provides options to:
 5 | | - Delete all derived data (ngrams, analytics, summaries)
 6 | | - Recreate ngrams from session keystrokes
 7 | | - Recreate session summaries
 8 | | - Recreate ngram statistics
 9 | | """
   | |___^ D212
10 |
11 |   import os
   |
   = help: Remove whitespace after opening quotes

desktop_ui\cleanup_data_dialog.py:36:5: D212 [*] Multi-line docstring summary should start at the first line
   |
35 |   class CleanupDataDialog(QDialog):
36 | /     """
37 | |     Dialog for managing data cleanup and regeneration operations.
38 | |
39 | |     Provides a centralized interface for cleaning up derived data
40 | |     and regenerating it using various scaffold tools.
41 | |     """
   | |_______^ D212
42 |
43 |       def __init__(
   |
   = help: Remove whitespace after opening quotes

desktop_ui\cleanup_data_dialog.py:43:9: D107 Missing docstring in `__init__`
   |
41 |     """
42 |
43 |     def __init__(
   |         ^^^^^^^^ D107
44 |         self,
45 |         parent: Optional[QtWidgets.QWidget] = None,
   |

desktop_ui\consistency_typing.py:2:1: D205 1 blank line required between summary line and description
  |
1 |   # ruff: noqa: E501
2 | / """
3 | | ConsistencyTypingScreen - Interactive typing practice UI focused on rhythm consistency.
4 | | Implements consistency-focused typing drill with metronome and variability tracking.
5 | | """
  | |___^ D205
6 |
7 |   import datetime
  |
  = help: Insert single blank line

desktop_ui\consistency_typing.py:2:1: D212 [*] Multi-line docstring summary should start at the first line
  |
1 |   # ruff: noqa: E501
2 | / """
3 | | ConsistencyTypingScreen - Interactive typing practice UI focused on rhythm consistency.
4 | | Implements consistency-focused typing drill with metronome and variability tracking.
5 | | """
  | |___^ D212
6 |
7 |   import datetime
  |
  = help: Remove whitespace after opening quotes

desktop_ui\consistency_typing.py:7:1: I001 [*] Import block is un-sorted or un-formatted
   |
 5 |   """
 6 |
 7 | / import datetime
 8 | | import logging
 9 | | import math
10 | | import statistics
11 | | import time
12 | | import uuid
13 | | from typing import Any, Dict, List, Optional, Union
14 | |
15 | | from PySide6.QtCore import Qt, QTimer
16 | | from PySide6.QtGui import QColor, QFont, QPalette, QTextCharFormat, QTextCursor
17 | | from PySide6.QtWidgets import (
18 | |     QDialog,
19 | |     QGridLayout,
20 | |     QHBoxLayout,
21 | |     QLabel,
22 | |     QProgressBar,
23 | |     QPushButton,
24 | |     QRadioButton,
25 | |     QSizePolicy,
26 | |     QSpacerItem,
27 | |     QSpinBox,
28 | |     QStatusBar,
29 | |     QTextEdit,
30 | |     QVBoxLayout,
31 | |     QWidget,
32 | |     QButtonGroup,
33 | |     QGroupBox,
34 | |     QSlider,
35 | |     QCheckBox,
36 | | )
37 | |
38 | | from db.database_manager import DatabaseManager
39 | | from models.keyboard_manager import KeyboardManager, KeyboardNotFound
40 | | from models.keystroke import Keystroke
41 | | from models.keystroke_manager import KeystrokeManager
42 | | from models.session import Session
43 | | from models.session_manager import SessionManager
44 | | from models.user_manager import UserManager, UserNotFound
   | |_________________________________________________________^ I001
   |
   = help: Organize imports

desktop_ui\consistency_typing.py:8:8: F401 [*] `logging` imported but unused
   |
 7 | import datetime
 8 | import logging
   |        ^^^^^^^ F401
 9 | import math
10 | import statistics
   |
   = help: Remove unused import: `logging`

desktop_ui\consistency_typing.py:9:8: F401 [*] `math` imported but unused
   |
 7 | import datetime
 8 | import logging
 9 | import math
   |        ^^^^ F401
10 | import statistics
11 | import time
   |
   = help: Remove unused import: `math`

desktop_ui\consistency_typing.py:12:8: F401 [*] `uuid` imported but unused
   |
10 | import statistics
11 | import time
12 | import uuid
   |        ^^^^ F401
13 | from typing import Any, Dict, List, Optional, Union
   |
   = help: Remove unused import: `uuid`

desktop_ui\consistency_typing.py:13:47: F401 [*] `typing.Union` imported but unused
   |
11 | import time
12 | import uuid
13 | from typing import Any, Dict, List, Optional, Union
   |                                               ^^^^^ F401
14 |
15 | from PySide6.QtCore import Qt, QTimer
   |
   = help: Remove unused import: `typing.Union`

desktop_ui\consistency_typing.py:25:5: F401 [*] `PySide6.QtWidgets.QSizePolicy` imported but unused
   |
23 |     QPushButton,
24 |     QRadioButton,
25 |     QSizePolicy,
   |     ^^^^^^^^^^^ F401
26 |     QSpacerItem,
27 |     QSpinBox,
   |
   = help: Remove unused import

desktop_ui\consistency_typing.py:26:5: F401 [*] `PySide6.QtWidgets.QSpacerItem` imported but unused
   |
24 |     QRadioButton,
25 |     QSizePolicy,
26 |     QSpacerItem,
   |     ^^^^^^^^^^^ F401
27 |     QSpinBox,
28 |     QStatusBar,
   |
   = help: Remove unused import

desktop_ui\consistency_typing.py:39:37: F401 [*] `models.keyboard_manager.KeyboardManager` imported but unused
   |
38 | from db.database_manager import DatabaseManager
39 | from models.keyboard_manager import KeyboardManager, KeyboardNotFound
   |                                     ^^^^^^^^^^^^^^^ F401
40 | from models.keystroke import Keystroke
41 | from models.keystroke_manager import KeystrokeManager
   |
   = help: Remove unused import

desktop_ui\consistency_typing.py:39:54: F401 [*] `models.keyboard_manager.KeyboardNotFound` imported but unused
   |
38 | from db.database_manager import DatabaseManager
39 | from models.keyboard_manager import KeyboardManager, KeyboardNotFound
   |                                                      ^^^^^^^^^^^^^^^^ F401
40 | from models.keystroke import Keystroke
41 | from models.keystroke_manager import KeystrokeManager
   |
   = help: Remove unused import

desktop_ui\consistency_typing.py:40:30: F401 [*] `models.keystroke.Keystroke` imported but unused
   |
38 | from db.database_manager import DatabaseManager
39 | from models.keyboard_manager import KeyboardManager, KeyboardNotFound
40 | from models.keystroke import Keystroke
   |                              ^^^^^^^^^ F401
41 | from models.keystroke_manager import KeystrokeManager
42 | from models.session import Session
   |
   = help: Remove unused import: `models.keystroke.Keystroke`

desktop_ui\consistency_typing.py:41:38: F401 [*] `models.keystroke_manager.KeystrokeManager` imported but unused
   |
39 | from models.keyboard_manager import KeyboardManager, KeyboardNotFound
40 | from models.keystroke import Keystroke
41 | from models.keystroke_manager import KeystrokeManager
   |                                      ^^^^^^^^^^^^^^^^ F401
42 | from models.session import Session
43 | from models.session_manager import SessionManager
   |
   = help: Remove unused import: `models.keystroke_manager.KeystrokeManager`

desktop_ui\consistency_typing.py:42:28: F401 [*] `models.session.Session` imported but unused
   |
40 | from models.keystroke import Keystroke
41 | from models.keystroke_manager import KeystrokeManager
42 | from models.session import Session
   |                            ^^^^^^^ F401
43 | from models.session_manager import SessionManager
44 | from models.user_manager import UserManager, UserNotFound
   |
   = help: Remove unused import: `models.session.Session`

desktop_ui\consistency_typing.py:43:36: F401 [*] `models.session_manager.SessionManager` imported but unused
   |
41 | from models.keystroke_manager import KeystrokeManager
42 | from models.session import Session
43 | from models.session_manager import SessionManager
   |                                    ^^^^^^^^^^^^^^ F401
44 | from models.user_manager import UserManager, UserNotFound
   |
   = help: Remove unused import: `models.session_manager.SessionManager`

desktop_ui\consistency_typing.py:44:33: F401 [*] `models.user_manager.UserManager` imported but unused
   |
42 | from models.session import Session
43 | from models.session_manager import SessionManager
44 | from models.user_manager import UserManager, UserNotFound
   |                                 ^^^^^^^^^^^ F401
   |
   = help: Remove unused import

desktop_ui\consistency_typing.py:44:46: F401 [*] `models.user_manager.UserNotFound` imported but unused
   |
42 | from models.session import Session
43 | from models.session_manager import SessionManager
44 | from models.user_manager import UserManager, UserNotFound
   |                                              ^^^^^^^^^^^^ F401
   |
   = help: Remove unused import

desktop_ui\consistency_typing.py:48:5: D205 1 blank line required between summary line and description
   |
47 |   class ConsistencyTypingScreen(QDialog):
48 | /     """
49 | |     ConsistencyTypingScreen handles consistency-focused typing practice.
50 | |     Emphasizes rhythm and timing consistency over speed or accuracy.
51 | |     
52 | |     Supports two modes:
53 | |     - Metronome-Led: User sets target pace with audible metronome
54 | |     - User-Led: System adapts to user's natural rhythm
55 | |     """
   | |_______^ D205
56 |
57 |       def __init__(
   |
   = help: Insert single blank line

desktop_ui\consistency_typing.py:48:5: D212 [*] Multi-line docstring summary should start at the first line
   |
47 |   class ConsistencyTypingScreen(QDialog):
48 | /     """
49 | |     ConsistencyTypingScreen handles consistency-focused typing practice.
50 | |     Emphasizes rhythm and timing consistency over speed or accuracy.
51 | |     
52 | |     Supports two modes:
53 | |     - Metronome-Led: User sets target pace with audible metronome
54 | |     - User-Led: System adapts to user's natural rhythm
55 | |     """
   | |_______^ D212
56 |
57 |       def __init__(
   |
   = help: Remove whitespace after opening quotes

desktop_ui\consistency_typing.py:57:9: D107 Missing docstring in `__init__`
   |
55 |     """
56 |
57 |     def __init__(
   |         ^^^^^^^^ D107
58 |         self,
59 |         snippet_id: int,
   |

desktop_ui\consistency_typing.py:435:16: B007 Loop control variable `char` not used within loop body
    |
433 |         current_text = self.typing_input.toPlainText()
434 |         
435 |         for i, char in enumerate(self.display_text):
    |                ^^^^ B007
436 |             cursor.setPosition(i)
437 |             cursor.setPosition(i + 1, QTextCursor.MoveMode.KeepAnchor)
    |
    = help: Rename unused `char` to `_char`

desktop_ui\db_viewer_dialog.py:1:1: D212 [*] Multi-line docstring summary should start at the first line
  |
1 | / """
2 | | Database Viewer Dialog for AI Typing Trainer (PySide6)
3 | |
4 | | This module provides a GUI for viewing database tables in a read-only interface.
5 | | """
  | |___^ D212
6 |
7 |   from typing import Optional, cast
  |
  = help: Remove whitespace after opening quotes

desktop_ui\db_viewer_dialog.py:1:1: D415 First line should end with a period, question mark, or exclamation point
  |
1 | / """
2 | | Database Viewer Dialog for AI Typing Trainer (PySide6)
3 | |
4 | | This module provides a GUI for viewing database tables in a read-only interface.
5 | | """
  | |___^ D415
6 |
7 |   from typing import Optional, cast
  |
  = help: Add closing punctuation

desktop_ui\db_viewer_dialog.py:29:5: D212 [*] Multi-line docstring summary should start at the first line
   |
28 |   class DatabaseViewerDialog(QDialog):
29 | /     """
30 | |     Dialog for viewing database tables and content.
31 | |
32 | |     Features:
33 | |     - Table selection
34 | |     - Data display with pagination, sorting, filtering
35 | |     - Export to CSV
36 | |     - Error handling
37 | |
38 | |     Args:
39 | |         service: DatabaseViewerService instance to access table data
40 | |         parent: Optional parent widget
41 | |     """
   | |_______^ D212
42 |
43 |       def __init__(
   |
   = help: Remove whitespace after opening quotes

desktop_ui\db_viewer_dialog.py:43:9: D107 Missing docstring in `__init__`
   |
41 |     """
42 |
43 |     def __init__(
   |         ^^^^^^^^ D107
44 |         self,
45 |         service: DatabaseViewerService,
   |

desktop_ui\db_viewer_dialog.py:306:24: F821 Undefined name `QProgressBar`
    |
305 |             # Show progress dialog
306 |             progress = QProgressBar(self)
    |                        ^^^^^^^^^^^^ F821
307 |             progress.setWindowTitle("Exporting data...")
308 |             progress.setRange(0, 0)  # Indeterminate
    |

desktop_ui\dialogs\keyboard_dialog.py:1:1: D200 One-line docstring should fit on one line
  |
1 | / """
2 | | Keyboard dialog for adding/editing keyboards.
3 | | """
  | |___^ D200
4 |
5 |   from typing import Optional
  |
  = help: Reformat to one line

desktop_ui\dialogs\keyboard_dialog.py:1:1: D212 [*] Multi-line docstring summary should start at the first line
  |
1 | / """
2 | | Keyboard dialog for adding/editing keyboards.
3 | | """
  | |___^ D212
4 |
5 |   from typing import Optional
  |
  = help: Remove whitespace after opening quotes

desktop_ui\dialogs\keyboard_dialog.py:23:5: D200 One-line docstring should fit on one line
   |
22 |   class KeyboardDialog(QDialog):
23 | /     """
24 | |     Dialog for adding or editing a keyboard.
25 | |     """
   | |_______^ D200
26 |
27 |       def __init__(
   |
   = help: Reformat to one line

desktop_ui\dialogs\keyboard_dialog.py:23:5: D212 [*] Multi-line docstring summary should start at the first line
   |
22 |   class KeyboardDialog(QDialog):
23 | /     """
24 | |     Dialog for adding or editing a keyboard.
25 | |     """
   | |_______^ D212
26 |
27 |       def __init__(
   |
   = help: Remove whitespace after opening quotes

desktop_ui\dialogs\keyboard_dialog.py:33:9: D212 [*] Multi-line docstring summary should start at the first line
   |
31 |           parent: Optional[QWidget] = None,
32 |       ) -> None:
33 | /         """
34 | |         Initialize the keyboard dialog.
35 | |
36 | |         Args:
37 | |             user_id: ID of the user this keyboard belongs to.
38 | |             keyboard: Optional keyboard to edit. If None, create a new keyboard.
39 | |             parent: Parent widget.
40 | |         """
   | |___________^ D212
41 |           super().__init__(parent)
42 |           self.user_id = user_id
   |
   = help: Remove whitespace after opening quotes

desktop_ui\dialogs\keyboard_dialog.py:118:9: D212 [*] Multi-line docstring summary should start at the first line
    |
117 |       def get_keyboard(self) -> Keyboard:
118 | /         """
119 | |         Get the keyboard object with updated values.
120 | |
121 | |         Returns:
122 | |             The updated or new keyboard object.
123 | |         """
    | |___________^ D212
124 |           return self.keyboard
    |
    = help: Remove whitespace after opening quotes

desktop_ui\dialogs\user_dialog.py:1:1: D200 One-line docstring should fit on one line
  |
1 | / """
2 | | User dialog for adding/editing users.
3 | | """
  | |___^ D200
4 |
5 |   from typing import Optional
  |
  = help: Reformat to one line

desktop_ui\dialogs\user_dialog.py:1:1: D212 [*] Multi-line docstring summary should start at the first line
  |
1 | / """
2 | | User dialog for adding/editing users.
3 | | """
  | |___^ D212
4 |
5 |   from typing import Optional
  |
  = help: Remove whitespace after opening quotes

desktop_ui\dialogs\user_dialog.py:21:5: D200 One-line docstring should fit on one line
   |
20 |   class UserDialog(QDialog):
21 | /     """
22 | |     Dialog for adding or editing a user.
23 | |     """
   | |_______^ D200
24 |
25 |       def __init__(
   |
   = help: Reformat to one line

desktop_ui\dialogs\user_dialog.py:21:5: D212 [*] Multi-line docstring summary should start at the first line
   |
20 |   class UserDialog(QDialog):
21 | /     """
22 | |     Dialog for adding or editing a user.
23 | |     """
   | |_______^ D212
24 |
25 |       def __init__(
   |
   = help: Remove whitespace after opening quotes

desktop_ui\dialogs\user_dialog.py:30:9: D212 [*] Multi-line docstring summary should start at the first line
   |
28 |           parent: Optional[QWidget] = None,
29 |       ) -> None:
30 | /         """
31 | |         Initialize the user dialog.
32 | |
33 | |         Args:
34 | |             user: Optional user to edit. If None, create a new user.
35 | |             parent: Parent widget.
36 | |         """
   | |___________^ D212
37 |           super().__init__(parent)
38 |           self.user = user
   |
   = help: Remove whitespace after opening quotes

desktop_ui\dialogs\user_dialog.py:119:9: D212 [*] Multi-line docstring summary should start at the first line
    |
118 |       def get_user(self) -> User:
119 | /         """
120 | |         Get the user object with updated values.
121 | |
122 | |         Returns:
123 | |             The updated or new user object.
124 | |         """
    | |___________^ D212
125 |           return self.user
    |
    = help: Remove whitespace after opening quotes

desktop_ui\drill_config.py:1:1: D212 [*] Multi-line docstring summary should start at the first line
  |
1 | / """
2 | | Drill Configuration Dialog for AI Typing Trainer.
3 | |
4 | | This module provides a dialog for configuring typing drill parameters,
5 | | including snippet selection, index ranges, and launches the typing drill.
6 | | """
  | |___^ D212
7 |
8 |   # Standard library imports
  |
  = help: Remove whitespace after opening quotes

desktop_ui\drill_config.py:9:1: I001 [*] Import block is un-sorted or un-formatted
   |
 8 |   # Standard library imports
 9 | / import os
10 | | from typing import List, Optional
11 | |
12 | | # Third-party imports
13 | | from PySide6 import QtCore, QtWidgets
14 | | from PySide6.QtWidgets import QStatusBar
15 | |
16 | | # Local application imports
17 | | from db.database_manager import DatabaseManager
18 | | from desktop_ui.typing_drill import TypingDrillScreen
19 | | from models.category import Category
20 | | from models.category_manager import CategoryManager
21 | | from models.dynamic_content_service import DynamicContentService
22 | | from models.keyboard_manager import KeyboardManager
23 | | from models.setting import Setting
24 | | from models.setting_manager import SettingManager
25 | | from models.snippet import Snippet
26 | | from models.snippet_manager import SnippetManager
27 | | from models.user_manager import UserManager
28 | | from helpers.debug_util import DebugUtil
   | |________________________________________^ I001
29 |
30 |   # Define project_root if needed
   |
   = help: Organize imports

desktop_ui\drill_config.py:37:5: D212 [*] Multi-line docstring summary should start at the first line
   |
36 |   class DrillConfigDialog(QtWidgets.QDialog):
37 | /     """
38 | |     Dialog for configuring typing drill parameters.
39 | |
40 | |     Allows users to:
41 | |     - Select a category
42 | |     - Select a snippet from the chosen category
43 | |     - Set start and end indices for partial snippets
44 | |     - Launch the typing drill with configured parameters
45 | |
46 | |     Args:
47 | |         db_manager: Database manager instance to access categories and snippets
48 | |         user_id: Optional user ID to load user information
49 | |         keyboard_id: Optional keyboard ID to load keyboard information
50 | |         parent: Optional parent widget
51 | |     """
   | |_______^ D212
52 |
53 |       def __init__(
   |
   = help: Remove whitespace after opening quotes

desktop_ui\drill_config.py:53:9: D107 Missing docstring in `__init__`
   |
51 |     """
52 |
53 |     def __init__(
   |         ^^^^^^^^ D107
54 |         self,
55 |         db_manager: DatabaseManager,
   |

desktop_ui\drill_config.py:109:121: E501 Line too long (134 > 120)
    |
107 |                         self.debug_util.debugMessage(f"User type: {type(self.current_user)}")
108 |                         self.debug_util.debugMessage(
109 |                             f"User attributes: {vars(self.current_user) if hasattr(self.current_user, '__dict__') else 'No __dict__'}"
    |                                                                                                                         ^^^^^^^^^^^^^^ E501
110 |                         )
111 |                     except Exception as e:
    |

desktop_ui\drill_config.py:458:121: E501 Line too long (122 > 120)
    |
456 |                             start_idx = 0
457 |                     else:
458 |                         self.debug_util.debugMessage(" No snippet manager or user/keyboard ID, using default start index")
    |                                                                                                                         ^^ E501
459 |                         
460 |                     self.start_index.setMaximum(len(snippet.content) - 1)
    |

desktop_ui\drill_screen_tester.py:1:1: D205 1 blank line required between summary line and description
   |
 1 | / """
 2 | | Drill Screen Tester UI
 3 | | ---------------------
 4 | | A minimal PySide6 UI for selecting between snippet-based or manual text input.
 5 | | - If 'Snippet Selection' is chosen: shows a dropdown of snippets and start/end index fields.
 6 | | - If 'Manual Input' is chosen: shows a text box for manual entry.
 7 | | - A preview panel always shows the current text (subset or manual).
 8 | | - A Start button emits the relevant parameters.
 9 | | """
   | |___^ D205
10 |
11 |   import os
   |
   = help: Insert single blank line

desktop_ui\drill_screen_tester.py:1:1: D212 [*] Multi-line docstring summary should start at the first line
   |
 1 | / """
 2 | | Drill Screen Tester UI
 3 | | ---------------------
 4 | | A minimal PySide6 UI for selecting between snippet-based or manual text input.
 5 | | - If 'Snippet Selection' is chosen: shows a dropdown of snippets and start/end index fields.
 6 | | - If 'Manual Input' is chosen: shows a text box for manual entry.
 7 | | - A preview panel always shows the current text (subset or manual).
 8 | | - A Start button emits the relevant parameters.
 9 | | """
   | |___^ D212
10 |
11 |   import os
   |
   = help: Remove whitespace after opening quotes

desktop_ui\drill_screen_tester.py:1:1: D415 First line should end with a period, question mark, or exclamation point
   |
 1 | / """
 2 | | Drill Screen Tester UI
 3 | | ---------------------
 4 | | A minimal PySide6 UI for selecting between snippet-based or manual text input.
 5 | | - If 'Snippet Selection' is chosen: shows a dropdown of snippets and start/end index fields.
 6 | | - If 'Manual Input' is chosen: shows a text box for manual entry.
 7 | | - A preview panel always shows the current text (subset or manual).
 8 | | - A Start button emits the relevant parameters.
 9 | | """
   | |___^ D415
10 |
11 |   import os
   |
   = help: Add closing punctuation

desktop_ui\drill_screen_tester.py:20:1: E402 Module level import not at top of file
   |
18 |     sys.path.insert(0, project_root)
19 |
20 | import sys
   | ^^^^^^^^^^ E402
21 |
22 | from PySide6 import QtWidgets
   |

desktop_ui\drill_screen_tester.py:22:1: E402 Module level import not at top of file
   |
20 | import sys
21 |
22 | from PySide6 import QtWidgets
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
23 |
24 | # Dummy snippet data for demonstration
   |

desktop_ui\drill_screen_tester.py:44:7: D101 Missing docstring in public class
   |
44 | class DrillScreenTester(QtWidgets.QWidget):
   |       ^^^^^^^^^^^^^^^^^ D101
45 |     def __init__(self) -> None:
46 |         super().__init__()
   |

desktop_ui\drill_screen_tester.py:45:9: D107 Missing docstring in `__init__`
   |
44 | class DrillScreenTester(QtWidgets.QWidget):
45 |     def __init__(self) -> None:
   |         ^^^^^^^^ D107
46 |         super().__init__()
47 |         self.setWindowTitle("Drill Screen Tester")
   |

desktop_ui\drill_screen_tester.py:51:9: D102 Missing docstring in public method
   |
49 |         self.init_ui()
50 |
51 |     def init_ui(self) -> None:
   |         ^^^^^^^ D102
52 |         layout = QtWidgets.QVBoxLayout()
   |

desktop_ui\drill_screen_tester.py:125:9: D102 Missing docstring in public method
    |
123 |         self.update_preview()
124 |
125 |     def on_radio_changed(self) -> None:
    |         ^^^^^^^^^^^^^^^^ D102
126 |         snippet_mode = self.rb_snippet.isChecked()
127 |         self.snippet_panel.setVisible(snippet_mode)
    |

desktop_ui\drill_screen_tester.py:131:9: D102 Missing docstring in public method
    |
129 |         self.update_preview()
130 |
131 |     def update_preview(self) -> None:
    |         ^^^^^^^^^^^^^^ D102
132 |         if self.rb_snippet.isChecked():
133 |             idx = self.snippet_combo.currentIndex()
    |

desktop_ui\drill_screen_tester.py:153:9: D200 One-line docstring should fit on one line
    |
152 |       def on_start(self) -> None:
153 | /         """
154 | |         Launch TypingDrillScreen with the selected snippet/manual text and indices.
155 | |         """
    | |___________^ D200
156 |           print("Start button clicked!")
157 |           # Robust import for both direct script and package usage
    |
    = help: Reformat to one line

desktop_ui\drill_screen_tester.py:153:9: D212 [*] Multi-line docstring summary should start at the first line
    |
152 |       def on_start(self) -> None:
153 | /         """
154 | |         Launch TypingDrillScreen with the selected snippet/manual text and indices.
155 | |         """
    | |___________^ D212
156 |           print("Start button clicked!")
157 |           # Robust import for both direct script and package usage
    |
    = help: Remove whitespace after opening quotes

desktop_ui\dynamic_config.py:1:1: D212 [*] Multi-line docstring summary should start at the first line
  |
1 | / """
2 | | Dynamic N-gram Practice Configuration Dialog.
3 | |
4 | | This module provides a dialog for configuring n-gram based practice sessions,
5 | | allowing users to target specific n-gram patterns for improvement.
6 | | """
  | |___^ D212
7 |
8 |   from typing import Optional
  |
  = help: Remove whitespace after opening quotes

desktop_ui\dynamic_config.py:8:1: I001 [*] Import block is un-sorted or un-formatted
   |
 6 |   """
 7 |
 8 | / from typing import Optional
 9 | | from uuid import uuid4
10 | |
11 | | from PySide6.QtCore import Qt
12 | | from PySide6.QtWidgets import (
13 | |     QAbstractItemView,
14 | |     QButtonGroup,
15 | |     QCheckBox,
16 | |     QComboBox,
17 | |     QDialog,
18 | |     QDialogButtonBox,
19 | |     QFormLayout,
20 | |     QGroupBox,
21 | |     QHeaderView,
22 | |     QHBoxLayout,
23 | |     QLineEdit,
24 | |     QMessageBox,
25 | |     QPushButton,
26 | |     QRadioButton,
27 | |     QSpinBox,
28 | |     QStatusBar,
29 | |     QTableWidget,
30 | |     QTableWidgetItem,
31 | |     QTextEdit,
32 | |     QVBoxLayout,
33 | |     QWidget,
34 | | )
35 | |
36 | | from db.database_manager import DatabaseManager
37 | | from desktop_ui.typing_drill import TypingDrillScreen
38 | |
39 | | from models.category_manager import CategoryManager
40 | | from models.dynamic_content_service import ContentMode, DynamicContentService
41 | | from models.keyboard_manager import KeyboardManager
42 | | from models.llm_ngram_service import LLMMissingAPIKeyError, LLMNgramService
43 | | from models.ngram_analytics_service import NGramAnalyticsService
44 | | from models.ngram_manager import NGramManager
45 | | from models.setting import Setting
46 | | from models.setting_manager import SettingManager
47 | |
48 | | from models.snippet_manager import SnippetManager
49 | | from models.user_manager import UserManager
   | |___________________________________________^ I001
   |
   = help: Organize imports

desktop_ui\dynamic_config.py:53:5: D212 [*] Multi-line docstring summary should start at the first line
   |
52 |   class DynamicConfigDialog(QDialog):
53 | /     """
54 | |     Dialog for configuring n-gram based typing practice.
55 | |
56 | |     Allows users to:
57 | |     - Select n-gram size (3-10 characters)
58 | |     - Choose focus area (speed or accuracy)
59 | |     - Set desired practice length
60 | |     - View problematic n-grams
61 | |     - Generate and preview practice content
62 | |     - Launch the typing drill with generated content
63 | |
64 | |     Args:
65 | |         db_manager: Database manager instance
66 | |         parent: Optional parent widget
67 | |     """
   | |_______^ D212
68 |
69 |       def __init__(
   |
   = help: Remove whitespace after opening quotes

desktop_ui\dynamic_config.py:69:9: D107 Missing docstring in `__init__`
   |
67 |     """
68 |
69 |     def __init__(
   |         ^^^^^^^^ D107
70 |         self,
71 |         db_manager: DatabaseManager,
   |

desktop_ui\games_menu.py:2:1: D205 1 blank line required between summary line and description
  |
1 |   # ruff: noqa: E501
2 | / """
3 | | Games Menu UI for AI Typing Trainer (PySide6).
4 | | Provides access to various typing games and entertainment features.
5 | | """
  | |___^ D205
6 |
7 |   import os
  |
  = help: Insert single blank line

desktop_ui\games_menu.py:2:1: D212 [*] Multi-line docstring summary should start at the first line
  |
1 |   # ruff: noqa: E501
2 | / """
3 | | Games Menu UI for AI Typing Trainer (PySide6).
4 | | Provides access to various typing games and entertainment features.
5 | | """
  | |___^ D212
6 |
7 |   import os
  |
  = help: Remove whitespace after opening quotes

desktop_ui\games_menu.py:18:5: D212 [*] Multi-line docstring summary should start at the first line
   |
17 |   class GamesMenu(QtWidgets.QDialog):
18 | /     """
19 | |     Games Menu UI for AI Typing Trainer.
20 | |     
21 | |     Provides access to various typing games and entertainment features.
22 | |     Uses the same modern styling as the main menu for consistency.
23 | |     """
   | |_______^ D212
24 |
25 |       def __init__(self, parent: Optional[QtWidgets.QWidget] = None) -> None:
   |
   = help: Remove whitespace after opening quotes

desktop_ui\games_menu.py:25:9: D107 Missing docstring in `__init__`
   |
23 |     """
24 |
25 |     def __init__(self, parent: Optional[QtWidgets.QWidget] = None) -> None:
   |         ^^^^^^^^ D107
26 |         super().__init__(parent)
27 |         self.setWindowTitle("Games Menu - AI Typing Trainer")
   |

desktop_ui\graphql_client.py:1:1: D205 1 blank line required between summary line and description
  |
1 | / """
2 | | GraphQL client for PySide6 desktop UI.
3 | | Handles queries and mutations to /api/library_graphql.
4 | | """
  | |___^ D205
5 |
6 |   from typing import Any, Dict, Optional
  |
  = help: Insert single blank line

desktop_ui\graphql_client.py:1:1: D212 [*] Multi-line docstring summary should start at the first line
  |
1 | / """
2 | | GraphQL client for PySide6 desktop UI.
3 | | Handles queries and mutations to /api/library_graphql.
4 | | """
  | |___^ D212
5 |
6 |   from typing import Any, Dict, Optional
  |
  = help: Remove whitespace after opening quotes

desktop_ui\graphql_client.py:13:7: D101 Missing docstring in public class
   |
13 | class GraphQLClient:
   |       ^^^^^^^^^^^^^ D101
14 |     def __init__(self, api_url: str = API_URL):
15 |         self.api_url = api_url
   |

desktop_ui\graphql_client.py:14:9: ANN204 Missing return type annotation for special method `__init__`
   |
13 | class GraphQLClient:
14 |     def __init__(self, api_url: str = API_URL):
   |         ^^^^^^^^ ANN204
15 |         self.api_url = api_url
   |
   = help: Add return type annotation: `None`

desktop_ui\graphql_client.py:14:9: D107 Missing docstring in `__init__`
   |
13 | class GraphQLClient:
14 |     def __init__(self, api_url: str = API_URL):
   |         ^^^^^^^^ D107
15 |         self.api_url = api_url
   |

desktop_ui\graphql_client.py:17:9: D102 Missing docstring in public method
   |
15 |         self.api_url = api_url
16 |
17 |     def query(
   |         ^^^^^ D102
18 |         self, query: str, variables: Optional[Dict[str, Any]] = None
19 |     ) -> Dict[str, Any]:
   |

desktop_ui\library_main.py:1:1: D205 1 blank line required between summary line and description
  |
1 | / """PySide6 Desktop UI for the Snippets Library
2 | | - Fullscreen main window, maximized dialogs
3 | | - Category and snippet management with validation and error dialogs
4 | | - Direct integration with the model layer (no GraphQL)
5 | | """
  | |___^ D205
6 |
7 |   import os
  |
  = help: Insert single blank line

desktop_ui\library_main.py:1:1: D415 First line should end with a period, question mark, or exclamation point
  |
1 | / """PySide6 Desktop UI for the Snippets Library
2 | | - Fullscreen main window, maximized dialogs
3 | | - Category and snippet management with validation and error dialogs
4 | | - Direct integration with the model layer (no GraphQL)
5 | | """
  | |___^ D415
6 |
7 |   import os
  |
  = help: Add closing punctuation

desktop_ui\library_main.py:40:5: D205 1 blank line required between summary line and description
   |
39 |   class LibraryMainWindow(QMainWindow):
40 | /     """
41 | |     Modern Windows 11-style Snippets Library main window (PyQt5).
42 | |     Implements all category and snippet management features as per Library.md spec.
43 | |     """
   | |_______^ D205
44 |
45 |       def __init__(
   |
   = help: Insert single blank line

desktop_ui\library_main.py:40:5: D212 [*] Multi-line docstring summary should start at the first line
   |
39 |   class LibraryMainWindow(QMainWindow):
40 | /     """
41 | |     Modern Windows 11-style Snippets Library main window (PyQt5).
42 | |     Implements all category and snippet management features as per Library.md spec.
43 | |     """
   | |_______^ D212
44 |
45 |       def __init__(
   |
   = help: Remove whitespace after opening quotes

desktop_ui\library_main.py:48:9: D205 1 blank line required between summary line and description
   |
46 |           self, db_manager: Optional[DatabaseManager] = None, testing_mode: bool = False
47 |       ) -> None:
48 | /         """
49 | |         Initialize the LibraryMainWindow.
50 | |         :param db_manager: Optional DatabaseManager instance to use (for testability/
51 | |             singleton connection)
52 | |         :param testing_mode: If True, suppress modal dialogs for automated testing.
53 | |         """
   | |___________^ D205
54 |           super().__init__()
55 |           self.testing_mode = testing_mode
   |
   = help: Insert single blank line

desktop_ui\library_main.py:48:9: D212 [*] Multi-line docstring summary should start at the first line
   |
46 |           self, db_manager: Optional[DatabaseManager] = None, testing_mode: bool = False
47 |       ) -> None:
48 | /         """
49 | |         Initialize the LibraryMainWindow.
50 | |         :param db_manager: Optional DatabaseManager instance to use (for testability/
51 | |             singleton connection)
52 | |         :param testing_mode: If True, suppress modal dialogs for automated testing.
53 | |         """
   | |___________^ D212
54 |           super().__init__()
55 |           self.testing_mode = testing_mode
   |
   = help: Remove whitespace after opening quotes

desktop_ui\library_main.py:200:9: D102 Missing docstring in public method
    |
198 |             self.show_error(f"Error loading data: {e}")
199 |
200 |     def show_error(self, msg: str) -> None:
    |         ^^^^^^^^^^ D102
201 |         if self.testing_mode:
202 |             print(f"ERROR: {msg}")
    |

desktop_ui\library_main.py:207:9: D102 Missing docstring in public method
    |
205 |         self.status.setText(msg)
206 |
207 |     def show_info(self, msg: str) -> None:
    |         ^^^^^^^^^ D102
208 |         if self.testing_mode:
209 |             print(f"INFO: {msg}")
    |

desktop_ui\library_main.py:214:9: D102 Missing docstring in public method
    |
212 |         self.status.setText(msg)
213 |
214 |     def filter_snippets(self, search_text: str) -> None:
    |         ^^^^^^^^^^^^^^^ D102
215 |         if not self.selected_category:
216 |             self.snippetList.clear()
    |

desktop_ui\library_main.py:228:9: D102 Missing docstring in public method
    |
226 |             self.snippetList.addItem(item)
227 |
228 |     def refresh_categories(self) -> None:
    |         ^^^^^^^^^^^^^^^^^^ D102
229 |         self.categoryList.clear()
230 |         for cat in self.categories:
    |

desktop_ui\library_main.py:235:9: D102 Missing docstring in public method
    |
233 |             self.categoryList.addItem(item)
234 |
235 |     def on_category_selection_changed(self) -> None:
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
236 |         items = self.categoryList.selectedItems()
237 |         if not items:
    |

desktop_ui\library_main.py:248:9: D102 Missing docstring in public method
    |
246 |         self.update_snippet_buttons_state(True)
247 |
248 |     def update_snippet_buttons_state(self, enabled: bool) -> None:
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
249 |         self.addSnipBtn.setEnabled(enabled)
250 |         self.editSnipBtn.setEnabled(enabled)
    |

desktop_ui\library_main.py:253:9: D102 Missing docstring in public method
    |
251 |         self.delSnipBtn.setEnabled(enabled)
252 |
253 |     def on_snippet_selection_changed(self, item: QListWidgetItem) -> None:
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
254 |         snippet: Optional[Snippet] = item.data(Qt.ItemDataRole.UserRole)
255 |         self.selected_snippet = snippet
    |

desktop_ui\library_main.py:258:9: D102 Missing docstring in public method
    |
256 |         # No auto-view on click; only on double-click
257 |
258 |     def load_snippets(self) -> None:
    |         ^^^^^^^^^^^^^ D102
259 |         self.snippetList.clear()
260 |         if not self.selected_category:
    |

desktop_ui\library_main.py:273:9: D102 Missing docstring in public method
    |
271 |             self.show_error(f"Error loading snippets: {e}")
272 |
273 |     def add_category(self) -> None:
    |         ^^^^^^^^^^^^ D102
274 |         dlg = CategoryDialog("Add Category", "Category Name", parent=self)
275 |         if dlg.exec_() == QtWidgets.QDialog.DialogCode.Accepted:
    |

desktop_ui\library_main.py:286:9: D102 Missing docstring in public method
    |
284 |                 self.show_error(f"Failed to add category: {e}")
285 |
286 |     def edit_category(self) -> None:
    |         ^^^^^^^^^^^^^ D102
287 |         items = self.categoryList.selectedItems()
288 |         if not items:
    |

desktop_ui\library_main.py:306:9: D102 Missing docstring in public method
    |
304 |                 self.show_error(f"Failed to update category: {e}")
305 |
306 |     def delete_category(self) -> None:
    |         ^^^^^^^^^^^^^^^ D102
307 |         items = self.categoryList.selectedItems()
308 |         if not items:
    |

desktop_ui\library_main.py:329:9: D102 Missing docstring in public method
    |
327 |             self.show_error(f"Failed to delete category: {e}")
328 |
329 |     def add_snippet(self) -> None:
    |         ^^^^^^^^^^^ D102
330 |         if not self.selected_category:
331 |             self.show_error("No category selected.")
    |

desktop_ui\library_main.py:347:9: D102 Missing docstring in public method
    |
345 |                 self.show_error(f"Failed to add snippet: {e}")
346 |
347 |     def edit_snippet(self) -> None:
    |         ^^^^^^^^^^^^ D102
348 |         items = self.snippetList.selectedItems()
349 |         if not items:
    |

desktop_ui\library_main.py:372:9: D102 Missing docstring in public method
    |
370 |                 self.show_error(f"Failed to update snippet: {e}")
371 |
372 |     def delete_snippet(self) -> None:
    |         ^^^^^^^^^^^^^^ D102
373 |         items = self.snippetList.selectedItems()
374 |         if not items:
    |

desktop_ui\library_main.py:393:9: D102 Missing docstring in public method
    |
391 |             self.show_error(f"Failed to delete snippet: {e}")
392 |
393 |     def view_snippet(self, item: QListWidgetItem) -> None:
    |         ^^^^^^^^^^^^ D102
394 |         snippet: Optional[Snippet] = item.data(Qt.ItemDataRole.UserRole)
395 |         if snippet:
    |

desktop_ui\library_main.py:406:5: D205 1 blank line required between summary line and description
    |
405 |   def _modern_qss() -> str:
406 | /     """Return QSS for a modern Windows 11 look (rounded corners, subtle shadows,
407 | |     modern palette)."""
    | |_______________________^ D205
408 |       return """
409 |       QWidget {
    |
    = help: Insert single blank line

desktop_ui\library_main.py:406:5: D209 [*] Multi-line docstring closing quotes should be on a separate line
    |
405 |   def _modern_qss() -> str:
406 | /     """Return QSS for a modern Windows 11 look (rounded corners, subtle shadows,
407 | |     modern palette)."""
    | |_______________________^ D209
408 |       return """
409 |       QWidget {
    |
    = help: Move closing quotes to new line

desktop_ui\main_menu.py:1:1: D100 Missing docstring in public module
desktop_ui\main_menu.py:25:5: D212 [*] Multi-line docstring summary should start at the first line
   |
24 |   class MainMenu(QtWidgets.QWidget):
25 | /     """
26 | |     Modern Main Menu UI for AI Typing Trainer (PySide6).
27 | |
28 | |     - Uses Fusion style, Segoe UI font, and modern color palette
29 | |     - Initiates a single DatabaseManager connection to typing_data.db
30 | |     - Passes the open database connection to the Library window
31 | |     - Testable: supports dependency injection and testing_mode
32 | |     """
   | |_______^ D212
33 |
34 |       def __init__(
   |
   = help: Remove whitespace after opening quotes

desktop_ui\main_menu.py:34:9: D107 Missing docstring in `__init__`
   |
32 |     """
33 |
34 |     def __init__(
   |         ^^^^^^^^ D107
35 |         self,
36 |         db_path: Optional[str] = None,
   |

desktop_ui\main_menu.py:77:9: D102 Missing docstring in public method
   |
75 |         self.setup_ui()
76 |
77 |     def center_on_screen(self) -> None:
   |         ^^^^^^^^^^^^^^^^ D102
78 |         screen = QtWidgets.QApplication.primaryScreen()
79 |         if screen is not None:
   |

desktop_ui\main_menu.py:86:9: D102 Missing docstring in public method
   |
84 |             self.move(x, y)
85 |
86 |     def setup_ui(self) -> None:
   |         ^^^^^^^^ D102
87 |         layout = QtWidgets.QVBoxLayout()
88 |         header = QtWidgets.QLabel("AI Typing Trainer")
   |

desktop_ui\main_menu.py:127:9: D102 Missing docstring in public method
    |
125 |         self.setLayout(layout)
126 |
127 |     def button_stylesheet(self, normal: bool = True) -> str:
    |         ^^^^^^^^^^^^^^^^^ D102
128 |         if normal:
129 |             return (
    |

desktop_ui\main_menu.py:140:9: D102 Missing docstring in public method
    |
138 |             )
139 |
140 |     def eventFilter(self, obj: QtCore.QObject, event: QtCore.QEvent) -> bool:
    |         ^^^^^^^^^^^ D102
141 |         if isinstance(obj, QtWidgets.QPushButton):
142 |             if event.type() == QtCore.QEvent.Type.Enter:
    |

desktop_ui\main_menu.py:150:9: D200 One-line docstring should fit on one line
    |
148 |       # Placeholder slots for button actions
149 |       def open_library(self) -> None:
150 | /         """
151 | |         Open the Snippets Library main window, passing the existing DatabaseManager.
152 | |         """
    | |___________^ D200
153 |           try:
154 |               from desktop_ui.library_main import LibraryMainWindow
    |
    = help: Reformat to one line

desktop_ui\main_menu.py:150:9: D212 [*] Multi-line docstring summary should start at the first line
    |
148 |       # Placeholder slots for button actions
149 |       def open_library(self) -> None:
150 | /         """
151 | |         Open the Snippets Library main window, passing the existing DatabaseManager.
152 | |         """
    | |___________^ D212
153 |           try:
154 |               from desktop_ui.library_main import LibraryMainWindow
    |
    = help: Remove whitespace after opening quotes

desktop_ui\main_menu.py:170:9: D200 One-line docstring should fit on one line
    |
169 |       def setup_user_keyboard_selection(self, parent_layout: QtWidgets.QLayout) -> None:
170 | /         """
171 | |         Set up the user and keyboard selection widgets.
172 | |         """
    | |___________^ D200
173 |           # User selection
174 |           user_group = QtWidgets.QGroupBox("User & Keyboard Selection")
    |
    = help: Reformat to one line

desktop_ui\main_menu.py:170:9: D212 [*] Multi-line docstring summary should start at the first line
    |
169 |       def setup_user_keyboard_selection(self, parent_layout: QtWidgets.QLayout) -> None:
170 | /         """
171 | |         Set up the user and keyboard selection widgets.
172 | |         """
    | |___________^ D212
173 |           # User selection
174 |           user_group = QtWidgets.QGroupBox("User & Keyboard Selection")
    |
    = help: Remove whitespace after opening quotes

desktop_ui\main_menu.py:339:9: D200 One-line docstring should fit on one line
    |
338 |       def configure_drill(self) -> None:
339 | /         """
340 | |         Open the Drill Configuration dialog with the selected user and keyboard.
341 | |         """
    | |___________^ D200
342 |           if not self.current_user or not self.current_user.user_id:
343 |               QtWidgets.QMessageBox.warning(
    |
    = help: Reformat to one line

desktop_ui\main_menu.py:339:9: D212 [*] Multi-line docstring summary should start at the first line
    |
338 |       def configure_drill(self) -> None:
339 | /         """
340 | |         Open the Drill Configuration dialog with the selected user and keyboard.
341 | |         """
    | |___________^ D212
342 |           if not self.current_user or not self.current_user.user_id:
343 |               QtWidgets.QMessageBox.warning(
    |
    = help: Remove whitespace after opening quotes

desktop_ui\main_menu.py:405:9: D200 One-line docstring should fit on one line
    |
404 |       def open_games_menu(self) -> None:
405 | /         """
406 | |         Open the Games Menu dialog.
407 | |         """
    | |___________^ D200
408 |           try:
409 |               from desktop_ui.games_menu import GamesMenu
    |
    = help: Reformat to one line

desktop_ui\main_menu.py:405:9: D212 [*] Multi-line docstring summary should start at the first line
    |
404 |       def open_games_menu(self) -> None:
405 | /         """
406 | |         Open the Games Menu dialog.
407 | |         """
    | |___________^ D212
408 |           try:
409 |               from desktop_ui.games_menu import GamesMenu
    |
    = help: Remove whitespace after opening quotes

desktop_ui\main_menu.py:422:9: D102 Missing docstring in public method
    |
420 |             )
421 |
422 |     def view_progress(self) -> None:
    |         ^^^^^^^^^^^^^ D102
423 |         QtWidgets.QMessageBox.information(
424 |             self, "Progress", "View Progress Over Time - Not yet implemented."
    |

desktop_ui\main_menu.py:428:9: D200 One-line docstring should fit on one line
    |
427 |       def open_ngram_heatmap(self) -> None:
428 | /         """
429 | |         Open the N-gram Speed Heatmap screen with the selected user and keyboard.
430 | |         """
    | |___________^ D200
431 |           if not self.current_user or not self.current_user.user_id:
432 |               QtWidgets.QMessageBox.warning(
    |
    = help: Reformat to one line

desktop_ui\main_menu.py:428:9: D212 [*] Multi-line docstring summary should start at the first line
    |
427 |       def open_ngram_heatmap(self) -> None:
428 | /         """
429 | |         Open the N-gram Speed Heatmap screen with the selected user and keyboard.
430 | |         """
    | |___________^ D212
431 |           if not self.current_user or not self.current_user.user_id:
432 |               QtWidgets.QMessageBox.warning(
    |
    = help: Remove whitespace after opening quotes

desktop_ui\main_menu.py:468:9: D200 One-line docstring should fit on one line
    |
467 |       def data_management(self) -> None:
468 | /         """
469 | |         Open the Data Cleanup and Management dialog.
470 | |         """
    | |___________^ D200
471 |           try:
472 |               from desktop_ui.cleanup_data_dialog import CleanupDataDialog
    |
    = help: Reformat to one line

desktop_ui\main_menu.py:468:9: D212 [*] Multi-line docstring summary should start at the first line
    |
467 |       def data_management(self) -> None:
468 | /         """
469 | |         Open the Data Cleanup and Management dialog.
470 | |         """
    | |___________^ D212
471 |           try:
472 |               from desktop_ui.cleanup_data_dialog import CleanupDataDialog
    |
    = help: Remove whitespace after opening quotes

desktop_ui\main_menu.py:487:9: D205 1 blank line required between summary line and description
    |
486 |       def reset_sessions(self) -> None:
487 | /         """
488 | |         Reset all session data after user confirmation.
489 | |         The following tables will be cleared:
490 | |         - practice_sessions
491 | |         - session_keystrokes
492 | |         - session_ngram_speed
493 | |         - session_ngram_errors
494 | |         """
    | |___________^ D205
495 |           # Create confirmation dialog
496 |           confirm = QtWidgets.QMessageBox.question(
    |
    = help: Insert single blank line

desktop_ui\main_menu.py:487:9: D212 [*] Multi-line docstring summary should start at the first line
    |
486 |       def reset_sessions(self) -> None:
487 | /         """
488 | |         Reset all session data after user confirmation.
489 | |         The following tables will be cleared:
490 | |         - practice_sessions
491 | |         - session_keystrokes
492 | |         - session_ngram_speed
493 | |         - session_ngram_errors
494 | |         """
    | |___________^ D212
495 |           # Create confirmation dialog
496 |           confirm = QtWidgets.QMessageBox.question(
    |
    = help: Remove whitespace after opening quotes

desktop_ui\main_menu.py:487:9: D415 First line should end with a period, question mark, or exclamation point
    |
486 |       def reset_sessions(self) -> None:
487 | /         """
488 | |         Reset all session data after user confirmation.
489 | |         The following tables will be cleared:
490 | |         - practice_sessions
491 | |         - session_keystrokes
492 | |         - session_ngram_speed
493 | |         - session_ngram_errors
494 | |         """
    | |___________^ D415
495 |           # Create confirmation dialog
496 |           confirm = QtWidgets.QMessageBox.question(
    |
    = help: Add closing punctuation

desktop_ui\main_menu.py:526:9: D200 One-line docstring should fit on one line
    |
525 |       def open_db_content_viewer(self) -> None:
526 | /         """
527 | |         Open the Database Viewer dialog, using the DatabaseViewerService.
528 | |         """
    | |___________^ D200
529 |           try:
530 |               from desktop_ui.db_viewer_dialog import DatabaseViewerDialog
    |
    = help: Reformat to one line

desktop_ui\main_menu.py:526:9: D212 [*] Multi-line docstring summary should start at the first line
    |
525 |       def open_db_content_viewer(self) -> None:
526 | /         """
527 | |         Open the Database Viewer dialog, using the DatabaseViewerService.
528 | |         """
    | |___________^ D212
529 |           try:
530 |               from desktop_ui.db_viewer_dialog import DatabaseViewerDialog
    |
    = help: Remove whitespace after opening quotes

desktop_ui\main_menu.py:549:9: D200 One-line docstring should fit on one line
    |
548 |       def open_sql_query_screen(self) -> None:
549 | /         """
550 | |         Open the SQL Query Screen dialog, passing user_id and keyboard_id.
551 | |         """
    | |___________^ D200
552 |           try:
553 |               from desktop_ui.query_screen import QueryScreen
    |
    = help: Reformat to one line

desktop_ui\main_menu.py:549:9: D212 [*] Multi-line docstring summary should start at the first line
    |
548 |       def open_sql_query_screen(self) -> None:
549 | /         """
550 | |         Open the SQL Query Screen dialog, passing user_id and keyboard_id.
551 | |         """
    | |___________^ D212
552 |           try:
553 |               from desktop_ui.query_screen import QueryScreen
    |
    = help: Remove whitespace after opening quotes

desktop_ui\metroid_typing_game.py:2:1: D205 1 blank line required between summary line and description
  |
1 |   # ruff: noqa: E501
2 | / """
3 | | Metroid-style Typing Game for AI Typing Trainer (PySide6).
4 | | Words float in from edges toward center, user types to destroy them.
5 | | Features exponential scoring and orange highlighting for matching words.
6 | | """
  | |___^ D205
7 |
8 |   import math
  |
  = help: Insert single blank line

desktop_ui\metroid_typing_game.py:2:1: D212 [*] Multi-line docstring summary should start at the first line
  |
1 |   # ruff: noqa: E501
2 | / """
3 | | Metroid-style Typing Game for AI Typing Trainer (PySide6).
4 | | Words float in from edges toward center, user types to destroy them.
5 | | Features exponential scoring and orange highlighting for matching words.
6 | | """
  | |___^ D212
7 |
8 |   import math
  |
  = help: Remove whitespace after opening quotes

desktop_ui\metroid_typing_game.py:19:9: D107 Missing docstring in `__init__`
   |
17 |     """Represents a word floating toward the center of the screen."""
18 |     
19 |     def __init__(self, text: str, start_x: float, start_y: float, target_x: float, target_y: float, is_bonus: bool = False) -> None:
   |         ^^^^^^^^ D107
20 |         self.text = text
21 |         self.original_text = text
   |

desktop_ui\metroid_typing_game.py:90:5: D205 1 blank line required between summary line and description
   |
89 |   class MetroidTypingGame(QtWidgets.QDialog):
90 | /     """
91 | |     Metroid-style typing game where words float in from edges toward center.
92 | |     Features exponential scoring and real-time highlighting.
93 | |     """
   | |_______^ D205
94 |
95 |       def __init__(self, parent: Optional[QtWidgets.QWidget] = None, word_list: Optional[List[str]] = None) -> None:
   |
   = help: Insert single blank line

desktop_ui\metroid_typing_game.py:90:5: D212 [*] Multi-line docstring summary should start at the first line
   |
89 |   class MetroidTypingGame(QtWidgets.QDialog):
90 | /     """
91 | |     Metroid-style typing game where words float in from edges toward center.
92 | |     Features exponential scoring and real-time highlighting.
93 | |     """
   | |_______^ D212
94 |
95 |       def __init__(self, parent: Optional[QtWidgets.QWidget] = None, word_list: Optional[List[str]] = None) -> None:
   |
   = help: Remove whitespace after opening quotes

desktop_ui\metroid_typing_game.py:95:9: D107 Missing docstring in `__init__`
   |
93 |     """
94 |
95 |     def __init__(self, parent: Optional[QtWidgets.QWidget] = None, word_list: Optional[List[str]] = None) -> None:
   |         ^^^^^^^^ D107
96 |         super().__init__(parent)
97 |         self.setWindowTitle("Metroid Typing Game - AI Typing Trainer")
   |

desktop_ui\modern_dialogs.py:1:1: D205 1 blank line required between summary line and description
  |
1 | / """
2 | | Modern Windows 11-style dialogs for the Snippets Library desktop UI.
3 | | Includes: CategoryDialog, SnippetDialog (with multi-line editing), ConfirmDialog.
4 | | """
  | |___^ D205
5 |
6 |   from typing import Optional
  |
  = help: Insert single blank line

desktop_ui\modern_dialogs.py:1:1: D212 [*] Multi-line docstring summary should start at the first line
  |
1 | / """
2 | | Modern Windows 11-style dialogs for the Snippets Library desktop UI.
3 | | Includes: CategoryDialog, SnippetDialog (with multi-line editing), ConfirmDialog.
4 | | """
  | |___^ D212
5 |
6 |   from typing import Optional
  |
  = help: Remove whitespace after opening quotes

desktop_ui\modern_dialogs.py:34:7: D101 Missing docstring in public class
   |
34 | class CategoryDialog(QDialog):
   |       ^^^^^^^^^^^^^^ D101
35 |     def __init__(
36 |         self: "CategoryDialog",
   |

desktop_ui\modern_dialogs.py:35:9: D107 Missing docstring in `__init__`
   |
34 | class CategoryDialog(QDialog):
35 |     def __init__(
   |         ^^^^^^^^ D107
36 |         self: "CategoryDialog",
37 |         title: str,
   |

desktop_ui\modern_dialogs.py:67:9: D102 Missing docstring in public method
   |
65 |         self.input.returnPressed.connect(self.accept)
66 |
67 |     def get_value(self) -> str:
   |         ^^^^^^^^^ D102
68 |         return self.input.text().strip()
   |

desktop_ui\modern_dialogs.py:71:7: D101 Missing docstring in public class
   |
71 | class SnippetDialog(QDialog):
   |       ^^^^^^^^^^^^^ D101
72 |     def __init__(
73 |         self: "SnippetDialog",
   |

desktop_ui\modern_dialogs.py:72:9: D107 Missing docstring in `__init__`
   |
71 | class SnippetDialog(QDialog):
72 |     def __init__(
   |         ^^^^^^^^ D107
73 |         self: "SnippetDialog",
74 |         title: str,
   |

desktop_ui\modern_dialogs.py:112:9: D102 Missing docstring in public method
    |
110 |         self.name_input.returnPressed.connect(self.accept)
111 |
112 |     def get_values(self) -> tuple[str, str]:
    |         ^^^^^^^^^^ D102
113 |         name = remove_non_ascii(self.name_input.text().strip())
114 |         content = remove_non_ascii(self.content_input.toPlainText().strip())
    |

desktop_ui\ngram_heatmap_screen.py:1:1: D212 [*] Multi-line docstring summary should start at the first line
  |
1 | / """
2 | | NGram Speed Heatmap UI Screen.
3 | |
4 | | This module provides a desktop UI for visualizing n-gram typing speed performance
5 | | using a heatmap with filtering, sorting, and color coding capabilities.
6 | | """
  | |___^ D212
7 |
8 |   import os
  |
  = help: Remove whitespace after opening quotes

desktop_ui\ngram_heatmap_screen.py:25:5: D212 [*] Multi-line docstring summary should start at the first line
   |
24 |   class NGramHeatmapDialog(QtWidgets.QDialog):
25 | /     """
26 | |     N-gram Speed Heatmap visualization screen.
27 | |
28 | |     Features:
29 | |     - Interactive heatmap showing n-gram typing speeds
30 | |     - Color-coded performance indicators
31 | |     - Filtering by n-gram size, speed ranges, and performance levels
32 | |     - Sorting options for different metrics
33 | |     - Export functionality for analysis data
34 | |     """
   | |_______^ D212
35 |
36 |       def __init__(
   |
   = help: Remove whitespace after opening quotes

desktop_ui\ngram_heatmap_screen.py:43:9: D212 [*] Multi-line docstring summary should start at the first line
   |
41 |           parent: Optional[QtWidgets.QWidget] = None,
42 |       ) -> None:
43 | /         """
44 | |         Initialize the NGram Heatmap Dialog.
45 | |
46 | |         Args:
47 | |             db_manager: Database manager instance
48 | |             user: Current user
49 | |             keyboard: Current keyboard
50 | |             parent: Parent widget (optional)
51 | |         """
   | |___________^ D212
52 |           super().__init__(parent)
53 |           self.db_manager = db_manager
   |
   = help: Remove whitespace after opening quotes

desktop_ui\ngram_heatmap_screen.py:276:9: F841 Local variable `min_speed` is assigned to but never used
    |
275 |         # Get filter values
276 |         min_speed = self.speed_min_spin.value()
    |         ^^^^^^^^^ F841
277 |         max_speed = self.speed_max_spin.value()
278 |         ngram_size = self.ngram_size_combo.currentData()
    |
    = help: Remove assignment to unused variable `min_speed`

desktop_ui\ngram_heatmap_screen.py:277:9: F841 Local variable `max_speed` is assigned to but never used
    |
275 |         # Get filter values
276 |         min_speed = self.speed_min_spin.value()
277 |         max_speed = self.speed_max_spin.value()
    |         ^^^^^^^^^ F841
278 |         ngram_size = self.ngram_size_combo.currentData()
    |
    = help: Remove assignment to unused variable `max_speed`

desktop_ui\ngram_heatmap_screen.py:278:9: F841 Local variable `ngram_size` is assigned to but never used
    |
276 |         min_speed = self.speed_min_spin.value()
277 |         max_speed = self.speed_max_spin.value()
278 |         ngram_size = self.ngram_size_combo.currentData()
    |         ^^^^^^^^^^ F841
279 |
280 |         # Update display
    |
    = help: Remove assignment to unused variable `ngram_size`

desktop_ui\ngram_llm_screen.py:1:1: D100 Missing docstring in public module
desktop_ui\ngram_llm_screen.py:21:7: D101 Missing docstring in public class
   |
21 | class NgramLLMScreen(QWidget):
   |       ^^^^^^^^^^^^^^ D101
22 |     def __init__(self, parent: Optional[Any] = None) -> None:
23 |         super().__init__(parent)
   |

desktop_ui\ngram_llm_screen.py:22:9: D107 Missing docstring in `__init__`
   |
21 | class NgramLLMScreen(QWidget):
22 |     def __init__(self, parent: Optional[Any] = None) -> None:
   |         ^^^^^^^^ D107
23 |         super().__init__(parent)
24 |         self.setWindowTitle("LLM N-Gram Word Generator")
   |

desktop_ui\ngram_llm_screen.py:22:32: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `parent`
   |
21 | class NgramLLMScreen(QWidget):
22 |     def __init__(self, parent: Optional[Any] = None) -> None:
   |                                ^^^^^^^^^^^^^ ANN401
23 |         super().__init__(parent)
24 |         self.setWindowTitle("LLM N-Gram Word Generator")
   |

desktop_ui\ngram_llm_screen.py:63:9: D102 Missing docstring in public method
   |
61 |         self.init_ui()
62 |
63 |     def init_ui(self) -> None:
   |         ^^^^^^^ D102
64 |         layout = QVBoxLayout()
   |

desktop_ui\ngram_llm_screen.py:92:9: D102 Missing docstring in public method
   |
90 |         self.setLayout(layout)
91 |
92 |     def add_snippet_input(self) -> None:
   |         ^^^^^^^^^^^^^^^^^ D102
93 |         hbox = QHBoxLayout()
94 |         line_edit = QLineEdit()
   |

desktop_ui\ngram_llm_screen.py:104:9: D102 Missing docstring in public method
    |
102 |         self.snippet_inputs.append(line_edit)
103 |
104 |     def remove_snippet_input(self, hbox: QHBoxLayout, line_edit: QLineEdit) -> None:
    |         ^^^^^^^^^^^^^^^^^^^^ D102
105 |         # Remove from layout and list
106 |         for i in reversed(range(hbox.count())):
    |

desktop_ui\ngram_llm_screen.py:115:9: D102 Missing docstring in public method
    |
113 |             self.snippet_inputs.remove(line_edit)
114 |
115 |     def call_llm(self) -> None:
    |         ^^^^^^^^ D102
116 |         if not self.service:
117 |             QMessageBox.critical(self, "Service Error", "LLM service not available.")
    |

desktop_ui\query_screen.py:1:1: D212 [*] Multi-line docstring summary should start at the first line
  |
1 | / """
2 | | SQL Query Screen for AI Typing Trainer (PySide6)
3 | |
4 | | This module provides a GUI for executing custom SQL queries on the database and viewing results.
5 | | """
  | |___^ D212
6 |
7 |   from typing import Any, Dict, List, Optional
  |
  = help: Remove whitespace after opening quotes

desktop_ui\query_screen.py:1:1: D415 First line should end with a period, question mark, or exclamation point
  |
1 | / """
2 | | SQL Query Screen for AI Typing Trainer (PySide6)
3 | |
4 | | This module provides a GUI for executing custom SQL queries on the database and viewing results.
5 | | """
  | |___^ D415
6 |
7 |   from typing import Any, Dict, List, Optional
  |
  = help: Add closing punctuation

desktop_ui\query_screen.py:7:1: I001 [*] Import block is un-sorted or un-formatted
   |
 5 |   """
 6 |
 7 | / from typing import Any, Dict, List, Optional
 8 | |
 9 | | from PySide6 import QtWidgets
10 | | from PySide6.QtWidgets import (
11 | |     QDialog,
12 | |     QGridLayout,
13 | |     QHBoxLayout,
14 | |     QHeaderView,
15 | |     QLabel,
16 | |     QLineEdit,
17 | |     QMessageBox,
18 | |     QPushButton,
19 | |     QPlainTextEdit,
20 | |     QTableWidget,
21 | |     QTableWidgetItem,
22 | |     QVBoxLayout,
23 | | )
24 | |
25 | | from db.database_manager import DatabaseManager
26 | | from models.session_manager import SessionManager
   | |_________________________________________________^ I001
   |
   = help: Organize imports

desktop_ui\query_screen.py:30:5: D212 [*] Multi-line docstring summary should start at the first line
   |
29 |   class QueryScreen(QDialog):
30 | /     """
31 | |     Dialog for executing custom SQL queries on the database.
32 | |
33 | |     Features:
34 | |     - User and keyboard ID display
35 | |     - SQL query input
36 | |     - Dynamic results grid
37 | |     - Error handling
38 | |
39 | |     Args:
40 | |         db_manager: DatabaseManager instance to execute queries
41 | |         user_id: ID of the current user
42 | |         keyboard_id: ID of the current keyboard
43 | |         parent: Optional parent widget
44 | |     """
   | |_______^ D212
45 |
46 |       def __init__(
   |
   = help: Remove whitespace after opening quotes

desktop_ui\query_screen.py:46:9: D107 Missing docstring in `__init__`
   |
44 |     """
45 |
46 |     def __init__(
   |         ^^^^^^^^ D107
47 |         self,
48 |         db_manager: DatabaseManager,
   |

desktop_ui\query_screen.py:181:9: D212 [*] Multi-line docstring summary should start at the first line
    |
180 |       def _execute_raw_query(self, query: str) -> List[Dict[str, Any]]:
181 | /         """
182 | |         Execute a raw SQL query using the DatabaseManager.
183 | |
184 | |         Args:
185 | |             query: The SQL query to execute
186 | |
187 | |         Returns:
188 | |             A list of dictionaries representing the query results
189 | |         """
    | |___________^ D212
190 |           # Ensure we have a database connection
191 |           if not self.db_manager:
    |
    = help: Remove whitespace after opening quotes

desktop_ui\query_screen.py:207:9: D212 [*] Multi-line docstring summary should start at the first line
    |
206 |       def _populate_results_table(self, results: List[Dict[str, Any]]) -> None:
207 | /         """
208 | |         Populate the results table with query results.
209 | |
210 | |         Args:
211 | |             results: List of dictionaries representing query results
212 | |         """
    | |___________^ D212
213 |           if not results:
214 |               return
    |
    = help: Remove whitespace after opening quotes

desktop_ui\scaffold_add_speed_summary_for_session.py:1:1: D212 [*] Multi-line docstring summary should start at the first line
  |
1 | / """
2 | | ScaffoldAddSpeedSummaryForSession UI form for triggering speed summary for a specific session.
3 | |
4 | | This form provides an interface to run the AddSpeedSummaryForSession method
5 | | from the NGramAnalyticsService for a specific session ID.
6 | | """
  | |___^ D212
7 |
8 |   # Standard library imports
  |
  = help: Remove whitespace after opening quotes

desktop_ui\scaffold_add_speed_summary_for_session.py:43:9: D107 Missing docstring in `__init__`
   |
41 |     error = Signal(str)      # Signal with error message
42 |     
43 |     def __init__(self, analytics_service: NGramAnalyticsService, session_id: str) -> None:
   |         ^^^^^^^^ D107
44 |         super().__init__()
45 |         self.analytics_service = analytics_service
   |

desktop_ui\scaffold_add_speed_summary_for_session.py:48:9: D102 Missing docstring in public method
   |
46 |         self.session_id = session_id
47 |     
48 |     def run(self) -> None:
   |         ^^^ D102
49 |         try:
50 |             result = self.analytics_service.add_speed_summary_for_session(self.session_id)
   |

desktop_ui\scaffold_add_speed_summary_for_session.py:57:5: D212 [*] Multi-line docstring summary should start at the first line
   |
56 |   class ScaffoldAddSpeedSummaryForSession(QWidget):
57 | /     """
58 | |     UI form for triggering speed summary for a specific session.
59 | |     
60 | |     Provides an interface with session ID input and a button to run the 
61 | |     AddSpeedSummaryForSession method and displays progress and results.
62 | |     """
   | |_______^ D212
63 |       
64 |       def __init__(
   |
   = help: Remove whitespace after opening quotes

desktop_ui\scaffold_add_speed_summary_for_session.py:64:9: D107 Missing docstring in `__init__`
   |
62 |     """
63 |     
64 |     def __init__(
   |         ^^^^^^^^ D107
65 |         self,
66 |         db_path: Optional[str] = None,
   |

desktop_ui\scaffold_bulk_insert_performance.py:1:1: D212 [*] Multi-line docstring summary should start at the first line
  |
1 | / """
2 | | ScaffoldBulkInsertPerformance UI form for benchmarking bulk insert strategies on Aurora PostgreSQL.
3 | |
4 | | This screen connects to the cloud database, creates a temporary test table
5 | | `test_bulk_performance`, runs timed inserts (10,000 rows) using several methods,
6 | | then drops the table and shows results.
7 | | """
  | |___^ D212
8 |
9 |   from __future__ import annotations
  |
  = help: Remove whitespace after opening quotes

desktop_ui\scaffold_bulk_insert_performance.py:18:20: F401 [*] `typing.Dict` imported but unused
   |
16 | from dataclasses import dataclass
17 | from datetime import datetime, timezone
18 | from typing import Dict, List, Optional, Tuple
   |                    ^^^^ F401
19 | from uuid import uuid4
   |
   = help: Remove unused import

desktop_ui\scaffold_bulk_insert_performance.py:18:32: F401 [*] `typing.Optional` imported but unused
   |
16 | from dataclasses import dataclass
17 | from datetime import datetime, timezone
18 | from typing import Dict, List, Optional, Tuple
   |                                ^^^^^^^^ F401
19 | from uuid import uuid4
   |
   = help: Remove unused import

desktop_ui\scaffold_bulk_insert_performance.py:40:1: E402 Module level import not at top of file
   |
38 |     sys.path.insert(0, project_root)
39 |
40 | from db.database_manager import BulkMethod, ConnectionType, DatabaseManager
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
   |

desktop_ui\scaffold_bulk_insert_performance.py:44:7: D101 Missing docstring in public class
   |
43 | @dataclass
44 | class TimingResult:
   |       ^^^^^^^^^^^^ D101
45 |     label: str
46 |     rows: int
   |

desktop_ui\scaffold_bulk_insert_performance.py:56:9: D107 Missing docstring in `__init__`
   |
54 |     TABLE_NAME = "test_bulk_performance"
55 |
56 |     def __init__(self, connection_type: ConnectionType = ConnectionType.CLOUD) -> None:
   |         ^^^^^^^^ D107
57 |         super().__init__()
58 |         self.setWindowTitle("Bulk Insert Performance Benchmark")
   |

desktop_ui\scaffold_bulk_insert_performance.py:132:35: ANN001 Missing type annotation for function argument `func`
    |
130 |         return rows
131 |
132 |     def _timeit(self, label: str, func, rows_count: int) -> float:
    |                                   ^^^^ ANN001
133 |         t0 = time.perf_counter()
134 |         func()
    |

desktop_ui\scaffold_bulk_insert_performance.py:154:9: D102 Missing docstring in public method
    |
153 |     # ----------------------- Benchmark actions -----------------------
154 |     def on_run(self) -> None:
    |         ^^^^^^ D102
155 |         self.run_btn.setEnabled(False)
156 |         self._clear_previous()
    |

desktop_ui\scaffold_bulk_insert_performance.py:237:9: D102 Missing docstring in public method
    |
235 |             self.run_btn.setEnabled(True)
236 |
237 |     def closeEvent(self, event: QCloseEvent) -> None:  # noqa: N802 (Qt signature)
    |         ^^^^^^^^^^ D102
238 |         try:
239 |             self.db.close()
    |

desktop_ui\scaffold_bulk_insert_performance.py:245:5: D103 Missing docstring in public function
    |
245 | def launch_scaffold_bulk_insert_performance() -> None:
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D103
246 |     app = QtWidgets.QApplication.instance()
247 |     if app is None:
    |

desktop_ui\scaffold_catchup_speed_summary.py:1:1: D212 [*] Multi-line docstring summary should start at the first line
  |
1 | / """
2 | | ScaffoldCatchupSpeedSummary UI form for triggering speed summary catchup for all sessions.
3 | |
4 | | This form provides an interface to run the CatchupSpeedSummary method
5 | | from the NGramAnalyticsService to process all sessions from oldest to newest.
6 | | """
  | |___^ D212
7 |
8 |   import os
  |
  = help: Remove whitespace after opening quotes

desktop_ui\scaffold_catchup_speed_summary.py:15:1: I001 [*] Import block is un-sorted or un-formatted
   |
13 |   sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), "..")))
14 |
15 | / from PySide6.QtCore import QThread, Signal
16 | | from PySide6.QtGui import QCloseEvent
17 | | from PySide6.QtWidgets import (
18 | |     QApplication,
19 | |     QDialog,
20 | |     QHBoxLayout,
21 | |     QLabel,
22 | |     QMessageBox,
23 | |     QPushButton,
24 | |     QProgressBar,
25 | |     QTextEdit,
26 | |     QVBoxLayout,
27 | | )
28 | |
29 | | from db.database_manager import ConnectionType, DatabaseManager
30 | | from models.ngram_analytics_service import NGramAnalyticsService
31 | | from models.ngram_manager import NGramManager
   | |_____________________________________________^ I001
   |
   = help: Organize imports

desktop_ui\scaffold_catchup_speed_summary.py:42:9: D107 Missing docstring in `__init__`
   |
40 |     session_processed = Signal(str, int, int)  # Signal for individual session progress (session_info, current, total)
41 |
42 |     def __init__(self, analytics_service: NGramAnalyticsService) -> None:
   |         ^^^^^^^^ D107
43 |         super().__init__()
44 |         self.analytics_service = analytics_service
   |

desktop_ui\scaffold_catchup_speed_summary.py:46:9: D102 Missing docstring in public method
   |
44 |         self.analytics_service = analytics_service
45 |
46 |     def run(self) -> None:
   |         ^^^ D102
47 |         try:
48 |             result = self.catchup_speed_summary_with_progress()
   |

desktop_ui\scaffold_catchup_speed_summary.py:128:5: D212 [*] Multi-line docstring summary should start at the first line
    |
127 |   class ScaffoldCatchupSpeedSummary(QDialog):
128 | /     """
129 | |     UI form for triggering speed summary catchup for all sessions.
130 | |
131 | |     Provides an interface with a button to run the CatchupSpeedSummary method
132 | |     and displays progress and results in real-time.
133 | |     """
    | |_______^ D212
134 |
135 |       def __init__(
    |
    = help: Remove whitespace after opening quotes

desktop_ui\scaffold_catchup_speed_summary.py:135:9: D107 Missing docstring in `__init__`
    |
133 |     """
134 |
135 |     def __init__(
    |         ^^^^^^^^ D107
136 |         self, db_path: Optional[str] = None, connection_type: ConnectionType = ConnectionType.CLOUD
137 |     ) -> None:
    |

desktop_ui\scaffold_catchup_speed_summary.py:189:121: E501 Line too long (141 > 120)
    |
187 | ΓÇª
188 | ΓÇª
189 | ΓÇª padding: 12px; font-size: 14px; border-radius: 5px; font-weight: bold; }"
    |                                                       ^^^^^^^^^^^^^^^^^^^^^ E501
190 | ΓÇª
191 | ΓÇª
    |

desktop_ui\scaffold_llm_call.py:1:1: D100 Missing docstring in public module
desktop_ui\scaffold_llm_call.py:34:5: D205 1 blank line required between summary line and description
   |
33 |   class ScaffoldLLMCallDialog(QDialog):
34 | /     """
35 | |     Minimal scaffold to test an LLM call:
36 | |     - One text entry box for the prompt (editable)
37 | |     - One result box where the result content is displayed (read-only)
38 | |
39 | |     It loads the default prompt from Prompts/ngram_words_prompt.txt if available.
40 | |     Uses OPENAI_API_KEY from environment to initialize the service.
41 | |     Calls LLMNgramService.get_words_with_ngrams_2 with sensible defaults.
42 | |     """
   | |_______^ D205
43 |
44 |       def __init__(self, parent: Optional[QWidget] = None) -> None:
   |
   = help: Insert single blank line

desktop_ui\scaffold_llm_call.py:34:5: D212 [*] Multi-line docstring summary should start at the first line
   |
33 |   class ScaffoldLLMCallDialog(QDialog):
34 | /     """
35 | |     Minimal scaffold to test an LLM call:
36 | |     - One text entry box for the prompt (editable)
37 | |     - One result box where the result content is displayed (read-only)
38 | |
39 | |     It loads the default prompt from Prompts/ngram_words_prompt.txt if available.
40 | |     Uses OPENAI_API_KEY from environment to initialize the service.
41 | |     Calls LLMNgramService.get_words_with_ngrams_2 with sensible defaults.
42 | |     """
   | |_______^ D212
43 |
44 |       def __init__(self, parent: Optional[QWidget] = None) -> None:
   |
   = help: Remove whitespace after opening quotes

desktop_ui\scaffold_llm_call.py:34:5: D415 First line should end with a period, question mark, or exclamation point
   |
33 |   class ScaffoldLLMCallDialog(QDialog):
34 | /     """
35 | |     Minimal scaffold to test an LLM call:
36 | |     - One text entry box for the prompt (editable)
37 | |     - One result box where the result content is displayed (read-only)
38 | |
39 | |     It loads the default prompt from Prompts/ngram_words_prompt.txt if available.
40 | |     Uses OPENAI_API_KEY from environment to initialize the service.
41 | |     Calls LLMNgramService.get_words_with_ngrams_2 with sensible defaults.
42 | |     """
   | |_______^ D415
43 |
44 |       def __init__(self, parent: Optional[QWidget] = None) -> None:
   |
   = help: Add closing punctuation

desktop_ui\scaffold_llm_call.py:44:9: D107 Missing docstring in `__init__`
   |
42 |     """
43 |
44 |     def __init__(self, parent: Optional[QWidget] = None) -> None:
   |         ^^^^^^^^ D107
45 |         super().__init__(parent)
46 |         self.setWindowTitle("LLM Call Scaffold")
   |

desktop_ui\scaffold_llm_call.py:171:5: D103 Missing docstring in public function
    |
171 | def open_scaffold_llm_call(parent: Optional[QWidget] = None) -> None:
    |     ^^^^^^^^^^^^^^^^^^^^^^ D103
172 |     dlg = ScaffoldLLMCallDialog(parent)
173 |     # exec() creates a modal dialog by default
    |

desktop_ui\scaffold_recreate_ngram_data.py:1:1: D212 [*] Multi-line docstring summary should start at the first line
  |
1 | / """
2 | | ScaffoldRecreateNgramData UI form for recreating ngram data from session keystrokes.
3 | |
4 | | This form provides an interface to find all practice sessions that don't have
5 | | corresponding ngram data and recreate the ngrams from their keystrokes.
6 | | """
  | |___^ D212
7 |
8 |   # Standard library imports
  |
  = help: Remove whitespace after opening quotes

desktop_ui\scaffold_recreate_ngram_data.py:9:1: I001 [*] Import block is un-sorted or un-formatted
   |
 8 |   # Standard library imports
 9 | / import logging
10 | | import os
11 | | import sys
12 | | from datetime import datetime
13 | | from typing import Dict, List, Optional
14 | | from uuid import UUID
15 | |
16 | | # Third-party imports
17 | | from PySide6.QtCore import QThread, Signal
18 | | from PySide6.QtGui import QCloseEvent
19 | | from PySide6.QtWidgets import (
20 | |     QApplication,
21 | |     QDialog,
22 | |     QGroupBox,
23 | |     QLabel,
24 | |     QMessageBox,
25 | |     QPushButton,
26 | |     QProgressBar,
27 | |     QTextEdit,
28 | |     QVBoxLayout,
29 | | )
   | |_^ I001
30 |
31 |   # Local imports (after sys.path adjustment)
   |
   = help: Organize imports

desktop_ui\scaffold_recreate_ngram_data.py:52:9: D107 Missing docstring in `__init__`
   |
50 |     session_processed = Signal(str, int, int)  # Signal for individual session progress
51 |
52 |     def __init__(self, db_manager: DatabaseManager, ngram_manager: NGramManager) -> None:
   |         ^^^^^^^^ D107
53 |         super().__init__()
54 |         self.db_manager = db_manager
   |

desktop_ui\scaffold_recreate_ngram_data.py:57:9: D102 Missing docstring in public method
   |
55 |         self.ngram_manager = ngram_manager
56 |
57 |     def run(self) -> None:
   |         ^^^ D102
58 |         try:
59 |             result = self.recreate_ngram_data_with_progress()
   |

desktop_ui\scaffold_recreate_ngram_data.py:204:5: D212 [*] Multi-line docstring summary should start at the first line
    |
203 |   class ScaffoldRecreateNgramData(QDialog):
204 | /     """
205 | |     UI form for recreating ngram data from session keystrokes.
206 | |
207 | |     Provides an interface with a button to run the recreate process
208 | |     and displays progress and results in real-time.
209 | |     """
    | |_______^ D212
210 |
211 |       def __init__(
    |
    = help: Remove whitespace after opening quotes

desktop_ui\scaffold_recreate_ngram_data.py:211:9: D107 Missing docstring in `__init__`
    |
209 |     """
210 |
211 |     def __init__(
    |         ^^^^^^^^ D107
212 |         self, db_path: Optional[str] = None, connection_type: ConnectionType = ConnectionType.CLOUD
213 |     ) -> None:
    |

desktop_ui\scaffold_recreate_ngram_data.py:400:9: D102 Missing docstring in public method
    |
398 |         scrollbar.setValue(scrollbar.maximum())
399 |
400 |     def on_recreate_finished(self, result: Dict[str, int]) -> None:
    |         ^^^^^^^^^^^^^^^^^^^^ D102
401 |         self.progress_bar.setValue(100)
402 |         self.recreate_button.setEnabled(True)
    |

desktop_ui\scaffold_summarize_session_ngrams.py:1:1: D212 [*] Multi-line docstring summary should start at the first line
  |
1 | / """
2 | | ScaffoldSummarizeSessionNgrams UI form for triggering session ngram summarization.
3 | |
4 | | This form provides a simple interface to run the SummarizeSessionNgrams method
5 | | from the NGramAnalyticsService.
6 | | """
  | |___^ D212
7 |
8 |   import os
  |
  = help: Remove whitespace after opening quotes

desktop_ui\scaffold_summarize_session_ngrams.py:15:1: I001 [*] Import block is un-sorted or un-formatted
   |
13 |   sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), "..")))
14 |
15 | / from PySide6.QtCore import QThread, Signal
16 | | from PySide6.QtGui import QCloseEvent
17 | | from PySide6.QtWidgets import (
18 | |     QApplication,
19 | |     QDialog,
20 | |     QLabel,
21 | |     QMessageBox,
22 | |     QPushButton,
23 | |     QProgressBar,
24 | |     QTextEdit,
25 | |     QVBoxLayout,
26 | | )
27 | |
28 | | from db.database_manager import ConnectionType, DatabaseManager
29 | | from models.ngram_analytics_service import NGramAnalyticsService
30 | | from models.ngram_manager import NGramManager
   | |_____________________________________________^ I001
   |
   = help: Organize imports

desktop_ui\scaffold_summarize_session_ngrams.py:39:9: D107 Missing docstring in `__init__`
   |
37 |     error = Signal(str)  # Signal with error message
38 |
39 |     def __init__(self, analytics_service: NGramAnalyticsService) -> None:
   |         ^^^^^^^^ D107
40 |         super().__init__()
41 |         self.analytics_service = analytics_service
   |

desktop_ui\scaffold_summarize_session_ngrams.py:43:9: D102 Missing docstring in public method
   |
41 |         self.analytics_service = analytics_service
42 |
43 |     def run(self) -> None:
   |         ^^^ D102
44 |         try:
45 |             result = self.analytics_service.summarize_session_ngrams()
   |

desktop_ui\scaffold_summarize_session_ngrams.py:52:5: D212 [*] Multi-line docstring summary should start at the first line
   |
51 |   class ScaffoldSummarizeSessionNgrams(QDialog):
52 | /     """
53 | |     UI form for triggering session ngram summarization.
54 | |
55 | |     Provides a simple interface with a button to run the SummarizeSessionNgrams method
56 | |     and displays progress and results.
57 | |     """
   | |_______^ D212
58 |
59 |       def __init__(
   |
   = help: Remove whitespace after opening quotes

desktop_ui\scaffold_summarize_session_ngrams.py:59:9: D107 Missing docstring in `__init__`
   |
57 |     """
58 |
59 |     def __init__(
   |         ^^^^^^^^ D107
60 |         self, db_path: Optional[str] = None, connection_type: ConnectionType = ConnectionType.CLOUD
61 |     ) -> None:
   |

desktop_ui\scaffold_summarize_session_ngrams.py:107:121: E501 Line too long (122 > 120)
    |
105 |         self.summarize_button = QPushButton("Summarize Ngrams")
106 |         self.summarize_button.setStyleSheet(
107 |             "QPushButton { background-color: #4CAF50; color: white; padding: 10px; font-size: 14px; border-radius: 5px; }"
    |                                                                                                                         ^^ E501
108 |             "QPushButton:hover { background-color: #45a049; }"
109 |             "QPushButton:disabled { background-color: #cccccc; }"
    |

desktop_ui\snippet_model_tester.py:1:1: D205 1 blank line required between summary line and description
   |
 1 | / """
 2 | | Snippet Model Tester UI
 3 | | ----------------------
 4 | | A simple PySide6-based desktop UI for directly testing the Snippet object model (SnippetModel, SnippetManager).
 5 | |
 6 | | - List all snippets (optionally filter by category)
 7 | | - Add a new snippet
 8 | | - Edit a snippet (name/content/category)
 9 | | - Delete a snippet
10 | | - Show validation and error messages
11 | |
12 | | Bypasses API and service layers; interacts directly with SnippetManager, SnippetModel, and CategoryManager.
13 | |
14 | | Author: Cascade AI
15 | | """
   | |___^ D205
16 |
17 |   import os
   |
   = help: Insert single blank line

desktop_ui\snippet_model_tester.py:1:1: D212 [*] Multi-line docstring summary should start at the first line
   |
 1 | / """
 2 | | Snippet Model Tester UI
 3 | | ----------------------
 4 | | A simple PySide6-based desktop UI for directly testing the Snippet object model (SnippetModel, SnippetManager).
 5 | |
 6 | | - List all snippets (optionally filter by category)
 7 | | - Add a new snippet
 8 | | - Edit a snippet (name/content/category)
 9 | | - Delete a snippet
10 | | - Show validation and error messages
11 | |
12 | | Bypasses API and service layers; interacts directly with SnippetManager, SnippetModel, and CategoryManager.
13 | |
14 | | Author: Cascade AI
15 | | """
   | |___^ D212
16 |
17 |   import os
   |
   = help: Remove whitespace after opening quotes

desktop_ui\snippet_model_tester.py:1:1: D415 First line should end with a period, question mark, or exclamation point
   |
 1 | / """
 2 | | Snippet Model Tester UI
 3 | | ----------------------
 4 | | A simple PySide6-based desktop UI for directly testing the Snippet object model (SnippetModel, SnippetManager).
 5 | |
 6 | | - List all snippets (optionally filter by category)
 7 | | - Add a new snippet
 8 | | - Edit a snippet (name/content/category)
 9 | | - Delete a snippet
10 | | - Show validation and error messages
11 | |
12 | | Bypasses API and service layers; interacts directly with SnippetManager, SnippetModel, and CategoryManager.
13 | |
14 | | Author: Cascade AI
15 | | """
   | |___^ D415
16 |
17 |   import os
   |
   = help: Add closing punctuation

desktop_ui\snippet_model_tester.py:43:5: D200 One-line docstring should fit on one line
   |
42 |   class SnippetModelTester(QWidget):
43 | /     """
44 | |     Simple UI to test SnippetManager CRUD and validation logic.
45 | |     """
   | |_______^ D200
46 |
47 |       def __init__(self) -> None:
   |
   = help: Reformat to one line

desktop_ui\snippet_model_tester.py:43:5: D212 [*] Multi-line docstring summary should start at the first line
   |
42 |   class SnippetModelTester(QWidget):
43 | /     """
44 | |     Simple UI to test SnippetManager CRUD and validation logic.
45 | |     """
   | |_______^ D212
46 |
47 |       def __init__(self) -> None:
   |
   = help: Remove whitespace after opening quotes

desktop_ui\snippet_model_tester.py:47:9: D107 Missing docstring in `__init__`
   |
45 |     """
46 |
47 |     def __init__(self) -> None:
   |         ^^^^^^^^ D107
48 |         super().__init__()
49 |         self.setWindowTitle("Snippet Model Tester")
   |

desktop_ui\snippet_model_tester.py:60:9: D102 Missing docstring in public method
   |
58 |         self.refresh_snippets()
59 |
60 |     def init_ui(self) -> None:
   |         ^^^^^^^ D102
61 |         layout = QVBoxLayout()
   |

desktop_ui\snippet_model_tester.py:96:9: D102 Missing docstring in public method
   |
94 |         self.btn_delete.clicked.connect(self.delete_snippet)
95 |
96 |     def refresh_categories(self) -> None:
   |         ^^^^^^^^^^^^^^^^^^ D102
97 |         self.cat_combo.blockSignals(True)
98 |         self.cat_combo.clear()
   |

desktop_ui\snippet_model_tester.py:111:9: D102 Missing docstring in public method
    |
109 |         self.cat_combo.blockSignals(False)
110 |
111 |     def refresh_snippets(self) -> None:
    |         ^^^^^^^^^^^^^^^^ D102
112 |         self.list_widget.clear()
113 |         try:
    |

desktop_ui\snippet_model_tester.py:119:121: E501 Line too long (147 > 120)
    |
117 | ΓÇª
118 | ΓÇª
119 | ΓÇªp.snippet_name} - {snip.content[:40]}{'...' if len(snip.content)>40 else ''}"
    |                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
120 | ΓÇª
121 | ΓÇª
    |

desktop_ui\snippet_model_tester.py:124:9: D102 Missing docstring in public method
    |
122 |             self.set_status(f"Error loading snippets: {e}")
123 |
124 |     def on_category_filter(self) -> None:
    |         ^^^^^^^^^^^^^^^^^^ D102
125 |         self.refresh_snippets()
    |

desktop_ui\snippet_model_tester.py:127:9: D102 Missing docstring in public method
    |
125 |         self.refresh_snippets()
126 |
127 |     def add_snippet(self) -> None:
    |         ^^^^^^^^^^^ D102
128 |         cats = self.cat_mgr.list_categories()
129 |         if not cats:
    |

desktop_ui\snippet_model_tester.py:156:9: D102 Missing docstring in public method
    |
154 |             self.set_status(f"Error adding snippet: {e}")
155 |
156 |     def get_selected_snippet_id(self) -> Optional[int]:
    |         ^^^^^^^^^^^^^^^^^^^^^^^ D102
157 |         item = self.list_widget.currentItem()
158 |         if not item:
    |

desktop_ui\snippet_model_tester.py:168:9: D102 Missing docstring in public method
    |
166 |             return None
167 |
168 |     def edit_snippet(self) -> None:
    |         ^^^^^^^^^^^^ D102
169 |         snip_id = self.get_selected_snippet_id()
170 |         if snip_id is None:
    |

desktop_ui\snippet_model_tester.py:211:9: D102 Missing docstring in public method
    |
209 |             self.set_status(f"Error updating snippet: {e}")
210 |
211 |     def delete_snippet(self) -> None:
    |         ^^^^^^^^^^^^^^ D102
212 |         snip_id = self.get_selected_snippet_id()
213 |         if snip_id is None:
    |

desktop_ui\snippet_model_tester.py:230:9: D102 Missing docstring in public method
    |
228 |                 self.set_status(f"Error deleting snippet: {e}")
229 |
230 |     def set_status(self, msg: str, error: bool = True) -> None:
    |         ^^^^^^^^^^ D102
231 |         self.status_label.setText(msg)
232 |         if error:
    |

desktop_ui\snippet_model_tester.py:238:5: D103 Missing docstring in public function
    |
238 | def main() -> None:
    |     ^^^^ D103
239 |     app = QApplication(sys.argv)
240 |     tester = SnippetModelTester()
    |

desktop_ui\snippet_scaffold.py:1:1: D205 1 blank line required between summary line and description
  |
1 | / """
2 | | PySide6-based development scaffold for Snippet CRUD.
3 | | This is for development/testing only. Not for production use.
4 | | """
  | |___^ D205
5 |
6 |   from typing import Any
  |
  = help: Insert single blank line

desktop_ui\snippet_scaffold.py:1:1: D212 [*] Multi-line docstring summary should start at the first line
  |
1 | / """
2 | | PySide6-based development scaffold for Snippet CRUD.
3 | | This is for development/testing only. Not for production use.
4 | | """
  | |___^ D212
5 |
6 |   from typing import Any
  |
  = help: Remove whitespace after opening quotes

desktop_ui\snippet_scaffold.py:13:5: D212 [*] Multi-line docstring summary should start at the first line
   |
12 |   class SnippetScaffold(QtWidgets.QMainWindow):
13 | /     """
14 | |     A development scaffold UI for testing snippet management functionality.
15 | |
16 | |     This class provides a simple UI for adding, editing, deleting, and viewing snippets
17 | |     using the snippet_manager. It is intended for development and testing only.
18 | |     """
   | |_______^ D212
19 |
20 |       def __init__(self, snippet_manager: Any) -> None:
   |
   = help: Remove whitespace after opening quotes

desktop_ui\snippet_scaffold.py:20:9: D107 Missing docstring in `__init__`
   |
18 |     """
19 |
20 |     def __init__(self, snippet_manager: Any) -> None:
   |         ^^^^^^^^ D107
21 |         super().__init__()
22 |         self.snippet_manager = snippet_manager
   |

desktop_ui\snippet_scaffold.py:20:41: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `snippet_manager`
   |
18 |     """
19 |
20 |     def __init__(self, snippet_manager: Any) -> None:
   |                                         ^^^ ANN401
21 |         super().__init__()
22 |         self.snippet_manager = snippet_manager
   |

desktop_ui\snippet_scaffold.py:98:9: D205 1 blank line required between summary line and description
    |
 97 |       def refresh_snippets(self) -> None:
 98 | /         """
 99 | |         Refresh the snippet list widget with the latest snippets from the database.
100 | |         All snippets are loaded from category ID 1 (for demo purposes).
101 | |         """
    | |___________^ D205
102 |           self.snippet_list.clear()
103 |           # Display a status message while loading
    |
    = help: Insert single blank line

desktop_ui\snippet_scaffold.py:98:9: D212 [*] Multi-line docstring summary should start at the first line
    |
 97 |       def refresh_snippets(self) -> None:
 98 | /         """
 99 | |         Refresh the snippet list widget with the latest snippets from the database.
100 | |         All snippets are loaded from category ID 1 (for demo purposes).
101 | |         """
    | |___________^ D212
102 |           self.snippet_list.clear()
103 |           # Display a status message while loading
    |
    = help: Remove whitespace after opening quotes

desktop_ui\snippet_scaffold.py:156:9: D205 1 blank line required between summary line and description
    |
155 |       def add_snippet(self) -> None:
156 | /         """
157 | |         Add a new snippet using the values from the input fields.
158 | |         Shows an error message if the operation fails.
159 | |         """
    | |___________^ D205
160 |           name = self.name_input.text().strip()
161 |           content = self.content_input.toPlainText().strip()
    |
    = help: Insert single blank line

desktop_ui\snippet_scaffold.py:156:9: D212 [*] Multi-line docstring summary should start at the first line
    |
155 |       def add_snippet(self) -> None:
156 | /         """
157 | |         Add a new snippet using the values from the input fields.
158 | |         Shows an error message if the operation fails.
159 | |         """
    | |___________^ D212
160 |           name = self.name_input.text().strip()
161 |           content = self.content_input.toPlainText().strip()
    |
    = help: Remove whitespace after opening quotes

desktop_ui\snippet_scaffold.py:194:9: D205 1 blank line required between summary line and description
    |
193 |       def edit_snippet(self) -> None:
194 | /         """
195 | |         Edit the currently selected snippet with values from input fields.
196 | |         Shows an error message if no snippet is selected or the operation fails.
197 | |         """
    | |___________^ D205
198 |           item = self.snippet_list.currentItem()
199 |           if not item:
    |
    = help: Insert single blank line

desktop_ui\snippet_scaffold.py:194:9: D212 [*] Multi-line docstring summary should start at the first line
    |
193 |       def edit_snippet(self) -> None:
194 | /         """
195 | |         Edit the currently selected snippet with values from input fields.
196 | |         Shows an error message if no snippet is selected or the operation fails.
197 | |         """
    | |___________^ D212
198 |           item = self.snippet_list.currentItem()
199 |           if not item:
    |
    = help: Remove whitespace after opening quotes

desktop_ui\snippet_scaffold.py:235:9: D205 1 blank line required between summary line and description
    |
234 |       def delete_snippet(self) -> None:
235 | /         """
236 | |         Delete the currently selected snippet.
237 | |         Shows an error message if no snippet is selected or the operation fails.
238 | |         """
    | |___________^ D205
239 |           item = self.snippet_list.currentItem()
240 |           if not item:
    |
    = help: Insert single blank line

desktop_ui\snippet_scaffold.py:235:9: D212 [*] Multi-line docstring summary should start at the first line
    |
234 |       def delete_snippet(self) -> None:
235 | /         """
236 | |         Delete the currently selected snippet.
237 | |         Shows an error message if no snippet is selected or the operation fails.
238 | |         """
    | |___________^ D212
239 |           item = self.snippet_list.currentItem()
240 |           if not item:
    |
    = help: Remove whitespace after opening quotes

desktop_ui\snippet_scaffold.py:274:9: D212 [*] Multi-line docstring summary should start at the first line
    |
273 |       def load_selected_snippet(self, item: QtWidgets.QListWidgetItem) -> None:
274 | /         """
275 | |         Load the selected snippet into the edit fields for viewing or editing.
276 | |
277 | |         Args:
278 | |             item: The list widget item that was clicked or selected
279 | |         """
    | |___________^ D212
280 |           if not item:
281 |               return
    |
    = help: Remove whitespace after opening quotes

desktop_ui\space_invaders_game.py:2:1: D205 1 blank line required between summary line and description
  |
1 |   # ruff: noqa: E501
2 | / """
3 | | Space Invaders Typing Game - A fun typing game inspired by the classic Space Invaders.
4 | | Words move across the screen in formation, and players type them to destroy them.
5 | | """
  | |___^ D205
6 |
7 |   import random
  |
  = help: Insert single blank line

desktop_ui\space_invaders_game.py:2:1: D212 [*] Multi-line docstring summary should start at the first line
  |
1 |   # ruff: noqa: E501
2 | / """
3 | | Space Invaders Typing Game - A fun typing game inspired by the classic Space Invaders.
4 | | Words move across the screen in formation, and players type them to destroy them.
5 | | """
  | |___^ D212
6 |
7 |   import random
  |
  = help: Remove whitespace after opening quotes

desktop_ui\space_invaders_game.py:7:1: I001 [*] Import block is un-sorted or un-formatted
   |
 5 |   """
 6 |
 7 | / import random
 8 | | from typing import List, Optional
 9 | |
10 | | from PySide6.QtCore import QTimer, Qt
11 | | from PySide6.QtGui import QColor, QFont, QKeyEvent, QPaintEvent, QPainter, QPen
12 | | from PySide6.QtWidgets import QDialog, QLabel, QVBoxLayout, QWidget
   | |___________________________________________________________________^ I001
   |
   = help: Organize imports

desktop_ui\space_invaders_game.py:18:9: D107 Missing docstring in `__init__`
   |
16 |     """Represents a word in the game with position and state."""
17 |     
18 |     def __init__(self, text: str, x: int, y: int) -> None:
   |         ^^^^^^^^ D107
19 |         self.text = text
20 |         self.original_text = text
   |

desktop_ui\space_invaders_game.py:38:9: D200 One-line docstring should fit on one line
   |
37 |       def type_char(self, char: str) -> bool:
38 | /         """
39 | |         Type a character. Returns True if the character was correct.
40 | |         """
   | |___________^ D200
41 |           if self.typed_chars < len(self.text) and self.text[self.typed_chars].lower() == char.lower():
42 |               self.typed_chars += 1
   |
   = help: Reformat to one line

desktop_ui\space_invaders_game.py:38:9: D212 [*] Multi-line docstring summary should start at the first line
   |
37 |       def type_char(self, char: str) -> bool:
38 | /         """
39 | |         Type a character. Returns True if the character was correct.
40 | |         """
   | |___________^ D212
41 |           if self.typed_chars < len(self.text) and self.text[self.typed_chars].lower() == char.lower():
42 |               self.typed_chars += 1
   |
   = help: Remove whitespace after opening quotes

desktop_ui\space_invaders_game.py:68:9: D107 Missing docstring in `__init__`
   |
66 |     PLAYER_Y = 550
67 |     
68 |     def __init__(self, parent: Optional[QWidget] = None) -> None:
   |         ^^^^^^^^ D107
69 |         super().__init__(parent)
70 |         self.setWindowTitle("Space Invaders Typing Game")
   |

desktop_ui\splash.py:1:1: D205 1 blank line required between summary line and description
   |
 1 | / """
 2 | | splash.py
 3 | | AI Typing Trainer Splash Screen
 4 | | - Shows splash with large title and status label
 5 | | - Starts GraphQL server asynchronously
 6 | | - Polls server and displays snippet count in a message box
 7 | |
 8 | | Updated to use PySide6 instead of PyQt5.
 9 | | """
   | |___^ D205
10 |
11 |   import sys
   |
   = help: Insert single blank line

desktop_ui\splash.py:1:1: D212 [*] Multi-line docstring summary should start at the first line
   |
 1 | / """
 2 | | splash.py
 3 | | AI Typing Trainer Splash Screen
 4 | | - Shows splash with large title and status label
 5 | | - Starts GraphQL server asynchronously
 6 | | - Polls server and displays snippet count in a message box
 7 | |
 8 | | Updated to use PySide6 instead of PyQt5.
 9 | | """
   | |___^ D212
10 |
11 |   import sys
   |
   = help: Remove whitespace after opening quotes

desktop_ui\splash.py:1:1: D415 First line should end with a period, question mark, or exclamation point
   |
 1 | / """
 2 | | splash.py
 3 | | AI Typing Trainer Splash Screen
 4 | | - Shows splash with large title and status label
 5 | | - Starts GraphQL server asynchronously
 6 | | - Polls server and displays snippet count in a message box
 7 | |
 8 | | Updated to use PySide6 instead of PyQt5.
 9 | | """
   | |___^ D415
10 |
11 |   import sys
   |
   = help: Add closing punctuation

desktop_ui\splash.py:30:7: D101 Missing docstring in public class
   |
30 | class SplashConfig(BaseModel):
   |       ^^^^^^^^^^^^ D101
31 |     graphql_url: str = GRAPHQL_URL
32 |     poll_interval_ms: int = 500
   |

desktop_ui\splash.py:40:5: D205 1 blank line required between summary line and description
   |
39 |   class SplashScreen(QWidget):
40 | /     """
41 | |     Splash screen for AI Typing Trainer.
42 | |     - Frameless, no minimize/close, centered, stays on top.
43 | |     - Starts and polls GraphQL server via APIServerManager.
44 | |     - Queries snippet count via GraphQLClient.
45 | |     - Retains dummy/test mode for tests.
46 | |     """
   | |_______^ D205
47 |
48 |       def __init__(self, graphql=None, config: Optional[SplashConfig] = None) -> None:
   |
   = help: Insert single blank line

desktop_ui\splash.py:40:5: D212 [*] Multi-line docstring summary should start at the first line
   |
39 |   class SplashScreen(QWidget):
40 | /     """
41 | |     Splash screen for AI Typing Trainer.
42 | |     - Frameless, no minimize/close, centered, stays on top.
43 | |     - Starts and polls GraphQL server via APIServerManager.
44 | |     - Queries snippet count via GraphQLClient.
45 | |     - Retains dummy/test mode for tests.
46 | |     """
   | |_______^ D212
47 |
48 |       def __init__(self, graphql=None, config: Optional[SplashConfig] = None) -> None:
   |
   = help: Remove whitespace after opening quotes

desktop_ui\splash.py:48:9: D107 Missing docstring in `__init__`
   |
46 |     """
47 |
48 |     def __init__(self, graphql=None, config: Optional[SplashConfig] = None) -> None:
   |         ^^^^^^^^ D107
49 |         super().__init__()
50 |         self.setWindowTitle("AI Typing Trainer")
   |

desktop_ui\splash.py:48:24: ANN001 Missing type annotation for function argument `graphql`
   |
46 |     """
47 |
48 |     def __init__(self, graphql=None, config: Optional[SplashConfig] = None) -> None:
   |                        ^^^^^^^ ANN001
49 |         super().__init__()
50 |         self.setWindowTitle("AI Typing Trainer")
   |

desktop_ui\splash.py:156:30: F821 Undefined name `GraphQLServerThread`
    |
154 |     def _start_graphql_server(self) -> None:
155 |         self.status_label.setText("Starting up GraphQL")
156 |         self.server_thread = GraphQLServerThread()
    |                              ^^^^^^^^^^^^^^^^^^^ F821
157 |         self.server_thread.started_signal.connect(self._poll_graphql)
158 |         self.server_thread.start()
    |

desktop_ui\splash.py:182:9: D200 One-line docstring should fit on one line
    |
181 |       def check_graphql_and_show_count(self) -> None:
182 | /         """
183 | |         Checks if GraphQL is running; if not, updates status. If running, fetches snippet count and shows message box.
184 | |         """
    | |___________^ D200
185 |           count = 0
186 |           error = None
    |
    = help: Reformat to one line

desktop_ui\splash.py:182:9: D212 [*] Multi-line docstring summary should start at the first line
    |
181 |       def check_graphql_and_show_count(self) -> None:
182 | /         """
183 | |         Checks if GraphQL is running; if not, updates status. If running, fetches snippet count and shows message box.
184 | |         """
    | |___________^ D212
185 |           count = 0
186 |           error = None
    |
    = help: Remove whitespace after opening quotes

desktop_ui\splash.py:228:5: D205 1 blank line required between summary line and description
    |
227 |   def ensure_graphql_server_running() -> bool:
228 | /     """
229 | |     Utility function to ensure the GraphQL server is running.
230 | |     Can be called from other parts of the application.
231 | |
232 | |     Returns:
233 | |         bool: True if server is running, False otherwise
234 | |     """
    | |_______^ D205
235 |       if SplashScreen._api_server_manager is None:
236 |           SplashScreen._api_server_manager = APIServerManager()
    |
    = help: Insert single blank line

desktop_ui\splash.py:228:5: D212 [*] Multi-line docstring summary should start at the first line
    |
227 |   def ensure_graphql_server_running() -> bool:
228 | /     """
229 | |     Utility function to ensure the GraphQL server is running.
230 | |     Can be called from other parts of the application.
231 | |
232 | |     Returns:
233 | |         bool: True if server is running, False otherwise
234 | |     """
    | |_______^ D212
235 |       if SplashScreen._api_server_manager is None:
236 |           SplashScreen._api_server_manager = APIServerManager()
    |
    = help: Remove whitespace after opening quotes

desktop_ui\typing_drill.py:2:1: D205 1 blank line required between summary line and description
  |
1 |   # ruff: noqa: E501
2 | / """
3 | | TypingDrillScreen - Interactive typing practice UI with real-time feedback.
4 | | Implements full typing drill functionality including timing, statistics, and session persistence.
5 | | """
  | |___^ D205
6 |
7 |   # Move all imports to the top of the file for PEP8 compliance
  |
  = help: Insert single blank line

desktop_ui\typing_drill.py:2:1: D212 [*] Multi-line docstring summary should start at the first line
  |
1 |   # ruff: noqa: E501
2 | / """
3 | | TypingDrillScreen - Interactive typing practice UI with real-time feedback.
4 | | Implements full typing drill functionality including timing, statistics, and session persistence.
5 | | """
  | |___^ D212
6 |
7 |   # Move all imports to the top of the file for PEP8 compliance
  |
  = help: Remove whitespace after opening quotes

desktop_ui\typing_drill.py:8:1: I001 [*] Import block is un-sorted or un-formatted
   |
 7 |   # Move all imports to the top of the file for PEP8 compliance
 8 | / import datetime
 9 | | import logging
10 | | import time
11 | | import traceback
12 | | import uuid
13 | | from typing import TYPE_CHECKING, Any, Dict, List, Optional
14 | |
15 | | from PySide6.QtCore import Qt, QTimer
16 | | from PySide6.QtGui import QColor, QFont, QPalette, QTextCharFormat, QTextCursor
17 | | from PySide6.QtWidgets import (
18 | |     QDialog,
19 | |     QGridLayout,
20 | |     QHBoxLayout,
21 | |     QLabel,
22 | |     QProgressBar,
23 | |     QPushButton,
24 | |     QSizePolicy,
25 | |     QSpacerItem,
26 | |     QStatusBar,
27 | |     QTextEdit,
28 | |     QVBoxLayout,
29 | |     QWidget,
30 | | )
31 | |
32 | | from helpers.debug_util import DebugUtil
33 | | from models.keyboard_manager import KeyboardManager, KeyboardNotFound
34 | | from models.ngram_manager import NGramManager
35 | | from models.ngram_analytics_service import NGramAnalyticsService
36 | | from models.session import Session
37 | | from models.session_manager import SessionManager
38 | | from models.user_manager import UserManager, UserNotFound
   | |_________________________________________________________^ I001
39 |
40 |   if TYPE_CHECKING:
   |
   = help: Organize imports

desktop_ui\typing_drill.py:45:5: D205 1 blank line required between summary line and description
   |
44 |   class PersistSummary(QDialog):
45 | /     """
46 | |     Dialog shown after persistence operations complete.
47 | |     Displays the results of saving session data including record counts.
48 | |     """
   | |_______^ D205
49 |
50 |       def __init__(self, persist_results: Dict[str, Any], parent: Optional[QWidget] = None) -> None:
   |
   = help: Insert single blank line

desktop_ui\typing_drill.py:45:5: D212 [*] Multi-line docstring summary should start at the first line
   |
44 |   class PersistSummary(QDialog):
45 | /     """
46 | |     Dialog shown after persistence operations complete.
47 | |     Displays the results of saving session data including record counts.
48 | |     """
   | |_______^ D212
49 |
50 |       def __init__(self, persist_results: Dict[str, Any], parent: Optional[QWidget] = None) -> None:
   |
   = help: Remove whitespace after opening quotes

desktop_ui\typing_drill.py:51:9: D212 [*] Multi-line docstring summary should start at the first line
   |
50 |       def __init__(self, persist_results: Dict[str, Any], parent: Optional[QWidget] = None) -> None:
51 | /         """
52 | |         Initialize the persistence summary dialog.
53 | |
54 | |         Args:
55 | |             persist_results (Dict[str, Any]): Results of persistence operations.
56 | |             parent (Optional[QWidget]): Parent widget for the dialog.
57 | |         """
   | |___________^ D212
58 |           super().__init__(parent)
59 |           self.setWindowTitle("Session Saved")
   |
   = help: Remove whitespace after opening quotes

desktop_ui\typing_drill.py:150:9: D212 [*] Multi-line docstring summary should start at the first line
    |
149 |       def _add_result_row(self, grid: QGridLayout, row: int, label: str, status: str) -> None:
150 | /         """
151 | |         Add a row to the results grid with label and status.
152 | |
153 | |         Args:
154 | |             grid (QGridLayout): The grid layout to add the row to.
155 | |             row (int): The row index.
156 | |             label (str): The label text.
157 | |             status (str): The status text.
158 | |         """
    | |___________^ D212
159 |           label_widget = QLabel(label)
160 |           label_widget.setFont(QFont("Arial", 10, QFont.Bold))
    |
    = help: Remove whitespace after opening quotes

desktop_ui\typing_drill.py:175:5: D205 1 blank line required between summary line and description
    |
174 |   class CompletionDialog(QDialog):
175 | /     """
176 | |     Dialog shown when the typing session is completed.
177 | |     Displays typing statistics and provides options to retry or close.
178 | |     """
    | |_______^ D205
179 |
180 |       def __init__(self, stats: Dict[str, Any], parent: Optional[QWidget] = None) -> None:
    |
    = help: Insert single blank line

desktop_ui\typing_drill.py:175:5: D212 [*] Multi-line docstring summary should start at the first line
    |
174 |   class CompletionDialog(QDialog):
175 | /     """
176 | |     Dialog shown when the typing session is completed.
177 | |     Displays typing statistics and provides options to retry or close.
178 | |     """
    | |_______^ D212
179 |
180 |       def __init__(self, stats: Dict[str, Any], parent: Optional[QWidget] = None) -> None:
    |
    = help: Remove whitespace after opening quotes

desktop_ui\typing_drill.py:181:9: D212 [*] Multi-line docstring summary should start at the first line
    |
180 |       def __init__(self, stats: Dict[str, Any], parent: Optional[QWidget] = None) -> None:
181 | /         """
182 | |         Initialize the completion dialog with typing statistics and parent widget.
183 | |
184 | |         Args:
185 | |             stats (Dict[str, Any]): Typing statistics to display.
186 | |             parent (Optional[QWidget]): Parent widget for the dialog.
187 | |         """
    | |___________^ D212
188 |           super().__init__(parent)
189 |           self.setWindowTitle("Typing Session Completed")
    |
    = help: Remove whitespace after opening quotes

desktop_ui\typing_drill.py:264:9: D212 [*] Multi-line docstring summary should start at the first line
    |
263 |       def _add_stat_row(self, grid: QGridLayout, row: int, label: str, value: str) -> None:
264 | /         """
265 | |         Add a row to the stats grid with label and value.
266 | |
267 | |         Args:
268 | |             grid (QGridLayout): The grid layout to add the row to.
269 | |             row (int): The row index.
270 | |             label (str): The label text.
271 | |             value (str): The value text.
272 | |         """
    | |___________^ D212
273 |           label_widget = QLabel(label)
274 |           label_widget.setFont(QFont("Arial", 10, QFont.Bold))
    |
    = help: Remove whitespace after opening quotes

desktop_ui\typing_drill.py:282:9: D200 One-line docstring should fit on one line
    |
281 |       def _on_retry(self) -> None:
282 | /         """
283 | |         Handle retry button click.
284 | |         """
    | |___________^ D200
285 |           self.done(2)  # Custom return code for retry
    |
    = help: Reformat to one line

desktop_ui\typing_drill.py:282:9: D212 [*] Multi-line docstring summary should start at the first line
    |
281 |       def _on_retry(self) -> None:
282 | /         """
283 | |         Handle retry button click.
284 | |         """
    | |___________^ D212
285 |           self.done(2)  # Custom return code for retry
    |
    = help: Remove whitespace after opening quotes

desktop_ui\typing_drill.py:289:5: D205 1 blank line required between summary line and description
    |
288 |   class TypingDrillScreen(QDialog):
289 | /     """
290 | |     TypingDrillScreen handles the typing drill UI and session persistence for desktop.
291 | |     Implements real-time feedback, timing, statistics, and session recording.
292 | |
293 | |     Args:
294 | |         snippet_id (int): ID of the snippet being practiced (-1 for manual text)
295 | |         start (int): Starting index in the snippet
296 | |         end (int): Ending index in the snippet
297 | |         content (str): Content to type (substring of snippet between start and end)
298 | |         db_manager (Optional[Any]): Database manager instance
299 | |         parent (Optional[QWidget]): Parent widget
300 | |     """
    | |_______^ D205
301 |
302 |       def __init__(
    |
    = help: Insert single blank line

desktop_ui\typing_drill.py:289:5: D212 [*] Multi-line docstring summary should start at the first line
    |
288 |   class TypingDrillScreen(QDialog):
289 | /     """
290 | |     TypingDrillScreen handles the typing drill UI and session persistence for desktop.
291 | |     Implements real-time feedback, timing, statistics, and session recording.
292 | |
293 | |     Args:
294 | |         snippet_id (int): ID of the snippet being practiced (-1 for manual text)
295 | |         start (int): Starting index in the snippet
296 | |         end (int): Ending index in the snippet
297 | |         content (str): Content to type (substring of snippet between start and end)
298 | |         db_manager (Optional[Any]): Database manager instance
299 | |         parent (Optional[QWidget]): Parent widget
300 | |     """
    | |_______^ D212
301 |
302 |       def __init__(
    |
    = help: Remove whitespace after opening quotes

desktop_ui\typing_drill.py:313:9: D212 [*] Multi-line docstring summary should start at the first line
    |
311 |           parent: Optional[QWidget] = None,
312 |       ) -> None:
313 | /         """
314 | |         Initialize the TypingDrillScreen dialog and session state.
315 | |
316 | |         Args:
317 | |             snippet_id (int): ID of the snippet being practiced (-1 for manual text)
318 | |             start (int): Starting index in the snippet
319 | |             end (int): Ending index in the snippet
320 | |             content (str): Content to type (substring of snippet between start and end)
321 | |             db_manager (Optional[DatabaseManager]): Database manager instance
322 | |             user_id (Optional[str]): ID of the current user
323 | |             keyboard_id (Optional[str]): ID of the keyboard being used
324 | |             parent (Optional[QWidget]): Parent widget
325 | |         """
    | |___________^ D212
326 |           super().__init__(parent)
327 |           self.setWindowTitle("Typing Drill")
    |
    = help: Remove whitespace after opening quotes

desktop_ui\typing_drill.py:429:9: D200 One-line docstring should fit on one line
    |
428 |       def _update_status_bar(self) -> None:
429 | /         """
430 | |         Update status bar with user and keyboard information.
431 | |         """
    | |___________^ D200
432 |           status_text = ""
433 |           if self.current_user:
    |
    = help: Reformat to one line

desktop_ui\typing_drill.py:429:9: D212 [*] Multi-line docstring summary should start at the first line
    |
428 |       def _update_status_bar(self) -> None:
429 | /         """
430 | |         Update status bar with user and keyboard information.
431 | |         """
    | |___________^ D212
432 |           status_text = ""
433 |           if self.current_user:
    |
    = help: Remove whitespace after opening quotes

desktop_ui\typing_drill.py:449:9: D212 [*] Multi-line docstring summary should start at the first line
    |
448 |       def _create_new_session(self) -> Session:
449 | /         """
450 | |         Helper to create a new Session object for this typing drill.
451 | |
452 | |         Returns:
453 | |             Session: A new Session instance with the current configuration.
454 | |         """
    | |___________^ D212
455 |
456 |           def ensure_uuid(val):
    |
    = help: Remove whitespace after opening quotes

desktop_ui\typing_drill.py:456:13: ANN202 Missing return type annotation for private function `ensure_uuid`
    |
454 |         """
455 |
456 |         def ensure_uuid(val):
    |             ^^^^^^^^^^^ ANN202
457 |             try:
458 |                 return str(uuid.UUID(str(val)))
    |
    = help: Add return type annotation

desktop_ui\typing_drill.py:456:25: ANN001 Missing type annotation for function argument `val`
    |
454 |         """
455 |
456 |         def ensure_uuid(val):
    |                         ^^^ ANN001
457 |             try:
458 |                 return str(uuid.UUID(str(val)))
    |

desktop_ui\typing_drill.py:481:9: D212 [*] Multi-line docstring summary should start at the first line
    |
480 |       def _preprocess_content(self, content: str) -> str:
481 | /         """
482 | |         Preprocess content to make whitespace and special characters visible for display.
483 | |
484 | |         Args:
485 | |             content (str): Original text content to preprocess.
486 | |
487 | |         Returns:
488 | |             str: Preprocessed content with visible whitespace markers for display.
489 | |         """
    | |___________^ D212
490 |           # Replace spaces with visible space character (using subscript up arrow as specified)
491 |           result = content.replace(" ", "ΓÉú")  # Visible space character
    |
    = help: Remove whitespace after opening quotes

desktop_ui\typing_drill.py:505:9: D212 [*] Multi-line docstring summary should start at the first line
    |
504 |       def _setup_ui(self) -> None:
505 | /         """
506 | |         Set up the UI components for the typing drill screen.
507 | |
508 | |         Returns:
509 | |             None: This method does not return a value.
510 | |         """
    | |___________^ D212
511 |           # Main layout
512 |           main_layout = QVBoxLayout(self)
    |
    = help: Remove whitespace after opening quotes

desktop_ui\typing_drill.py:592:9: D212 [*] Multi-line docstring summary should start at the first line
    |
591 |       def _on_text_changed(self) -> None:
592 | /         """
593 | |         Handle text changes in the typing input and update session state, stats, and UI.
594 | |
595 | |         Returns:
596 | |             None: This method does not return a value.
597 | |         """
    | |___________^ D212
598 |           current_text = self.typing_input.toPlainText()
    |
    = help: Remove whitespace after opening quotes

desktop_ui\typing_drill.py:702:9: D205 1 blank line required between summary line and description
    |
701 |       def _process_typing_input(self) -> None:
702 | /         """
703 | |         Process the current typing input, check progress, and update UI highlighting and
704 | |         progress bar.
705 | |
706 | |         Returns:
707 | |             None: This method does not return a value.
708 | |         """
    | |___________^ D205
709 |           current_text = self.typing_input.toPlainText()
    |
    = help: Insert single blank line

desktop_ui\typing_drill.py:702:9: D212 [*] Multi-line docstring summary should start at the first line
    |
701 |       def _process_typing_input(self) -> None:
702 | /         """
703 | |         Process the current typing input, check progress, and update UI highlighting and
704 | |         progress bar.
705 | |
706 | |         Returns:
707 | |             None: This method does not return a value.
708 | |         """
    | |___________^ D212
709 |           current_text = self.typing_input.toPlainText()
    |
    = help: Remove whitespace after opening quotes

desktop_ui\typing_drill.py:721:9: D212 [*] Multi-line docstring summary should start at the first line
    |
720 |       def _update_highlighting(self, current_text: str) -> None:
721 | /         """
722 | |         Update the display text with highlighting based on typing accuracy.
723 | |
724 | |         Args:
725 | |             current_text (str): Current text input by the user.
726 | |
727 | |         Returns:
728 | |             None: This method does not return a value.
729 | |         """
    | |___________^ D212
730 |           # Block signals temporarily to avoid recursive calls
731 |           self.display_text.blockSignals(True)
    |
    = help: Remove whitespace after opening quotes

desktop_ui\typing_drill.py:788:9: D212 [*] Multi-line docstring summary should start at the first line
    |
787 |       def _update_timer(self) -> None:
788 | /         """
789 | |         Update timer and stats display during the typing session.
790 | |
791 | |         Returns:
792 | |             None: This method does not return a value.
793 | |         """
    | |___________^ D212
794 |           if self.timer_running:
795 |               self.elapsed_time = time.time() - self.start_time
    |
    = help: Remove whitespace after opening quotes

desktop_ui\typing_drill.py:800:9: D212 [*] Multi-line docstring summary should start at the first line
    |
799 |       def _update_stats(self) -> None:
800 | /         """
801 | |         Calculate and update WPM, CPM, and accuracy statistics for the session.
802 | |
803 | |         Returns:
804 | |             None: This method does not return a value.
805 | |         """
    | |___________^ D212
806 |           if not self.timer_running or self.elapsed_time < 0.1:
807 |               return
    |
    = help: Remove whitespace after opening quotes

desktop_ui\typing_drill.py:826:9: D205 1 blank line required between summary line and description
    |
825 |       def _check_completion(self) -> None:
826 | /         """
827 | |         Check and handle completion of the typing session, including saving session data
828 | |         and showing completion dialog.
829 | |
830 | |         Returns:
831 | |             None: This method does not return a value.
832 | |         """
    | |___________^ D205
833 |           logging.debug("Entering _check_completion")
834 |           if getattr(self, "session_completed", False):
    |
    = help: Insert single blank line

desktop_ui\typing_drill.py:826:9: D212 [*] Multi-line docstring summary should start at the first line
    |
825 |       def _check_completion(self) -> None:
826 | /         """
827 | |         Check and handle completion of the typing session, including saving session data
828 | |         and showing completion dialog.
829 | |
830 | |         Returns:
831 | |             None: This method does not return a value.
832 | |         """
    | |___________^ D212
833 |           logging.debug("Entering _check_completion")
834 |           if getattr(self, "session_completed", False):
    |
    = help: Remove whitespace after opening quotes

desktop_ui\typing_drill.py:877:9: D212 [*] Multi-line docstring summary should start at the first line
    |
876 |       def save_session(self) -> bool:
877 | /         """
878 | |         Save the session using the local Session object and session_manager.
879 | |
880 | |         Returns:
881 | |             bool: True if the session was saved successfully, otherwise raises an exception.
882 | |         """
    | |___________^ D212
883 |           logging.debug("Entering save_session with session: %s", self.session)
884 |           try:
    |
    = help: Remove whitespace after opening quotes

desktop_ui\typing_drill.py:900:9: D200 One-line docstring should fit on one line
    |
899 |       def _persist_session_data(self, session: Session) -> Dict[str, Any]:
900 | /         """
901 | |         Persist the session, keystrokes, n-grams, and analytics via orchestrator and return a summary dict.
902 | |         """
    | |___________^ D200
903 |           results = {
904 |               "session_saved": False,
    |
    = help: Reformat to one line

desktop_ui\typing_drill.py:900:9: D212 [*] Multi-line docstring summary should start at the first line
    |
899 |       def _persist_session_data(self, session: Session) -> Dict[str, Any]:
900 | /         """
901 | |         Persist the session, keystrokes, n-grams, and analytics via orchestrator and return a summary dict.
902 | |         """
    | |___________^ D212
903 |           results = {
904 |               "session_saved": False,
    |
    = help: Remove whitespace after opening quotes

desktop_ui\typing_drill.py:946:9: D212 [*] Multi-line docstring summary should start at the first line
    |
945 |       def _show_completion_dialog(self, session: Session) -> None:
946 | /         """
947 | |         Show the completion dialog with the given session object and handle persistence.
948 | |
949 | |         Args:
950 | |             session (Session): The Session object containing session results.
951 | |
952 | |         Returns:
953 | |             None: This method does not return a value.
954 | |         """
    | |___________^ D212
955 |           # Calculate final stats
956 |           stats = self._calculate_stats()
    |
    = help: Remove whitespace after opening quotes

desktop_ui\typing_drill.py:984:9: D200 One-line docstring should fit on one line
    |
983 |       def _reset_session(self) -> None:
984 | /         """
985 | |         Reset the typing session to its initial state.
986 | |         """
    | |___________^ D200
987 |           self.session = self._create_new_session()
988 |           self.timer_running = False
    |
    = help: Reformat to one line

desktop_ui\typing_drill.py:984:9: D212 [*] Multi-line docstring summary should start at the first line
    |
983 |       def _reset_session(self) -> None:
984 | /         """
985 | |         Reset the typing session to its initial state.
986 | |         """
    | |___________^ D212
987 |           self.session = self._create_new_session()
988 |           self.timer_running = False
    |
    = help: Remove whitespace after opening quotes

desktop_ui\typing_drill.py:1008:9: D205 1 blank line required between summary line and description
     |
1007 |       def _calculate_stats(self) -> Dict[str, Any]:
1008 | /         """
1009 | |         Calculate and return typing statistics for the session.
1010 | |         Returns:
1011 | |             Dict[str, Any]: Dictionary of stats for the completion dialog.
1012 | |         """
     | |___________^ D205
1013 |           total_time = (
1014 |               (self.session.end_time - self.session.start_time).total_seconds()
     |
     = help: Insert single blank line

desktop_ui\typing_drill.py:1008:9: D212 [*] Multi-line docstring summary should start at the first line
     |
1007 |       def _calculate_stats(self) -> Dict[str, Any]:
1008 | /         """
1009 | |         Calculate and return typing statistics for the session.
1010 | |         Returns:
1011 | |             Dict[str, Any]: Dictionary of stats for the completion dialog.
1012 | |         """
     | |___________^ D212
1013 |           total_time = (
1014 |               (self.session.end_time - self.session.start_time).total_seconds()
     |
     = help: Remove whitespace after opening quotes

desktop_ui\typing_drill.py:1010:9: D411 [*] Missing blank line before section ("Returns")
     |
1008 |         """
1009 |         Calculate and return typing statistics for the session.
1010 |         Returns:
     |         ^^^^^^^ D411
1011 |             Dict[str, Any]: Dictionary of stats for the completion dialog.
1012 |         """
     |
     = help: Add blank line before "Returns"

desktop_ui\users_and_keyboards.py:1:1: D212 [*] Multi-line docstring summary should start at the first line
  |
1 | / """
2 | | Users and Keyboards management screen.
3 | |
4 | | This module provides a UI for managing users and their associated keyboards.
5 | | """
  | |___^ D212
6 |
7 |   from typing import Optional
  |
  = help: Remove whitespace after opening quotes

desktop_ui\users_and_keyboards.py:37:5: D200 One-line docstring should fit on one line
   |
36 |   class UsersAndKeyboards(QDialog):
37 | /     """
38 | |     Dialog for managing users and their keyboards.
39 | |     """
   | |_______^ D200
40 |
41 |       def __init__(self, db_manager: DatabaseManager, parent: Optional[QWidget] = None) -> None:
   |
   = help: Reformat to one line

desktop_ui\users_and_keyboards.py:37:5: D212 [*] Multi-line docstring summary should start at the first line
   |
36 |   class UsersAndKeyboards(QDialog):
37 | /     """
38 | |     Dialog for managing users and their keyboards.
39 | |     """
   | |_______^ D212
40 |
41 |       def __init__(self, db_manager: DatabaseManager, parent: Optional[QWidget] = None) -> None:
   |
   = help: Remove whitespace after opening quotes

desktop_ui\users_and_keyboards.py:42:9: D212 [*] Multi-line docstring summary should start at the first line
   |
41 |       def __init__(self, db_manager: DatabaseManager, parent: Optional[QWidget] = None) -> None:
42 | /         """
43 | |         Initialize the Users and Keyboards dialog.
44 | |
45 | |         Args:
46 | |             db_manager: Database manager instance.
47 | |             parent: Parent widget.
48 | |         """
   | |___________^ D212
49 |           super().__init__(parent)
50 |           self.db_manager = db_manager
   |
   = help: Remove whitespace after opening quotes

desktop_ui\users_and_keyboards.py:151:9: D212 [*] Multi-line docstring summary should start at the first line
    |
150 |       def load_keyboards_for_user(self, user_id: str) -> None:
151 | /         """
152 | |         Load keyboards for the specified user.
153 | |
154 | |         Args:
155 | |             user_id: ID of the user to load keyboards for.
156 | |         """
    | |___________^ D212
157 |           self.keyboards_list.clear()
158 |           try:
    |
    = help: Remove whitespace after opening quotes

desktop_ui\view_snippet_dialog.py:1:1: D212 [*] Multi-line docstring summary should start at the first line
  |
1 | / """
2 | | View Snippet Dialog for the Desktop UI
3 | |
4 | | Provides a maximized dialog for viewing snippet content with proper formatting.
5 | | Updated to use PySide6 instead of PyQt5.
6 | | """
  | |___^ D212
7 |
8 |   from typing import Optional
  |
  = help: Remove whitespace after opening quotes

desktop_ui\view_snippet_dialog.py:1:1: D415 First line should end with a period, question mark, or exclamation point
  |
1 | / """
2 | | View Snippet Dialog for the Desktop UI
3 | |
4 | | Provides a maximized dialog for viewing snippet content with proper formatting.
5 | | Updated to use PySide6 instead of PyQt5.
6 | | """
  | |___^ D415
7 |
8 |   from typing import Optional
  |
  = help: Add closing punctuation

desktop_ui\view_snippet_dialog.py:31:5: D205 1 blank line required between summary line and description
   |
30 |   class ViewSnippetDialog(QDialog):
31 | /     """
32 | |     Dialog for viewing snippet content with all its parts.
33 | |     Shows in maximized mode with proper formatting.
34 | |     """
   | |_______^ D205
35 |
36 |       def __init__(
   |
   = help: Insert single blank line

desktop_ui\view_snippet_dialog.py:31:5: D212 [*] Multi-line docstring summary should start at the first line
   |
30 |   class ViewSnippetDialog(QDialog):
31 | /     """
32 | |     Dialog for viewing snippet content with all its parts.
33 | |     Shows in maximized mode with proper formatting.
34 | |     """
   | |_______^ D212
35 |
36 |       def __init__(
   |
   = help: Remove whitespace after opening quotes

desktop_ui\view_snippet_dialog.py:43:9: D212 [*] Multi-line docstring summary should start at the first line
   |
41 |           parent: Optional[QWidget] = None,
42 |       ) -> None:
43 | /         """
44 | |         Initialize the view snippet dialog.
45 | |
46 | |         Args:
47 | |             title: Dialog title
48 | |             snippet_name: Name of the snippet
49 | |             content: Full snippet content (all parts)
50 | |             parent: Parent widget
51 | |         """
   | |___________^ D212
52 |           super().__init__(parent)
53 |           self.setWindowTitle(title)
   |
   = help: Remove whitespace after opening quotes

desktop_ui\view_snippet_dialog.py:95:5: D212 [*] Multi-line docstring summary should start at the first line
    |
 94 |   def _view_dialog_qss() -> str:
 95 | /     """
 96 | |     Return QSS for a modern Windows 11 view dialog look.
 97 | |
 98 | |     Returns:
 99 | |         str: QSS styling for the view dialog
100 | |     """
    | |_______^ D212
101 |       return """
102 |       QDialog {
    |
    = help: Remove whitespace after opening quotes

examples\service_usage_example.py:1:1: D212 [*] Multi-line docstring summary should start at the first line
  |
1 | / """
2 | | Example demonstrating the recommended way to initialize and use services.
3 | |
4 | | This example shows how to properly initialize services using dependency injection
5 | | and the new service initialization pattern.
6 | | """
  | |___^ D212
7 |   import sys
8 |   from pathlib import Path
  |
  = help: Remove whitespace after opening quotes

examples\service_usage_example.py:15:1: E402 Module level import not at top of file
   |
13 |     sys.path.insert(0, project_root)
14 |
15 | from services import init_services
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
   |

examples\service_usage_example.py:18:5: ANN201 Missing return type annotation for public function `main`
   |
18 | def main():
   |     ^^^^ ANN201
19 |     """Demonstrate service initialization and usage."""
20 |     try:
   |
   = help: Add return type annotation: `int`

examples\service_usage_example.py:48:7: D101 Missing docstring in public class
   |
47 | # Example of how to use the services in a class:
48 | class MyApplication:
   |       ^^^^^^^^^^^^^ D101
49 |     def __init__(self, snippet_manager, session_manager):
50 |         self.snippet_manager = snippet_manager
   |

examples\service_usage_example.py:49:9: ANN204 Missing return type annotation for special method `__init__`
   |
47 | # Example of how to use the services in a class:
48 | class MyApplication:
49 |     def __init__(self, snippet_manager, session_manager):
   |         ^^^^^^^^ ANN204
50 |         self.snippet_manager = snippet_manager
51 |         self.session_manager = session_manager
   |
   = help: Add return type annotation: `None`

examples\service_usage_example.py:49:9: D107 Missing docstring in `__init__`
   |
47 | # Example of how to use the services in a class:
48 | class MyApplication:
49 |     def __init__(self, snippet_manager, session_manager):
   |         ^^^^^^^^ D107
50 |         self.snippet_manager = snippet_manager
51 |         self.session_manager = session_manager
   |

examples\service_usage_example.py:49:24: ANN001 Missing type annotation for function argument `snippet_manager`
   |
47 | # Example of how to use the services in a class:
48 | class MyApplication:
49 |     def __init__(self, snippet_manager, session_manager):
   |                        ^^^^^^^^^^^^^^^ ANN001
50 |         self.snippet_manager = snippet_manager
51 |         self.session_manager = session_manager
   |

examples\service_usage_example.py:49:41: ANN001 Missing type annotation for function argument `session_manager`
   |
47 | # Example of how to use the services in a class:
48 | class MyApplication:
49 |     def __init__(self, snippet_manager, session_manager):
   |                                         ^^^^^^^^^^^^^^^ ANN001
50 |         self.snippet_manager = snippet_manager
51 |         self.session_manager = session_manager
   |

examples\service_usage_example.py:53:9: ANN201 Missing return type annotation for public function `do_something`
   |
51 |         self.session_manager = session_manager
52 |
53 |     def do_something(self):
   |         ^^^^^^^^^^^^ ANN201
54 |         """Example method showing service usage."""
55 |         # Use the injected services
   |
   = help: Add return type annotation: `None`

helpers\__init__.py:1:1: D212 [*] Multi-line docstring summary should start at the first line
  |
1 | / """
2 | | Helper utilities for the AITypingTrainer application.
3 | |
4 | | This package contains various utility functions and classes that are used across
5 | | the application to provide common functionality.
6 | | """
  | |___^ D212
7 |
8 |   # Make the error message box function available at the package level
  |
  = help: Remove whitespace after opening quotes

helpers\debug_util.py:1:1: D212 [*] Multi-line docstring summary should start at the first line
  |
1 | / """
2 | | Debug utility class for controlling debug output throughout the AI Typing Trainer application.
3 | |
4 | | This module provides a centralized way to handle debug messages, supporting both
5 | | quiet mode (logging only) and loud mode (print to stdout).
6 | | """
  | |___^ D212
7 |
8 |   import logging
  |
  = help: Remove whitespace after opening quotes

helpers\debug_util.py:14:5: D212 [*] Multi-line docstring summary should start at the first line
   |
13 |   class DebugUtil:
14 | /     """
15 | |     Utility class for managing debug output based on debug mode setting.
16 | |
17 | |     Supports two modes:
18 | |     - "quiet": Debug messages are logged only
19 | |     - "loud": Debug messages are printed to stdout
20 | |     """
   | |_______^ D212
21 |
22 |       def __init__(self) -> None:
   |
   = help: Remove whitespace after opening quotes

helpers\debug_util.py:23:9: D212 [*] Multi-line docstring summary should start at the first line
   |
22 |       def __init__(self) -> None:
23 | /         """
24 | |         Initialize the DebugUtil by reading debug mode from environment variable.
25 | |
26 | |         Reads the AI_TYPING_TRAINER_DEBUG_MODE environment variable.
27 | |         Defaults to "quiet" if not set or invalid.
28 | |         """
   | |___________^ D212
29 |           # Read debug mode from environment variable
30 |           env_mode = os.environ.get("AI_TYPING_TRAINER_DEBUG_MODE", "quiet").lower()
   |
   = help: Remove whitespace after opening quotes

helpers\debug_util.py:46:9: D212 [*] Multi-line docstring summary should start at the first line
   |
45 |       def debug_mode(self) -> str:
46 | /         """
47 | |         Get the current debug mode.
48 | |
49 | |         Returns:
50 | |             The current debug mode ("quiet" or "loud")
51 | |         """
   | |___________^ D212
52 |           return self._mode
   |
   = help: Remove whitespace after opening quotes

helpers\debug_util.py:54:35: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `*args`
   |
52 |         return self._mode
53 |
54 |     def debugMessage(self, *args: Any, **kwargs: Any) -> None:
   |                                   ^^^ ANN401
55 |         """
56 |         Output a debug message based on the current debug mode.
   |

helpers\debug_util.py:54:50: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `**kwargs`
   |
52 |         return self._mode
53 |
54 |     def debugMessage(self, *args: Any, **kwargs: Any) -> None:
   |                                                  ^^^ ANN401
55 |         """
56 |         Output a debug message based on the current debug mode.
   |

helpers\debug_util.py:55:9: D212 [*] Multi-line docstring summary should start at the first line
   |
54 |       def debugMessage(self, *args: Any, **kwargs: Any) -> None:
55 | /         """
56 | |         Output a debug message based on the current debug mode.
57 | |
58 | |         In "quiet" mode: Messages are logged using the logger
59 | |         In "loud" mode: Messages are printed to stdout using print()
60 | |
61 | |         Args:
62 | |             *args: Arguments to pass to print() or logger
63 | |             **kwargs: Keyword arguments to pass to print() or logger
64 | |         """
   | |___________^ D212
65 |           if self._mode == "loud":
66 |               # Print to stdout in loud mode
   |
   = help: Remove whitespace after opening quotes

helpers\debug_util.py:76:9: D212 [*] Multi-line docstring summary should start at the first line
   |
75 |       def set_mode(self, mode: str) -> None:
76 | /         """
77 | |         Change the debug mode.
78 | |
79 | |         Args:
80 | |             mode: New debug mode - either "quiet" or "loud".
81 | |                   Invalid values will default to "quiet".
82 | |         """
   | |___________^ D212
83 |           self._mode = mode.lower() if mode.lower() in ["quiet", "loud"] else "quiet"
   |
   = help: Remove whitespace after opening quotes

helpers\debug_util.py:86:9: D212 [*] Multi-line docstring summary should start at the first line
   |
85 |       def is_loud(self) -> bool:
86 | /         """
87 | |         Check if debug mode is set to loud.
88 | |
89 | |         Returns:
90 | |             True if debug mode is "loud", False otherwise
91 | |         """
   | |___________^ D212
92 |           return self._mode == "loud"
   |
   = help: Remove whitespace after opening quotes

helpers\debug_util.py:95:9: D212 [*] Multi-line docstring summary should start at the first line
    |
 94 |       def is_quiet(self) -> bool:
 95 | /         """
 96 | |         Check if debug mode is set to quiet.
 97 | |
 98 | |         Returns:
 99 | |             True if debug mode is "quiet", False otherwise
100 | |         """
    | |___________^ D212
101 |           return self._mode == "quiet"
    |
    = help: Remove whitespace after opening quotes

helpers\error_utils.py:1:1: D212 [*] Multi-line docstring summary should start at the first line
  |
1 | / """
2 | | Error handling utilities for the AITypingTrainer application.
3 | |
4 | | This module provides utility functions for displaying error messages and handling
5 | | errors in a user-friendly way across the application.
6 | | """
  | |___^ D212
7 |
8 |   import logging
  |
  = help: Remove whitespace after opening quotes

inspect_db.py:1:1: D100 Missing docstring in public module
inspect_db.py:5:5: ANN201 Missing return type annotation for public function `inspect_database`
  |
5 | def inspect_database(db_path):
  |     ^^^^^^^^^^^^^^^^ ANN201
6 |     """Inspect the database schema and print detailed information."""
7 |     print(f"\nInspecting database at: {db_path}")
  |
  = help: Add return type annotation: `None`

inspect_db.py:5:22: ANN001 Missing type annotation for function argument `db_path`
  |
5 | def inspect_database(db_path):
  |                      ^^^^^^^ ANN001
6 |     """Inspect the database schema and print detailed information."""
7 |     print(f"\nInspecting database at: {db_path}")
  |

inspect_db.py:54:5: ANN201 Missing return type annotation for public function `main`
   |
52 |         conn.close()
53 |
54 | def main():
   |     ^^^^ ANN201
55 |     """Main function to inspect the database."""
56 |     # Create a temporary database file
   |
   = help: Add return type annotation: `None`

inspect_db.py:103:121: E501 Line too long (161 > 120)
    |
101 | ΓÇª
102 | ΓÇª
103 | ΓÇª else 'NULL':10} DEFAULT: {default_val or 'None':10} {'PRIMARY KEY' if pk else ''}")
    |                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
104 | ΓÇª
105 | ΓÇª
    |

main.py:1:1: D100 Missing docstring in public module
main.py:4:5: ANN201 Missing return type annotation for public function `main`
  |
4 | def main():
  |     ^^^^ ANN201
5 |     desktop_ui.main_menu.launch_main_menu()
  |
  = help: Add return type annotation: `None`

main.py:4:5: D103 Missing docstring in public function
  |
4 | def main():
  |     ^^^^ D103
5 |     desktop_ui.main_menu.launch_main_menu()
  |

migrate_add_text_index.py:2:1: D212 [*] Multi-line docstring summary should start at the first line
   |
 1 |   #!/usr/bin/env python3
 2 | / """
 3 | | Database migration script to add text_index column to session_keystrokes table.
 4 | |
 5 | | This script:
 6 | | 1. Adds a nullable text_index column to session_keystrokes table
 7 | | 2. Populates the column using ROW_NUMBER() partitioned by session_id, ordered by keystroke_time ASC
 8 | | 3. Makes the column NOT NULL after population
 9 | |
10 | | Usage:
11 | |     python migrate_add_text_index.py
12 | | """
   | |___^ D212
13 |
14 |   import os
   |
   = help: Remove whitespace after opening quotes

migrate_add_text_index.py:14:1: I001 [*] Import block is un-sorted or un-formatted
   |
12 |   """
13 |
14 | / import os
15 | | import sqlite3
16 | | import sys
17 | | from pathlib import Path
   | |________________________^ I001
18 |
19 |   def get_database_path():
   |
   = help: Organize imports

migrate_add_text_index.py:14:8: F401 [*] `os` imported but unused
   |
12 | """
13 |
14 | import os
   |        ^^ F401
15 | import sqlite3
16 | import sys
   |
   = help: Remove unused import: `os`

migrate_add_text_index.py:19:5: ANN201 Missing return type annotation for public function `get_database_path`
   |
17 | from pathlib import Path
18 |
19 | def get_database_path():
   |     ^^^^^^^^^^^^^^^^^ ANN201
20 |     """Get the path to the typing_data.db database."""
21 |     # Get the project root directory
   |
   = help: Add return type annotation

migrate_add_text_index.py:32:5: ANN201 Missing return type annotation for public function `check_column_exists`
   |
30 |     return str(db_path)
31 |
32 | def check_column_exists(cursor, table_name, column_name):
   |     ^^^^^^^^^^^^^^^^^^^ ANN201
33 |     """Check if a column exists in the specified table."""
34 |     cursor.execute(f"PRAGMA table_info({table_name})")
   |
   = help: Add return type annotation

migrate_add_text_index.py:32:25: ANN001 Missing type annotation for function argument `cursor`
   |
30 |     return str(db_path)
31 |
32 | def check_column_exists(cursor, table_name, column_name):
   |                         ^^^^^^ ANN001
33 |     """Check if a column exists in the specified table."""
34 |     cursor.execute(f"PRAGMA table_info({table_name})")
   |

migrate_add_text_index.py:32:33: ANN001 Missing type annotation for function argument `table_name`
   |
30 |     return str(db_path)
31 |
32 | def check_column_exists(cursor, table_name, column_name):
   |                                 ^^^^^^^^^^ ANN001
33 |     """Check if a column exists in the specified table."""
34 |     cursor.execute(f"PRAGMA table_info({table_name})")
   |

migrate_add_text_index.py:32:45: ANN001 Missing type annotation for function argument `column_name`
   |
30 |     return str(db_path)
31 |
32 | def check_column_exists(cursor, table_name, column_name):
   |                                             ^^^^^^^^^^^ ANN001
33 |     """Check if a column exists in the specified table."""
34 |     cursor.execute(f"PRAGMA table_info({table_name})")
   |

migrate_add_text_index.py:38:5: ANN201 Missing return type annotation for public function `migrate_add_text_index`
   |
36 |     return any(col[1] == column_name for col in columns)
37 |
38 | def migrate_add_text_index():
   |     ^^^^^^^^^^^^^^^^^^^^^^ ANN201
39 |     """Add text_index column to session_keystrokes table and populate it."""
40 |     db_path = get_database_path()
   |
   = help: Add return type annotation: `None`

migrate_add_text_index.py:92:39: B007 Loop control variable `keystroke_time` not used within loop body
   |
91 |             # Update each keystroke with its text_index (0-based)
92 |             for index, (keystroke_id, keystroke_time) in enumerate(keystrokes):
   |                                       ^^^^^^^^^^^^^^ B007
93 |                 cursor.execute("""
94 |                     UPDATE session_keystrokes 
   |
   = help: Rename unused `keystroke_time` to `_keystroke_time`

migrate_add_text_index_cloud.py:2:1: D212 [*] Multi-line docstring summary should start at the first line
   |
 1 |   #!/usr/bin/env python3
 2 | / """
 3 | | Database migration script to add text_index column to session_keystrokes table (CLOUD VERSION).
 4 | |
 5 | | This script:
 6 | | 1. Adds a nullable text_index column to session_keystrokes table
 7 | | 2. Populates the column using ROW_NUMBER() partitioned by session_id, ordered by keystroke_time ASC
 8 | | 3. Makes the column NOT NULL after population
 9 | |
10 | | Usage:
11 | |     python migrate_add_text_index_cloud.py
12 | | """
   | |___^ D212
13 |
14 |   import os
   |
   = help: Remove whitespace after opening quotes

migrate_add_text_index_cloud.py:16:21: F401 [*] `pathlib.Path` imported but unused
   |
14 | import os
15 | import sys
16 | from pathlib import Path
   |                     ^^^^ F401
17 |
18 | # Ensure project root is in sys.path before any project imports
   |
   = help: Remove unused import: `pathlib.Path`

migrate_add_text_index_cloud.py:21:1: I001 [*] Import block is un-sorted or un-formatted
   |
19 | sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__))))
20 |
21 | from db.database_manager import ConnectionType, DatabaseManager
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ I001
22 |
23 | def migrate_add_text_index_cloud():
   |
   = help: Organize imports

migrate_add_text_index_cloud.py:23:5: ANN201 Missing return type annotation for public function `migrate_add_text_index_cloud`
   |
21 | from db.database_manager import ConnectionType, DatabaseManager
22 |
23 | def migrate_add_text_index_cloud():
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
24 |     """Add text_index column to session_keystrokes table and populate it (CLOUD VERSION)."""
   |
   = help: Add return type annotation: `None`

migrate_add_text_index_cloud.py:24:5: D202 [*] No blank lines allowed after function docstring (found 1)
   |
23 | def migrate_add_text_index_cloud():
24 |     """Add text_index column to session_keystrokes table and populate it (CLOUD VERSION)."""
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D202
25 |     
26 |     print("=== Adding text_index column to session_keystrokes table (CLOUD) ===")
   |
   = help: Remove blank line(s) after function docstring

models\__init__.py:1:1: D212 [*] Multi-line docstring summary should start at the first line
  |
1 | / """
2 | | Models package for AI Typing Trainer.
3 | |
4 | | This package contains all the data models and related functionality.
5 | | """
  | |___^ D212
6 |
7 |   # Import key modules to make them available at the package level
  |
  = help: Remove whitespace after opening quotes

models\category.py:1:1: D205 1 blank line required between summary line and description
  |
1 | / """
2 | | Category data model.
3 | | Defines the structure and validation for a category.
4 | | """
  | |___^ D205
5 |
6 |   from __future__ import annotations
  |
  = help: Insert single blank line

models\category.py:1:1: D212 [*] Multi-line docstring summary should start at the first line
  |
1 | / """
2 | | Category data model.
3 | | Defines the structure and validation for a category.
4 | | """
  | |___^ D212
5 |
6 |   from __future__ import annotations
  |
  = help: Remove whitespace after opening quotes

models\category.py:57:9: D102 Missing docstring in public method
   |
55 |     @model_validator(mode="before")
56 |     @classmethod
57 |     def ensure_category_id(cls, values: dict) -> dict:
   |         ^^^^^^^^^^^^^^^^^^ D102
58 |         if not values.get("category_id"):
59 |             values["category_id"] = str(uuid4())
   |

models\category_manager.py:1:1: D205 1 blank line required between summary line and description
  |
1 | / """
2 | | Category Manager for CRUD operations.
3 | | Handles all DB access for categories.
4 | | """
  | |___^ D205
5 |
6 |   from typing import List, Optional
  |
  = help: Insert single blank line

models\category_manager.py:1:1: D212 [*] Multi-line docstring summary should start at the first line
  |
1 | / """
2 | | Category Manager for CRUD operations.
3 | | Handles all DB access for categories.
4 | | """
  | |___^ D212
5 |
6 |   from typing import List, Optional
  |
  = help: Remove whitespace after opening quotes

models\category_manager.py:19:9: D107 Missing docstring in `__init__`
   |
17 |     """
18 |
19 |     def __init__(self, message: str = "Category validation failed") -> None:
   |         ^^^^^^^^ D107
20 |         self.message = message
21 |         super().__init__(self.message)
   |

models\category_manager.py:31:9: D107 Missing docstring in `__init__`
   |
29 |     """
30 |
31 |     def __init__(self, message: str = "Category not found") -> None:
   |         ^^^^^^^^ D107
32 |         self.message = message
33 |         super().__init__(self.message)
   |

models\category_manager.py:37:5: D200 One-line docstring should fit on one line
   |
36 |   class CategoryManager:
37 | /     """
38 | |     Manager for CRUD operations on Category, using DatabaseManager for DB access.
39 | |     """
   | |_______^ D200
40 |
41 |       def __init__(self, db_manager: DatabaseManager) -> None:
   |
   = help: Reformat to one line

models\category_manager.py:37:5: D212 [*] Multi-line docstring summary should start at the first line
   |
36 |   class CategoryManager:
37 | /     """
38 | |     Manager for CRUD operations on Category, using DatabaseManager for DB access.
39 | |     """
   | |_______^ D212
40 |
41 |       def __init__(self, db_manager: DatabaseManager) -> None:
   |
   = help: Remove whitespace after opening quotes

models\category_manager.py:42:9: D200 One-line docstring should fit on one line
   |
41 |       def __init__(self, db_manager: DatabaseManager) -> None:
42 | /         """
43 | |         Initialize CategoryManager with a DatabaseManager instance.
44 | |         """
   | |___________^ D200
45 |           self.db_manager: DatabaseManager = db_manager
   |
   = help: Reformat to one line

models\category_manager.py:42:9: D212 [*] Multi-line docstring summary should start at the first line
   |
41 |       def __init__(self, db_manager: DatabaseManager) -> None:
42 | /         """
43 | |         Initialize CategoryManager with a DatabaseManager instance.
44 | |         """
   | |___________^ D212
45 |           self.db_manager: DatabaseManager = db_manager
   |
   = help: Remove whitespace after opening quotes

models\category_manager.py:50:9: D205 1 blank line required between summary line and description
   |
48 |           self, category_name: str, category_id: Optional[str] = None
49 |       ) -> None:
50 | /         """
51 | |         Validate category name for database uniqueness.
52 | |         This complements the Pydantic model's format validation.
53 | |
54 | |         Args:
55 | |             category_name: The category name to validate.
56 | |             category_id: The ID of the category being updated, if any.
57 | |
58 | |         Raises:
59 | |             CategoryValidationError: If the name is not unique.
60 | |         """
   | |___________^ D205
61 |           query = "SELECT 1 FROM categories WHERE category_name = ?"
62 |           params = [category_name]
   |
   = help: Insert single blank line

models\category_manager.py:50:9: D212 [*] Multi-line docstring summary should start at the first line
   |
48 |           self, category_name: str, category_id: Optional[str] = None
49 |       ) -> None:
50 | /         """
51 | |         Validate category name for database uniqueness.
52 | |         This complements the Pydantic model's format validation.
53 | |
54 | |         Args:
55 | |             category_name: The category name to validate.
56 | |             category_id: The ID of the category being updated, if any.
57 | |
58 | |         Raises:
59 | |             CategoryValidationError: If the name is not unique.
60 | |         """
   | |___________^ D212
61 |           query = "SELECT 1 FROM categories WHERE category_name = ?"
62 |           params = [category_name]
   |
   = help: Remove whitespace after opening quotes

models\category_manager.py:72:9: D205 1 blank line required between summary line and description
   |
71 |       def get_category_by_id(self, category_id: str) -> Category:
72 | /         """
73 | |         Retrieve a single category by ID.
74 | |         Args:
75 | |             category_id: The ID of the category to retrieve.
76 | |         Returns:
77 | |             Category: The category with the specified ID.
78 | |         Raises:
79 | |             CategoryNotFound: If no category exists with the specified ID.
80 | |         """
   | |___________^ D205
81 |           row = self.db_manager.execute(
82 |               "SELECT category_id, category_name FROM categories WHERE category_id = ?",
   |
   = help: Insert single blank line

models\category_manager.py:72:9: D212 [*] Multi-line docstring summary should start at the first line
   |
71 |       def get_category_by_id(self, category_id: str) -> Category:
72 | /         """
73 | |         Retrieve a single category by ID.
74 | |         Args:
75 | |             category_id: The ID of the category to retrieve.
76 | |         Returns:
77 | |             Category: The category with the specified ID.
78 | |         Raises:
79 | |             CategoryNotFound: If no category exists with the specified ID.
80 | |         """
   | |___________^ D212
81 |           row = self.db_manager.execute(
82 |               "SELECT category_id, category_name FROM categories WHERE category_id = ?",
   |
   = help: Remove whitespace after opening quotes

models\category_manager.py:74:9: D410 [*] Missing blank line after section ("Args")
   |
72 |         """
73 |         Retrieve a single category by ID.
74 |         Args:
   |         ^^^^ D410
75 |             category_id: The ID of the category to retrieve.
76 |         Returns:
   |
   = help: Add blank line after "Args"

models\category_manager.py:74:9: D411 [*] Missing blank line before section ("Args")
   |
72 |         """
73 |         Retrieve a single category by ID.
74 |         Args:
   |         ^^^^ D411
75 |             category_id: The ID of the category to retrieve.
76 |         Returns:
   |
   = help: Add blank line before "Args"

models\category_manager.py:76:9: D410 [*] Missing blank line after section ("Returns")
   |
74 |         Args:
75 |             category_id: The ID of the category to retrieve.
76 |         Returns:
   |         ^^^^^^^ D410
77 |             Category: The category with the specified ID.
78 |         Raises:
   |
   = help: Add blank line after "Returns"

models\category_manager.py:76:9: D411 [*] Missing blank line before section ("Returns")
   |
74 |         Args:
75 |             category_id: The ID of the category to retrieve.
76 |         Returns:
   |         ^^^^^^^ D411
77 |             Category: The category with the specified ID.
78 |         Raises:
   |
   = help: Add blank line before "Returns"

models\category_manager.py:78:9: D411 [*] Missing blank line before section ("Raises")
   |
76 |         Returns:
77 |             Category: The category with the specified ID.
78 |         Raises:
   |         ^^^^^^ D411
79 |             CategoryNotFound: If no category exists with the specified ID.
80 |         """
   |
   = help: Add blank line before "Raises"

models\category_manager.py:90:9: D205 1 blank line required between summary line and description
    |
 89 |       def get_category_by_name(self, category_name: str) -> Category:
 90 | /         """
 91 | |         Retrieve a single category by name.
 92 | |         Args:
 93 | |             category_name: The name of the category to retrieve.
 94 | |         Returns:
 95 | |             Category: The category with the specified name.
 96 | |         Raises:
 97 | |             CategoryNotFound: If no category exists with the specified name.
 98 | |         """
    | |___________^ D205
 99 |           row = self.db_manager.execute(
100 |               "SELECT category_id, category_name FROM categories WHERE category_name = ?",
    |
    = help: Insert single blank line

models\category_manager.py:90:9: D212 [*] Multi-line docstring summary should start at the first line
    |
 89 |       def get_category_by_name(self, category_name: str) -> Category:
 90 | /         """
 91 | |         Retrieve a single category by name.
 92 | |         Args:
 93 | |             category_name: The name of the category to retrieve.
 94 | |         Returns:
 95 | |             Category: The category with the specified name.
 96 | |         Raises:
 97 | |             CategoryNotFound: If no category exists with the specified name.
 98 | |         """
    | |___________^ D212
 99 |           row = self.db_manager.execute(
100 |               "SELECT category_id, category_name FROM categories WHERE category_name = ?",
    |
    = help: Remove whitespace after opening quotes

models\category_manager.py:92:9: D410 [*] Missing blank line after section ("Args")
   |
90 |         """
91 |         Retrieve a single category by name.
92 |         Args:
   |         ^^^^ D410
93 |             category_name: The name of the category to retrieve.
94 |         Returns:
   |
   = help: Add blank line after "Args"

models\category_manager.py:92:9: D411 [*] Missing blank line before section ("Args")
   |
90 |         """
91 |         Retrieve a single category by name.
92 |         Args:
   |         ^^^^ D411
93 |             category_name: The name of the category to retrieve.
94 |         Returns:
   |
   = help: Add blank line before "Args"

models\category_manager.py:94:9: D410 [*] Missing blank line after section ("Returns")
   |
92 |         Args:
93 |             category_name: The name of the category to retrieve.
94 |         Returns:
   |         ^^^^^^^ D410
95 |             Category: The category with the specified name.
96 |         Raises:
   |
   = help: Add blank line after "Returns"

models\category_manager.py:94:9: D411 [*] Missing blank line before section ("Returns")
   |
92 |         Args:
93 |             category_name: The name of the category to retrieve.
94 |         Returns:
   |         ^^^^^^^ D411
95 |             Category: The category with the specified name.
96 |         Raises:
   |
   = help: Add blank line before "Returns"

models\category_manager.py:96:9: D411 [*] Missing blank line before section ("Raises")
   |
94 |         Returns:
95 |             Category: The category with the specified name.
96 |         Raises:
   |         ^^^^^^ D411
97 |             CategoryNotFound: If no category exists with the specified name.
98 |         """
   |
   = help: Add blank line before "Raises"

models\category_manager.py:108:9: D205 1 blank line required between summary line and description
    |
107 |       def list_all_categories(self) -> List[Category]:
108 | /         """
109 | |         List all categories in the database.
110 | |         Returns:
111 | |             List[Category]: All categories, ordered by name.
112 | |         """
    | |___________^ D205
113 |           rows = self.db_manager.execute(
114 |               "SELECT category_id, category_name FROM categories ORDER BY category_name"
    |
    = help: Insert single blank line

models\category_manager.py:108:9: D212 [*] Multi-line docstring summary should start at the first line
    |
107 |       def list_all_categories(self) -> List[Category]:
108 | /         """
109 | |         List all categories in the database.
110 | |         Returns:
111 | |             List[Category]: All categories, ordered by name.
112 | |         """
    | |___________^ D212
113 |           rows = self.db_manager.execute(
114 |               "SELECT category_id, category_name FROM categories ORDER BY category_name"
    |
    = help: Remove whitespace after opening quotes

models\category_manager.py:110:9: D411 [*] Missing blank line before section ("Returns")
    |
108 |         """
109 |         List all categories in the database.
110 |         Returns:
    |         ^^^^^^^ D411
111 |             List[Category]: All categories, ordered by name.
112 |         """
    |
    = help: Add blank line before "Returns"

models\category_manager.py:125:9: D205 1 blank line required between summary line and description
    |
124 |       def save_category(self, category: Category) -> bool:
125 | /         """
126 | |         Insert or update a category in the DB. Returns True if successful.
127 | |         Args:
128 | |             category: The Category object to save.
129 | |         Returns:
130 | |             True if the category was inserted or updated successfully.
131 | |         Raises:
132 | |             CategoryValidationError: If the category name is not unique.
133 | |             ValueError: If validation fails (e.g., invalid data).
134 | |             DatabaseError: If a database operation fails.
135 | |         """
    | |___________^ D205
136 |           # Explicitly validate uniqueness before DB operation
137 |           self._validate_name_uniqueness(category.category_name, category.category_id)
    |
    = help: Insert single blank line

models\category_manager.py:125:9: D212 [*] Multi-line docstring summary should start at the first line
    |
124 |       def save_category(self, category: Category) -> bool:
125 | /         """
126 | |         Insert or update a category in the DB. Returns True if successful.
127 | |         Args:
128 | |             category: The Category object to save.
129 | |         Returns:
130 | |             True if the category was inserted or updated successfully.
131 | |         Raises:
132 | |             CategoryValidationError: If the category name is not unique.
133 | |             ValueError: If validation fails (e.g., invalid data).
134 | |             DatabaseError: If a database operation fails.
135 | |         """
    | |___________^ D212
136 |           # Explicitly validate uniqueness before DB operation
137 |           self._validate_name_uniqueness(category.category_name, category.category_id)
    |
    = help: Remove whitespace after opening quotes

models\category_manager.py:127:9: D410 [*] Missing blank line after section ("Args")
    |
125 |         """
126 |         Insert or update a category in the DB. Returns True if successful.
127 |         Args:
    |         ^^^^ D410
128 |             category: The Category object to save.
129 |         Returns:
    |
    = help: Add blank line after "Args"

models\category_manager.py:127:9: D411 [*] Missing blank line before section ("Args")
    |
125 |         """
126 |         Insert or update a category in the DB. Returns True if successful.
127 |         Args:
    |         ^^^^ D411
128 |             category: The Category object to save.
129 |         Returns:
    |
    = help: Add blank line before "Args"

models\category_manager.py:129:9: D410 [*] Missing blank line after section ("Returns")
    |
127 |         Args:
128 |             category: The Category object to save.
129 |         Returns:
    |         ^^^^^^^ D410
130 |             True if the category was inserted or updated successfully.
131 |         Raises:
    |
    = help: Add blank line after "Returns"

models\category_manager.py:129:9: D411 [*] Missing blank line before section ("Returns")
    |
127 |         Args:
128 |             category: The Category object to save.
129 |         Returns:
    |         ^^^^^^^ D411
130 |             True if the category was inserted or updated successfully.
131 |         Raises:
    |
    = help: Add blank line before "Returns"

models\category_manager.py:131:9: D411 [*] Missing blank line before section ("Raises")
    |
129 |         Returns:
130 |             True if the category was inserted or updated successfully.
131 |         Raises:
    |         ^^^^^^ D411
132 |             CategoryValidationError: If the category name is not unique.
133 |             ValueError: If validation fails (e.g., invalid data).
    |
    = help: Add blank line before "Raises"

models\category_manager.py:164:9: D212 [*] Multi-line docstring summary should start at the first line
    |
163 |       def delete_category_by_id(self, category_id: str) -> bool:
164 | /         """
165 | |         Delete a category by its ID.
166 | |
167 | |         Returns:
168 | |             bool: True if deleted, False if not found.
169 | |
170 | |         Note:
171 | |             Cascades to delete associated snippets and snippet_parts if DB schema
172 | |             supports it.
173 | |         """
    | |___________^ D212
174 |           # Ensure the category exists
175 |           if not self.db_manager.execute(
    |
    = help: Remove whitespace after opening quotes

models\category_manager.py:187:9: D212 [*] Multi-line docstring summary should start at the first line
    |
186 |       def delete_category(self, category_id: str) -> bool:
187 | /         """
188 | |         Delete a category by its ID.
189 | |
190 | |         This is an alias for delete_category_by_id for test compatibility.
191 | |         """
    | |___________^ D212
192 |           return self.delete_category_by_id(category_id)
    |
    = help: Remove whitespace after opening quotes

models\category_manager.py:195:9: D205 1 blank line required between summary line and description
    |
194 |       def delete_all_categories(self) -> bool:
195 | /         """
196 | |         Delete all categories from the database.
197 | |         Returns True if any were deleted, False if already empty.
198 | |         """
    | |___________^ D205
199 |           count = self.db_manager.execute("SELECT COUNT(*) FROM categories").fetchone()[0]
200 |           self.db_manager.execute("DELETE FROM categories")
    |
    = help: Insert single blank line

models\category_manager.py:195:9: D212 [*] Multi-line docstring summary should start at the first line
    |
194 |       def delete_all_categories(self) -> bool:
195 | /         """
196 | |         Delete all categories from the database.
197 | |         Returns True if any were deleted, False if already empty.
198 | |         """
    | |___________^ D212
199 |           count = self.db_manager.execute("SELECT COUNT(*) FROM categories").fetchone()[0]
200 |           self.db_manager.execute("DELETE FROM categories")
    |
    = help: Remove whitespace after opening quotes

models\category_manager.py:204:9: D212 [*] Multi-line docstring summary should start at the first line
    |
203 |       def create_dynamic_category(self) -> str:
204 | /         """
205 | |         Create or retrieve a category named 'Custom Snippets' for dynamic content.
206 | |         
207 | |         This method ensures that a standard category exists for dynamic and custom
208 | |         snippets generated by the application. If the category already exists,
209 | |         it returns the existing category's ID. If not, it creates the category
210 | |         and returns the new ID.
211 | |         
212 | |         Returns:
213 | |             str: The category_id of the 'Custom Snippets' category
214 | |             
215 | |         Raises:
216 | |             CategoryValidationError: If there are validation issues
217 | |             DatabaseError: If database operations fail
218 | |         """
    | |___________^ D212
219 |           category_name = "Custom Snippets"
220 |           try:
    |
    = help: Remove whitespace after opening quotes

models\dynamic_content_manager.py:1:1: D205 1 blank line required between summary line and description
  |
1 | / """
2 | | Dynamic Content Manager for generating typing practice content.
3 | | Handles different generation modes (NGramOnly, WordsOnly, Mixed)
4 | | for customizable practice.
5 | | """
  | |___^ D205
6 |
7 |   import random
  |
  = help: Insert single blank line

models\dynamic_content_manager.py:1:1: D212 [*] Multi-line docstring summary should start at the first line
  |
1 | / """
2 | | Dynamic Content Manager for generating typing practice content.
3 | | Handles different generation modes (NGramOnly, WordsOnly, Mixed)
4 | | for customizable practice.
5 | | """
  | |___^ D212
6 |
7 |   import random
  |
  = help: Remove whitespace after opening quotes

models\dynamic_content_manager.py:23:5: D205 1 blank line required between summary line and description
   |
22 |   class DynamicContentManager:
23 | /     """
24 | |     Manager for generating dynamic typing practice content based on
25 | |     specified parameters.
26 | |
27 | |     Supports different content generation modes:
28 | |     - NGramOnly: Uses only the specified ngrams
29 | |     - WordsOnly: Uses words containing the specified ngrams and in-scope keys
30 | |     - Mixed: Combination of both ngram sequences and words
31 | |     """
   | |_______^ D205
32 |
33 |       def __init__(
   |
   = help: Insert single blank line

models\dynamic_content_manager.py:23:5: D212 [*] Multi-line docstring summary should start at the first line
   |
22 |   class DynamicContentManager:
23 | /     """
24 | |     Manager for generating dynamic typing practice content based on
25 | |     specified parameters.
26 | |
27 | |     Supports different content generation modes:
28 | |     - NGramOnly: Uses only the specified ngrams
29 | |     - WordsOnly: Uses words containing the specified ngrams and in-scope keys
30 | |     - Mixed: Combination of both ngram sequences and words
31 | |     """
   | |_______^ D212
32 |
33 |       def __init__(
   |
   = help: Remove whitespace after opening quotes

models\dynamic_content_manager.py:41:9: D212 [*] Multi-line docstring summary should start at the first line
   |
39 |           llm_service: Optional[LLMNgramService] = None,
40 |       ) -> None:
41 | /         """
42 | |         Initialize the DynamicContentManager with customizable parameters.
43 | |
44 | |         Args:
45 | |             in_scope_keys: List of characters (keyboard keys) that are allowed
46 | |                 in generated content
47 | |             practice_length: Maximum length of generated content (1-1000 characters)
48 | |             ngram_focus_list: List of ngrams to focus on in the generated content
49 | |             mode: Content generation mode (NGramOnly, WordsOnly, or Mixed)
50 | |             llm_service: Optional LLMNgramService instance for word generation
51 | |         """
   | |___________^ D212
52 |           self.in_scope_keys: List[str] = in_scope_keys or []
53 |           self._set_practice_length(practice_length)
   |
   = help: Remove whitespace after opening quotes

models\dynamic_content_manager.py:142:9: D205 1 blank line required between summary line and description
    |
141 |       def _generate_words_content(self, max_length: int, delimiter: str) -> str:
142 | /         """
143 | |         Generate content using words that contain the focus ngrams
144 | |         and only use in-scope keys.
145 | |         Requires the LLM service.
146 | |         """
    | |___________^ D205
147 |           if not self.llm_service:
148 |               return ""
    |
    = help: Insert single blank line

models\dynamic_content_manager.py:142:9: D212 [*] Multi-line docstring summary should start at the first line
    |
141 |       def _generate_words_content(self, max_length: int, delimiter: str) -> str:
142 | /         """
143 | |         Generate content using words that contain the focus ngrams
144 | |         and only use in-scope keys.
145 | |         Requires the LLM service.
146 | |         """
    | |___________^ D212
147 |           if not self.llm_service:
148 |               return ""
    |
    = help: Remove whitespace after opening quotes

models\dynamic_content_manager.py:247:9: D212 [*] Multi-line docstring summary should start at the first line
    |
246 |       def generate_content(self, delimiter: str = " ") -> str:
247 | /         """
248 | |         Generate typing practice content based on the configured parameters.
249 | |
250 | |         Args:
251 | |             delimiter: String to use between ngrams/words (default: space)
252 | |
253 | |         Returns:
254 | |             Generated practice content string
255 | |
256 | |         Raises:
257 | |             ValueError: If required parameters are missing or invalid
258 | |         """
    | |___________^ D212
259 |           self._validate_requirements()
    |
    = help: Remove whitespace after opening quotes

models\dynamic_content_service.py:1:1: D205 1 blank line required between summary line and description
  |
1 | / """
2 | | Dynamic Content Service for generating typing practice content.
3 | | Handles different generation modes (NGramOnly, WordsOnly, Mixed)
4 | | for customizable practice.
5 | | """
  | |___^ D205
6 |
7 |   import random
  |
  = help: Insert single blank line

models\dynamic_content_service.py:1:1: D212 [*] Multi-line docstring summary should start at the first line
  |
1 | / """
2 | | Dynamic Content Service for generating typing practice content.
3 | | Handles different generation modes (NGramOnly, WordsOnly, Mixed)
4 | | for customizable practice.
5 | | """
  | |___^ D212
6 |
7 |   import random
  |
  = help: Remove whitespace after opening quotes

models\dynamic_content_service.py:25:5: D205 1 blank line required between summary line and description
   |
24 |   class DynamicContentService:
25 | /     """
26 | |     Service for generating dynamic typing practice content based on
27 | |     specified parameters.
28 | |
29 | |     Supports different content generation modes:
30 | |     - NGramOnly: Uses only the specified ngrams
31 | |     - WordsOnly: Uses words containing the specified ngrams and in-scope keys
32 | |     - Mixed: Combination of both ngram sequences and words
33 | |     """
   | |_______^ D205
34 |
35 |       def __init__(
   |
   = help: Insert single blank line

models\dynamic_content_service.py:25:5: D212 [*] Multi-line docstring summary should start at the first line
   |
24 |   class DynamicContentService:
25 | /     """
26 | |     Service for generating dynamic typing practice content based on
27 | |     specified parameters.
28 | |
29 | |     Supports different content generation modes:
30 | |     - NGramOnly: Uses only the specified ngrams
31 | |     - WordsOnly: Uses words containing the specified ngrams and in-scope keys
32 | |     - Mixed: Combination of both ngram sequences and words
33 | |     """
   | |_______^ D212
34 |
35 |       def __init__(
   |
   = help: Remove whitespace after opening quotes

models\dynamic_content_service.py:43:9: D212 [*] Multi-line docstring summary should start at the first line
   |
41 |           llm_service: Optional[LLMNgramService] = None,
42 |       ) -> None:
43 | /         """
44 | |         Initialize the DynamicContentService with customizable parameters.
45 | |
46 | |         Args:
47 | |             in_scope_keys: List of characters (keyboard keys) that are allowed
48 | |                 in generated content
49 | |             practice_length: Maximum length of generated content (1-1000 characters)
50 | |             ngram_focus_list: List of ngrams to focus on in the generated content
51 | |             mode: Content generation mode (NGramOnly, WordsOnly, or Mixed)
52 | |             llm_service: Optional LLMNgramService instance for word generation
53 | |         """
   | |___________^ D212
54 |           self.in_scope_keys: List[str] = in_scope_keys or []
55 |           self._set_practice_length(practice_length)
   |
   = help: Remove whitespace after opening quotes

models\dynamic_content_service.py:144:9: D205 1 blank line required between summary line and description
    |
143 |       def _generate_words_content(self, max_length: int, delimiter: str) -> str:
144 | /         """
145 | |         Generate content using words that contain the focus ngrams
146 | |         and only use in-scope keys.
147 | |         Requires the LLM service.
148 | |         """
    | |___________^ D205
149 |           if not self.llm_service:
150 |               raise ValueError("LLM service is required for word generation")
    |
    = help: Insert single blank line

models\dynamic_content_service.py:144:9: D212 [*] Multi-line docstring summary should start at the first line
    |
143 |       def _generate_words_content(self, max_length: int, delimiter: str) -> str:
144 | /         """
145 | |         Generate content using words that contain the focus ngrams
146 | |         and only use in-scope keys.
147 | |         Requires the LLM service.
148 | |         """
    | |___________^ D212
149 |           if not self.llm_service:
150 |               raise ValueError("LLM service is required for word generation")
    |
    = help: Remove whitespace after opening quotes

models\dynamic_content_service.py:249:9: D212 [*] Multi-line docstring summary should start at the first line
    |
248 |       def generate_content(self, delimiter: str = " ") -> str:
249 | /         """
250 | |         Generate typing practice content based on the configured parameters.
251 | |
252 | |         Args:
253 | |             delimiter: String to use between ngrams/words (default: space)
254 | |
255 | |         Returns:
256 | |             Generated practice content string
257 | |
258 | |         Raises:
259 | |             ValueError: If required parameters are missing or invalid
260 | |         """
    | |___________^ D212
261 |           self._validate_requirements()
    |
    = help: Remove whitespace after opening quotes

models\dynamic_content_service.py:271:9: D205 1 blank line required between summary line and description
    |
270 |       def ensure_dynamic_snippet_id(self, category_manager: CategoryManager, snippet_manager: SnippetManager) -> str:
271 | /         """
272 | |         Ensure a valid dynamic snippet_id exists by coordinating with
273 | |         CategoryManager and SnippetManager.
274 | |
275 | |         This method:
276 | |         1. Uses CategoryManager.create_dynamic_category() to get the
277 | |            "Custom Snippets" category_id
278 | |         2. Uses SnippetManager.create_dynamic_snippet() to get or create a
279 | |            dynamic snippet
280 | |         3. Returns the snippet_id for use in typing drills
281 | |
282 | |         Args:
283 | |             category_manager: CategoryManager instance for category operations
284 | |             snippet_manager: SnippetManager instance for snippet operations
285 | |
286 | |         Returns:
287 | |             str: The snippet_id of the dynamic snippet that can be used in
288 | |             typing drills
289 | |
290 | |         Raises:
291 | |             Exception: If category or snippet creation fails
292 | |         """
    | |___________^ D205
293 |           try:
294 |               # Step 1: Ensure "Custom Snippets" category exists and get its ID
    |
    = help: Insert single blank line

models\dynamic_content_service.py:271:9: D212 [*] Multi-line docstring summary should start at the first line
    |
270 |       def ensure_dynamic_snippet_id(self, category_manager: CategoryManager, snippet_manager: SnippetManager) -> str:
271 | /         """
272 | |         Ensure a valid dynamic snippet_id exists by coordinating with
273 | |         CategoryManager and SnippetManager.
274 | |
275 | |         This method:
276 | |         1. Uses CategoryManager.create_dynamic_category() to get the
277 | |            "Custom Snippets" category_id
278 | |         2. Uses SnippetManager.create_dynamic_snippet() to get or create a
279 | |            dynamic snippet
280 | |         3. Returns the snippet_id for use in typing drills
281 | |
282 | |         Args:
283 | |             category_manager: CategoryManager instance for category operations
284 | |             snippet_manager: SnippetManager instance for snippet operations
285 | |
286 | |         Returns:
287 | |             str: The snippet_id of the dynamic snippet that can be used in
288 | |             typing drills
289 | |
290 | |         Raises:
291 | |             Exception: If category or snippet creation fails
292 | |         """
    | |___________^ D212
293 |           try:
294 |               # Step 1: Ensure "Custom Snippets" category exists and get its ID
    |
    = help: Remove whitespace after opening quotes

models\keyboard.py:1:1: D205 1 blank line required between summary line and description
  |
1 | / """
2 | | Keyboard data model.
3 | | Defines the structure and validation for a keyboard.
4 | | """
  | |___^ D205
5 |
6 |   from __future__ import annotations
  |
  = help: Insert single blank line

models\keyboard.py:1:1: D212 [*] Multi-line docstring summary should start at the first line
  |
1 | / """
2 | | Keyboard data model.
3 | | Defines the structure and validation for a keyboard.
4 | | """
  | |___^ D212
5 |
6 |   from __future__ import annotations
  |
  = help: Remove whitespace after opening quotes

models\keyboard.py:15:5: D205 1 blank line required between summary line and description
   |
14 |   class Keyboard(BaseModel):
15 | /     """Keyboard data model with validation.
16 | |     Attributes:
17 | |         keyboard_id: Unique identifier for the keyboard (UUID string).
18 | |         user_id: UUID string, foreign key to user table.
19 | |         keyboard_name: Name of the keyboard (ASCII, 1-64 chars).
20 | |         target_ms_per_keystroke: Target milliseconds per keystroke for speed goal
21 | |         (integer).
22 | |     """
   | |_______^ D205
23 |
24 |       keyboard_id: str | None = None
   |
   = help: Insert single blank line

models\keyboard.py:16:5: D411 [*] Missing blank line before section ("Attributes")
   |
14 | class Keyboard(BaseModel):
15 |     """Keyboard data model with validation.
16 |     Attributes:
   |     ^^^^^^^^^^ D411
17 |         keyboard_id: Unique identifier for the keyboard (UUID string).
18 |         user_id: UUID string, foreign key to user table.
   |
   = help: Add blank line before "Attributes"

models\keyboard.py:33:9: D102 Missing docstring in public method
   |
31 |     @field_validator("keyboard_name")
32 |     @classmethod
33 |     def validate_keyboard_name(cls, v: str) -> str:
   |         ^^^^^^^^^^^^^^^^^^^^^^ D102
34 |         if not v or not v.strip():
35 |             raise ValueError("Keyboard name cannot be blank.")
   |

models\keyboard.py:45:9: D102 Missing docstring in public method
   |
43 |     @field_validator("target_ms_per_keystroke")
44 |     @classmethod
45 |     def validate_target_ms_per_keystroke(cls, v: int) -> int:
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
46 |         if v is None:
47 |             raise ValueError("Target milliseconds per keystroke cannot be None.")
   |

models\keyboard.py:58:9: D102 Missing docstring in public method
   |
56 |     @model_validator(mode="before")
57 |     @classmethod
58 |     def ensure_keyboard_id(cls, values: dict) -> dict:
   |         ^^^^^^^^^^^^^^^^^^ D102
59 |         if not values.get("keyboard_id"):
60 |             values["keyboard_id"] = str(uuid4())
   |

models\keyboard.py:65:9: D102 Missing docstring in public method
   |
63 |     @field_validator("keyboard_id")
64 |     @classmethod
65 |     def validate_keyboard_id(cls, v: str) -> str:
   |         ^^^^^^^^^^^^^^^^^^^^ D102
66 |         if not v:
67 |             raise ValueError("keyboard_id must not be empty")
   |

models\keyboard.py:76:9: D102 Missing docstring in public method
   |
74 |     @field_validator("user_id")
75 |     @classmethod
76 |     def validate_user_id(cls, v: str) -> str:
   |         ^^^^^^^^^^^^^^^^ D102
77 |         if not v:
78 |             raise ValueError("user_id must not be empty")
   |

models\keyboard.py:85:9: D102 Missing docstring in public method
   |
83 |         return v
84 |
85 |     def to_dict(self) -> Dict[str, Any]:
   |         ^^^^^^^ D102
86 |         return self.dict()
   |

models\keyboard.py:89:9: D102 Missing docstring in public method
   |
88 |     @classmethod
89 |     def from_dict(cls, d: Dict[str, Any]) -> "Keyboard":
   |         ^^^^^^^^^ D102
90 |         allowed = set(cls.model_fields.keys())
91 |         extra = set(d.keys()) - allowed
   |

models\keyboard_manager.py:1:1: D205 1 blank line required between summary line and description
  |
1 | / """
2 | | Keyboard Manager for CRUD operations.
3 | | Handles all DB access for keyboards.
4 | | """
  | |___^ D205
5 |
6 |   from typing import List, Optional
  |
  = help: Insert single blank line

models\keyboard_manager.py:1:1: D212 [*] Multi-line docstring summary should start at the first line
  |
1 | / """
2 | | Keyboard Manager for CRUD operations.
3 | | Handles all DB access for keyboards.
4 | | """
  | |___^ D212
5 |
6 |   from typing import List, Optional
  |
  = help: Remove whitespace after opening quotes

models\keyboard_manager.py:12:7: D101 Missing docstring in public class
   |
12 | class KeyboardValidationError(Exception):
   |       ^^^^^^^^^^^^^^^^^^^^^^^ D101
13 |     def __init__(self, message: str = "Keyboard validation failed") -> None:
14 |         self.message = message
   |

models\keyboard_manager.py:13:9: D107 Missing docstring in `__init__`
   |
12 | class KeyboardValidationError(Exception):
13 |     def __init__(self, message: str = "Keyboard validation failed") -> None:
   |         ^^^^^^^^ D107
14 |         self.message = message
15 |         super().__init__(self.message)
   |

models\keyboard_manager.py:18:7: D101 Missing docstring in public class
   |
18 | class KeyboardNotFound(Exception):
   |       ^^^^^^^^^^^^^^^^ D101
19 |     def __init__(self, message: str = "Keyboard not found") -> None:
20 |         self.message = message
   |

models\keyboard_manager.py:19:9: D107 Missing docstring in `__init__`
   |
18 | class KeyboardNotFound(Exception):
19 |     def __init__(self, message: str = "Keyboard not found") -> None:
   |         ^^^^^^^^ D107
20 |         self.message = message
21 |         super().__init__(self.message)
   |

models\keyboard_manager.py:24:7: D101 Missing docstring in public class
   |
24 | class KeyboardManager:
   |       ^^^^^^^^^^^^^^^ D101
25 |     def __init__(self, db_manager: DatabaseManager) -> None:
26 |         self.db_manager: DatabaseManager = db_manager
   |

models\keyboard_manager.py:25:9: D107 Missing docstring in `__init__`
   |
24 | class KeyboardManager:
25 |     def __init__(self, db_manager: DatabaseManager) -> None:
   |         ^^^^^^^^ D107
26 |         self.db_manager: DatabaseManager = db_manager
   |

models\keyboard_manager.py:41:9: D102 Missing docstring in public method
   |
39 |             )
40 |
41 |     def get_keyboard_by_id(self, keyboard_id: str) -> Keyboard:
   |         ^^^^^^^^^^^^^^^^^^ D102
42 |         row = self.db_manager.execute(
43 |             """
   |

models\keyboard_manager.py:59:9: D102 Missing docstring in public method
   |
57 |         )
58 |
59 |     def list_keyboards_for_user(self, user_id: str) -> List[Keyboard]:
   |         ^^^^^^^^^^^^^^^^^^^^^^^ D102
60 |         rows = self.db_manager.execute(
61 |             """
   |

models\keyboard_manager.py:78:9: D102 Missing docstring in public method
   |
76 |         ]
77 |
78 |     def save_keyboard(self, keyboard: Keyboard) -> bool:
   |         ^^^^^^^^^^^^^ D102
79 |         self._validate_name_uniqueness(
80 |             keyboard.keyboard_name, keyboard.user_id, keyboard.keyboard_id
   |

models\keyboard_manager.py:128:9: D102 Missing docstring in public method
    |
126 |         return True
127 |
128 |     def delete_keyboard_by_id(self, keyboard_id: str) -> bool:
    |         ^^^^^^^^^^^^^^^^^^^^^ D102
129 |         if not self.db_manager.execute(
130 |             "SELECT 1 FROM keyboards WHERE keyboard_id = ?",
    |

models\keyboard_manager.py:140:9: D102 Missing docstring in public method
    |
138 |         return True
139 |
140 |     def delete_keyboard(self, keyboard_id: str) -> bool:
    |         ^^^^^^^^^^^^^^^ D102
141 |         return self.delete_keyboard_by_id(keyboard_id)
    |

models\keyboard_manager.py:143:9: D102 Missing docstring in public method
    |
141 |         return self.delete_keyboard_by_id(keyboard_id)
142 |
143 |     def delete_all_keyboards(self) -> bool:
    |         ^^^^^^^^^^^^^^^^^^^^ D102
144 |         count = self.db_manager.execute("SELECT COUNT(*) FROM keyboards").fetchone()[0]
145 |         self.db_manager.execute("DELETE FROM keyboards")
    |

models\keystroke.py:1:1: D200 One-line docstring should fit on one line
  |
1 | / """
2 | | Keystroke model for tracking keystrokes during practice sessions.
3 | | """
  | |___^ D200
4 |
5 |   import datetime
  |
  = help: Reformat to one line

models\keystroke.py:1:1: D212 [*] Multi-line docstring summary should start at the first line
  |
1 | / """
2 | | Keystroke model for tracking keystrokes during practice sessions.
3 | | """
  | |___^ D212
4 |
5 |   import datetime
  |
  = help: Remove whitespace after opening quotes

models\keystroke.py:18:5: D200 One-line docstring should fit on one line
   |
17 |   class Keystroke(BaseModel):
18 | /     """
19 | |     Pydantic model for tracking individual keystrokes in practice sessions.
20 | |     """
   | |_______^ D200
21 |
22 |       session_id: Optional[str] = None
   |
   = help: Reformat to one line

models\keystroke.py:18:5: D212 [*] Multi-line docstring summary should start at the first line
   |
17 |   class Keystroke(BaseModel):
18 | /     """
19 | |     Pydantic model for tracking individual keystrokes in practice sessions.
20 | |     """
   | |_______^ D212
21 |
22 |       session_id: Optional[str] = None
   |
   = help: Remove whitespace after opening quotes

models\keystroke.py:166:9: D212 [*] Multi-line docstring summary should start at the first line
    |
164 |       @classmethod
165 |       def delete_all_keystrokes(cls, db: DatabaseManager) -> bool:
166 | /         """
167 | |         Delete all keystrokes from the database.
168 | |
169 | |         This will clear the session_keystrokes table.
170 | |
171 | |         Args:
172 | |             db: DatabaseManager instance to use for the operation
173 | |
174 | |         Returns:
175 | |             bool: True if successful, False otherwise
176 | |         """
    | |___________^ D212
177 |           try:
178 |               logger.info("Deleting all keystrokes from database")
    |
    = help: Remove whitespace after opening quotes

models\keystroke_manager.py:1:1: D100 Missing docstring in public module
models\keystroke_manager.py:8:5: D200 One-line docstring should fit on one line
   |
 7 |   class KeystrokeManager:
 8 | /     """
 9 | |     Manager class for handling keystroke operations in the database.
10 | |     """
   | |_______^ D200
11 |
12 |       def __init__(self, db_manager: Optional[DatabaseManager] = None) -> None:
   |
   = help: Reformat to one line

models\keystroke_manager.py:8:5: D212 [*] Multi-line docstring summary should start at the first line
   |
 7 |   class KeystrokeManager:
 8 | /     """
 9 | |     Manager class for handling keystroke operations in the database.
10 | |     """
   | |_______^ D212
11 |
12 |       def __init__(self, db_manager: Optional[DatabaseManager] = None) -> None:
   |
   = help: Remove whitespace after opening quotes

models\keystroke_manager.py:12:9: D107 Missing docstring in `__init__`
   |
10 |     """
11 |
12 |     def __init__(self, db_manager: Optional[DatabaseManager] = None) -> None:
   |         ^^^^^^^^ D107
13 |         self.db_manager = db_manager or DatabaseManager()
14 |         self.keystroke_list: List[Keystroke] = []
   |

models\keystroke_manager.py:17:9: D200 One-line docstring should fit on one line
   |
16 |       def add_keystroke(self, keystroke: Keystroke) -> None:
17 | /         """
18 | |         Add a single keystroke to the in-memory list.
19 | |         """
   | |___________^ D200
20 |           self.keystroke_list.append(keystroke)
   |
   = help: Reformat to one line

models\keystroke_manager.py:17:9: D212 [*] Multi-line docstring summary should start at the first line
   |
16 |       def add_keystroke(self, keystroke: Keystroke) -> None:
17 | /         """
18 | |         Add a single keystroke to the in-memory list.
19 | |         """
   | |___________^ D212
20 |           self.keystroke_list.append(keystroke)
   |
   = help: Remove whitespace after opening quotes

models\keystroke_manager.py:23:9: D200 One-line docstring should fit on one line
   |
22 |       def get_keystrokes_for_session(self, session_id: str) -> List[Keystroke]:
23 | /         """
24 | |         Populate keystroke_list with all keystrokes for a session from the DB.
25 | |         """
   | |___________^ D200
26 |           self.keystroke_list = Keystroke.get_for_session(session_id)
27 |           return self.keystroke_list
   |
   = help: Reformat to one line

models\keystroke_manager.py:23:9: D212 [*] Multi-line docstring summary should start at the first line
   |
22 |       def get_keystrokes_for_session(self, session_id: str) -> List[Keystroke]:
23 | /         """
24 | |         Populate keystroke_list with all keystrokes for a session from the DB.
25 | |         """
   | |___________^ D212
26 |           self.keystroke_list = Keystroke.get_for_session(session_id)
27 |           return self.keystroke_list
   |
   = help: Remove whitespace after opening quotes

models\keystroke_manager.py:30:9: D205 1 blank line required between summary line and description
   |
29 |       def save_keystrokes(self) -> bool:
30 | /         """
31 | |         Save all keystrokes in the in-memory list to the database.
32 | |         Returns True if all are saved successfully, False otherwise.
33 | |         """
   | |___________^ D205
34 |           try:
35 |               if not self.keystroke_list:
   |
   = help: Insert single blank line

models\keystroke_manager.py:30:9: D212 [*] Multi-line docstring summary should start at the first line
   |
29 |       def save_keystrokes(self) -> bool:
30 | /         """
31 | |         Save all keystrokes in the in-memory list to the database.
32 | |         Returns True if all are saved successfully, False otherwise.
33 | |         """
   | |___________^ D212
34 |           try:
35 |               if not self.keystroke_list:
   |
   = help: Remove whitespace after opening quotes

models\keystroke_manager.py:78:9: D212 [*] Multi-line docstring summary should start at the first line
   |
77 |       def delete_keystrokes_by_session(self, session_id: str) -> bool:
78 | /         """
79 | |         Delete all keystrokes for a given session ID.
80 | |
81 | |         Args:
82 | |             session_id: UUID string of the session to delete keystrokes for
83 | |
84 | |         Returns:
85 | |             bool: True if successful, False otherwise
86 | |         """
   | |___________^ D212
87 |           try:
88 |               self.db_manager.execute(
   |
   = help: Remove whitespace after opening quotes

models\keystroke_manager.py:104:9: D205 1 blank line required between summary line and description
    |
103 |       def delete_all_keystrokes(self) -> bool:
104 | /         """
105 | |         Delete all keystrokes from the session_keystrokes table.
106 | |         Returns True if successful, False otherwise.
107 | |         """
    | |___________^ D205
108 |           try:
109 |               self.db_manager.execute("DELETE FROM session_keystrokes")
    |
    = help: Insert single blank line

models\keystroke_manager.py:104:9: D212 [*] Multi-line docstring summary should start at the first line
    |
103 |       def delete_all_keystrokes(self) -> bool:
104 | /         """
105 | |         Delete all keystrokes from the session_keystrokes table.
106 | |         Returns True if successful, False otherwise.
107 | |         """
    | |___________^ D212
108 |           try:
109 |               self.db_manager.execute("DELETE FROM session_keystrokes")
    |
    = help: Remove whitespace after opening quotes

models\keystroke_manager.py:116:9: D212 [*] Multi-line docstring summary should start at the first line
    |
115 |       def count_keystrokes_per_session(self, session_id: str) -> int:
116 | /         """
117 | |         Count the number of keystrokes for a specific session.
118 | |
119 | |         Args:
120 | |             session_id: The ID of the session to count keystrokes for (UUID string)
121 | |
122 | |         Returns:
123 | |             int: The number of keystrokes for the session, or 0 if an error occurs
124 | |         """
    | |___________^ D212
125 |           try:
126 |               result = self.db_manager.fetchone(
    |
    = help: Remove whitespace after opening quotes

models\library.py:1:1: D205 1 blank line required between summary line and description
  |
1 | / """
2 | | Library models and manager for Snippets Library (categories, snippets, snippet parts).
3 | | Implements all CRUD, validation, and business logic for the Snippets Library.
4 | | """
  | |___^ D205
5 |
6 |   # Standard library imports
  |
  = help: Insert single blank line

models\library.py:1:1: D212 [*] Multi-line docstring summary should start at the first line
  |
1 | / """
2 | | Library models and manager for Snippets Library (categories, snippets, snippet parts).
3 | | Implements all CRUD, validation, and business logic for the Snippets Library.
4 | | """
  | |___^ D212
5 |
6 |   # Standard library imports
  |
  = help: Remove whitespace after opening quotes

models\library.py:24:5: D205 1 blank line required between summary line and description
   |
23 |   class LibraryManager:
24 | /     """
25 | |     Manages categories and snippets for the Snippets Library using the new
26 | |     models and managers.
27 | |     All DB operations are parameterized. Validation is enforced via Pydantic and
28 | |     explicit checks.
29 | |     """
   | |_______^ D205
30 |
31 |       def __init__(self, db_manager: DatabaseManager) -> None:
   |
   = help: Insert single blank line

models\library.py:24:5: D212 [*] Multi-line docstring summary should start at the first line
   |
23 |   class LibraryManager:
24 | /     """
25 | |     Manages categories and snippets for the Snippets Library using the new
26 | |     models and managers.
27 | |     All DB operations are parameterized. Validation is enforced via Pydantic and
28 | |     explicit checks.
29 | |     """
   | |_______^ D212
30 |
31 |       def __init__(self, db_manager: DatabaseManager) -> None:
   |
   = help: Remove whitespace after opening quotes

models\library.py:31:9: D107 Missing docstring in `__init__`
   |
29 |     """
30 |
31 |     def __init__(self, db_manager: DatabaseManager) -> None:
   |         ^^^^^^^^ D107
32 |         self.db = db_manager
33 |         self.category_manager = CategoryManager(db_manager)
   |

models\library.py:42:9: D212 [*] Multi-line docstring summary should start at the first line
   |
41 |       def create_category(self, name: str) -> str:
42 | /         """
43 | |         Create a new category with the given name.
44 | |
45 | |         Args:
46 | |             name: The name of the category to create
47 | |
48 | |         Returns:
49 | |             str: The ID of the created category
50 | |
51 | |         Raises:
52 | |             CategoryValidationError: If the category name is invalid
53 | |         """
   | |___________^ D212
54 |           category = Category(category_name=name, description="")
55 |           self.category_manager.save_category(category)
   |
   = help: Remove whitespace after opening quotes

models\library.py:60:9: D102 Missing docstring in public method
   |
58 |         return str(category.category_id)
59 |
60 |     def rename_category(self, category_id: str, new_name: str) -> None:
   |         ^^^^^^^^^^^^^^^ D102
61 |         try:
62 |             category = self.category_manager.get_category_by_id(category_id)
   |

models\library.py:68:9: D102 Missing docstring in public method
   |
66 |             raise
67 |
68 |     def delete_category(self, category_id: str) -> bool:
   |         ^^^^^^^^^^^^^^^ D102
69 |         try:
70 |             return self.category_manager.delete_category_by_id(category_id)
   |

models\library.py:75:9: D102 Missing docstring in public method
   |
74 |     # SNIPPET CRUD
75 |     def list_snippets(self, category_id: str) -> List[Snippet]:
   |         ^^^^^^^^^^^^^ D102
76 |         return self.snippet_manager.list_snippets_by_category(category_id)
   |

models\library.py:79:9: D212 [*] Multi-line docstring summary should start at the first line
   |
78 |       def create_snippet(self, category_id: str, name: str, content: str) -> str:
79 | /         """
80 | |         Create a new snippet in the specified category.
81 | |
82 | |         Args:
83 | |             category_id: The ID of the category to create the snippet in
84 | |             name: The name of the snippet
85 | |             content: The content of the snippet
86 | |
87 | |         Returns:
88 | |             str: The ID of the created snippet
89 | |
90 | |         Raises:
91 | |             ValueError: If the category doesn't exist or snippet creation fails
92 | |             DatabaseError: If there's an error saving the snippet
93 | |         """
   | |___________^ D212
94 |           try:
95 |               # Verify category exists first
   |
   = help: Remove whitespace after opening quotes

models\library.py:124:9: D212 [*] Multi-line docstring summary should start at the first line
    |
122 |           category_id: Optional[str] = None,
123 |       ) -> None:
124 | /         """
125 | |         Edit an existing snippet.
126 | |
127 | |         Args:
128 | |             snippet_id: The ID of the snippet to edit
129 | |             snippet_name: New name for the snippet
130 | |             content: New content for the snippet
131 | |             category_id: Optional new category ID for the snippet
132 | |
133 | |         Raises:
134 | |             ValueError: If the snippet with the given ID doesn't exist
135 | |             DatabaseError: If there's an error saving the snippet
136 | |             Exception: For other unexpected errors
137 | |         """
    | |___________^ D212
138 |           snippet = self.snippet_manager.get_snippet_by_id(snippet_id)
139 |           if snippet is None:
    |
    = help: Remove whitespace after opening quotes

models\llm_ngram_service.py:1:1: D100 Missing docstring in public module
models\llm_ngram_service.py:14:7: D101 Missing docstring in public class
   |
14 | class LLMMissingAPIKeyError(Exception):
   |       ^^^^^^^^^^^^^^^^^^^^^ D101
15 |     pass
   |

models\llm_ngram_service.py:19:5: D212 [*] Multi-line docstring summary should start at the first line
   |
18 |   class LLMNgramService:
19 | /     """
20 | |     Service for generating words containing specified n-grams using an LLM (OpenAI).
21 | |
22 | |     Updates:
23 | |     - API key argument now optional; if omitted and allow_env=True, resolves from environment
24 | |       variables in priority order: OPENAI_API_KEY, OpenAPI_Key, OPENAI_API_TOKEN.
25 | |     - Reuses a single OpenAI client instance (instead of recreating in get_words_with_ngrams_2).
26 | |     - Optional validation (list models) can be enabled via validate=True.
27 | |     """
   | |_______^ D212
28 |
29 |       def __init__(
   |
   = help: Remove whitespace after opening quotes

models\llm_ngram_service.py:29:9: D107 Missing docstring in `__init__`
   |
27 |     """
28 |
29 |     def __init__(
   |         ^^^^^^^^ D107
30 |         self,
31 |         api_key: Optional[str] = None,
   |

models\llm_ngram_service.py:85:9: D202 [*] No blank lines allowed after function docstring (found 1)
   |
83 |         self, ngram_str: str, allowed_chars_str: str, max_length: int
84 |     ) -> str:
85 |         """Load prompt template from file and format it with parameters."""
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D202
86 |
87 |         target_word_count: int = int(max_length / 5)
   |
   = help: Remove blank line(s) after function docstring

models\ngram.py:1:1: D100 Missing docstring in public module
models\ngram.py:27:7: D101 Missing docstring in public class
   |
27 | class SpeedMode(str, Enum):
   |       ^^^^^^^^^ D101
28 |     RAW = "raw"
29 |     NET = "net"
   |

models\ngram.py:32:7: D101 Missing docstring in public class
   |
32 | class NGramType(str, Enum):
   |       ^^^^^^^^^ D101
33 |     CLEAN = "clean"
34 |     ERROR_LAST_CHAR = "error_last_char"
   |

models\ngram.py:37:7: D101 Missing docstring in public class
   |
37 | class SpeedNGram(BaseModel):
   |       ^^^^^^^^^^ D101
38 |     id: uuid.UUID
39 |     session_id: uuid.UUID
   |

models\ngram.py:69:7: D101 Missing docstring in public class
   |
69 | class ErrorNGram(BaseModel):
   |       ^^^^^^^^^^ D101
70 |     id: uuid.UUID
71 |     session_id: uuid.UUID
   |

models\ngram.py:107:5: D103 Missing docstring in public function
    |
107 | def validate_ngram_size(size: int) -> bool:
    |     ^^^^^^^^^^^^^^^^^^^ D103
108 |     return MIN_NGRAM_SIZE <= size <= MAX_NGRAM_SIZE
    |

models\ngram.py:111:5: D103 Missing docstring in public function
    |
111 | def is_valid_ngram_text(text: str) -> bool:
    |     ^^^^^^^^^^^^^^^^^^^ D103
112 |     return (not has_sequence_separators(text)) and validate_ngram_size(len(text))
    |

models\ngram_analytics_service.py:1:1: D212 [*] Multi-line docstring summary should start at the first line
   |
 1 | / """
 2 | | NGramAnalyticsService for advanced n-gram performance analysis.
 3 | |
 4 | | This module provides comprehensive analytics for n-gram performance including:
 5 | | - Decaying average calculations for recent performance weighting
 6 | | - Performance summaries with historical tracking
 7 | | - Heatmap data generation for visualization
 8 | | - Migration of analytics methods from NGramManager
 9 | | """
   | |___^ D212
10 |
11 |   import logging
   |
   = help: Remove whitespace after opening quotes

models\ngram_analytics_service.py:11:1: I001 [*] Import block is un-sorted or un-formatted
   |
 9 |   """
10 |
11 | / import logging
12 | | import traceback
13 | | from dataclasses import dataclass
14 | | from datetime import datetime
15 | | from math import log
16 | | from typing import Dict, List, Optional, TYPE_CHECKING, Union
17 | |
18 | | from pydantic import BaseModel, Field
19 | |
20 | | from db.database_manager import DatabaseManager
21 | | from helpers.debug_util import DebugUtil
22 | | from models.ngram_manager import NGramManager
   | |_____________________________________________^ I001
23 |
24 |   if TYPE_CHECKING:  # Only for type hints to avoid circular imports at runtime
   |
   = help: Organize imports

models\ngram_analytics_service.py:25:5: I001 [*] Import block is un-sorted or un-formatted
   |
24 |   if TYPE_CHECKING:  # Only for type hints to avoid circular imports at runtime
25 | /     from models.session import Session
26 | |     from models.keystroke import Keystroke
   | |__________________________________________^ I001
27 |
28 |   logger = logging.getLogger(__name__)
   |
   = help: Organize imports

models\ngram_analytics_service.py:32:5: D212 [*] Multi-line docstring summary should start at the first line
   |
31 |   class DecayingAverageCalculator:
32 | /     """
33 | |     Calculator for decaying average with exponential weighting.
34 | |
35 | |     Implements an ELO-like system where more recent measurements
36 | |     have exponentially higher weights than older ones.
37 | |     """
   | |_______^ D212
38 |
39 |       def __init__(self, decay_factor: float = 0.9, max_samples: int = 20) -> None:
   |
   = help: Remove whitespace after opening quotes

models\ngram_analytics_service.py:40:9: D212 [*] Multi-line docstring summary should start at the first line
   |
39 |       def __init__(self, decay_factor: float = 0.9, max_samples: int = 20) -> None:
40 | /         """
41 | |         Initialize the decaying average calculator.
42 | |
43 | |         Args:
44 | |             decay_factor: Exponential decay factor (0.0 to 1.0). Higher values
45 | |                          give more weight to recent measurements.
46 | |             max_samples: Maximum number of most recent samples to consider.
47 | |         """
   | |___________^ D212
48 |           self.decay_factor = decay_factor
49 |           self.max_samples = max_samples
   |
   = help: Remove whitespace after opening quotes

models\ngram_analytics_service.py:52:9: D212 [*] Multi-line docstring summary should start at the first line
   |
51 |       def calculate_decaying_average(self, values: List[float], timestamps: List[datetime]) -> float:
52 | /         """
53 | |         Calculate decaying average with exponential weighting.
54 | |
55 | |         More recent values receive exponentially higher weights according to:
56 | |         weight = decay_factor ^ (days_ago)
57 | |
58 | |         Args:
59 | |             values: List of measurement values
60 | |             timestamps: List of corresponding timestamps (must match values length)
61 | |
62 | |         Returns:
63 | |             Weighted average with recent values weighted more heavily
64 | |         """
   | |___________^ D212
65 |           if not values or not timestamps:
66 |               return 0.0
   |
   = help: Remove whitespace after opening quotes

models\ngram_analytics_service.py:168:5: D212 [*] Multi-line docstring summary should start at the first line
    |
167 |   class NGramAnalyticsService:
168 | /     """
169 | |     Service for advanced n-gram performance analytics.
170 | |
171 | |     Provides comprehensive analytics including decaying averages,
172 | |     performance summaries, heatmap data, and historical tracking.
173 | |
174 | |     """
    | |_______^ D212
175 |
176 |       def __init__(self, db: Optional[DatabaseManager], ngram_manager: Optional[NGramManager]) -> None:
    |
    = help: Remove whitespace after opening quotes

models\ngram_analytics_service.py:177:9: D205 1 blank line required between summary line and description
    |
176 |       def __init__(self, db: Optional[DatabaseManager], ngram_manager: Optional[NGramManager]) -> None:
177 | /         """
178 | |         Initialize the NGramAnalyticsService with database and
179 | |         n-gram manager dependencies.
180 | |         """
    | |___________^ D205
181 |           self.db = db
182 |           self.ngram_manager = ngram_manager
    |
    = help: Insert single blank line

models\ngram_analytics_service.py:177:9: D212 [*] Multi-line docstring summary should start at the first line
    |
176 |       def __init__(self, db: Optional[DatabaseManager], ngram_manager: Optional[NGramManager]) -> None:
177 | /         """
178 | |         Initialize the NGramAnalyticsService with database and
179 | |         n-gram manager dependencies.
180 | |         """
    | |___________^ D212
181 |           self.db = db
182 |           self.ngram_manager = ngram_manager
    |
    = help: Remove whitespace after opening quotes

models\ngram_analytics_service.py:189:9: D417 Missing argument description in the docstring for `process_end_of_session`: `save_session_first`
    |
187 |         return
188 |
189 |     def process_end_of_session(
    |         ^^^^^^^^^^^^^^^^^^^^^^ D417
190 |         self,
191 |         session: "Session",
    |

models\ngram_analytics_service.py:195:9: D212 [*] Multi-line docstring summary should start at the first line
    |
193 |           save_session_first: bool = True,
194 |       ) -> Dict[str, Union[int, bool, str]]:
195 | /         """
196 | |         Orchestrate end-of-session persistence and analytics in strict order.
197 | |
198 | |         Steps:
199 | |         1) Save session
200 | |         2) Save keystrokes
201 | |         3) Generate and persist n-grams
202 | |         4) Summarize session n-grams (populate session_ngram_summary)
203 | |         5) Update speed summaries for the specific session (curr and hist)
204 | |
205 | |         Args:
206 | |             session: Session model instance with populated fields
207 | |             keystrokes_input: list of keystroke dicts or Keystroke objects to persist
208 | |
209 | |         Returns:
210 | |             Dict summary with counts and success flags
211 | |
212 | |         Raises:
213 | |             Exception: If any step fails, the exception is propagated
214 | |         """
    | |___________^ D212
215 |           # Local imports to avoid circular dependencies
216 |           from models.keystroke import Keystroke
    |
    = help: Remove whitespace after opening quotes

models\ngram_analytics_service.py:295:9: D212 [*] Multi-line docstring summary should start at the first line
    |
294 |       def refresh_speed_summaries(self, user_id: str, keyboard_id: str) -> int:
295 | /         """
296 | |         Refresh current and historical n-gram speed summaries for a user/keyboard.
297 | |
298 | |         Note: Current implementation processes pending sessions globally via
299 | |         summarize_session_ngrams(). This satisfies test expectations by ensuring
300 | |         summaries are updated; future refinement can scope by user/keyboard.
301 | |
302 | |         Args:
303 | |             user_id: The user ID to refresh (currently informational)
304 | |             keyboard_id: The keyboard ID to refresh (currently informational)
305 | |
306 | |         Returns:
307 | |             Number of summary rows inserted into session_ngram_summary during run.
308 | |         """
    | |___________^ D212
309 |           # Reuse existing summarization pipeline which updates summary tables.
310 |           try:
    |
    = help: Remove whitespace after opening quotes

models\ngram_analytics_service.py:324:9: D212 [*] Multi-line docstring summary should start at the first line
    |
322 |           self, user_id: str, keyboard_id: str, ngram_text: Optional[str] = None
323 |       ) -> List[NGramHistoricalData]:
324 | /         """
325 | |         Retrieve historical performance data for n-grams.
326 | |
327 | |         Args:
328 | |             user_id: User ID to get history for
329 | |             keyboard_id: Keyboard ID to get history for
330 | |             ngram_text: Optional filter for specific n-gram text
331 | |
332 | |         Returns:
333 | |             List of NGramHistoricalData objects sorted by measurement date
334 | |         """
    | |___________^ D212
335 |           if not self.db:
336 |               logger.warning("No database connection for history retrieval")
    |
    = help: Remove whitespace after opening quotes

models\ngram_analytics_service.py:405:9: D212 [*] Multi-line docstring summary should start at the first line
    |
403 |           sort_order: str = "decaying_average_ms desc",
404 |       ) -> List[NGramHeatmapData]:
405 | /         """
406 | |         Get heatmap data for n-gram performance visualization.
407 | |
408 | |         Args:
409 | |             user_id: User ID to get data for
410 | |             keyboard_id: Keyboard ID to get data for
411 | |             target_speed_ms: Optional target speed override
412 | |             ngram_size_filter: Optional filter for specific n-gram size
413 | |             exclude_successful: Whether to exclude n-grams meeting target
414 | |             sort_order: Sort order ("worst_to_best" or "best_to_worst")
415 | |
416 | |         Returns:
417 | |             List of NGramHeatmapData objects for visualization
418 | |         """
    | |___________^ D212
419 |           if not self.db:
420 |               return []
    |
    = help: Remove whitespace after opening quotes

models\ngram_analytics_service.py:534:9: D212 [*] Multi-line docstring summary should start at the first line
    |
532 |           self, user_id: str, keyboard_id: str, time_window_days: int = 30
533 |       ) -> Dict[str, List[NGramHistoricalData]]:
534 | /         """
535 | |         Get historical performance trends for n-grams.
536 | |
537 | |         Analyzes how the decaying average performance has changed over time
538 | |         by calculating weighted averages at different time points.
539 | |
540 | |         Args:
541 | |             user_id: User ID to get trends for
542 | |             keyboard_id: Keyboard ID to get trends for
543 | |             time_window_days: Number of days to look back
544 | |
545 | |         Returns:
546 | |             Dictionary mapping n-gram text to list of historical data points
547 | |         """
    | |___________^ D212
548 |           if not self.db:
549 |               return {}
    |
    = help: Remove whitespace after opening quotes

models\ngram_analytics_service.py:657:9: D417 Missing argument descriptions in the docstring for `slowest_n`: `focus_on_speed_target`, `min_occurrences`
    |
655 |             return {}
656 |
657 |     def slowest_n(
    |         ^^^^^^^^^ D417
658 |         self,
659 |         n: int,
    |

models\ngram_analytics_service.py:668:9: D212 [*] Multi-line docstring summary should start at the first line
    |
666 |           focus_on_speed_target: bool = False,
667 |       ) -> List[NGramStats]:
668 | /         """
669 | |         Find the n slowest n-grams by average speed.
670 | |
671 | |         This method was moved from NGramManager to NGramAnalyticsService
672 | |         for better organization of analytics functionality.
673 | |
674 | |         Args:
675 | |             n: Number of n-grams to return
676 | |             keyboard_id: The ID of the keyboard to filter by
677 | |             user_id: The ID of the user to filter by
678 | |             ngram_sizes: List of n-gram sizes to include (default is 2-20)
679 | |             lookback_distance: Number of most recent sessions to consider
680 | |             included_keys: List of characters to filter n-grams by (only n-grams
681 | |                          containing exclusively these characters will be returned)
682 | |
683 | |         Returns:
684 | |             List of NGramStats objects sorted by speed (slowest first)
685 | |         """
    | |___________^ D212
686 |           if n <= 0:
687 |               return []
    |
    = help: Remove whitespace after opening quotes

models\ngram_analytics_service.py:764:9: D212 [*] Multi-line docstring summary should start at the first line
    |
762 |           included_keys: Optional[List[str]] = None,
763 |       ) -> List[NGramStats]:
764 | /         """
765 | |         Find the n most error-prone n-grams by error count.
766 | |
767 | |         This method was moved from NGramManager to NGramAnalyticsService
768 | |         for better organization of analytics functionality.
769 | |
770 | |         Args:
771 | |             n: Number of n-grams to return
772 | |             keyboard_id: The ID of the keyboard to filter by
773 | |             user_id: The ID of the user to filter by
774 | |             ngram_sizes: List of n-gram sizes to include (default is 2-20)
775 | |             lookback_distance: Number of most recent sessions to consider
776 | |             included_keys: List of characters to filter n-grams by (only n-grams
777 | |                          containing exclusively these characters will be returned)
778 | |
779 | |         Returns:
780 | |             List of NGramStats objects sorted by error count (highest first)
781 | |         """
    | |___________^ D212
782 |           if n <= 0:
783 |               return []
    |
    = help: Remove whitespace after opening quotes

models\ngram_analytics_service.py:848:9: D212 [*] Multi-line docstring summary should start at the first line
    |
847 |       def summarize_session_ngrams(self) -> int:
848 | /         """
849 | |         Summarize session ngram performance for all sessions not yet in session_ngram_summary.
850 | |
851 | |         Uses complex CTEs to aggregate data from session_ngram_speed, session_ngram_errors,
852 | |         and session_keystrokes tables, then inserts the results into session_ngram_summary.
853 | |
854 | |         Returns:
855 | |             Number of records inserted into session_ngram_summary
856 | |
857 | |         Raises:
858 | |             DatabaseError: If the database operation fails
859 | |         """
    | |___________^ D212
860 |           logger.info("Starting SummarizeSessionNgrams process")
    |
    = help: Remove whitespace after opening quotes

models\ngram_analytics_service.py:1016:9: D212 [*] Multi-line docstring summary should start at the first line
     |
1015 |       def add_speed_summary_for_session(self, session_id: str) -> dict:
1016 | /         """
1017 | |         Update performance summary for a specific session using decaying average calculation.
1018 | |
1019 | |         Uses the last 20 sessions (including the given session) to calculate decaying averages
1020 | |         and updates both ngram_speed_summary_curr (merge) and ngram_speed_summary_hist (insert).
1021 | |
1022 | |         Args:
1023 | |             session_id: The session ID to process
1024 | |
1025 | |         Returns:
1026 | |             Dictionary with counts of updated and inserted records
1027 | |
1028 | |         Raises:
1029 | |             DatabaseError: If the database operation fails
1030 | |         """
     | |___________^ D212
1031 |           logger.info(f"Starting AddSpeedSummaryForSession for session: {session_id}")
     |
     = help: Remove whitespace after opening quotes

models\ngram_analytics_service.py:1250:9: D212 [*] Multi-line docstring summary should start at the first line
     |
1249 |       def catchup_speed_summary(self) -> dict:
1250 | /         """
1251 | |         Process all sessions from oldest to newest to catch up speed summaries.
1252 | |
1253 | |         Queries all sessions in chronological order and calls AddSpeedSummaryForSession
1254 | |         for each one, logging progress and record counts.
1255 | |
1256 | |         Returns:
1257 | |             Dictionary with total counts and processing summary
1258 | |
1259 | |         Raises:
1260 | |             DatabaseError: If the database operation fails
1261 | |         """
     | |___________^ D212
1262 |           logger.info("Starting CatchupSpeedSummary process")
     |
     = help: Remove whitespace after opening quotes

models\ngram_analytics_service.py:1349:9: D205 1 blank line required between summary line and description
     |
1348 |       def delete_all_analytics_data(self) -> bool:
1349 | /         """
1350 | |         Delete all analytics data from ngram_speed_hist, ngram_speed_summary_curr,
1351 | |         ngram_speed_summary_hist, and session_ngram_summary tables.
1352 | |
1353 | |         This will clear all derived analytics data but preserve the raw ngram data
1354 | |         in session_ngram_speed and session_ngram_errors.
1355 | |
1356 | |         Returns:
1357 | |             bool: True if successful, False otherwise
1358 | |         """
     | |___________^ D205
1359 |           try:
1360 |               if self.db is None:
     |
     = help: Insert single blank line

models\ngram_analytics_service.py:1349:9: D212 [*] Multi-line docstring summary should start at the first line
     |
1348 |       def delete_all_analytics_data(self) -> bool:
1349 | /         """
1350 | |         Delete all analytics data from ngram_speed_hist, ngram_speed_summary_curr,
1351 | |         ngram_speed_summary_hist, and session_ngram_summary tables.
1352 | |
1353 | |         This will clear all derived analytics data but preserve the raw ngram data
1354 | |         in session_ngram_speed and session_ngram_errors.
1355 | |
1356 | |         Returns:
1357 | |             bool: True if successful, False otherwise
1358 | |         """
     | |___________^ D212
1359 |           try:
1360 |               if self.db is None:
     |
     = help: Remove whitespace after opening quotes

models\ngram_analytics_service.py:1379:9: D212 [*] Multi-line docstring summary should start at the first line
     |
1378 |       def delete_all_session_summaries(self) -> bool:
1379 | /         """
1380 | |         Delete all data from session_ngram_summary table.
1381 | |
1382 | |         Returns:
1383 | |             bool: True if successful, False otherwise
1384 | |         """
     | |___________^ D212
1385 |           try:
1386 |               if self.db is None:
     |
     = help: Remove whitespace after opening quotes

models\ngram_manager.py:1:1: D100 Missing docstring in public module
models\ngram_manager.py:28:5: D212 [*] Multi-line docstring summary should start at the first line
   |
27 |   class NGramManager:
28 | /     """
29 | |     Implementation-agnostic n-gram extractor/classifier per Prompts/ngram.md.
30 | |
31 | |     Responsibilities:
32 | |     - Extract n-gram windows from expected text (respecting separators)
33 | |     - Classify each window as Clean, Error-last, or Ignored
34 | |     - Compute durations using Section 6 rules with start-of-sequence gross-up
35 | |     - Return SpeedNGram and ErrorNGram objects
36 | |     - Provide persistence helpers to store results to DB per Prompts/ngram.md
37 | |     """
   | |_______^ D212
38 |
39 |       def __init__(self, db_manager: Optional[DBExecutor] = None) -> None:
   |
   = help: Remove whitespace after opening quotes

models\session.py:1:1: D212 [*] Multi-line docstring summary should start at the first line
  |
1 | / """
2 | | Session module for backward compatibility with older tests.
3 | |
4 | | This module provides the Session class that was previously part of
5 | | the ngram_analyzer module but has been moved as part of the refactoring.
6 | | """
  | |___^ D212
7 |
8 |   from __future__ import annotations
  |
  = help: Remove whitespace after opening quotes

models\session.py:18:5: D205 1 blank line required between summary line and description
   |
17 |   class Session(BaseModel):
18 | /     """
19 | |     Pydantic model for a typing practice session, matching the practice_sessions table.
20 | |     All fields are validated and session_id is a UUID string.
21 | |     """
   | |_______^ D205
22 |
23 |       session_id: str = Field(default_factory=lambda: str(uuid.uuid4()))
   |
   = help: Insert single blank line

models\session.py:18:5: D212 [*] Multi-line docstring summary should start at the first line
   |
17 |   class Session(BaseModel):
18 | /     """
19 | |     Pydantic model for a typing practice session, matching the practice_sessions table.
20 | |     All fields are validated and session_id is a UUID string.
21 | |     """
   | |_______^ D212
22 |
23 |       session_id: str = Field(default_factory=lambda: str(uuid.uuid4()))
   |
   = help: Remove whitespace after opening quotes

models\session.py:42:9: D102 Missing docstring in public method
   |
40 |     @field_validator("session_id", "snippet_id", "user_id", "keyboard_id")
41 |     @classmethod
42 |     def validate_uuid(cls, v: str) -> str:
   |         ^^^^^^^^^^^^^ D102
43 |         uuid.UUID(v)
44 |         return v
   |

models\session.py:48:9: D102 Missing docstring in public method
   |
46 |     @field_validator("snippet_index_start", "snippet_index_end")
47 |     @classmethod
48 |     def validate_indices(cls, v: int) -> int:
   |         ^^^^^^^^^^^^^^^^ D102
49 |         if v < 0:
50 |             raise ValueError("Indices must be >= 0")
   |

models\session.py:54:9: D102 Missing docstring in public method
   |
53 |     @model_validator(mode="after")
54 |     def check_indices_and_times(self) -> "Session":
   |         ^^^^^^^^^^^^^^^^^^^^^^^ D102
55 |         if self.snippet_index_end <= self.snippet_index_start:
56 |             raise ValueError("snippet_index_end must be > snippet_index_start")
   |

models\session.py:64:9: D102 Missing docstring in public method
   |
63 |     @property
64 |     def expected_chars(self) -> int:
   |         ^^^^^^^^^^^^^^ D102
65 |         return self.snippet_index_end - self.snippet_index_start
   |

models\session.py:68:9: D102 Missing docstring in public method
   |
67 |     @property
68 |     def total_time(self) -> float:
   |         ^^^^^^^^^^ D102
69 |         return (self.end_time - self.start_time).total_seconds()
   |

models\session.py:72:9: D102 Missing docstring in public method
   |
71 |     @property
72 |     def efficiency(self) -> float:
   |         ^^^^^^^^^^ D102
73 |         if self.expected_chars == 0:
74 |             return 0.0
   |

models\session.py:78:9: D102 Missing docstring in public method
   |
77 |     @property
78 |     def correctness(self) -> float:
   |         ^^^^^^^^^^^ D102
79 |         if self.actual_chars == 0:
80 |             return 0.0
   |

models\session.py:84:9: D102 Missing docstring in public method
   |
83 |     @property
84 |     def accuracy(self) -> float:
   |         ^^^^^^^^ D102
85 |         if self.expected_chars == 0:
86 |             return 0.0
   |

models\session.py:90:9: D102 Missing docstring in public method
   |
89 |     @property
90 |     def session_cpm(self) -> float:
   |         ^^^^^^^^^^^ D102
91 |         if self.total_time == 0:
92 |             return 0.0
   |

models\session.py:96:9: D102 Missing docstring in public method
   |
95 |     @property
96 |     def session_wpm(self) -> float:
   |         ^^^^^^^^^^^ D102
97 |         if self.total_time == 0:
98 |             return 0.0
   |

models\session.py:102:9: D102 Missing docstring in public method
    |
101 |     @property
102 |     def ms_per_keystroke(self) -> float:
    |         ^^^^^^^^^^^^^^^^ D102
103 |         if self.expected_chars == 0 or self.total_time == 0:
104 |             return 0.0
    |

models\session.py:107:9: D102 Missing docstring in public method
    |
105 |         return (self.total_time * 1000.0) / self.expected_chars
106 |
107 |     def to_dict(self) -> Dict[str, Any]:
    |         ^^^^^^^ D102
108 |         return self.dict()
    |

models\session.py:111:9: D102 Missing docstring in public method
    |
110 |     @classmethod
111 |     def from_dict(cls, d: Dict[str, Any]) -> "Session":
    |         ^^^^^^^^^ D102
112 |         # Create a copy of the input dictionary to avoid modifying the original
113 |         data = d.copy()
    |

models\session.py:133:9: D200 One-line docstring should fit on one line
    |
132 |       def get_summary(self) -> str:
133 | /         """
134 | |         Return a summary of the session (business logic only).
135 | |         """
    | |___________^ D200
136 |           return (
137 |               f"Session {self.session_id} for snippet {self.snippet_id} "
    |
    = help: Reformat to one line

models\session.py:133:9: D212 [*] Multi-line docstring summary should start at the first line
    |
132 |       def get_summary(self) -> str:
133 | /         """
134 | |         Return a summary of the session (business logic only).
135 | |         """
    | |___________^ D212
136 |           return (
137 |               f"Session {self.session_id} for snippet {self.snippet_id} "
    |
    = help: Remove whitespace after opening quotes

models\session_manager.py:1:1: D100 Missing docstring in public module
models\session_manager.py:22:5: D205 1 blank line required between summary line and description
   |
21 |   class SessionManager:
22 | /     """
23 | |     Manages all database and aggregation operations for Session objects.
24 | |     Delegates all DB operations to DatabaseManager and handles only exceptions
25 | |     from exceptions.py.
26 | |     All session_id values are UUID strings.
27 | |     """
   | |_______^ D205
28 |
29 |       def __init__(self, db_manager: DatabaseManager) -> None:
   |
   = help: Insert single blank line

models\session_manager.py:22:5: D212 [*] Multi-line docstring summary should start at the first line
   |
21 |   class SessionManager:
22 | /     """
23 | |     Manages all database and aggregation operations for Session objects.
24 | |     Delegates all DB operations to DatabaseManager and handles only exceptions
25 | |     from exceptions.py.
26 | |     All session_id values are UUID strings.
27 | |     """
   | |_______^ D212
28 |
29 |       def __init__(self, db_manager: DatabaseManager) -> None:
   |
   = help: Remove whitespace after opening quotes

models\session_manager.py:29:9: D107 Missing docstring in `__init__`
   |
27 |     """
28 |
29 |     def __init__(self, db_manager: DatabaseManager) -> None:
   |         ^^^^^^^^ D107
30 |         self.db_manager = db_manager
31 |         self.debug_util = DebugUtil()
   |

models\session_manager.py:33:9: D102 Missing docstring in public method
   |
31 |         self.debug_util = DebugUtil()
32 |
33 |     def get_session_by_id(self, session_id: str) -> Optional[Session]:
   |         ^^^^^^^^^^^^^^^^^ D102
34 |         try:
35 |             row = self.db_manager.execute(
   |

models\session_manager.py:77:9: D102 Missing docstring in public method
   |
75 |             raise
76 |
77 |     def list_sessions_for_snippet(self, snippet_id: str) -> List[Session]:
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^ D102
78 |         try:
79 |             rows = self.db_manager.execute(
   |

models\session_manager.py:124:9: D205 1 blank line required between summary line and description
    |
123 |       def save_session(self, session: Session) -> str:
124 | /         """
125 | |         Save a Session object to the database. If a session with the same
126 | |         session_id exists, update it; otherwise, insert a new record.
127 | |         Returns the session_id.
128 | |         """
    | |___________^ D205
129 |           try:
130 |               row = self.db_manager.execute(
    |
    = help: Insert single blank line

models\session_manager.py:124:9: D212 [*] Multi-line docstring summary should start at the first line
    |
123 |       def save_session(self, session: Session) -> str:
124 | /         """
125 | |         Save a Session object to the database. If a session with the same
126 | |         session_id exists, update it; otherwise, insert a new record.
127 | |         Returns the session_id.
128 | |         """
    | |___________^ D212
129 |           try:
130 |               row = self.db_manager.execute(
    |
    = help: Remove whitespace after opening quotes

models\session_manager.py:211:9: D200 One-line docstring should fit on one line
    |
210 |       def delete_session_by_id(self, session_id: str) -> bool:
211 | /         """
212 | |         Delete a session by its session_id. Returns True if deleted, False if not found.
213 | |         """
    | |___________^ D200
214 |           try:
215 |               result = self.db_manager.execute(
    |
    = help: Reformat to one line

models\session_manager.py:211:9: D212 [*] Multi-line docstring summary should start at the first line
    |
210 |       def delete_session_by_id(self, session_id: str) -> bool:
211 | /         """
212 | |         Delete a session by its session_id. Returns True if deleted, False if not found.
213 | |         """
    | |___________^ D212
214 |           try:
215 |               result = self.db_manager.execute(
    |
    = help: Remove whitespace after opening quotes

models\session_manager.py:234:9: D205 1 blank line required between summary line and description
    |
233 |       def delete_all(self) -> bool:
234 | /         """
235 | |         Delete all keystrokes and ngrams before deleting all sessions.
236 | |         Only deletes sessions if both keystroke and ngram deletions succeed.
237 | |         Returns True if all deletions succeed, False otherwise.
238 | |         """
    | |___________^ D205
239 |           from models.keystroke_manager import KeystrokeManager
240 |           from models.ngram_manager import NGramManager
    |
    = help: Insert single blank line

models\session_manager.py:234:9: D212 [*] Multi-line docstring summary should start at the first line
    |
233 |       def delete_all(self) -> bool:
234 | /         """
235 | |         Delete all keystrokes and ngrams before deleting all sessions.
236 | |         Only deletes sessions if both keystroke and ngram deletions succeed.
237 | |         Returns True if all deletions succeed, False otherwise.
238 | |         """
    | |___________^ D212
239 |           from models.keystroke_manager import KeystrokeManager
240 |           from models.ngram_manager import NGramManager
    |
    = help: Remove whitespace after opening quotes

models\session_manager.py:285:9: D205 1 blank line required between summary line and description
    |
284 |       def get_latest_session_for_keyboard(self, keyboard_id: str) -> Optional[Session]:
285 | /         """
286 | |         Returns the most recent session for the given keyboard_id across all snippets.
287 | |         Returns None if no sessions found for this keyboard.
288 | |         """
    | |___________^ D205
289 |           try:
290 |               row = self.db_manager.fetchone(
    |
    = help: Insert single blank line

models\session_manager.py:285:9: D212 [*] Multi-line docstring summary should start at the first line
    |
284 |       def get_latest_session_for_keyboard(self, keyboard_id: str) -> Optional[Session]:
285 | /         """
286 | |         Returns the most recent session for the given keyboard_id across all snippets.
287 | |         Returns None if no sessions found for this keyboard.
288 | |         """
    | |___________^ D212
289 |           try:
290 |               row = self.db_manager.fetchone(
    |
    = help: Remove whitespace after opening quotes

models\session_manager.py:338:9: D205 1 blank line required between summary line and description
    |
337 |       def get_next_position(self, snippet_id: str) -> int:
338 | /         """
339 | |         Returns the next start index for a session on the given snippet.
340 | |         - If no previous sessions: returns 0
341 | |         - If last session ended at or beyond snippet length: returns 0
342 | |         - Otherwise: returns last session's snippet_index_end
343 | |         """
    | |___________^ D205
344 |           # Get all sessions for this snippet, most recent first
345 |           sessions = self.list_sessions_for_snippet(snippet_id)
    |
    = help: Insert single blank line

models\session_manager.py:338:9: D212 [*] Multi-line docstring summary should start at the first line
    |
337 |       def get_next_position(self, snippet_id: str) -> int:
338 | /         """
339 | |         Returns the next start index for a session on the given snippet.
340 | |         - If no previous sessions: returns 0
341 | |         - If last session ended at or beyond snippet length: returns 0
342 | |         - Otherwise: returns last session's snippet_index_end
343 | |         """
    | |___________^ D212
344 |           # Get all sessions for this snippet, most recent first
345 |           sessions = self.list_sessions_for_snippet(snippet_id)
    |
    = help: Remove whitespace after opening quotes

models\session_manager.py:338:9: D415 First line should end with a period, question mark, or exclamation point
    |
337 |       def get_next_position(self, snippet_id: str) -> int:
338 | /         """
339 | |         Returns the next start index for a session on the given snippet.
340 | |         - If no previous sessions: returns 0
341 | |         - If last session ended at or beyond snippet length: returns 0
342 | |         - Otherwise: returns last session's snippet_index_end
343 | |         """
    | |___________^ D415
344 |           # Get all sessions for this snippet, most recent first
345 |           sessions = self.list_sessions_for_snippet(snippet_id)
    |
    = help: Add closing punctuation

models\setting.py:1:1: D205 1 blank line required between summary line and description
  |
1 | / """
2 | | Setting data model.
3 | | Defines the structure and validation for a setting.
4 | | """
  | |___^ D205
5 |
6 |   from __future__ import annotations
  |
  = help: Insert single blank line

models\setting.py:1:1: D212 [*] Multi-line docstring summary should start at the first line
  |
1 | / """
2 | | Setting data model.
3 | | Defines the structure and validation for a setting.
4 | | """
  | |___^ D212
5 |
6 |   from __future__ import annotations
  |
  = help: Remove whitespace after opening quotes

models\setting.py:22:9: D107 Missing docstring in `__init__`
   |
20 |     """
21 |
22 |     def __init__(self, message: str = "Setting validation failed") -> None:
   |         ^^^^^^^^ D107
23 |         self.message = message
24 |         super().__init__(self.message)
   |

models\setting.py:34:9: D107 Missing docstring in `__init__`
   |
32 |     """
33 |
34 |     def __init__(self, message: str = "Setting not found") -> None:
   |         ^^^^^^^^ D107
35 |         self.message = message
36 |         super().__init__(self.message)
   |

models\setting_manager.py:1:1: D205 1 blank line required between summary line and description
  |
1 | / """
2 | | Setting Manager for CRUD operations.
3 | | Handles all DB access for settings.
4 | | """
  | |___^ D205
5 |
6 |   import datetime
  |
  = help: Insert single blank line

models\setting_manager.py:1:1: D212 [*] Multi-line docstring summary should start at the first line
  |
1 | / """
2 | | Setting Manager for CRUD operations.
3 | | Handles all DB access for settings.
4 | | """
  | |___^ D212
5 |
6 |   import datetime
  |
  = help: Remove whitespace after opening quotes

models\setting_manager.py:15:5: D200 One-line docstring should fit on one line
   |
14 |   class SettingManager:
15 | /     """
16 | |     Manager for CRUD operations on Setting, using DatabaseManager for DB access.
17 | |     """
   | |_______^ D200
18 |
19 |       def __init__(self, db_manager: DatabaseManager) -> None:
   |
   = help: Reformat to one line

models\setting_manager.py:15:5: D212 [*] Multi-line docstring summary should start at the first line
   |
14 |   class SettingManager:
15 | /     """
16 | |     Manager for CRUD operations on Setting, using DatabaseManager for DB access.
17 | |     """
   | |_______^ D212
18 |
19 |       def __init__(self, db_manager: DatabaseManager) -> None:
   |
   = help: Remove whitespace after opening quotes

models\setting_manager.py:20:9: D200 One-line docstring should fit on one line
   |
19 |       def __init__(self, db_manager: DatabaseManager) -> None:
20 | /         """
21 | |         Initialize SettingManager with a DatabaseManager instance.
22 | |         """
   | |___________^ D200
23 |           self.db_manager: DatabaseManager = db_manager
   |
   = help: Reformat to one line

models\setting_manager.py:20:9: D212 [*] Multi-line docstring summary should start at the first line
   |
19 |       def __init__(self, db_manager: DatabaseManager) -> None:
20 | /         """
21 | |         Initialize SettingManager with a DatabaseManager instance.
22 | |         """
   | |___________^ D212
23 |           self.db_manager: DatabaseManager = db_manager
   |
   = help: Remove whitespace after opening quotes

models\setting_manager.py:31:9: D205 1 blank line required between summary line and description
   |
29 |           setting_id: Optional[str] = None
30 |       ) -> None:
31 | /         """
32 | |         Validate setting for database uniqueness.
33 | |         This ensures there is only one setting per entity per type.
34 | |
35 | |         Args:
36 | |             setting_type_id: The setting type ID to validate.
37 | |             related_entity_id: The entity ID to validate.
38 | |             setting_id: The ID of the setting being updated, if any.
39 | |
40 | |         Raises:
41 | |             SettingValidationError: If the combination is not unique.
42 | |         """
   | |___________^ D205
43 |           query = "SELECT 1 FROM settings WHERE setting_type_id = ? AND related_entity_id = ?"
44 |           params = [setting_type_id, related_entity_id]
   |
   = help: Insert single blank line

models\setting_manager.py:31:9: D212 [*] Multi-line docstring summary should start at the first line
   |
29 |           setting_id: Optional[str] = None
30 |       ) -> None:
31 | /         """
32 | |         Validate setting for database uniqueness.
33 | |         This ensures there is only one setting per entity per type.
34 | |
35 | |         Args:
36 | |             setting_type_id: The setting type ID to validate.
37 | |             related_entity_id: The entity ID to validate.
38 | |             setting_id: The ID of the setting being updated, if any.
39 | |
40 | |         Raises:
41 | |             SettingValidationError: If the combination is not unique.
42 | |         """
   | |___________^ D212
43 |           query = "SELECT 1 FROM settings WHERE setting_type_id = ? AND related_entity_id = ?"
44 |           params = [setting_type_id, related_entity_id]
   |
   = help: Remove whitespace after opening quotes

models\setting_manager.py:61:9: D205 1 blank line required between summary line and description
   |
59 |           default_value: Optional[str] = None
60 |       ) -> Setting:
61 | /         """
62 | |         Retrieve a single setting by type ID and related entity ID.
63 | |         If the setting doesn't exist and a default value is provided, returns a new setting with the default.
64 | |
65 | |         Args:
66 | |             setting_type_id: The type ID of the setting to retrieve.
67 | |             related_entity_id: The related entity ID of the setting to retrieve.
68 | |             default_value: Default value to use if the setting doesn't exist.
69 | |
70 | |         Returns:
71 | |             Setting: The retrieved or newly created setting.
72 | |
73 | |         Raises:
74 | |             SettingNotFound: If no setting exists with the specified IDs and no default is provided.
75 | |         """
   | |___________^ D205
76 |           row = self.db_manager.execute(
77 |               """
   |
   = help: Insert single blank line

models\setting_manager.py:61:9: D212 [*] Multi-line docstring summary should start at the first line
   |
59 |           default_value: Optional[str] = None
60 |       ) -> Setting:
61 | /         """
62 | |         Retrieve a single setting by type ID and related entity ID.
63 | |         If the setting doesn't exist and a default value is provided, returns a new setting with the default.
64 | |
65 | |         Args:
66 | |             setting_type_id: The type ID of the setting to retrieve.
67 | |             related_entity_id: The related entity ID of the setting to retrieve.
68 | |             default_value: Default value to use if the setting doesn't exist.
69 | |
70 | |         Returns:
71 | |             Setting: The retrieved or newly created setting.
72 | |
73 | |         Raises:
74 | |             SettingNotFound: If no setting exists with the specified IDs and no default is provided.
75 | |         """
   | |___________^ D212
76 |           row = self.db_manager.execute(
77 |               """
   |
   = help: Remove whitespace after opening quotes

models\setting_manager.py:111:9: D212 [*] Multi-line docstring summary should start at the first line
    |
110 |       def list_settings(self, related_entity_id: str) -> List[Setting]:
111 | /         """
112 | |         List all settings for a specific entity.
113 | |
114 | |         Args:
115 | |             related_entity_id: The entity ID to retrieve settings for.
116 | |
117 | |         Returns:
118 | |             List[Setting]: All settings for the specified entity.
119 | |         """
    | |___________^ D212
120 |           rows = self.db_manager.execute(
121 |               """
    |
    = help: Remove whitespace after opening quotes

models\setting_manager.py:141:9: D205 1 blank line required between summary line and description
    |
140 |       def save_setting(self, setting: Setting) -> bool:
141 | /         """
142 | |         Insert or update a setting in the DB. Returns True if successful.
143 | |         Also creates an entry in the settings_history table.
144 | |
145 | |         Args:
146 | |             setting: The Setting object to save.
147 | |
148 | |         Returns:
149 | |             True if the setting was inserted or updated successfully.
150 | |
151 | |         Raises:
152 | |             SettingValidationError: If the setting is not unique.
153 | |             ValueError: If validation fails (e.g., invalid data).
154 | |         """
    | |___________^ D205
155 |           # Ensure the updated_at timestamp is current
156 |           setting.updated_at = datetime.datetime.now().isoformat()
    |
    = help: Insert single blank line

models\setting_manager.py:141:9: D212 [*] Multi-line docstring summary should start at the first line
    |
140 |       def save_setting(self, setting: Setting) -> bool:
141 | /         """
142 | |         Insert or update a setting in the DB. Returns True if successful.
143 | |         Also creates an entry in the settings_history table.
144 | |
145 | |         Args:
146 | |             setting: The Setting object to save.
147 | |
148 | |         Returns:
149 | |             True if the setting was inserted or updated successfully.
150 | |
151 | |         Raises:
152 | |             SettingValidationError: If the setting is not unique.
153 | |             ValueError: If validation fails (e.g., invalid data).
154 | |         """
    | |___________^ D212
155 |           # Ensure the updated_at timestamp is current
156 |           setting.updated_at = datetime.datetime.now().isoformat()
    |
    = help: Remove whitespace after opening quotes

models\setting_manager.py:185:9: D212 [*] Multi-line docstring summary should start at the first line
    |
184 |       def _add_history_entry(self, setting: Setting) -> None:
185 | /         """
186 | |         Add an entry to the settings_history table.
187 | |
188 | |         Args:
189 | |             setting: The setting that was changed.
190 | |         """
    | |___________^ D212
191 |           history_id = str(uuid4())
192 |           self.db_manager.execute(
    |
    = help: Remove whitespace after opening quotes

models\setting_manager.py:251:9: D212 [*] Multi-line docstring summary should start at the first line
    |
250 |       def delete_setting(self, setting_type_id: str, related_entity_id: str) -> bool:
251 | /         """
252 | |         Delete a setting by its type ID and related entity ID.
253 | |
254 | |         Args:
255 | |             setting_type_id: The type ID of the setting to delete.
256 | |             related_entity_id: The related entity ID of the setting to delete.
257 | |
258 | |         Returns:
259 | |             bool: True if deleted, False if not found.
260 | |         """
    | |___________^ D212
261 |           # First get the setting to record in history
262 |           try:
    |
    = help: Remove whitespace after opening quotes

models\setting_manager.py:281:9: D212 [*] Multi-line docstring summary should start at the first line
    |
280 |       def delete_all_settings(self, related_entity_id: str) -> bool:
281 | /         """
282 | |         Delete all settings for a specific entity.
283 | |
284 | |         Args:
285 | |             related_entity_id: The entity ID to delete settings for.
286 | |
287 | |         Returns:
288 | |             bool: True if any were deleted, False if none were found.
289 | |         """
    | |___________^ D212
290 |           # Get all settings for this entity first
291 |           settings = self.list_settings(related_entity_id)
    |
    = help: Remove whitespace after opening quotes

models\snippet.py:1:1: D200 One-line docstring should fit on one line
  |
1 | / """
2 | | Snippet Pydantic model and validation logic.
3 | | """
  | |___^ D200
4 |
5 |   from __future__ import annotations
  |
  = help: Reformat to one line

models\snippet.py:1:1: D212 [*] Multi-line docstring summary should start at the first line
  |
1 | / """
2 | | Snippet Pydantic model and validation logic.
3 | | """
  | |___^ D212
4 |
5 |   from __future__ import annotations
  |
  = help: Remove whitespace after opening quotes

models\snippet.py:120:9: D102 Missing docstring in public method
    |
118 |     @model_validator(mode="before")
119 |     @classmethod
120 |     def ensure_snippet_id(cls, values: dict) -> dict:
    |         ^^^^^^^^^^^^^^^^^ D102
121 |         if not values.get("snippet_id"):
122 |             values["snippet_id"] = str(uuid4())
    |

models\snippet.py:127:9: D102 Missing docstring in public method
    |
125 |     @field_validator("snippet_id", "category_id", mode="before")
126 |     @classmethod
127 |     def validate_ids(cls, v: str) -> str:
    |         ^^^^^^^^^^^^ D102
128 |         if not v:
129 |             raise ValueError("ID must not be empty")
    |

models\snippet.py:138:9: D102 Missing docstring in public method
    |
136 |     @field_validator("snippet_name", mode="before")
137 |     @classmethod
138 |     def validate_snippet_name(cls, v: str) -> str:
    |         ^^^^^^^^^^^^^^^^^^^^^ D102
139 |         v = validate_non_empty(v)
140 |         v = validate_ascii_only(v)
    |

models\snippet.py:148:9: D102 Missing docstring in public method
    |
146 |     @field_validator("content", mode="before")
147 |     @classmethod
148 |     def validate_content(cls, v: str) -> str:
    |         ^^^^^^^^^^^^^^^^ D102
149 |         v = validate_non_empty(v)
150 |         v = validate_ascii_only(v)
    |

models\snippet.py:156:9: D102 Missing docstring in public method
    |
154 |         return v
155 |
156 |     def to_dict(self) -> Dict[str, Any]:
    |         ^^^^^^^ D102
157 |         return self.dict()
    |

models\snippet.py:160:9: D102 Missing docstring in public method
    |
159 |     @classmethod
160 |     def from_dict(cls, d: Dict[str, Any]) -> "Snippet":
    |         ^^^^^^^^^ D102
161 |         allowed = set(cls.__fields__.keys())
162 |         extra = set(d.keys()) - allowed
    |

models\snippet_manager.py:1:1: D205 1 blank line required between summary line and description
  |
1 | / """
2 | | SnippetManager: Class for managing snippets in the database.
3 | | Provides methods for CRUD operations on snippets, utilizing the Snippet Pydantic model.
4 | | """
  | |___^ D205
5 |
6 |   import logging
  |
  = help: Insert single blank line

models\snippet_manager.py:1:1: D212 [*] Multi-line docstring summary should start at the first line
  |
1 | / """
2 | | SnippetManager: Class for managing snippets in the database.
3 | | Provides methods for CRUD operations on snippets, utilizing the Snippet Pydantic model.
4 | | """
  | |___^ D212
5 |
6 |   import logging
  |
  = help: Remove whitespace after opening quotes

models\snippet_manager.py:61:9: D212 [*] Multi-line docstring summary should start at the first line
   |
60 |       def save_snippet(self, snippet: Snippet) -> bool:
61 | /         """
62 | |         Insert or update a snippet in the DB. Returns True if successful.
63 | |
64 | |         Args:
65 | |             snippet: The Snippet object to save.
66 | |
67 | |         Returns:
68 | |             True if the snippet was inserted or updated successfully.
69 | |
70 | |         Raises:
71 | |             ValueError: If validation fails (e.g., duplicate name, invalid data).
72 | |             DatabaseError: If a database operation fails.
73 | |         """
   | |___________^ D212
74 |           exists = self.db.execute(
75 |               "SELECT 1 FROM snippets WHERE snippet_id = ?", (snippet.snippet_id,)
   |
   = help: Remove whitespace after opening quotes

models\snippet_manager.py:326:9: D212 [*] Multi-line docstring summary should start at the first line
    |
325 |       def create_dynamic_snippet(self, category_id: str) -> Snippet:
326 | /         """
327 | |         Creates or retrieves a dynamic snippet with preset content.
328 | |         
329 | |         Checks if a dynamic snippet named "Dynamic Exercises" already exists in the 
330 | |         specified category. If it exists, returns the existing snippet. If not, 
331 | |         creates a new dynamic snippet and returns it.
332 | |         
333 | |         Args:
334 | |             category_id: The UUID of the category to create/find the snippet in
335 | |             
336 | |         Returns:
337 | |             Snippet object for the dynamic exercises snippet
338 | |             
339 | |         Raises:
340 | |             DatabaseError: If database operations fail
341 | |         """
    | |___________^ D212
342 |           snippet_name = "Dynamic Exercises"
    |
    = help: Remove whitespace after opening quotes

models\snippet_manager.py:383:9: D205 1 blank line required between summary line and description
    |
382 |       def get_starting_index(self, snippet_id: str, user_id: str, keyboard_id: str) -> int:
383 | /         """
384 | |         Returns the next starting index for a snippet for a given user and keyboard.
385 | |         Looks up the latest practice_session for this snippet, user, and keyboard,
386 | |         and returns the maximum snippet_index_end typed so far + 1.
387 | |         If no session exists, returns 0.
388 | |         If the index is >= snippet length - 1, returns 0 (wraps around).
389 | |         """
    | |___________^ D205
390 |           snippet = self.get_snippet_by_id(snippet_id)
391 |           if not snippet:
    |
    = help: Insert single blank line

models\snippet_manager.py:383:9: D212 [*] Multi-line docstring summary should start at the first line
    |
382 |       def get_starting_index(self, snippet_id: str, user_id: str, keyboard_id: str) -> int:
383 | /         """
384 | |         Returns the next starting index for a snippet for a given user and keyboard.
385 | |         Looks up the latest practice_session for this snippet, user, and keyboard,
386 | |         and returns the maximum snippet_index_end typed so far + 1.
387 | |         If no session exists, returns 0.
388 | |         If the index is >= snippet length - 1, returns 0 (wraps around).
389 | |         """
    | |___________^ D212
390 |           snippet = self.get_snippet_by_id(snippet_id)
391 |           if not snippet:
    |
    = help: Remove whitespace after opening quotes

models\user.py:1:1: D205 1 blank line required between summary line and description
  |
1 | / """
2 | | User data model.
3 | | Defines the structure and validation for a user.
4 | | """
  | |___^ D205
5 |
6 |   from __future__ import annotations
  |
  = help: Insert single blank line

models\user.py:1:1: D212 [*] Multi-line docstring summary should start at the first line
  |
1 | / """
2 | | User data model.
3 | | Defines the structure and validation for a user.
4 | | """
  | |___^ D212
5 |
6 |   from __future__ import annotations
  |
  = help: Remove whitespace after opening quotes

models\user.py:37:9: D301 Use `r"""` if any backslashes in a docstring
   |
35 |       @classmethod
36 |       def validate_name_format(cls, v: str) -> str:
37 | /         """Validate name format.
38 | |
39 | |         Names must:
40 | |         - Not be empty or whitespace only
41 | |         - Be 1-64 characters long
42 | |         - Be ASCII-only
43 | |         - Not contain control characters (\n, \t, etc.)
44 | |         - Only contain letters, spaces, hyphens, and apostrophes
45 | |         - Not start or end with a space, hyphen, or apostrophe
46 | |         - Not contain consecutive spaces, hyphens, or apostrophes
47 | |
48 | |         Args:
49 | |             v: The name to validate
50 | |
51 | |         Returns:
52 | |             The validated and stripped name
53 | |
54 | |         Raises:
55 | |             ValueError: If the name is invalid
56 | |         """
   | |___________^ D301
57 |           if not v or not v.strip():
58 |               raise ValueError("Name cannot be blank.")
   |
   = help: Add `r` prefix

models\user.py:93:9: D102 Missing docstring in public method
   |
91 |     @field_validator("email_address")
92 |     @classmethod
93 |     def validate_email(cls, v: str) -> str:
   |         ^^^^^^^^^^^^^^ D102
94 |         if not v or not v.strip():
95 |             raise ValueError("Email address cannot be blank.")
   |

models\user.py:183:9: D102 Missing docstring in public method
    |
181 |     @model_validator(mode="before")
182 |     @classmethod
183 |     def ensure_user_id(cls, values: dict) -> dict:
    |         ^^^^^^^^^^^^^^ D102
184 |         # Only generate a default UUID if user_id is None (not provided)
185 |         # NOT if it's an empty string (explicitly provided as empty)
    |

models\user.py:192:9: D102 Missing docstring in public method
    |
190 |     @field_validator("user_id")
191 |     @classmethod
192 |     def validate_user_id(cls, v: str) -> str:
    |         ^^^^^^^^^^^^^^^^ D102
193 |         if not v:
194 |             raise ValueError("user_id must not be empty")
    |

models\user.py:201:9: D102 Missing docstring in public method
    |
199 |         return v
200 |
201 |     def to_dict(self) -> Dict[str, Any]:
    |         ^^^^^^^ D102
202 |         return self.dict()
    |

models\user.py:205:9: D102 Missing docstring in public method
    |
204 |     @classmethod
205 |     def from_dict(cls, d: Dict[str, Any]) -> "User":
    |         ^^^^^^^^^ D102
206 |         allowed = set(cls.model_fields.keys())
207 |         extra = set(d.keys()) - allowed
    |

models\user_manager.py:1:1: D205 1 blank line required between summary line and description
  |
1 | / """
2 | | User Manager for CRUD operations.
3 | | Handles all DB access for users.
4 | | """
  | |___^ D205
5 |
6 |   from typing import List, Optional
  |
  = help: Insert single blank line

models\user_manager.py:1:1: D212 [*] Multi-line docstring summary should start at the first line
  |
1 | / """
2 | | User Manager for CRUD operations.
3 | | Handles all DB access for users.
4 | | """
  | |___^ D212
5 |
6 |   from typing import List, Optional
  |
  = help: Remove whitespace after opening quotes

models\user_manager.py:12:7: D101 Missing docstring in public class
   |
12 | class UserValidationError(Exception):
   |       ^^^^^^^^^^^^^^^^^^^ D101
13 |     def __init__(self, message: str = "User validation failed") -> None:
14 |         self.message = message
   |

models\user_manager.py:13:9: D107 Missing docstring in `__init__`
   |
12 | class UserValidationError(Exception):
13 |     def __init__(self, message: str = "User validation failed") -> None:
   |         ^^^^^^^^ D107
14 |         self.message = message
15 |         super().__init__(self.message)
   |

models\user_manager.py:18:7: D101 Missing docstring in public class
   |
18 | class UserNotFound(Exception):
   |       ^^^^^^^^^^^^ D101
19 |     def __init__(self, message: str = "User not found") -> None:
20 |         self.message = message
   |

models\user_manager.py:19:9: D107 Missing docstring in `__init__`
   |
18 | class UserNotFound(Exception):
19 |     def __init__(self, message: str = "User not found") -> None:
   |         ^^^^^^^^ D107
20 |         self.message = message
21 |         super().__init__(self.message)
   |

models\user_manager.py:24:7: D101 Missing docstring in public class
   |
24 | class UserManager:
   |       ^^^^^^^^^^^ D101
25 |     def __init__(self, db_manager: DatabaseManager) -> None:
26 |         self.db_manager: DatabaseManager = db_manager
   |

models\user_manager.py:25:9: D107 Missing docstring in `__init__`
   |
24 | class UserManager:
25 |     def __init__(self, db_manager: DatabaseManager) -> None:
   |         ^^^^^^^^ D107
26 |         self.db_manager: DatabaseManager = db_manager
   |

models\user_manager.py:39:9: D102 Missing docstring in public method
   |
37 |             raise UserValidationError(f"Email address '{email_address}' must be unique.")
38 |
39 |     def get_user_by_id(self, user_id: str) -> User:
   |         ^^^^^^^^^^^^^^ D102
40 |         row = self.db_manager.fetchone(
41 |             "SELECT user_id, first_name, surname, email_address FROM users WHERE user_id = ?",
   |

models\user_manager.py:53:9: D102 Missing docstring in public method
   |
51 |         )
52 |
53 |     def get_user_by_email(self, email_address: str) -> User:
   |         ^^^^^^^^^^^^^^^^^ D102
54 |         # Use case-insensitive comparison for email retrieval
55 |         query = (
   |

models\user_manager.py:69:9: D102 Missing docstring in public method
   |
67 |         )
68 |
69 |     def list_all_users(self) -> List[User]:
   |         ^^^^^^^^^^^^^^ D102
70 |         query = (
71 |             "SELECT user_id, first_name, surname, email_address FROM users "
   |

models\user_manager.py:85:9: D102 Missing docstring in public method
   |
83 |         ]
84 |
85 |     def save_user(self, user: User) -> bool:
   |         ^^^^^^^^^ D102
86 |         self._validate_email_uniqueness(user.email_address, user.user_id)
87 |         if self.__user_exists(user.user_id):
   |

models\user_manager.py:112:9: D102 Missing docstring in public method
    |
110 |         return True
111 |
112 |     def delete_user_by_id(self, user_id: str) -> bool:
    |         ^^^^^^^^^^^^^^^^^ D102
113 |         if not self.db_manager.fetchone(
114 |             "SELECT 1 FROM users WHERE user_id = ?",
    |

models\user_manager.py:124:9: D102 Missing docstring in public method
    |
122 |         return True
123 |
124 |     def delete_user(self, user_id: str) -> bool:
    |         ^^^^^^^^^^^ D102
125 |         return self.delete_user_by_id(user_id)
    |

models\user_manager.py:127:9: D102 Missing docstring in public method
    |
125 |         return self.delete_user_by_id(user_id)
126 |
127 |     def delete_all_users(self) -> bool:
    |         ^^^^^^^^^^^^^^^^ D102
128 |         count_result = self.db_manager.fetchone("SELECT COUNT(*) FROM users")
129 |         # Handle different result structures safely
    |

run_snippets_library.py:1:1: D205 1 blank line required between summary line and description
  |
1 | / """
2 | | Combined runner for the Snippets Library - launches both Desktop and Web UIs.
3 | | This script starts the API server, Desktop UI, and optionally the Web UI.
4 | | """
  | |___^ D205
5 |
6 |   import argparse
  |
  = help: Insert single blank line

run_snippets_library.py:1:1: D212 [*] Multi-line docstring summary should start at the first line
  |
1 | / """
2 | | Combined runner for the Snippets Library - launches both Desktop and Web UIs.
3 | | This script starts the API server, Desktop UI, and optionally the Web UI.
4 | | """
  | |___^ D212
5 |
6 |   import argparse
  |
  = help: Remove whitespace after opening quotes

run_snippets_library.py:25:5: D205 1 blank line required between summary line and description
   |
24 |   class SnippetsLibraryRunner:
25 | /     """
26 | |     Main runner class for Snippets Library that manages all components.
27 | |     Handles starting and stopping the API server, Desktop UI, and Web UI.
28 | |     """
   | |_______^ D205
29 |
30 |       def __init__(self) -> None:
   |
   = help: Insert single blank line

run_snippets_library.py:25:5: D212 [*] Multi-line docstring summary should start at the first line
   |
24 |   class SnippetsLibraryRunner:
25 | /     """
26 | |     Main runner class for Snippets Library that manages all components.
27 | |     Handles starting and stopping the API server, Desktop UI, and Web UI.
28 | |     """
   | |_______^ D212
29 |
30 |       def __init__(self) -> None:
   |
   = help: Remove whitespace after opening quotes

run_snippets_library.py:38:9: D212 [*] Multi-line docstring summary should start at the first line
   |
37 |       def start_api_server(self) -> Optional[subprocess.Popen]:
38 | /         """
39 | |         Start the GraphQL API server.
40 | |
41 | |         Returns:
42 | |             Optional[subprocess.Popen]: Process object for the API server, or None if startup fails
43 | |         """
   | |___________^ D212
44 |           logger.info("Starting API server...")
   |
   = help: Remove whitespace after opening quotes

run_snippets_library.py:80:9: D212 [*] Multi-line docstring summary should start at the first line
   |
79 |       def start_desktop_ui(self) -> Optional[subprocess.Popen]:
80 | /         """
81 | |         Start the PyQt5 desktop UI.
82 | |
83 | |         Returns:
84 | |             Optional[subprocess.Popen]: Process object for the desktop UI, or None if startup fails
85 | |         """
   | |___________^ D212
86 |           logger.info("Starting Desktop UI...")
   |
   = help: Remove whitespace after opening quotes

run_snippets_library.py:100:9: D212 [*] Multi-line docstring summary should start at the first line
    |
 99 |       def start_web_ui(self) -> Optional[subprocess.Popen]:
100 | /         """
101 | |         Start the React Web UI using npm.
102 | |
103 | |         Returns:
104 | |             Optional[subprocess.Popen]: Process object for the web server, or None if startup fails
105 | |         """
    | |___________^ D212
106 |           logger.info("Starting Web UI (npm start)...")
    |
    = help: Remove whitespace after opening quotes

run_snippets_library.py:125:9: D212 [*] Multi-line docstring summary should start at the first line
    |
124 |       def run(self, include_web: bool = False) -> None:
125 | /         """
126 | |         Run all components of the Snippets Library.
127 | |
128 | |         Args:
129 | |             include_web (bool): Whether to include the web UI in addition to desktop UI
130 | |         """
    | |___________^ D212
131 |           # Start API server first
132 |           api_process = self.start_api_server()
    |
    = help: Remove whitespace after opening quotes

scripts\fix_all_critical_errors.py:2:1: D205 1 blank line required between summary line and description
  |
1 |   #!/usr/bin/env python3
2 | / """
3 | | Comprehensive final fix script for all critical type errors across the codebase.
4 | | Addresses missing description arguments, type mismatches, and other critical issues.
5 | | """
  | |___^ D205
6 |
7 |   import re
  |
  = help: Insert single blank line

scripts\fix_all_critical_errors.py:2:1: D212 [*] Multi-line docstring summary should start at the first line
  |
1 |   #!/usr/bin/env python3
2 | / """
3 | | Comprehensive final fix script for all critical type errors across the codebase.
4 | | Addresses missing description arguments, type mismatches, and other critical issues.
5 | | """
  | |___^ D212
6 |
7 |   import re
  |
  = help: Remove whitespace after opening quotes

scripts\fix_all_critical_errors.py:7:1: I001 [*] Import block is un-sorted or un-formatted
   |
 5 |   """
 6 |
 7 | / import re
 8 | | import os
 9 | | from typing import List, Tuple
   | |______________________________^ I001
10 |
11 |   def fix_file_content(file_path: str, fixes: List[Tuple[str, str]]) -> bool:
   |
   = help: Organize imports

scripts\fix_all_critical_errors.py:31:5: ANN201 Missing return type annotation for public function `fix_test_snippet`
   |
29 |     return False
30 |
31 | def fix_test_snippet():
   |     ^^^^^^^^^^^^^^^^ ANN201
32 |     """Fix all critical errors in test_snippet.py"""
33 |     file_path = r"d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py"
   |
   = help: Add return type annotation

scripts\fix_all_critical_errors.py:32:5: D415 First line should end with a period, question mark, or exclamation point
   |
31 | def fix_test_snippet():
32 |     """Fix all critical errors in test_snippet.py"""
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D415
33 |     file_path = r"d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py"
   |
   = help: Add closing punctuation

scripts\fix_all_critical_errors.py:67:5: ANN201 Missing return type annotation for public function `fix_test_snippet_manager`
   |
65 |     return fix_file_content(file_path, fixes)
66 |
67 | def fix_test_snippet_manager():
   |     ^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
68 |     """Fix all critical errors in test_snippet_manager.py"""
69 |     file_path = r"d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet_manager.py"
   |
   = help: Add return type annotation

scripts\fix_all_critical_errors.py:68:5: D415 First line should end with a period, question mark, or exclamation point
   |
67 | def fix_test_snippet_manager():
68 |     """Fix all critical errors in test_snippet_manager.py"""
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D415
69 |     file_path = r"d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet_manager.py"
   |
   = help: Add closing punctuation

scripts\fix_all_critical_errors.py:74:121: E501 Line too long (123 > 120)
   |
72 |         # Fix missing description argument and category_id type
73 |         (r'Snippet\(\s*snippet_name=([^,]+),\s*content=([^,]+),\s*category_id=([^,\)]+)\s*\)',
74 |          r'Snippet(snippet_name=\1, content=\2, category_id=\3 or "default_category_id", description="Test description")'),
   |                                                                                                                         ^^^ E501
75 |     ]
   |

scripts\fix_all_critical_errors.py:79:5: ANN201 Missing return type annotation for public function `fix_conftest`
   |
77 |     return fix_file_content(file_path, fixes)
78 |
79 | def fix_conftest():
   |     ^^^^^^^^^^^^ ANN201
80 |     """Fix all critical errors in conftest.py"""
81 |     file_path = r"d:\SeanDevLocal\AITypingTrainer\tests\models\conftest.py"
   |
   = help: Add return type annotation

scripts\fix_all_critical_errors.py:80:5: D415 First line should end with a period, question mark, or exclamation point
   |
79 | def fix_conftest():
80 |     """Fix all critical errors in conftest.py"""
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D415
81 |     file_path = r"d:\SeanDevLocal\AITypingTrainer\tests\models\conftest.py"
   |
   = help: Add closing punctuation

scripts\fix_all_critical_errors.py:98:121: E501 Line too long (164 > 120)
   |
96 | ΓÇª
97 | ΓÇªid,\s*keyboard_id=([^.]+)\.keyboard_id',
98 | ΓÇª.user_id or "default_user_id", keyboard_id=\3.keyboard_id or "default_keyboard_id"'),
   |                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
99 | ΓÇª
   |

scripts\fix_all_critical_errors.py:103:5: ANN201 Missing return type annotation for public function `fix_test_ngram_size`
    |
101 |     return fix_file_content(file_path, fixes)
102 |
103 | def fix_test_ngram_size():
    |     ^^^^^^^^^^^^^^^^^^^ ANN201
104 |     """Fix all critical errors in test_ngram_size.py"""
105 |     file_path = r"d:\SeanDevLocal\AITypingTrainer\tests\models\test_ngram_size.py"
    |
    = help: Add return type annotation

scripts\fix_all_critical_errors.py:104:5: D415 First line should end with a period, question mark, or exclamation point
    |
103 | def fix_test_ngram_size():
104 |     """Fix all critical errors in test_ngram_size.py"""
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D415
105 |     file_path = r"d:\SeanDevLocal\AITypingTrainer\tests\models\test_ngram_size.py"
    |
    = help: Add closing punctuation

scripts\fix_all_critical_errors.py:119:5: ANN201 Missing return type annotation for public function `fix_test_db_viewer_dialog`
    |
117 |     return fix_file_content(file_path, fixes)
118 |
119 | def fix_test_db_viewer_dialog():
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
120 |     """Fix critical errors in test_db_viewer_dialog.py"""
121 |     file_path = r"d:\SeanDevLocal\AITypingTrainer\tests\desktop_ui\test_db_viewer_dialog.py"
    |
    = help: Add return type annotation

scripts\fix_all_critical_errors.py:120:5: D415 First line should end with a period, question mark, or exclamation point
    |
119 | def fix_test_db_viewer_dialog():
120 |     """Fix critical errors in test_db_viewer_dialog.py"""
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D415
121 |     file_path = r"d:\SeanDevLocal\AITypingTrainer\tests\desktop_ui\test_db_viewer_dialog.py"
    |
    = help: Add closing punctuation

scripts\fix_all_critical_errors.py:135:5: ANN201 Missing return type annotation for public function `main`
    |
133 |     return fix_file_content(file_path, fixes)
134 |
135 | def main():
    |     ^^^^ ANN201
136 |     """Run all fixes"""
137 |     print("Starting comprehensive fix for all critical type errors...")
    |
    = help: Add return type annotation: `None`

scripts\fix_all_critical_errors.py:136:5: D415 First line should end with a period, question mark, or exclamation point
    |
135 | def main():
136 |     """Run all fixes"""
    |     ^^^^^^^^^^^^^^^^^^^ D415
137 |     print("Starting comprehensive fix for all critical type errors...")
    |
    = help: Add closing punctuation

scripts\fix_all_remaining_critical_errors.py:2:1: D205 1 blank line required between summary line and description
  |
1 |   #!/usr/bin/env python3
2 | / """
3 | | Comprehensive fix script to resolve all remaining critical type errors
4 | | across multiple test files in the AI Typing Trainer project.
5 | | """
  | |___^ D205
6 |
7 |   import re
  |
  = help: Insert single blank line

scripts\fix_all_remaining_critical_errors.py:2:1: D212 [*] Multi-line docstring summary should start at the first line
  |
1 |   #!/usr/bin/env python3
2 | / """
3 | | Comprehensive fix script to resolve all remaining critical type errors
4 | | across multiple test files in the AI Typing Trainer project.
5 | | """
  | |___^ D212
6 |
7 |   import re
  |
  = help: Remove whitespace after opening quotes

scripts\fix_all_remaining_critical_errors.py:7:1: I001 [*] Import block is un-sorted or un-formatted
   |
 5 |   """
 6 |
 7 | / import re
 8 | | from pathlib import Path
   | |________________________^ I001
 9 |
10 |   def fix_test_snippet_py():
   |
   = help: Organize imports

scripts\fix_all_remaining_critical_errors.py:10:5: ANN201 Missing return type annotation for public function `fix_test_snippet_py`
   |
 8 | from pathlib import Path
 9 |
10 | def fix_test_snippet_py():
   |     ^^^^^^^^^^^^^^^^^^^ ANN201
11 |     """Fix all critical type errors in test_snippet.py"""
12 |     file_path = Path("tests/models/test_snippet.py")
   |
   = help: Add return type annotation: `None`

scripts\fix_all_remaining_critical_errors.py:11:5: D415 First line should end with a period, question mark, or exclamation point
   |
10 | def fix_test_snippet_py():
11 |     """Fix all critical type errors in test_snippet.py"""
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D415
12 |     file_path = Path("tests/models/test_snippet.py")
13 |     if not file_path.exists():
   |
   = help: Add closing punctuation

scripts\fix_all_remaining_critical_errors.py:52:5: ANN201 Missing return type annotation for public function `fix_test_snippet_manager_py`
   |
50 |     print(f"Fixed critical type errors in {file_path}")
51 |
52 | def fix_test_snippet_manager_py():
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
53 |     """Fix all critical type errors in test_snippet_manager.py"""
54 |     file_path = Path("tests/models/test_snippet_manager.py")
   |
   = help: Add return type annotation: `None`

scripts\fix_all_remaining_critical_errors.py:53:5: D415 First line should end with a period, question mark, or exclamation point
   |
52 | def fix_test_snippet_manager_py():
53 |     """Fix all critical type errors in test_snippet_manager.py"""
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D415
54 |     file_path = Path("tests/models/test_snippet_manager.py")
55 |     if not file_path.exists():
   |
   = help: Add closing punctuation

scripts\fix_all_remaining_critical_errors.py:74:5: ANN201 Missing return type annotation for public function `fix_conftest_py`
   |
72 |     print(f"Fixed critical type errors in {file_path}")
73 |
74 | def fix_conftest_py():
   |     ^^^^^^^^^^^^^^^ ANN201
75 |     """Fix all critical type errors in conftest.py"""
76 |     file_path = Path("tests/models/conftest.py")
   |
   = help: Add return type annotation: `None`

scripts\fix_all_remaining_critical_errors.py:75:5: D415 First line should end with a period, question mark, or exclamation point
   |
74 | def fix_conftest_py():
75 |     """Fix all critical type errors in conftest.py"""
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D415
76 |     file_path = Path("tests/models/conftest.py")
77 |     if not file_path.exists():
   |
   = help: Add closing punctuation

scripts\fix_all_remaining_critical_errors.py:85:121: E501 Line too long (157 > 120)
   |
83 | ΓÇª
84 | ΓÇª
85 | ΓÇªer_id": user_id,\s*"keyboard_id": keyboard_id,\s*"snippet_id": snippet_id,?\s*\}',
   |                                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
86 | ΓÇª
87 | ΓÇª
   |

scripts\fix_all_remaining_critical_errors.py:109:5: ANN201 Missing return type annotation for public function `fix_test_ngram_size_py`
    |
107 |     print(f"Fixed critical type errors in {file_path}")
108 |
109 | def fix_test_ngram_size_py():
    |     ^^^^^^^^^^^^^^^^^^^^^^ ANN201
110 |     """Fix all critical type errors in test_ngram_size.py"""
111 |     file_path = Path("tests/models/test_ngram_size.py")
    |
    = help: Add return type annotation: `None`

scripts\fix_all_remaining_critical_errors.py:110:5: D415 First line should end with a period, question mark, or exclamation point
    |
109 | def fix_test_ngram_size_py():
110 |     """Fix all critical type errors in test_ngram_size.py"""
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D415
111 |     file_path = Path("tests/models/test_ngram_size.py")
112 |     if not file_path.exists():
    |
    = help: Add closing punctuation

scripts\fix_all_remaining_critical_errors.py:137:5: ANN201 Missing return type annotation for public function `fix_test_ngram_analytics_service_py`
    |
135 |     print(f"Fixed critical type errors in {file_path}")
136 |
137 | def fix_test_ngram_analytics_service_py():
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
138 |     """Fix undefined name errors in test_ngram_analytics_service.py"""
139 |     file_path = Path("tests/models/test_ngram_analytics_service.py")
    |
    = help: Add return type annotation: `None`

scripts\fix_all_remaining_critical_errors.py:138:5: D415 First line should end with a period, question mark, or exclamation point
    |
137 | def fix_test_ngram_analytics_service_py():
138 |     """Fix undefined name errors in test_ngram_analytics_service.py"""
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D415
139 |     file_path = Path("tests/models/test_ngram_analytics_service.py")
140 |     if not file_path.exists():
    |
    = help: Add closing punctuation

scripts\fix_all_remaining_critical_errors.py:152:5: ANN201 Missing return type annotation for public function `fix_database_viewer_service_py`
    |
150 |     print(f"Fixed undefined name errors in {file_path}")
151 |
152 | def fix_database_viewer_service_py():
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
153 |     """Fix type assignment error in database_viewer_service.py"""
154 |     file_path = Path("services/database_viewer_service.py")
    |
    = help: Add return type annotation: `None`

scripts\fix_all_remaining_critical_errors.py:153:5: D415 First line should end with a period, question mark, or exclamation point
    |
152 | def fix_database_viewer_service_py():
153 |     """Fix type assignment error in database_viewer_service.py"""
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D415
154 |     file_path = Path("services/database_viewer_service.py")
155 |     if not file_path.exists():
    |
    = help: Add closing punctuation

scripts\fix_all_remaining_critical_errors.py:171:5: ANN201 Missing return type annotation for public function `fix_test_db_viewer_dialog_py`
    |
169 |     print(f"Fixed type assignment error in {file_path}")
170 |
171 | def fix_test_db_viewer_dialog_py():
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
172 |     """Fix syntax and type errors in test_db_viewer_dialog.py"""
173 |     file_path = Path("tests/desktop_ui/test_db_viewer_dialog.py")
    |
    = help: Add return type annotation: `None`

scripts\fix_all_remaining_critical_errors.py:172:5: D415 First line should end with a period, question mark, or exclamation point
    |
171 | def fix_test_db_viewer_dialog_py():
172 |     """Fix syntax and type errors in test_db_viewer_dialog.py"""
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D415
173 |     file_path = Path("tests/desktop_ui/test_db_viewer_dialog.py")
174 |     if not file_path.exists():
    |
    = help: Add closing punctuation

scripts\fix_all_remaining_critical_errors.py:184:9: B007 Loop control variable `i` not used within loop body
    |
182 |     fixed_lines = []
183 |     
184 |     for i, line in enumerate(lines):
    |         ^ B007
185 |         # Look for unterminated strings (odd number of quotes)
186 |         if line.count('"') % 2 != 0 and not line.strip().endswith('\\'):
    |
    = help: Rename unused `i` to `_i`

scripts\fix_all_remaining_critical_errors.py:196:121: E501 Line too long (126 > 120)
    |
194 |     content = re.sub(
195 |         r'return app if app is not None else QApplication\(\[\]\)',
196 |         r'app_instance = app if app is not None else QApplication([])\n    return app_instance  # type: ignore[return-value]',
    |                                                                                                                         ^^^^^^ E501
197 |         content
198 |     )
    |

scripts\fix_all_remaining_critical_errors.py:206:5: ANN201 Missing return type annotation for public function `main`
    |
204 |     print(f"Fixed syntax and type errors in {file_path}")
205 |
206 | def main():
    |     ^^^^ ANN201
207 |     """Run all fixes"""
208 |     print("Starting comprehensive fix for all remaining critical type errors...")
    |
    = help: Add return type annotation: `None`

scripts\fix_all_remaining_critical_errors.py:207:5: D415 First line should end with a period, question mark, or exclamation point
    |
206 | def main():
207 |     """Run all fixes"""
    |     ^^^^^^^^^^^^^^^^^^^ D415
208 |     print("Starting comprehensive fix for all remaining critical type errors...")
    |
    = help: Add closing punctuation

scripts\fix_db_viewer_dialog_annotations.py:2:1: D205 1 blank line required between summary line and description
  |
1 |   #!/usr/bin/env python3
2 | / """
3 | | Batch fix script to add missing type annotations to test_db_viewer_dialog.py.
4 | | This script systematically adds type annotations to all test functions.
5 | | """
  | |___^ D205
6 |
7 |   import re
  |
  = help: Insert single blank line

scripts\fix_db_viewer_dialog_annotations.py:2:1: D212 [*] Multi-line docstring summary should start at the first line
  |
1 |   #!/usr/bin/env python3
2 | / """
3 | | Batch fix script to add missing type annotations to test_db_viewer_dialog.py.
4 | | This script systematically adds type annotations to all test functions.
5 | | """
  | |___^ D212
6 |
7 |   import re
  |
  = help: Remove whitespace after opening quotes

scripts\fix_db_viewer_dialog_annotations.py:11:5: ANN201 Missing return type annotation for public function `fix_test_db_viewer_dialog_annotations`
   |
11 | def fix_test_db_viewer_dialog_annotations():
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
12 |     """Fix missing type annotations in test_db_viewer_dialog.py."""
   |
   = help: Add return type annotation: `None`

scripts\fix_db_viewer_dialog_annotations.py:12:5: D202 [*] No blank lines allowed after function docstring (found 1)
   |
11 | def fix_test_db_viewer_dialog_annotations():
12 |     """Fix missing type annotations in test_db_viewer_dialog.py."""
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D202
13 |     
14 |     file_path = Path("tests/desktop_ui/test_db_viewer_dialog.py")
   |
   = help: Remove blank line(s) after function docstring

scripts\fix_db_viewer_dialog_annotations.py:37:121: E501 Line too long (128 > 120)
   |
36 | ΓÇª mock decorators
37 | ΓÇªox, mock_get_save_filename, qtapp, mock_db_viewer_service, qtbot\):'
   |                                                              ^^^^^^^^ E501
38 | ΓÇªet_save_filename: Any, qtapp: QApplication, mock_db_viewer_service: MagicMock, qtbot: QtBot) -> None:'
39 | ΓÇªtent)
   |

scripts\fix_db_viewer_dialog_annotations.py:38:121: E501 Line too long (162 > 120)
   |
36 | ΓÇª
37 | ΓÇª_filename, qtapp, mock_db_viewer_service, qtbot\):'
38 | ΓÇª Any, qtapp: QApplication, mock_db_viewer_service: MagicMock, qtbot: QtBot) -> None:'
   |                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
39 | ΓÇª
   |

scripts\fix_db_viewer_dialog_annotations.py:48:9: ANN202 Missing return type annotation for private function `fix_remaining_tests`
   |
46 |     # Fix 5: Handle any remaining test functions that might have been missed
47 |     remaining_test_pattern = r'def (test_\w+)\(([^)]+)\):'
48 |     def fix_remaining_tests(match):
   |         ^^^^^^^^^^^^^^^^^^^ ANN202
49 |         func_name = match.group(1)
50 |         params = match.group(2)
   |
   = help: Add return type annotation

scripts\fix_db_viewer_dialog_annotations.py:48:29: ANN001 Missing type annotation for function argument `match`
   |
46 |     # Fix 5: Handle any remaining test functions that might have been missed
47 |     remaining_test_pattern = r'def (test_\w+)\(([^)]+)\):'
48 |     def fix_remaining_tests(match):
   |                             ^^^^^ ANN001
49 |         func_name = match.group(1)
50 |         params = match.group(2)
   |

scripts\fix_remaining_critical_errors_targeted.py:2:1: D205 1 blank line required between summary line and description
  |
1 |   #!/usr/bin/env python3
2 | / """
3 | | Targeted fix script to resolve remaining critical type errors
4 | | without breaking existing syntax.
5 | | """
  | |___^ D205
6 |
7 |   import re
  |
  = help: Insert single blank line

scripts\fix_remaining_critical_errors_targeted.py:2:1: D212 [*] Multi-line docstring summary should start at the first line
  |
1 |   #!/usr/bin/env python3
2 | / """
3 | | Targeted fix script to resolve remaining critical type errors
4 | | without breaking existing syntax.
5 | | """
  | |___^ D212
6 |
7 |   import re
  |
  = help: Remove whitespace after opening quotes

scripts\fix_remaining_critical_errors_targeted.py:12:5: D415 First line should end with a period, question mark, or exclamation point
   |
11 | def fix_test_snippet_py() -> None:
12 |     """Fix remaining critical type errors in test_snippet.py"""
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D415
13 |     file_path = Path("tests/models/test_snippet.py")
14 |     if not file_path.exists():
   |
   = help: Add closing punctuation

scripts\fix_remaining_critical_errors_targeted.py:27:9: ANN202 Missing return type annotation for private function `fix_snippet_constructor`
   |
25 |     snippet_pattern = r'Snippet\(\s*([^)]*?)\s*\)'
26 |     
27 |     def fix_snippet_constructor(match):
   |         ^^^^^^^^^^^^^^^^^^^^^^^ ANN202
28 |         args = match.group(1)
29 |         # If description is not present, add it
   |
   = help: Add return type annotation

scripts\fix_remaining_critical_errors_targeted.py:27:33: ANN001 Missing type annotation for function argument `match`
   |
25 |     snippet_pattern = r'Snippet\(\s*([^)]*?)\s*\)'
26 |     
27 |     def fix_snippet_constructor(match):
   |                                 ^^^^^ ANN001
28 |         args = match.group(1)
29 |         # If description is not present, add it
   |

scripts\fix_remaining_critical_errors_targeted.py:84:5: D415 First line should end with a period, question mark, or exclamation point
   |
83 | def fix_test_snippet_manager_py() -> None:
84 |     """Fix critical type errors in test_snippet_manager.py"""
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D415
85 |     file_path = Path("tests/models/test_snippet_manager.py")
86 |     if not file_path.exists():
   |
   = help: Add closing punctuation

scripts\fix_remaining_critical_errors_targeted.py:96:9: ANN202 Missing return type annotation for private function `fix_snippet_constructor`
   |
94 |     snippet_pattern = r'Snippet\(\s*([^)]*?)\s*\)'
95 |     
96 |     def fix_snippet_constructor(match):
   |         ^^^^^^^^^^^^^^^^^^^^^^^ ANN202
97 |         args = match.group(1)
98 |         # If description is not present, add it
   |
   = help: Add return type annotation: `str`

scripts\fix_remaining_critical_errors_targeted.py:96:33: ANN001 Missing type annotation for function argument `match`
   |
94 |     snippet_pattern = r'Snippet\(\s*([^)]*?)\s*\)'
95 |     
96 |     def fix_snippet_constructor(match):
   |                                 ^^^^^ ANN001
97 |         args = match.group(1)
98 |         # If description is not present, add it
   |

scripts\fix_remaining_critical_errors_targeted.py:117:5: D415 First line should end with a period, question mark, or exclamation point
    |
116 | def fix_conftest_py() -> None:
117 |     """Fix critical type errors in conftest.py"""
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D415
118 |     file_path = Path("tests/models/conftest.py")
119 |     if not file_path.exists():
    |
    = help: Add closing punctuation

scripts\fix_remaining_critical_errors_targeted.py:153:5: D415 First line should end with a period, question mark, or exclamation point
    |
152 | def fix_test_ngram_size_py() -> None:
153 |     """Fix critical type errors in test_ngram_size.py"""
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D415
154 |     file_path = Path("tests/models/test_ngram_size.py")
155 |     if not file_path.exists():
    |
    = help: Add closing punctuation

scripts\fix_remaining_critical_errors_targeted.py:173:5: D415 First line should end with a period, question mark, or exclamation point
    |
172 | def fix_test_ngram_analytics_service_py() -> None:
173 |     """Fix undefined name errors in test_ngram_analytics_service.py"""
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D415
174 |     file_path = Path("tests/models/test_ngram_analytics_service.py")
175 |     if not file_path.exists():
    |
    = help: Add closing punctuation

scripts\fix_remaining_critical_errors_targeted.py:189:5: D415 First line should end with a period, question mark, or exclamation point
    |
188 | def main() -> None:
189 |     """Run targeted fixes for critical type errors"""
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D415
190 |     print("Starting targeted fix for remaining critical type errors...")
    |
    = help: Add closing punctuation

scripts\fix_snippet_test_errors.py:2:1: D205 1 blank line required between summary line and description
  |
1 |   #!/usr/bin/env python3
2 | / """
3 | | Script to systematically fix critical type errors in test_snippet.py.
4 | | This addresses the 80+ missing description arguments and type mismatches.
5 | | """
  | |___^ D205
6 |
7 |   import re
  |
  = help: Insert single blank line

scripts\fix_snippet_test_errors.py:2:1: D212 [*] Multi-line docstring summary should start at the first line
  |
1 |   #!/usr/bin/env python3
2 | / """
3 | | Script to systematically fix critical type errors in test_snippet.py.
4 | | This addresses the 80+ missing description arguments and type mismatches.
5 | | """
  | |___^ D212
6 |
7 |   import re
  |
  = help: Remove whitespace after opening quotes

scripts\fix_snippet_test_errors.py:13:5: D202 [*] No blank lines allowed after function docstring (found 1)
   |
12 | def fix_snippet_constructors(content: str) -> str:
13 |     """Fix missing description arguments in Snippet constructors."""
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D202
14 |     
15 |     # Pattern to match Snippet constructors without description
   |
   = help: Remove blank line(s) after function docstring

scripts\fix_snippet_test_errors.py:18:9: ANN202 Missing return type annotation for private function `add_description_if_missing`
   |
16 |     snippet_pattern = r'(Snippet\(\s*(?:[^)]*?))\)'
17 |     
18 |     def add_description_if_missing(match):
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN202
19 |         constructor_content = match.group(1)
20 |         if 'description=' not in constructor_content:
   |
   = help: Add return type annotation

scripts\fix_snippet_test_errors.py:18:36: ANN001 Missing type annotation for function argument `match`
   |
16 |     snippet_pattern = r'(Snippet\(\s*(?:[^)]*?))\)'
17 |     
18 |     def add_description_if_missing(match):
   |                                    ^^^^^ ANN001
19 |         constructor_content = match.group(1)
20 |         if 'description=' not in constructor_content:
   |

scripts\fix_snippet_test_errors.py:32:5: D202 [*] No blank lines allowed after function docstring (found 1)
   |
31 | def fix_category_constructors(content: str) -> str:
32 |     """Fix missing description arguments in Category constructors."""
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D202
33 |     
34 |     # Pattern to match Category constructors without description
   |
   = help: Remove blank line(s) after function docstring

scripts\fix_snippet_test_errors.py:37:9: ANN202 Missing return type annotation for private function `add_description_if_missing`
   |
35 |     category_pattern = r'(Category\(\s*(?:[^)]*?))\)'
36 |     
37 |     def add_description_if_missing(match):
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN202
38 |         constructor_content = match.group(1)
39 |         if 'description=' not in constructor_content:
   |
   = help: Add return type annotation

scripts\fix_snippet_test_errors.py:37:36: ANN001 Missing type annotation for function argument `match`
   |
35 |     category_pattern = r'(Category\(\s*(?:[^)]*?))\)'
36 |     
37 |     def add_description_if_missing(match):
   |                                    ^^^^^ ANN001
38 |         constructor_content = match.group(1)
39 |         if 'description=' not in constructor_content:
   |

scripts\fix_snippet_test_errors.py:44:121: E501 Line too long (121 > 120)
   |
42 |                 return f'{constructor_content}\n                description="Test category description",\n            )'
43 |             else:
44 |                 return f'{constructor_content},\n                description="Test category description",\n            )'
   |                                                                                                                         ^ E501
45 |         return match.group(0)
   |

scripts\fix_snippet_test_errors.py:51:5: D202 [*] No blank lines allowed after function docstring (found 1)
   |
50 | def fix_type_mismatches(content: str) -> str:
51 |     """Fix str | None vs str type mismatches by adding null checks."""
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D202
52 |     
53 |     # Fix category_id type mismatches in Snippet constructors
   |
   = help: Remove blank line(s) after function docstring

scripts\fix_snippet_test_errors.py:91:5: D202 [*] No blank lines allowed after function docstring (found 1)
   |
90 | def fix_duplicate_function_names(content: str) -> str:
91 |     """Fix duplicate function name definitions."""
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D202
92 |     
93 |     # Find and rename duplicate test_update_nonexistent_snippet
   |
   = help: Remove blank line(s) after function docstring

scripts\fix_snippet_test_errors.py:112:5: D202 [*] No blank lines allowed after function docstring (found 1)
    |
111 | def fix_return_type_mismatches(content: str) -> str:
112 |     """Fix return type mismatches."""
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D202
113 |     
114 |     # Fix incompatible return value type (got "int", expected "str")
    |
    = help: Remove blank line(s) after function docstring

scripts\fix_snippet_test_errors.py:125:5: ANN201 Missing return type annotation for public function `main`
    |
125 | def main():
    |     ^^^^ ANN201
126 |     """Main function to apply all fixes."""
    |
    = help: Add return type annotation: `None`

scripts\fix_snippet_test_errors.py:126:5: D202 [*] No blank lines allowed after function docstring (found 1)
    |
125 | def main():
126 |     """Main function to apply all fixes."""
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D202
127 |     
128 |     test_file = Path("tests/models/test_snippet.py")
    |
    = help: Remove blank line(s) after function docstring

scripts\fix_snippet_test_errors_v2.py:2:1: D205 1 blank line required between summary line and description
  |
1 |   #!/usr/bin/env python3
2 | / """
3 | | Improved batch fix script to comprehensively fix all remaining type errors in test_snippet.py.
4 | | This script addresses missing description arguments, syntax errors, and type mismatches.
5 | | """
  | |___^ D205
6 |
7 |   import re
  |
  = help: Insert single blank line

scripts\fix_snippet_test_errors_v2.py:2:1: D212 [*] Multi-line docstring summary should start at the first line
  |
1 |   #!/usr/bin/env python3
2 | / """
3 | | Improved batch fix script to comprehensively fix all remaining type errors in test_snippet.py.
4 | | This script addresses missing description arguments, syntax errors, and type mismatches.
5 | | """
  | |___^ D212
6 |
7 |   import re
  |
  = help: Remove whitespace after opening quotes

scripts\fix_snippet_test_errors_v2.py:11:5: ANN201 Missing return type annotation for public function `fix_test_snippet_errors_v2`
   |
11 | def fix_test_snippet_errors_v2():
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
12 |     """Fix all remaining type errors in test_snippet.py comprehensively."""
   |
   = help: Add return type annotation: `None`

scripts\fix_snippet_test_errors_v2.py:12:5: D202 [*] No blank lines allowed after function docstring (found 1)
   |
11 | def fix_test_snippet_errors_v2():
12 |     """Fix all remaining type errors in test_snippet.py comprehensively."""
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D202
13 |     
14 |     file_path = Path("tests/models/test_snippet.py")
   |
   = help: Remove blank line(s) after function docstring

scripts\fix_snippet_test_errors_v2.py:29:9: ANN202 Missing return type annotation for private function `fix_snippet_constructor`
   |
27 |     # Pattern: Snippet(...) without description
28 |     snippet_pattern = r'Snippet\(\s*([^)]*?)\s*\)'
29 |     def fix_snippet_constructor(match):
   |         ^^^^^^^^^^^^^^^^^^^^^^^ ANN202
30 |         args = match.group(1)
31 |         # Skip if already has description
   |
   = help: Add return type annotation

scripts\fix_snippet_test_errors_v2.py:29:33: ANN001 Missing type annotation for function argument `match`
   |
27 |     # Pattern: Snippet(...) without description
28 |     snippet_pattern = r'Snippet\(\s*([^)]*?)\s*\)'
29 |     def fix_snippet_constructor(match):
   |                                 ^^^^^ ANN001
30 |         args = match.group(1)
31 |         # Skip if already has description
   |

scripts\fix_snippet_test_errors_v2.py:45:9: ANN202 Missing return type annotation for private function `fix_category_constructor`
   |
43 |     # Pattern: Category(...) without description
44 |     category_pattern = r'Category\(\s*([^)]*?)\s*\)'
45 |     def fix_category_constructor(match):
   |         ^^^^^^^^^^^^^^^^^^^^^^^^ ANN202
46 |         args = match.group(1)
47 |         # Skip if already has description
   |
   = help: Add return type annotation

scripts\fix_snippet_test_errors_v2.py:45:34: ANN001 Missing type annotation for function argument `match`
   |
43 |     # Pattern: Category(...) without description
44 |     category_pattern = r'Category\(\s*([^)]*?)\s*\)'
45 |     def fix_category_constructor(match):
   |                                  ^^^^^ ANN001
46 |         args = match.group(1)
47 |         # Skip if already has description
   |

scripts\fix_snippet_test_errors_v2.py:80:121: E501 Line too long (136 > 120)
   |
78 | ΓÇª
79 | ΓÇª:\s*"""Test updating a non-existent snippet\."""',
80 | ΓÇªone:\n    """Test updating a non-existent snippet (duplicate test)."""',
   |                                                          ^^^^^^^^^^^^^^^^ E501
81 | ΓÇª
82 | ΓÇª
   |

scripts\fix_snippet_test_final.py:2:1: D205 1 blank line required between summary line and description
  |
1 |   #!/usr/bin/env python3
2 | / """
3 | | Final comprehensive batch fix script for test_snippet.py
4 | | Addresses all remaining missing description arguments, type mismatches, and syntax errors.
5 | | """
  | |___^ D205
6 |
7 |   import re
  |
  = help: Insert single blank line

scripts\fix_snippet_test_final.py:2:1: D212 [*] Multi-line docstring summary should start at the first line
  |
1 |   #!/usr/bin/env python3
2 | / """
3 | | Final comprehensive batch fix script for test_snippet.py
4 | | Addresses all remaining missing description arguments, type mismatches, and syntax errors.
5 | | """
  | |___^ D212
6 |
7 |   import re
  |
  = help: Remove whitespace after opening quotes

scripts\fix_snippet_test_final.py:7:1: I001 [*] Import block is un-sorted or un-formatted
   |
 5 |   """
 6 |
 7 | / import re
 8 | | import os
   | |_________^ I001
 9 |
10 |   def fix_test_snippet_final():
   |
   = help: Organize imports

scripts\fix_snippet_test_final.py:10:5: ANN201 Missing return type annotation for public function `fix_test_snippet_final`
   |
 8 | import os
 9 |
10 | def fix_test_snippet_final():
   |     ^^^^^^^^^^^^^^^^^^^^^^ ANN201
11 |     """Apply final comprehensive fixes to test_snippet.py"""
   |
   = help: Add return type annotation: `None`

scripts\fix_snippet_test_final.py:11:5: D202 [*] No blank lines allowed after function docstring (found 1)
   |
10 | def fix_test_snippet_final():
11 |     """Apply final comprehensive fixes to test_snippet.py"""
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D202
12 |     
13 |     file_path = r"d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py"
   |
   = help: Remove blank line(s) after function docstring

scripts\fix_snippet_test_final.py:11:5: D415 First line should end with a period, question mark, or exclamation point
   |
10 | def fix_test_snippet_final():
11 |     """Apply final comprehensive fixes to test_snippet.py"""
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D415
12 |     
13 |     file_path = r"d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py"
   |
   = help: Add closing punctuation

scripts\fix_snippet_test_final.py:29:121: E501 Line too long (162 > 120)
   |
27 | ΓÇª
28 | ΓÇª\s*\n\s*content=([^,\)]+)\s*\n\s*\)', 
29 | ΓÇª,\n            content=\3,\n            description="Test description",\n        )'),
   |                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
30 | ΓÇª
31 | ΓÇª
   |

scripts\fix_snippet_test_final.py:81:121: E501 Line too long (134 > 120)
   |
80 | ΓÇª
81 | ΓÇª)]+)\) -> None:\s*"""Test updating a snippet that doesn\'t exist\."""',
   |                                                           ^^^^^^^^^^^^^^ E501
82 | ΓÇªicate(\1) -> None:\n    """Test updating a snippet that doesn\'t exist (duplicate test)."""',
83 | ΓÇª
   |

scripts\fix_snippet_test_final.py:82:121: E501 Line too long (156 > 120)
   |
80 | ΓÇª
81 | ΓÇªone:\s*"""Test updating a snippet that doesn\'t exist\."""',
82 | ΓÇª> None:\n    """Test updating a snippet that doesn\'t exist (duplicate test)."""',
   |                                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
83 | ΓÇª
   |

services\__init__.py:1:1: D212 [*] Multi-line docstring summary should start at the first line
  |
1 | / """
2 | | Service initialization module.
3 | |
4 | | This module provides factory functions for creating and initializing service instances
5 | | with their required dependencies.
6 | | """
  | |___^ D212
7 |
8 |   from typing import Tuple
  |
  = help: Remove whitespace after opening quotes

services\__init__.py:14:5: D212 [*] Multi-line docstring summary should start at the first line
   |
13 |   def init_services(db_path: str) -> Tuple[DatabaseManager, object, object]:
14 | /     """
15 | |     Initialize and return all service instances with their dependencies.
16 | |
17 | |     Args:
18 | |         db_path: Path to the SQLite database file
19 | |
20 | |     Returns:
21 | |         A tuple containing (db_manager, snippet_manager, session_manager)
22 | |
23 | |     Example:
24 | |         db, snippets, sessions = init_services("path/to/db.sqlite")
25 | |     """
   | |_______^ D212
26 |       # Initialize database manager
27 |       db_manager = DatabaseManager(db_path)
   |
   = help: Remove whitespace after opening quotes

services\category_service.py:1:1: D100 Missing docstring in public module
services\database_viewer_service.py:1:1: D415 First line should end with a period, question mark, or exclamation point
   |
 1 | / """Database Viewer Service Module
 2 | |
 3 | | This module provides functionality for viewing and exploring database tables,
 4 | | including listing tables, fetching table data with pagination, sorting, filtering,
 5 | | and exporting to CSV.
 6 | |
 7 | | The service provides a read-only interface to access the database structure and content.
 8 | | """
   | |___^ D415
 9 |
10 |   import csv
   |
   = help: Add closing punctuation

services\database_viewer_service.py:50:5: D205 1 blank line required between summary line and description
   |
49 |   class DatabaseViewerService:
50 | /     """
51 | |     Service for database viewing operations: list tables, fetch data (with pagination,
52 | |     sorting, filtering), and export to CSV.
53 | |
54 | |     This service provides a read-only interface to inspect database tables and their contents.
55 | |     It handles pagination, sorting, and filtering of data, as well as exporting to CSV format.
56 | |     All operations are performed in a secure, read-only manner with proper input validation.
57 | |     """
   | |_______^ D205
58 |
59 |       def __init__(self, db_manager: DatabaseManager):
   |
   = help: Insert single blank line

services\database_viewer_service.py:50:5: D212 [*] Multi-line docstring summary should start at the first line
   |
49 |   class DatabaseViewerService:
50 | /     """
51 | |     Service for database viewing operations: list tables, fetch data (with pagination,
52 | |     sorting, filtering), and export to CSV.
53 | |
54 | |     This service provides a read-only interface to inspect database tables and their contents.
55 | |     It handles pagination, sorting, and filtering of data, as well as exporting to CSV format.
56 | |     All operations are performed in a secure, read-only manner with proper input validation.
57 | |     """
   | |_______^ D212
58 |
59 |       def __init__(self, db_manager: DatabaseManager):
   |
   = help: Remove whitespace after opening quotes

services\database_viewer_service.py:59:9: ANN204 Missing return type annotation for special method `__init__`
   |
57 |     """
58 |
59 |     def __init__(self, db_manager: DatabaseManager):
   |         ^^^^^^^^ ANN204
60 |         """
61 |         Initialize the DatabaseViewerService with a database manager.
   |
   = help: Add return type annotation: `None`

services\database_viewer_service.py:60:9: D212 [*] Multi-line docstring summary should start at the first line
   |
59 |       def __init__(self, db_manager: DatabaseManager):
60 | /         """
61 | |         Initialize the DatabaseViewerService with a database manager.
62 | |
63 | |         Args:
64 | |             db_manager: An instance of DatabaseManager for database access
65 | |         """
   | |___________^ D212
66 |           self.db_manager = db_manager
   |
   = help: Remove whitespace after opening quotes

services\database_viewer_service.py:69:9: D200 One-line docstring should fit on one line
   |
68 |       def list_tables(self) -> List[str]:
69 | /         """
70 | |         Return a list of all table names in the database (delegates to db_manager).
71 | |         """
   | |___________^ D200
72 |           return self.db_manager.list_tables()
   |
   = help: Reformat to one line

services\database_viewer_service.py:69:9: D212 [*] Multi-line docstring summary should start at the first line
   |
68 |       def list_tables(self) -> List[str]:
69 | /         """
70 | |         Return a list of all table names in the database (delegates to db_manager).
71 | |         """
   | |___________^ D212
72 |           return self.db_manager.list_tables()
   |
   = help: Remove whitespace after opening quotes

services\database_viewer_service.py:75:9: D205 1 blank line required between summary line and description
   |
74 |       def get_table_schema(self, table_name: str) -> List[Dict[str, Any]]:
75 | /         """
76 | |         Get schema information for the specified table.
77 | |         Args:
78 | |             table_name: The name of the table to get schema for
79 | |         Returns:
80 | |             A list of column definitions with name, type, etc.
81 | |         Raises:
82 | |             TableNotFoundError: If the specified table doesn't exist
83 | |         """
   | |___________^ D205
84 |           # Verify table exists using backend-agnostic method
85 |           if not self.db_manager.table_exists(table_name):
   |
   = help: Insert single blank line

services\database_viewer_service.py:75:9: D212 [*] Multi-line docstring summary should start at the first line
   |
74 |       def get_table_schema(self, table_name: str) -> List[Dict[str, Any]]:
75 | /         """
76 | |         Get schema information for the specified table.
77 | |         Args:
78 | |             table_name: The name of the table to get schema for
79 | |         Returns:
80 | |             A list of column definitions with name, type, etc.
81 | |         Raises:
82 | |             TableNotFoundError: If the specified table doesn't exist
83 | |         """
   | |___________^ D212
84 |           # Verify table exists using backend-agnostic method
85 |           if not self.db_manager.table_exists(table_name):
   |
   = help: Remove whitespace after opening quotes

services\database_viewer_service.py:75:9: D415 First line should end with a period, question mark, or exclamation point
   |
74 |       def get_table_schema(self, table_name: str) -> List[Dict[str, Any]]:
75 | /         """
76 | |         Get schema information for the specified table.
77 | |         Args:
78 | |             table_name: The name of the table to get schema for
79 | |         Returns:
80 | |             A list of column definitions with name, type, etc.
81 | |         Raises:
82 | |             TableNotFoundError: If the specified table doesn't exist
83 | |         """
   | |___________^ D415
84 |           # Verify table exists using backend-agnostic method
85 |           if not self.db_manager.table_exists(table_name):
   |
   = help: Add closing punctuation

services\database_viewer_service.py:77:9: D410 [*] Missing blank line after section ("Args")
   |
75 |         """
76 |         Get schema information for the specified table.
77 |         Args:
   |         ^^^^ D410
78 |             table_name: The name of the table to get schema for
79 |         Returns:
   |
   = help: Add blank line after "Args"

services\database_viewer_service.py:77:9: D411 [*] Missing blank line before section ("Args")
   |
75 |         """
76 |         Get schema information for the specified table.
77 |         Args:
   |         ^^^^ D411
78 |             table_name: The name of the table to get schema for
79 |         Returns:
   |
   = help: Add blank line before "Args"

services\database_viewer_service.py:81:9: D411 [*] Missing blank line before section ("Raises")
   |
79 |         Returns:
80 |             A list of column definitions with name, type, etc.
81 |         Raises:
   |         ^^^^^^ D411
82 |             TableNotFoundError: If the specified table doesn't exist
83 |         """
   |
   = help: Add blank line before "Raises"

services\database_viewer_service.py:140:9: D212 [*] Multi-line docstring summary should start at the first line
    |
138 |           filter_value: Optional[str] = None,
139 |       ) -> Dict[str, Any]:
140 | /         """
141 | |         Fetch table data with pagination, sorting, and filtering.
142 | |
143 | |         Args:
144 | |             table_name: Name of the table to query
145 | |             page: Page number (1-based)
146 | |             page_size: Number of rows per page
147 | |             sort_by: Column to sort by
148 | |             sort_order: Sort direction ('asc' or 'desc')
149 | |             filter_column: Column to filter on
150 | |             filter_value: Value to filter by (uses LIKE %value%)
151 | |
152 | |         Returns:
153 | |             Dict containing columns, rows, pagination info, etc.
154 | |
155 | |         Raises:
156 | |             TableNotFoundError: If table doesn't exist
157 | |             InvalidParameterError: If invalid parameters are provided
158 | |         """
    | |___________^ D212
159 |           # Input validation
160 |           if page < 1:
    |
    = help: Remove whitespace after opening quotes

services\database_viewer_service.py:260:9: D212 [*] Multi-line docstring summary should start at the first line
    |
258 |           filter_value: Optional[str] = None,
259 |       ) -> None:
260 | /         """
261 | |         Export the table data to CSV format.
262 | |
263 | |         Args:
264 | |             table_name: Name of the table to export
265 | |             output_file: File path or file-like object to write CSV to
266 | |             filter_column: Optional column to filter on
267 | |             filter_value: Optional value to filter by
268 | |
269 | |         Raises:
270 | |             TableNotFoundError: If table doesn't exist
271 | |             InvalidParameterError: If invalid parameters are provided
272 | |         """
    | |___________^ D212
273 |           # Get table data without pagination to export all rows
274 |           table_data = self.get_table_data(
    |
    = help: Remove whitespace after opening quotes

services\library_service.py:1:1: D100 Missing docstring in public module
services\library_service.py:15:7: D101 Missing docstring in public class
   |
15 | class ValidationError(Exception):
   |       ^^^^^^^^^^^^^^^ D101
16 |     pass
   |

services\library_service.py:23:7: D101 Missing docstring in public class
   |
23 | class Category(Base):
   |       ^^^^^^^^ D101
24 |     __tablename__ = "categories"
25 |     category_id = Column(Integer, primary_key=True, autoincrement=True)
   |

services\library_service.py:32:7: D101 Missing docstring in public class
   |
32 | class Snippet(Base):
   |       ^^^^^^^ D101
33 |     __tablename__ = "snippets"
34 |     snippet_id = Column(Integer, primary_key=True, autoincrement=True)
   |

services\library_service.py:44:7: D101 Missing docstring in public class
   |
44 | class LibraryService:
   |       ^^^^^^^^^^^^^^ D101
45 |     metadata = metadata
   |

services\library_service.py:47:9: ANN204 Missing return type annotation for special method `__init__`
   |
45 |     metadata = metadata
46 |
47 |     def __init__(self, session):
   |         ^^^^^^^^ ANN204
48 |         self.session = session
   |
   = help: Add return type annotation: `None`

services\library_service.py:47:9: D107 Missing docstring in `__init__`
   |
45 |     metadata = metadata
46 |
47 |     def __init__(self, session):
   |         ^^^^^^^^ D107
48 |         self.session = session
   |

services\library_service.py:47:24: ANN001 Missing type annotation for function argument `session`
   |
45 |     metadata = metadata
46 |
47 |     def __init__(self, session):
   |                        ^^^^^^^ ANN001
48 |         self.session = session
   |

services\library_service.py:51:9: ANN201 Missing return type annotation for public function `add_category`
   |
50 |     # Category methods
51 |     def add_category(self, name):
   |         ^^^^^^^^^^^^ ANN201
52 |         if not name or len(name) > 50 or not name.isascii():
53 |             raise ValidationError("Invalid category name")
   |
   = help: Add return type annotation

services\library_service.py:51:9: D102 Missing docstring in public method
   |
50 |     # Category methods
51 |     def add_category(self, name):
   |         ^^^^^^^^^^^^ D102
52 |         if not name or len(name) > 50 or not name.isascii():
53 |             raise ValidationError("Invalid category name")
   |

services\library_service.py:51:28: ANN001 Missing type annotation for function argument `name`
   |
50 |     # Category methods
51 |     def add_category(self, name):
   |                            ^^^^ ANN001
52 |         if not name or len(name) > 50 or not name.isascii():
53 |             raise ValidationError("Invalid category name")
   |

services\library_service.py:60:9: ANN201 Missing return type annotation for public function `get_categories`
   |
58 |         return cat
59 |
60 |     def get_categories(self):
   |         ^^^^^^^^^^^^^^ ANN201
61 |         return self.session.query(Category).all()
   |
   = help: Add return type annotation

services\library_service.py:60:9: D102 Missing docstring in public method
   |
58 |         return cat
59 |
60 |     def get_categories(self):
   |         ^^^^^^^^^^^^^^ D102
61 |         return self.session.query(Category).all()
   |

services\library_service.py:63:9: ANN201 Missing return type annotation for public function `edit_category`
   |
61 |         return self.session.query(Category).all()
62 |
63 |     def edit_category(self, category_id, new_name):
   |         ^^^^^^^^^^^^^ ANN201
64 |         if not new_name or len(new_name) > 50 or not new_name.isascii():
65 |             raise ValidationError("Invalid category name")
   |
   = help: Add return type annotation

services\library_service.py:63:9: D102 Missing docstring in public method
   |
61 |         return self.session.query(Category).all()
62 |
63 |     def edit_category(self, category_id, new_name):
   |         ^^^^^^^^^^^^^ D102
64 |         if not new_name or len(new_name) > 50 or not new_name.isascii():
65 |             raise ValidationError("Invalid category name")
   |

services\library_service.py:63:29: ANN001 Missing type annotation for function argument `category_id`
   |
61 |         return self.session.query(Category).all()
62 |
63 |     def edit_category(self, category_id, new_name):
   |                             ^^^^^^^^^^^ ANN001
64 |         if not new_name or len(new_name) > 50 or not new_name.isascii():
65 |             raise ValidationError("Invalid category name")
   |

services\library_service.py:63:42: ANN001 Missing type annotation for function argument `new_name`
   |
61 |         return self.session.query(Category).all()
62 |
63 |     def edit_category(self, category_id, new_name):
   |                                          ^^^^^^^^ ANN001
64 |         if not new_name or len(new_name) > 50 or not new_name.isascii():
65 |             raise ValidationError("Invalid category name")
   |

services\library_service.py:78:9: ANN201 Missing return type annotation for public function `delete_category`
   |
76 |         return cat
77 |
78 |     def delete_category(self, category_id):
   |         ^^^^^^^^^^^^^^^ ANN201
79 |         cat = self.session.query(Category).filter_by(category_id=category_id).first()
80 |         if not cat:
   |
   = help: Add return type annotation: `None`

services\library_service.py:78:9: D102 Missing docstring in public method
   |
76 |         return cat
77 |
78 |     def delete_category(self, category_id):
   |         ^^^^^^^^^^^^^^^ D102
79 |         cat = self.session.query(Category).filter_by(category_id=category_id).first()
80 |         if not cat:
   |

services\library_service.py:78:31: ANN001 Missing type annotation for function argument `category_id`
   |
76 |         return cat
77 |
78 |     def delete_category(self, category_id):
   |                               ^^^^^^^^^^^ ANN001
79 |         cat = self.session.query(Category).filter_by(category_id=category_id).first()
80 |         if not cat:
   |

services\library_service.py:85:9: ANN201 Missing return type annotation for public function `add_snippet`
   |
84 |     # Snippet methods
85 |     def add_snippet(self, category_id, name, content):
   |         ^^^^^^^^^^^ ANN201
86 |         if not name or len(name) > 50 or not name.isascii():
87 |             raise ValidationError("Invalid snippet name")
   |
   = help: Add return type annotation

services\library_service.py:85:9: D102 Missing docstring in public method
   |
84 |     # Snippet methods
85 |     def add_snippet(self, category_id, name, content):
   |         ^^^^^^^^^^^ D102
86 |         if not name or len(name) > 50 or not name.isascii():
87 |             raise ValidationError("Invalid snippet name")
   |

services\library_service.py:85:27: ANN001 Missing type annotation for function argument `category_id`
   |
84 |     # Snippet methods
85 |     def add_snippet(self, category_id, name, content):
   |                           ^^^^^^^^^^^ ANN001
86 |         if not name or len(name) > 50 or not name.isascii():
87 |             raise ValidationError("Invalid snippet name")
   |

services\library_service.py:85:40: ANN001 Missing type annotation for function argument `name`
   |
84 |     # Snippet methods
85 |     def add_snippet(self, category_id, name, content):
   |                                        ^^^^ ANN001
86 |         if not name or len(name) > 50 or not name.isascii():
87 |             raise ValidationError("Invalid snippet name")
   |

services\library_service.py:85:46: ANN001 Missing type annotation for function argument `content`
   |
84 |     # Snippet methods
85 |     def add_snippet(self, category_id, name, content):
   |                                              ^^^^^^^ ANN001
86 |         if not name or len(name) > 50 or not name.isascii():
87 |             raise ValidationError("Invalid snippet name")
   |

services\library_service.py:100:9: ANN201 Missing return type annotation for public function `get_snippets`
    |
 98 |         return snip
 99 |
100 |     def get_snippets(self, category_id):
    |         ^^^^^^^^^^^^ ANN201
101 |         return self.session.query(Snippet).filter_by(category_id=category_id).all()
    |
    = help: Add return type annotation

services\library_service.py:100:9: D102 Missing docstring in public method
    |
 98 |         return snip
 99 |
100 |     def get_snippets(self, category_id):
    |         ^^^^^^^^^^^^ D102
101 |         return self.session.query(Snippet).filter_by(category_id=category_id).all()
    |

services\library_service.py:100:28: ANN001 Missing type annotation for function argument `category_id`
    |
 98 |         return snip
 99 |
100 |     def get_snippets(self, category_id):
    |                            ^^^^^^^^^^^ ANN001
101 |         return self.session.query(Snippet).filter_by(category_id=category_id).all()
    |

services\library_service.py:103:9: ANN201 Missing return type annotation for public function `edit_snippet`
    |
101 |         return self.session.query(Snippet).filter_by(category_id=category_id).all()
102 |
103 |     def edit_snippet(self, snippet_id, new_name, new_content, new_category_id=None):
    |         ^^^^^^^^^^^^ ANN201
104 |         if not new_name or len(new_name) > 50 or not new_name.isascii():
105 |             raise ValidationError("Invalid snippet name")
    |
    = help: Add return type annotation

services\library_service.py:103:9: D102 Missing docstring in public method
    |
101 |         return self.session.query(Snippet).filter_by(category_id=category_id).all()
102 |
103 |     def edit_snippet(self, snippet_id, new_name, new_content, new_category_id=None):
    |         ^^^^^^^^^^^^ D102
104 |         if not new_name or len(new_name) > 50 or not new_name.isascii():
105 |             raise ValidationError("Invalid snippet name")
    |

services\library_service.py:103:28: ANN001 Missing type annotation for function argument `snippet_id`
    |
101 |         return self.session.query(Snippet).filter_by(category_id=category_id).all()
102 |
103 |     def edit_snippet(self, snippet_id, new_name, new_content, new_category_id=None):
    |                            ^^^^^^^^^^ ANN001
104 |         if not new_name or len(new_name) > 50 or not new_name.isascii():
105 |             raise ValidationError("Invalid snippet name")
    |

services\library_service.py:103:40: ANN001 Missing type annotation for function argument `new_name`
    |
101 |         return self.session.query(Snippet).filter_by(category_id=category_id).all()
102 |
103 |     def edit_snippet(self, snippet_id, new_name, new_content, new_category_id=None):
    |                                        ^^^^^^^^ ANN001
104 |         if not new_name or len(new_name) > 50 or not new_name.isascii():
105 |             raise ValidationError("Invalid snippet name")
    |

services\library_service.py:103:50: ANN001 Missing type annotation for function argument `new_content`
    |
101 |         return self.session.query(Snippet).filter_by(category_id=category_id).all()
102 |
103 |     def edit_snippet(self, snippet_id, new_name, new_content, new_category_id=None):
    |                                                  ^^^^^^^^^^^ ANN001
104 |         if not new_name or len(new_name) > 50 or not new_name.isascii():
105 |             raise ValidationError("Invalid snippet name")
    |

services\library_service.py:103:63: ANN001 Missing type annotation for function argument `new_category_id`
    |
101 |         return self.session.query(Snippet).filter_by(category_id=category_id).all()
102 |
103 |     def edit_snippet(self, snippet_id, new_name, new_content, new_category_id=None):
    |                                                               ^^^^^^^^^^^^^^^ ANN001
104 |         if not new_name or len(new_name) > 50 or not new_name.isascii():
105 |             raise ValidationError("Invalid snippet name")
    |

services\library_service.py:129:9: ANN201 Missing return type annotation for public function `delete_snippet`
    |
127 |         return snip
128 |
129 |     def delete_snippet(self, snippet_id):
    |         ^^^^^^^^^^^^^^ ANN201
130 |         snip = self.session.query(Snippet).filter_by(snippet_id=snippet_id).first()
131 |         if not snip:
    |
    = help: Add return type annotation: `None`

services\library_service.py:129:9: D102 Missing docstring in public method
    |
127 |         return snip
128 |
129 |     def delete_snippet(self, snippet_id):
    |         ^^^^^^^^^^^^^^ D102
130 |         snip = self.session.query(Snippet).filter_by(snippet_id=snippet_id).first()
131 |         if not snip:
    |

services\library_service.py:129:30: ANN001 Missing type annotation for function argument `snippet_id`
    |
127 |         return snip
128 |
129 |     def delete_snippet(self, snippet_id):
    |                              ^^^^^^^^^^ ANN001
130 |         snip = self.session.query(Snippet).filter_by(snippet_id=snippet_id).first()
131 |         if not snip:
    |

session_fix_script.py:1:1: D100 Missing docstring in public module
setup.py:1:1: D100 Missing docstring in public module
snippet_api.py:1:1: D100 Missing docstring in public module
temp_fix_script.py:1:1: D100 Missing docstring in public module
test_debug_mode.py:2:1: D212 [*] Multi-line docstring summary should start at the first line
  |
1 |   #!/usr/bin/env python3
2 | / """
3 | | Test script to demonstrate the debug mode functionality.
4 | |
5 | | This script shows how the debug_mode parameter controls debug output
6 | | in the AI Typing Trainer application.
7 | | """
  | |___^ D212
8 |
9 |   import os
  |
  = help: Remove whitespace after opening quotes

test_debug_mode.py:18:5: ANN201 Missing return type annotation for public function `test_debug_mode_functionality`
   |
18 | def test_debug_mode_functionality():
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
19 |     """Test the debug mode functionality with different settings."""
   |
   = help: Add return type annotation: `None`

test_debug_mode.py:19:5: D202 [*] No blank lines allowed after function docstring (found 1)
   |
18 | def test_debug_mode_functionality():
19 |     """Test the debug mode functionality with different settings."""
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D202
20 |     
21 |     print("=== Testing Debug Mode Functionality ===\n")
   |
   = help: Remove blank line(s) after function docstring

test_debug_mode.py:55:5: ANN201 Missing return type annotation for public function `test_main_menu_integration`
   |
55 | def test_main_menu_integration():
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
56 |     """Test the main menu integration with debug mode."""
   |
   = help: Add return type annotation: `None`

test_debug_mode.py:56:5: D202 [*] No blank lines allowed after function docstring (found 1)
   |
55 | def test_main_menu_integration():
56 |     """Test the main menu integration with debug mode."""
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D202
57 |     
58 |     print("\n=== Testing Main Menu Integration ===\n")
   |
   = help: Remove blank line(s) after function docstring

test_debug_util_integration.py:2:1: D200 One-line docstring should fit on one line
  |
1 |   #!/usr/bin/env python3
2 | / """
3 | | Test script to verify DebugUtil integration with main_menu and DatabaseManager.
4 | | """
  | |___^ D200
5 |
6 |   import os
  |
  = help: Reformat to one line

test_debug_util_integration.py:2:1: D212 [*] Multi-line docstring summary should start at the first line
  |
1 |   #!/usr/bin/env python3
2 | / """
3 | | Test script to verify DebugUtil integration with main_menu and DatabaseManager.
4 | | """
  | |___^ D212
5 |
6 |   import os
  |
  = help: Remove whitespace after opening quotes

test_debug_util_integration.py:6:1: I001 [*] Import block is un-sorted or un-formatted
   |
 4 |   """
 5 |
 6 | / import os
 7 | | import sys
 8 | | import tempfile
 9 | | from io import StringIO
10 | | from contextlib import redirect_stdout
   | |______________________________________^ I001
11 |
12 |   # Add project root to path
   |
   = help: Organize imports

test_debug_util_integration.py:15:1: I001 [*] Import block is un-sorted or un-formatted
   |
13 |   sys.path.insert(0, os.path.dirname(__file__))
14 |
15 | / from helpers.debug_util import DebugUtil
16 | | from db.database_manager import DatabaseManager, ConnectionType
   | |_______________________________________________________________^ I001
   |
   = help: Organize imports

test_debug_util_integration.py:19:5: ANN201 Missing return type annotation for public function `test_debug_util_standalone`
   |
19 | def test_debug_util_standalone():
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
20 |     """Test the DebugUtil class functionality standalone."""
   |
   = help: Add return type annotation: `None`

test_debug_util_integration.py:20:5: D202 [*] No blank lines allowed after function docstring (found 1)
   |
19 | def test_debug_util_standalone():
20 |     """Test the DebugUtil class functionality standalone."""
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D202
21 |     
22 |     print("=== Testing DebugUtil Standalone ===\n")
   |
   = help: Remove blank line(s) after function docstring

test_debug_util_integration.py:59:5: ANN201 Missing return type annotation for public function `test_database_manager_integration`
   |
59 | def test_database_manager_integration():
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
60 |     """Test DatabaseManager integration with DebugUtil."""
   |
   = help: Add return type annotation: `None`

test_debug_util_integration.py:60:5: D202 [*] No blank lines allowed after function docstring (found 1)
   |
59 | def test_database_manager_integration():
60 |     """Test DatabaseManager integration with DebugUtil."""
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D202
61 |     
62 |     print("=== Testing DatabaseManager Integration ===\n")
   |
   = help: Remove blank line(s) after function docstring

test_debug_util_integration.py:106:9: E722 Do not use bare `except`
    |
104 |         try:
105 |             os.unlink(temp_db_path)
106 |         except:
    |         ^^^^^^ E722
107 |             pass
    |

test_debug_util_integration.py:135:9: E722 Do not use bare `except`
    |
133 |         try:
134 |             os.unlink(temp_db_path)
135 |         except:
    |         ^^^^^^ E722
136 |             pass
    |

test_debug_util_integration.py:141:5: ANN201 Missing return type annotation for public function `test_fallback_behavior`
    |
141 | def test_fallback_behavior():
    |     ^^^^^^^^^^^^^^^^^^^^^^ ANN201
142 |     """Test fallback behavior when DebugUtil is not provided."""
    |
    = help: Add return type annotation: `None`

test_debug_util_integration.py:142:5: D202 [*] No blank lines allowed after function docstring (found 1)
    |
141 | def test_fallback_behavior():
142 |     """Test fallback behavior when DebugUtil is not provided."""
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D202
143 |     
144 |     print("=== Testing Fallback Behavior ===\n")
    |
    = help: Remove blank line(s) after function docstring

test_debug_util_integration.py:174:9: E722 Do not use bare `except`
    |
172 |         try:
173 |             os.unlink(temp_db_path)
174 |         except:
    |         ^^^^^^ E722
175 |             pass
    |

test_main_menu_args.py:2:1: D200 One-line docstring should fit on one line
  |
1 |   #!/usr/bin/env python3
2 | / """
3 | | Test script to verify command line argument parsing in main_menu.py
4 | | """
  | |___^ D200
5 |
6 |   import sys
  |
  = help: Reformat to one line

test_main_menu_args.py:2:1: D212 [*] Multi-line docstring summary should start at the first line
  |
1 |   #!/usr/bin/env python3
2 | / """
3 | | Test script to verify command line argument parsing in main_menu.py
4 | | """
  | |___^ D212
5 |
6 |   import sys
  |
  = help: Remove whitespace after opening quotes

test_main_menu_args.py:2:1: D415 First line should end with a period, question mark, or exclamation point
  |
1 |   #!/usr/bin/env python3
2 | / """
3 | | Test script to verify command line argument parsing in main_menu.py
4 | | """
  | |___^ D415
5 |
6 |   import sys
  |
  = help: Add closing punctuation

test_main_menu_args.py:6:1: I001 [*] Import block is un-sorted or un-formatted
  |
4 |   """
5 |
6 | / import sys
7 | | import os
  | |_________^ I001
8 |
9 |   # Add project root to path
  |
  = help: Organize imports

test_main_menu_args.py:12:5: ANN201 Missing return type annotation for public function `test_argument_parsing`
   |
10 | sys.path.insert(0, os.path.dirname(__file__))
11 |
12 | def test_argument_parsing():
   |     ^^^^^^^^^^^^^^^^^^^^^ ANN201
13 |     """Test the command line argument parsing logic from main_menu.py"""
   |
   = help: Add return type annotation: `None`

test_main_menu_args.py:13:5: D202 [*] No blank lines allowed after function docstring (found 1)
   |
12 | def test_argument_parsing():
13 |     """Test the command line argument parsing logic from main_menu.py"""
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D202
14 |     
15 |     print("=== Testing Main Menu Command Line Argument Parsing ===\n")
   |
   = help: Remove blank line(s) after function docstring

test_main_menu_args.py:13:5: D415 First line should end with a period, question mark, or exclamation point
   |
12 | def test_argument_parsing():
13 |     """Test the command line argument parsing logic from main_menu.py"""
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D415
14 |     
15 |     print("=== Testing Main Menu Command Line Argument Parsing ===\n")
   |
   = help: Add closing punctuation

tests\__init__.py:1:1: D104 Missing docstring in public package
tests\conftest.py:1:1: D200 One-line docstring should fit on one line
  |
1 | / """
2 | | Pytest configuration for the test suite.
3 | | """
  | |___^ D200
4 |   # Standard library imports
5 |   import os
  |
  = help: Reformat to one line

tests\conftest.py:1:1: D212 [*] Multi-line docstring summary should start at the first line
  |
1 | / """
2 | | Pytest configuration for the test suite.
3 | | """
  | |___^ D212
4 |   # Standard library imports
5 |   import os
  |
  = help: Remove whitespace after opening quotes

tests\db\__init__.py:1:1: D200 One-line docstring should fit on one line
  |
1 | / """
2 | | Test package for database-related tests.
3 | | """
  | |___^ D200
  |
  = help: Reformat to one line

tests\db\__init__.py:1:1: D212 [*] Multi-line docstring summary should start at the first line
  |
1 | / """
2 | | Test package for database-related tests.
3 | | """
  | |___^ D212
  |
  = help: Remove whitespace after opening quotes

tests\db\conftest.py:1:1: D212 [*] Multi-line docstring summary should start at the first line
  |
1 | / """
2 | | Pytest configuration for database tests.
3 | |
4 | | This file imports fixtures from the db_helpers module to make them available to all
5 | | test files in the db directory without explicit imports.
6 | | """
  | |___^ D212
  |
  = help: Remove whitespace after opening quotes

tests\db\test_database_exceptions.py:1:1: D200 One-line docstring should fit on one line
  |
1 | / """
2 | | Tests for database exception handling in DatabaseManager.
3 | | """
  | |___^ D200
4 |
5 |   import pytest
  |
  = help: Reformat to one line

tests\db\test_database_exceptions.py:1:1: D212 [*] Multi-line docstring summary should start at the first line
  |
1 | / """
2 | | Tests for database exception handling in DatabaseManager.
3 | | """
  | |___^ D212
4 |
5 |   import pytest
  |
  = help: Remove whitespace after opening quotes

tests\db\test_database_manager.py:1:1: D212 [*] Multi-line docstring summary should start at the first line
  |
1 | / """
2 | | Tests for the DatabaseManager class.
3 | |
4 | | This module contains comprehensive tests for the DatabaseManager class,
5 | | verifying its functionality, error handling, and edge cases.
6 | | """
  | |___^ D212
7 |
8 |   import os
  |
  = help: Remove whitespace after opening quotes

tests\db\test_database_manager.py:8:1: I001 [*] Import block is un-sorted or un-formatted
   |
 6 |   """
 7 |
 8 | / import os
 9 | | import tempfile
10 | | from typing import Any, Generator, Iterable, Optional, TextIO, Tuple, cast
11 | |
12 | | import pytest
13 | |
14 | | from db.database_manager import (
15 | |     CLOUD_DEPENDENCIES_AVAILABLE,
16 | |     ConnectionType,
17 | |     DatabaseManager,
18 | |     BulkMethod,
19 | | )
20 | | from db.database_manager import (
21 | |     CursorProtocol as DBCursorProtocol,
22 | | )
23 | | from db.exceptions import (
24 | |     ConstraintError,
25 | |     DatabaseError,
26 | |     DBConnectionError,
27 | |     ForeignKeyError,
28 | |     SchemaError,
29 | |     TableNotFoundError,
30 | | )
   | |_^ I001
31 |
32 |   # Test data constants
   |
   = help: Organize imports

tests\db\test_database_manager.py:43:5: D212 [*] Multi-line docstring summary should start at the first line
   |
41 |   @pytest.fixture(scope="function")
42 |   def temp_db_path() -> Generator[str, None, None]:
43 | /     """
44 | |     Create a temporary database file for testing.
45 | |
46 | |     Yields:
47 | |         str: Path to the temporary database file
48 | |
49 | |     The database file is automatically deleted after the test completes.
50 | |     """
   | |_______^ D212
51 |       with tempfile.NamedTemporaryFile(delete=False, suffix=".db") as tmp:
52 |           db_path = tmp.name
   |
   = help: Remove whitespace after opening quotes

tests\db\test_database_manager.py:65:5: D212 [*] Multi-line docstring summary should start at the first line
   |
63 |   @pytest.fixture(scope="function")
64 |   def db_manager(temp_db_path: str) -> DatabaseManager:
65 | /     """
66 | |     Create a DatabaseManager instance with a temporary database.
67 | |
68 | |     Args:
69 | |         temp_db_path: Path to the temporary database file
70 | |
71 | |     Returns:
72 | |         DatabaseManager: A new DatabaseManager instance
73 | |     """
   | |_______^ D212
74 |       return DatabaseManager(temp_db_path)
   |
   = help: Remove whitespace after opening quotes

tests\db\test_database_manager.py:79:5: D212 [*] Multi-line docstring summary should start at the first line
   |
77 |   @pytest.fixture(scope="function")
78 |   def initialized_db(db_manager: DatabaseManager) -> DatabaseManager:
79 | /     """
80 | |     Create a database with a test table and sample data.
81 | |
82 | |     Args:
83 | |         db_manager: DatabaseManager instance
84 | |
85 | |     Returns:
86 | |         DatabaseManager: The same DatabaseManager instance with test data
87 | |     """
   | |_______^ D212
88 |       # Create a test table
89 |       db_manager.execute(
   |
   = help: Remove whitespace after opening quotes

tests\db\test_database_manager.py:293:9: D102 Missing docstring in public method
    |
292 |     @pytest.fixture()
293 |     def sqlite_db(self, temp_db_path: str) -> Generator[DatabaseManager, None, None]:
    |         ^^^^^^^^^ D102
294 |         with DatabaseManager(temp_db_path) as db:
295 |             self._drop_table(db)
    |

tests\db\test_database_manager.py:308:9: D102 Missing docstring in public method
    |
307 |     @pytest.fixture()
308 |     def cloud_db(self) -> Generator[DatabaseManager, None, None]:
    |         ^^^^^^^^ D102
309 |         if not self._cloud_available():
310 |             pytest.skip("Cloud DB tests disabled or dependencies unavailable")
    |

tests\db\test_database_manager.py:319:9: D102 Missing docstring in public method
    |
317 |     # -------- SQLite positive and error scenarios --------
318 |
319 |     def test_execute_many_insert_success_sqlite(self, sqlite_db: DatabaseManager) -> None:
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
320 |         rows = [
321 |             (1, "Alice", 12.5, "2025-08-09T07:21:55-04:00", "a@example.com", 1),
    |

tests\db\test_database_manager.py:334:9: D102 Missing docstring in public method
    |
332 |         assert [tuple(r.values()) for r in results] == rows
333 |
334 |     def test_execute_many_pk_violation_sqlite(self, sqlite_db: DatabaseManager) -> None:
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
335 |         sqlite_db.execute_many(
336 |             f"INSERT INTO {self.TEST_TABLE} (id, name) VALUES (?, ?)",
    |

tests\db\test_database_manager.py:345:9: D102 Missing docstring in public method
    |
343 |             )
344 |
345 |     def test_execute_many_unique_violation_sqlite(self, sqlite_db: DatabaseManager) -> None:
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
346 |         sqlite_db.execute_many(
347 |             f"INSERT INTO {self.TEST_TABLE} (id, name, email) VALUES (?, ?, ?)",
    |

tests\db\test_database_manager.py:356:9: D102 Missing docstring in public method
    |
354 |             )
355 |
356 |     def test_execute_many_not_null_violation_sqlite(self, sqlite_db: DatabaseManager) -> None:
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
357 |         with pytest.raises(ConstraintError):
358 |             sqlite_db.execute_many(
    |

tests\db\test_database_manager.py:363:9: D102 Missing docstring in public method
    |
361 |             )
362 |
363 |     def test_execute_many_table_not_found_sqlite(self, sqlite_db: DatabaseManager) -> None:
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
364 |         with pytest.raises(TableNotFoundError):
365 |             sqlite_db.execute_many(
    |

tests\db\test_database_manager.py:372:9: D102 Missing docstring in public method
    |
370 |     # -------- Cloud (Postgres) scenarios, conditional --------
371 |
372 |     def test_execute_many_insert_success_cloud(self, cloud_db: DatabaseManager) -> None:
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
373 |         rows = [
374 |             (100, "P-Alice", 1.25, "2025-08-09T07:21:55Z", "pa@example.com", 1),
    |

tests\db\test_database_manager.py:401:9: D102 Missing docstring in public method
    |
399 |         assert got == exp
400 |
401 |     def test_execute_many_method_options_sqlite(self, sqlite_db: DatabaseManager) -> None:
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
402 |         rows = [
403 |             (11, "M1", 1.0, None, None, None),
    |

tests\db\test_database_manager.py:442:9: D102 Missing docstring in public method
    |
440 |         ],
441 |     )
442 |     def test_execute_many_method_options_cloud(
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
443 |         self, cloud_db: DatabaseManager, method: BulkMethod, base_id: int, rows: list[tuple]
444 |     ) -> None:
    |

tests\db\test_database_manager.py:466:9: D102 Missing docstring in public method
    |
464 |         assert [r["id"] for r in results] == ids
465 |
466 |     def test_postgres_bulk_insert_performance(self, cloud_db: DatabaseManager, capsys: Any) -> None:
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
467 |         import time
    |

tests\db\test_database_manager.py:466:88: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `capsys`
    |
464 |         assert [r["id"] for r in results] == ids
465 |
466 |     def test_postgres_bulk_insert_performance(self, cloud_db: DatabaseManager, capsys: Any) -> None:
    |                                                                                        ^^^ ANN401
467 |         import time
    |

tests\db\test_database_manager.py:499:9: D102 Missing docstring in public method
    |
497 |         assert "ms total" in captured.out
498 |
499 |     def test_execute_many_pk_violation_cloud(self, cloud_db: DatabaseManager) -> None:
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
500 |         cloud_db.execute_many(
501 |             f"INSERT INTO {self.TEST_TABLE} (id, name) VALUES (?, ?)",
    |

tests\db\test_database_manager.py:510:9: D102 Missing docstring in public method
    |
508 |             )
509 |
510 |     def test_execute_many_unique_violation_cloud(self, cloud_db: DatabaseManager) -> None:
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
511 |         cloud_db.execute_many(
512 |             f"INSERT INTO {self.TEST_TABLE} (id, name, email) VALUES (?, ?, ?)",
    |

tests\db\test_database_manager.py:521:9: D102 Missing docstring in public method
    |
519 |             )
520 |
521 |     def test_execute_many_not_null_violation_cloud(self, cloud_db: DatabaseManager) -> None:
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
522 |         with pytest.raises(ConstraintError):
523 |             cloud_db.execute_many(
    |

tests\db\test_database_manager.py:532:9: D102 Missing docstring in public method
    |
530 |     """Explicit unit tests for execute_many helper methods and schema qualifier."""
531 |
532 |     def test__bulk_executemany_sqlite_inserts(self, db_manager: DatabaseManager) -> None:
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
533 |         # Arrange: create table
534 |         db_manager.execute(
    |

tests\db\test_database_manager.py:552:9: D102 Missing docstring in public method
    |
550 |         assert [tuple(r.values()) for r in got] == rows
551 |
552 |     def test__bulk_execute_values_calls_psycopg2_extras(
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
553 |         self,
554 |         db_manager: DatabaseManager,
    |

tests\db\test_database_manager.py:613:9: D102 Missing docstring in public method
    |
611 |             )
612 |
613 |     def test__bulk_copy_from_builds_tsv_and_calls_copy(self, db_manager: DatabaseManager) -> None:
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
614 |         # Arrange fake cursor to capture copy_from inputs
615 |         captured = {"table": None, "columns": None, "content": None}
    |

tests\db\test_database_manager.py:657:121: E501 Line too long (143 > 120)
    |
655 | ΓÇª WHERE id=%s"),
656 | ΓÇª
657 | ΓÇªWHERE table_schema = %s AND table_type = 'BASE TABLE' ORDER BY table_name",
    |                                                      ^^^^^^^^^^^^^^^^^^^^^^^ E501
658 | ΓÇªWHERE table_schema = typing AND table_type = 'BASE TABLE' ORDER BY table_name",
659 | ΓÇª
    |

tests\db\test_database_manager.py:658:121: E501 Line too long (147 > 120)
    |
656 | ΓÇª
657 | ΓÇªERE table_schema = %s AND table_type = 'BASE TABLE' ORDER BY table_name",
658 | ΓÇªERE table_schema = typing AND table_type = 'BASE TABLE' ORDER BY table_name",
    |                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
659 | ΓÇª
660 | ΓÇªoo WHERE id=%s"),
    |

tests\desktop_ui\__init__.py:1:1: D104 Missing docstring in public package
tests\desktop_ui\conftest.py:1:1: D200 One-line docstring should fit on one line
  |
1 | / """
2 | | Pytest configuration and fixtures for desktop_ui tests.
3 | | """
  | |___^ D200
4 |   import os
5 |   import tempfile
  |
  = help: Reformat to one line

tests\desktop_ui\conftest.py:1:1: D212 [*] Multi-line docstring summary should start at the first line
  |
1 | / """
2 | | Pytest configuration and fixtures for desktop_ui tests.
3 | | """
  | |___^ D212
4 |   import os
5 |   import tempfile
  |
  = help: Remove whitespace after opening quotes

tests\desktop_ui\conftest.py:118:5: D212 [*] Multi-line docstring summary should start at the first line
    |
116 |   @pytest.fixture(scope="session")
117 |   def app() -> Generator[QApplication, None, None]:
118 | /     """
119 | |     Fixture providing a QApplication instance for GUI tests.
120 | |
121 | |     Yields:
122 | |         QApplication: The application instance
123 | |     """
    | |_______^ D212
124 |       app = QApplication.instance()
125 |       if app is None:
    |
    = help: Remove whitespace after opening quotes

tests\desktop_ui\test_db_viewer_dialog.py:1:1: D200 One-line docstring should fit on one line
  |
1 | / """
2 | | Tests for the Database Viewer Dialog UI component.
3 | | """
  | |___^ D200
4 |
5 |   import os
  |
  = help: Reformat to one line

tests\desktop_ui\test_db_viewer_dialog.py:1:1: D212 [*] Multi-line docstring summary should start at the first line
  |
1 | / """
2 | | Tests for the Database Viewer Dialog UI component.
3 | | """
  | |___^ D212
4 |
5 |   import os
  |
  = help: Remove whitespace after opening quotes

tests\desktop_ui\test_db_viewer_dialog.py:22:5: ANN201 Missing return type annotation for public function `qtapp`
   |
21 | @pytest.fixture
22 | def qtapp():
   |     ^^^^^ ANN201
23 |     """Create a QApplication instance for testing.
24 |     This avoids conflicts with pytest-flask by creating a dedicated QApplication for Qt tests.
   |
   = help: Add return type annotation

tests\desktop_ui\test_db_viewer_dialog.py:23:5: D205 1 blank line required between summary line and description
   |
21 |   @pytest.fixture
22 |   def qtapp():
23 | /     """Create a QApplication instance for testing.
24 | |     This avoids conflicts with pytest-flask by creating a dedicated QApplication for Qt tests.
25 | |     """
   | |_______^ D205
26 |       app = QApplication.instance()
27 |       if app is None:
   |
   = help: Insert single blank line

tests\desktop_ui\test_db_viewer_dialog.py:35:9: ANN204 Missing return type annotation for special method `__init__`
   |
33 |     """Simple QtBot class to replace pytest-qt's qtbot when it's not available."""
34 |
35 |     def __init__(self, app):
   |         ^^^^^^^^ ANN204
36 |         self.app = app
37 |         self.widgets = []
   |
   = help: Add return type annotation: `None`

tests\desktop_ui\test_db_viewer_dialog.py:35:9: D107 Missing docstring in `__init__`
   |
33 |     """Simple QtBot class to replace pytest-qt's qtbot when it's not available."""
34 |
35 |     def __init__(self, app):
   |         ^^^^^^^^ D107
36 |         self.app = app
37 |         self.widgets = []
   |

tests\desktop_ui\test_db_viewer_dialog.py:35:24: ANN001 Missing type annotation for function argument `app`
   |
33 |     """Simple QtBot class to replace pytest-qt's qtbot when it's not available."""
34 |
35 |     def __init__(self, app):
   |                        ^^^ ANN001
36 |         self.app = app
37 |         self.widgets = []
   |

tests\desktop_ui\test_db_viewer_dialog.py:39:9: ANN201 Missing return type annotation for public function `addWidget`
   |
37 |         self.widgets = []
38 |
39 |     def addWidget(self, widget):
   |         ^^^^^^^^^ ANN201
40 |         """Keep track of widgets to ensure they don't get garbage collected."""
41 |         self.widgets.append(widget)
   |
   = help: Add return type annotation

tests\desktop_ui\test_db_viewer_dialog.py:39:25: ANN001 Missing type annotation for function argument `widget`
   |
37 |         self.widgets = []
38 |
39 |     def addWidget(self, widget):
   |                         ^^^^^^ ANN001
40 |         """Keep track of widgets to ensure they don't get garbage collected."""
41 |         self.widgets.append(widget)
   |

tests\desktop_ui\test_db_viewer_dialog.py:44:9: ANN201 Missing return type annotation for public function `mouseClick`
   |
42 |         return widget
43 |
44 |     def mouseClick(self, widget, button=Qt.LeftButton, pos=None):
   |         ^^^^^^^^^^ ANN201
45 |         """Simulate mouse click."""
46 |         if pos is None:
   |
   = help: Add return type annotation: `None`

tests\desktop_ui\test_db_viewer_dialog.py:44:26: ANN001 Missing type annotation for function argument `widget`
   |
42 |         return widget
43 |
44 |     def mouseClick(self, widget, button=Qt.LeftButton, pos=None):
   |                          ^^^^^^ ANN001
45 |         """Simulate mouse click."""
46 |         if pos is None:
   |

tests\desktop_ui\test_db_viewer_dialog.py:44:34: ANN001 Missing type annotation for function argument `button`
   |
42 |         return widget
43 |
44 |     def mouseClick(self, widget, button=Qt.LeftButton, pos=None):
   |                                  ^^^^^^ ANN001
45 |         """Simulate mouse click."""
46 |         if pos is None:
   |

tests\desktop_ui\test_db_viewer_dialog.py:44:56: ANN001 Missing type annotation for function argument `pos`
   |
42 |         return widget
43 |
44 |     def mouseClick(self, widget, button=Qt.LeftButton, pos=None):
   |                                                        ^^^ ANN001
45 |         """Simulate mouse click."""
46 |         if pos is None:
   |

tests\desktop_ui\test_db_viewer_dialog.py:57:5: ANN201 Missing return type annotation for public function `qtbot`
   |
56 | @pytest.fixture
57 | def qtbot(qtapp):
   |     ^^^^^ ANN201
58 |     """Create a QtBot instance for testing when pytest-qt's qtbot isn't available."""
59 |     return QtBot(qtapp)
   |
   = help: Add return type annotation

tests\desktop_ui\test_db_viewer_dialog.py:57:11: ANN001 Missing type annotation for function argument `qtapp`
   |
56 | @pytest.fixture
57 | def qtbot(qtapp):
   |           ^^^^^ ANN001
58 |     """Create a QtBot instance for testing when pytest-qt's qtbot isn't available."""
59 |     return QtBot(qtapp)
   |

tests\desktop_ui\test_db_viewer_dialog.py:63:5: ANN201 Missing return type annotation for public function `mock_db_viewer_service`
   |
62 | @pytest.fixture
63 | def mock_db_viewer_service():
   |     ^^^^^^^^^^^^^^^^^^^^^^ ANN201
64 |     """Create a mock DatabaseViewerService for testing."""
65 |     service = MagicMock(spec=DatabaseViewerService)
   |
   = help: Add return type annotation

tests\desktop_ui\test_db_viewer_dialog.py:85:5: ANN201 Missing return type annotation for public function `test_db_viewer_dialog_initialization`
   |
85 | def test_db_viewer_dialog_initialization(qtapp, mock_db_viewer_service, qtbot):
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
86 |     """Test that the DatabaseViewerDialog initializes correctly."""
87 |     # Setup mock for table data with more complete structure
   |
   = help: Add return type annotation: `None`

tests\desktop_ui\test_db_viewer_dialog.py:85:42: ANN001 Missing type annotation for function argument `qtapp`
   |
85 | def test_db_viewer_dialog_initialization(qtapp, mock_db_viewer_service, qtbot):
   |                                          ^^^^^ ANN001
86 |     """Test that the DatabaseViewerDialog initializes correctly."""
87 |     # Setup mock for table data with more complete structure
   |

tests\desktop_ui\test_db_viewer_dialog.py:85:49: ANN001 Missing type annotation for function argument `mock_db_viewer_service`
   |
85 | def test_db_viewer_dialog_initialization(qtapp, mock_db_viewer_service, qtbot):
   |                                                 ^^^^^^^^^^^^^^^^^^^^^^ ANN001
86 |     """Test that the DatabaseViewerDialog initializes correctly."""
87 |     # Setup mock for table data with more complete structure
   |

tests\desktop_ui\test_db_viewer_dialog.py:85:73: ANN001 Missing type annotation for function argument `qtbot`
   |
85 | def test_db_viewer_dialog_initialization(qtapp, mock_db_viewer_service, qtbot):
   |                                                                         ^^^^^ ANN001
86 |     """Test that the DatabaseViewerDialog initializes correctly."""
87 |     # Setup mock for table data with more complete structure
   |

tests\desktop_ui\test_db_viewer_dialog.py:137:5: ANN201 Missing return type annotation for public function `test_table_selection`
    |
137 | def test_table_selection(qtapp, mock_db_viewer_service, qtbot):
    |     ^^^^^^^^^^^^^^^^^^^^ ANN201
138 |     """Test that selecting a table loads its data."""
139 |     dialog = DatabaseViewerDialog(service=mock_db_viewer_service)
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_db_viewer_dialog.py:137:26: ANN001 Missing type annotation for function argument `qtapp`
    |
137 | def test_table_selection(qtapp, mock_db_viewer_service, qtbot):
    |                          ^^^^^ ANN001
138 |     """Test that selecting a table loads its data."""
139 |     dialog = DatabaseViewerDialog(service=mock_db_viewer_service)
    |

tests\desktop_ui\test_db_viewer_dialog.py:137:33: ANN001 Missing type annotation for function argument `mock_db_viewer_service`
    |
137 | def test_table_selection(qtapp, mock_db_viewer_service, qtbot):
    |                                 ^^^^^^^^^^^^^^^^^^^^^^ ANN001
138 |     """Test that selecting a table loads its data."""
139 |     dialog = DatabaseViewerDialog(service=mock_db_viewer_service)
    |

tests\desktop_ui\test_db_viewer_dialog.py:137:57: ANN001 Missing type annotation for function argument `qtbot`
    |
137 | def test_table_selection(qtapp, mock_db_viewer_service, qtbot):
    |                                                         ^^^^^ ANN001
138 |     """Test that selecting a table loads its data."""
139 |     dialog = DatabaseViewerDialog(service=mock_db_viewer_service)
    |

tests\desktop_ui\test_db_viewer_dialog.py:184:5: ANN201 Missing return type annotation for public function `test_pagination`
    |
184 | def test_pagination(qtapp, mock_db_viewer_service, qtbot):
    |     ^^^^^^^^^^^^^^^ ANN201
185 |     """Test pagination controls."""
186 |     # First prepare the mock to return pagination data
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_db_viewer_dialog.py:184:21: ANN001 Missing type annotation for function argument `qtapp`
    |
184 | def test_pagination(qtapp, mock_db_viewer_service, qtbot):
    |                     ^^^^^ ANN001
185 |     """Test pagination controls."""
186 |     # First prepare the mock to return pagination data
    |

tests\desktop_ui\test_db_viewer_dialog.py:184:28: ANN001 Missing type annotation for function argument `mock_db_viewer_service`
    |
184 | def test_pagination(qtapp, mock_db_viewer_service, qtbot):
    |                            ^^^^^^^^^^^^^^^^^^^^^^ ANN001
185 |     """Test pagination controls."""
186 |     # First prepare the mock to return pagination data
    |

tests\desktop_ui\test_db_viewer_dialog.py:184:52: ANN001 Missing type annotation for function argument `qtbot`
    |
184 | def test_pagination(qtapp, mock_db_viewer_service, qtbot):
    |                                                    ^^^^^ ANN001
185 |     """Test pagination controls."""
186 |     # First prepare the mock to return pagination data
    |

tests\desktop_ui\test_db_viewer_dialog.py:241:5: ANN201 Missing return type annotation for public function `test_sorting`
    |
241 | def test_sorting(qtapp, mock_db_viewer_service, qtbot):
    |     ^^^^^^^^^^^^ ANN201
242 |     """Test column sorting."""
243 |     dialog = DatabaseViewerDialog(service=mock_db_viewer_service)
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_db_viewer_dialog.py:241:18: ANN001 Missing type annotation for function argument `qtapp`
    |
241 | def test_sorting(qtapp, mock_db_viewer_service, qtbot):
    |                  ^^^^^ ANN001
242 |     """Test column sorting."""
243 |     dialog = DatabaseViewerDialog(service=mock_db_viewer_service)
    |

tests\desktop_ui\test_db_viewer_dialog.py:241:25: ANN001 Missing type annotation for function argument `mock_db_viewer_service`
    |
241 | def test_sorting(qtapp, mock_db_viewer_service, qtbot):
    |                         ^^^^^^^^^^^^^^^^^^^^^^ ANN001
242 |     """Test column sorting."""
243 |     dialog = DatabaseViewerDialog(service=mock_db_viewer_service)
    |

tests\desktop_ui\test_db_viewer_dialog.py:241:49: ANN001 Missing type annotation for function argument `qtbot`
    |
241 | def test_sorting(qtapp, mock_db_viewer_service, qtbot):
    |                                                 ^^^^^ ANN001
242 |     """Test column sorting."""
243 |     dialog = DatabaseViewerDialog(service=mock_db_viewer_service)
    |

tests\desktop_ui\test_db_viewer_dialog.py:310:5: ANN201 Missing return type annotation for public function `test_filtering`
    |
310 | def test_filtering(qtapp, mock_db_viewer_service, qtbot):
    |     ^^^^^^^^^^^^^^ ANN201
311 |     """Test table filtering."""
312 |     dialog = DatabaseViewerDialog(service=mock_db_viewer_service)
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_db_viewer_dialog.py:310:20: ANN001 Missing type annotation for function argument `qtapp`
    |
310 | def test_filtering(qtapp, mock_db_viewer_service, qtbot):
    |                    ^^^^^ ANN001
311 |     """Test table filtering."""
312 |     dialog = DatabaseViewerDialog(service=mock_db_viewer_service)
    |

tests\desktop_ui\test_db_viewer_dialog.py:310:27: ANN001 Missing type annotation for function argument `mock_db_viewer_service`
    |
310 | def test_filtering(qtapp, mock_db_viewer_service, qtbot):
    |                           ^^^^^^^^^^^^^^^^^^^^^^ ANN001
311 |     """Test table filtering."""
312 |     dialog = DatabaseViewerDialog(service=mock_db_viewer_service)
    |

tests\desktop_ui\test_db_viewer_dialog.py:310:51: ANN001 Missing type annotation for function argument `qtbot`
    |
310 | def test_filtering(qtapp, mock_db_viewer_service, qtbot):
    |                                                   ^^^^^ ANN001
311 |     """Test table filtering."""
312 |     dialog = DatabaseViewerDialog(service=mock_db_viewer_service)
    |

tests\desktop_ui\test_db_viewer_dialog.py:352:5: ANN201 Missing return type annotation for public function `test_export_to_csv`
    |
350 | @patch("PySide6.QtWidgets.QFileDialog.getSaveFileName")
351 | @patch("PySide6.QtWidgets.QMessageBox.information")
352 | def test_export_to_csv(mock_info_box, mock_get_save_filename, qtapp, mock_db_viewer_service, qtbot):
    |     ^^^^^^^^^^^^^^^^^^ ANN201
353 |     """Test exporting to CSV."""
354 |     # Setup mock to return a file path
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_db_viewer_dialog.py:352:24: ANN001 Missing type annotation for function argument `mock_info_box`
    |
350 | @patch("PySide6.QtWidgets.QFileDialog.getSaveFileName")
351 | @patch("PySide6.QtWidgets.QMessageBox.information")
352 | def test_export_to_csv(mock_info_box, mock_get_save_filename, qtapp, mock_db_viewer_service, qtbot):
    |                        ^^^^^^^^^^^^^ ANN001
353 |     """Test exporting to CSV."""
354 |     # Setup mock to return a file path
    |

tests\desktop_ui\test_db_viewer_dialog.py:352:39: ANN001 Missing type annotation for function argument `mock_get_save_filename`
    |
350 | @patch("PySide6.QtWidgets.QFileDialog.getSaveFileName")
351 | @patch("PySide6.QtWidgets.QMessageBox.information")
352 | def test_export_to_csv(mock_info_box, mock_get_save_filename, qtapp, mock_db_viewer_service, qtbot):
    |                                       ^^^^^^^^^^^^^^^^^^^^^^ ANN001
353 |     """Test exporting to CSV."""
354 |     # Setup mock to return a file path
    |

tests\desktop_ui\test_db_viewer_dialog.py:352:63: ANN001 Missing type annotation for function argument `qtapp`
    |
350 | @patch("PySide6.QtWidgets.QFileDialog.getSaveFileName")
351 | @patch("PySide6.QtWidgets.QMessageBox.information")
352 | def test_export_to_csv(mock_info_box, mock_get_save_filename, qtapp, mock_db_viewer_service, qtbot):
    |                                                               ^^^^^ ANN001
353 |     """Test exporting to CSV."""
354 |     # Setup mock to return a file path
    |

tests\desktop_ui\test_db_viewer_dialog.py:352:70: ANN001 Missing type annotation for function argument `mock_db_viewer_service`
    |
350 | @patch("PySide6.QtWidgets.QFileDialog.getSaveFileName")
351 | @patch("PySide6.QtWidgets.QMessageBox.information")
352 | def test_export_to_csv(mock_info_box, mock_get_save_filename, qtapp, mock_db_viewer_service, qtbot):
    |                                                                      ^^^^^^^^^^^^^^^^^^^^^^ ANN001
353 |     """Test exporting to CSV."""
354 |     # Setup mock to return a file path
    |

tests\desktop_ui\test_db_viewer_dialog.py:352:94: ANN001 Missing type annotation for function argument `qtbot`
    |
350 | @patch("PySide6.QtWidgets.QFileDialog.getSaveFileName")
351 | @patch("PySide6.QtWidgets.QMessageBox.information")
352 | def test_export_to_csv(mock_info_box, mock_get_save_filename, qtapp, mock_db_viewer_service, qtbot):
    |                                                                                              ^^^^^ ANN001
353 |     """Test exporting to CSV."""
354 |     # Setup mock to return a file path
    |

tests\desktop_ui\test_db_viewer_dialog.py:371:9: ANN202 Missing return type annotation for private function `custom_export`
    |
370 |     # Create a custom implementation of export_to_csv to bypass QFileDialog issue
371 |     def custom_export():
    |         ^^^^^^^^^^^^^ ANN202
372 |         # This simulates user selecting a file name from QFileDialog
373 |         # and the method proceeding with that file name
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_db_viewer_dialog.py:405:5: ANN201 Missing return type annotation for public function `test_error_handling`
    |
405 | def test_error_handling(qtapp, mock_db_viewer_service, qtbot):
    |     ^^^^^^^^^^^^^^^^^^^ ANN201
406 |     """Test error handling for service exceptions."""
407 |     dialog = DatabaseViewerDialog(service=mock_db_viewer_service)
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_db_viewer_dialog.py:405:25: ANN001 Missing type annotation for function argument `qtapp`
    |
405 | def test_error_handling(qtapp, mock_db_viewer_service, qtbot):
    |                         ^^^^^ ANN001
406 |     """Test error handling for service exceptions."""
407 |     dialog = DatabaseViewerDialog(service=mock_db_viewer_service)
    |

tests\desktop_ui\test_db_viewer_dialog.py:405:32: ANN001 Missing type annotation for function argument `mock_db_viewer_service`
    |
405 | def test_error_handling(qtapp, mock_db_viewer_service, qtbot):
    |                                ^^^^^^^^^^^^^^^^^^^^^^ ANN001
406 |     """Test error handling for service exceptions."""
407 |     dialog = DatabaseViewerDialog(service=mock_db_viewer_service)
    |

tests\desktop_ui\test_db_viewer_dialog.py:405:56: ANN001 Missing type annotation for function argument `qtbot`
    |
405 | def test_error_handling(qtapp, mock_db_viewer_service, qtbot):
    |                                                        ^^^^^ ANN001
406 |     """Test error handling for service exceptions."""
407 |     dialog = DatabaseViewerDialog(service=mock_db_viewer_service)
    |

tests\desktop_ui\test_db_viewer_dialog.py:429:5: ANN201 Missing return type annotation for public function `test_empty_table_handling`
    |
429 | def test_empty_table_handling(qtapp, mock_db_viewer_service, qtbot):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
430 |     """Test handling of empty tables."""
431 |     # Configure service to return empty table data
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_db_viewer_dialog.py:429:31: ANN001 Missing type annotation for function argument `qtapp`
    |
429 | def test_empty_table_handling(qtapp, mock_db_viewer_service, qtbot):
    |                               ^^^^^ ANN001
430 |     """Test handling of empty tables."""
431 |     # Configure service to return empty table data
    |

tests\desktop_ui\test_db_viewer_dialog.py:429:38: ANN001 Missing type annotation for function argument `mock_db_viewer_service`
    |
429 | def test_empty_table_handling(qtapp, mock_db_viewer_service, qtbot):
    |                                      ^^^^^^^^^^^^^^^^^^^^^^ ANN001
430 |     """Test handling of empty tables."""
431 |     # Configure service to return empty table data
    |

tests\desktop_ui\test_db_viewer_dialog.py:429:62: ANN001 Missing type annotation for function argument `qtbot`
    |
429 | def test_empty_table_handling(qtapp, mock_db_viewer_service, qtbot):
    |                                                              ^^^^^ ANN001
430 |     """Test handling of empty tables."""
431 |     # Configure service to return empty table data
    |

tests\desktop_ui\test_db_viewer_dialog.py:460:5: ANN201 Missing return type annotation for public function `test_count_result_edge_cases`
    |
460 | def test_count_result_edge_cases(qtapp, qtbot):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
461 |     """Test edge cases in count result handling that could cause tuple index out of range."""
462 |     from services.database_viewer_service import DatabaseViewerService
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_db_viewer_dialog.py:460:34: ANN001 Missing type annotation for function argument `qtapp`
    |
460 | def test_count_result_edge_cases(qtapp, qtbot):
    |                                  ^^^^^ ANN001
461 |     """Test edge cases in count result handling that could cause tuple index out of range."""
462 |     from services.database_viewer_service import DatabaseViewerService
    |

tests\desktop_ui\test_db_viewer_dialog.py:460:41: ANN001 Missing type annotation for function argument `qtbot`
    |
460 | def test_count_result_edge_cases(qtapp, qtbot):
    |                                         ^^^^^ ANN001
461 |     """Test edge cases in count result handling that could cause tuple index out of range."""
462 |     from services.database_viewer_service import DatabaseViewerService
    |

tests\desktop_ui\test_db_viewer_dialog.py:462:5: I001 [*] Import block is un-sorted or un-formatted
    |
460 |   def test_count_result_edge_cases(qtapp, qtbot):
461 |       """Test edge cases in count result handling that could cause tuple index out of range."""
462 | /     from services.database_viewer_service import DatabaseViewerService
463 | |     from unittest.mock import MagicMock
    | |_______________________________________^ I001
464 |
465 |       # Create a real service instance with mocked db_manager
    |
    = help: Organize imports

tests\desktop_ui\test_db_viewer_dialog.py:503:5: ANN201 Missing return type annotation for public function `test_pagination_with_zero_total_pages`
    |
503 | def test_pagination_with_zero_total_pages(qtapp, mock_db_viewer_service, qtbot):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
504 |     """Test pagination controls when total_pages is 0."""
505 |     # Configure service to return data with 0 total pages
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_db_viewer_dialog.py:503:43: ANN001 Missing type annotation for function argument `qtapp`
    |
503 | def test_pagination_with_zero_total_pages(qtapp, mock_db_viewer_service, qtbot):
    |                                           ^^^^^ ANN001
504 |     """Test pagination controls when total_pages is 0."""
505 |     # Configure service to return data with 0 total pages
    |

tests\desktop_ui\test_db_viewer_dialog.py:503:50: ANN001 Missing type annotation for function argument `mock_db_viewer_service`
    |
503 | def test_pagination_with_zero_total_pages(qtapp, mock_db_viewer_service, qtbot):
    |                                                  ^^^^^^^^^^^^^^^^^^^^^^ ANN001
504 |     """Test pagination controls when total_pages is 0."""
505 |     # Configure service to return data with 0 total pages
    |

tests\desktop_ui\test_db_viewer_dialog.py:503:74: ANN001 Missing type annotation for function argument `qtbot`
    |
503 | def test_pagination_with_zero_total_pages(qtapp, mock_db_viewer_service, qtbot):
    |                                                                          ^^^^^ ANN001
504 |     """Test pagination controls when total_pages is 0."""
505 |     # Configure service to return data with 0 total pages
    |

tests\desktop_ui\test_db_viewer_dialog.py:531:5: ANN201 Missing return type annotation for public function `test_service_integration_with_real_count_scenarios`
    |
531 | def test_service_integration_with_real_count_scenarios(qtapp, qtbot):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
532 |     """Test service integration with various count result scenarios."""
533 |     from services.database_viewer_service import DatabaseViewerService
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_db_viewer_dialog.py:531:56: ANN001 Missing type annotation for function argument `qtapp`
    |
531 | def test_service_integration_with_real_count_scenarios(qtapp, qtbot):
    |                                                        ^^^^^ ANN001
532 |     """Test service integration with various count result scenarios."""
533 |     from services.database_viewer_service import DatabaseViewerService
    |

tests\desktop_ui\test_db_viewer_dialog.py:531:63: ANN001 Missing type annotation for function argument `qtbot`
    |
531 | def test_service_integration_with_real_count_scenarios(qtapp, qtbot):
    |                                                               ^^^^^ ANN001
532 |     """Test service integration with various count result scenarios."""
533 |     from services.database_viewer_service import DatabaseViewerService
    |

tests\desktop_ui\test_db_viewer_dialog.py:533:5: I001 [*] Import block is un-sorted or un-formatted
    |
531 |   def test_service_integration_with_real_count_scenarios(qtapp, qtbot):
532 |       """Test service integration with various count result scenarios."""
533 | /     from services.database_viewer_service import DatabaseViewerService
534 | |     from unittest.mock import MagicMock
    | |_______________________________________^ I001
535 |
536 |       # Create service with mocked database manager
    |
    = help: Organize imports

tests\desktop_ui\test_db_viewer_dialog_fixed.py:1:1: D200 One-line docstring should fit on one line
  |
1 | / """
2 | | Tests for the Database Viewer Dialog UI component.
3 | | """
  | |___^ D200
4 |
5 |   import os
  |
  = help: Reformat to one line

tests\desktop_ui\test_db_viewer_dialog_fixed.py:1:1: D212 [*] Multi-line docstring summary should start at the first line
  |
1 | / """
2 | | Tests for the Database Viewer Dialog UI component.
3 | | """
  | |___^ D212
4 |
5 |   import os
  |
  = help: Remove whitespace after opening quotes

tests\desktop_ui\test_db_viewer_dialog_fixed.py:24:5: D205 1 blank line required between summary line and description
   |
22 |   @pytest.fixture
23 |   def qtapp() -> QApplication:
24 | /     """Create a QApplication instance for testing.
25 | |     This avoids conflicts with pytest-flask by creating a dedicated QApplication for Qt tests.
26 | |     """
   | |_______^ D205
27 |       app = QApplication.instance()
28 |       if app is None:
   |
   = help: Insert single blank line

tests\desktop_ui\test_db_viewer_dialog_fixed.py:37:9: D107 Missing docstring in `__init__`
   |
35 |     """Simple QtBot class to replace pytest-qt's qtbot when it's not available."""
36 |
37 |     def __init__(self, app: QApplication) -> None:
   |         ^^^^^^^^ D107
38 |         self.app = app
39 |         self.widgets: List[Any] = []
   |

tests\desktop_ui\test_db_viewer_dialog_fixed.py:41:33: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `widget`
   |
39 |         self.widgets: List[Any] = []
40 |
41 |     def addWidget(self, widget: Any) -> Any:
   |                                 ^^^ ANN401
42 |         """Keep track of widgets to ensure they don't get garbage collected."""
43 |         self.widgets.append(widget)
   |

tests\desktop_ui\test_db_viewer_dialog_fixed.py:41:41: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `addWidget`
   |
39 |         self.widgets: List[Any] = []
40 |
41 |     def addWidget(self, widget: Any) -> Any:
   |                                         ^^^ ANN401
42 |         """Keep track of widgets to ensure they don't get garbage collected."""
43 |         self.widgets.append(widget)
   |

tests\desktop_ui\test_db_viewer_dialog_fixed.py:46:34: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `widget`
   |
44 |         return widget
45 |
46 |     def mouseClick(self, widget: Any, button: Any = Qt.LeftButton, pos: Any = None) -> None:
   |                                  ^^^ ANN401
47 |         """Simulate mouse click."""
48 |         if pos is None:
   |

tests\desktop_ui\test_db_viewer_dialog_fixed.py:46:47: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `button`
   |
44 |         return widget
45 |
46 |     def mouseClick(self, widget: Any, button: Any = Qt.LeftButton, pos: Any = None) -> None:
   |                                               ^^^ ANN401
47 |         """Simulate mouse click."""
48 |         if pos is None:
   |

tests\desktop_ui\test_db_viewer_dialog_fixed.py:46:73: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `pos`
   |
44 |         return widget
45 |
46 |     def mouseClick(self, widget: Any, button: Any = Qt.LeftButton, pos: Any = None) -> None:
   |                                                                         ^^^ ANN401
47 |         """Simulate mouse click."""
48 |         if pos is None:
   |

tests\desktop_ui\test_db_viewer_dialog_fixed.py:67:9: D107 Missing docstring in `__init__`
   |
65 |     """Mock QTableWidgetItem for testing."""
66 |
67 |     def __init__(self, text: str = "") -> None:
   |         ^^^^^^^^ D107
68 |         self._text = text
   |

tests\desktop_ui\test_db_viewer_dialog_fixed.py:70:9: D102 Missing docstring in public method
   |
68 |         self._text = text
69 |
70 |     def text(self) -> str:
   |         ^^^^ D102
71 |         return self._text
   |

tests\desktop_ui\test_drill_config.py:1:1: D100 Missing docstring in public module
tests\desktop_ui\test_library_main_ui_new.py:1:1: D212 [*] Multi-line docstring summary should start at the first line
  |
1 | / """
2 | | Tests for LibraryManager and Snippets Library functionality.
3 | |
4 | | This test suite covers only the models/library.py logic (categories, snippets, CRUD, validation).
5 | | """
  | |___^ D212
6 |
7 |   import os
  |
  = help: Remove whitespace after opening quotes

tests\desktop_ui\test_library_main_ui_new.py:45:5: D212 [*] Multi-line docstring summary should start at the first line
   |
43 |   @pytest.fixture
44 |   def db_manager(temp_db: str) -> Generator[DatabaseManager, None, None]:
45 | /     """
46 | |     Provide a DatabaseManager instance with a temporary database.
47 | |
48 | |     Args:
49 | |         temp_db: Path to the temporary database file
50 | |
51 | |     Yields:
52 | |         DatabaseManager: A database manager instance connected to the temp database
53 | |     """
   | |_______^ D212
54 |       db = None
55 |       try:
   |
   = help: Remove whitespace after opening quotes

tests\desktop_ui\test_library_main_ui_new.py:76:5: ANN201 Missing return type annotation for public function `qt_app`
   |
75 | @pytest.fixture(scope="module")
76 | def qt_app():
   |     ^^^^^^ ANN201
77 |     """Provide a QApplication instance for UI tests."""
78 |     app = QApplication.instance()
   |
   = help: Add return type annotation

tests\desktop_ui\test_library_main_ui_new.py:85:5: ANN201 Missing return type annotation for public function `mock_db_manager`
   |
84 | @pytest.fixture
85 | def mock_db_manager(db_manager):
   |     ^^^^^^^^^^^^^^^ ANN201
86 |     # Patch CategoryManager and SnippetManager to use the test db
87 |     return db_manager
   |
   = help: Add return type annotation

tests\desktop_ui\test_library_main_ui_new.py:85:5: D103 Missing docstring in public function
   |
84 | @pytest.fixture
85 | def mock_db_manager(db_manager):
   |     ^^^^^^^^^^^^^^^ D103
86 |     # Patch CategoryManager and SnippetManager to use the test db
87 |     return db_manager
   |

tests\desktop_ui\test_library_main_ui_new.py:85:21: ANN001 Missing type annotation for function argument `db_manager`
   |
84 | @pytest.fixture
85 | def mock_db_manager(db_manager):
   |                     ^^^^^^^^^^ ANN001
86 |     # Patch CategoryManager and SnippetManager to use the test db
87 |     return db_manager
   |

tests\desktop_ui\test_library_main_ui_new.py:91:5: ANN201 Missing return type annotation for public function `main_window`
   |
90 | @pytest.fixture
91 | def main_window(qt_app, mock_db_manager):
   |     ^^^^^^^^^^^ ANN201
92 |     win = library_main.LibraryMainWindow(db_manager=mock_db_manager, testing_mode=True)
93 |     yield win
   |
   = help: Add return type annotation

tests\desktop_ui\test_library_main_ui_new.py:91:5: D103 Missing docstring in public function
   |
90 | @pytest.fixture
91 | def main_window(qt_app, mock_db_manager):
   |     ^^^^^^^^^^^ D103
92 |     win = library_main.LibraryMainWindow(db_manager=mock_db_manager, testing_mode=True)
93 |     yield win
   |

tests\desktop_ui\test_library_main_ui_new.py:91:17: ANN001 Missing type annotation for function argument `qt_app`
   |
90 | @pytest.fixture
91 | def main_window(qt_app, mock_db_manager):
   |                 ^^^^^^ ANN001
92 |     win = library_main.LibraryMainWindow(db_manager=mock_db_manager, testing_mode=True)
93 |     yield win
   |

tests\desktop_ui\test_library_main_ui_new.py:91:25: ANN001 Missing type annotation for function argument `mock_db_manager`
   |
90 | @pytest.fixture
91 | def main_window(qt_app, mock_db_manager):
   |                         ^^^^^^^^^^^^^^^ ANN001
92 |     win = library_main.LibraryMainWindow(db_manager=mock_db_manager, testing_mode=True)
93 |     yield win
   |

tests\desktop_ui\test_library_main_ui_new.py:153:10: B017 Do not assert blind exception: `Exception`
    |
151 | def test_create_snippet_invalid_category(library_manager: LibraryManager) -> None:
152 |     """Test creating a snippet with an invalid category."""
153 |     with pytest.raises(Exception):
    |          ^^^^^^^^^^^^^^^^^^^^^^^^ B017
154 |         library_manager.create_snippet("nonexistent", "Name", "Content")
    |

tests\desktop_ui\test_library_main_ui_new.py:159:10: B017 Do not assert blind exception: `Exception`
    |
157 | def test_edit_snippet_invalid_id(library_manager: LibraryManager) -> None:
158 |     """Test editing a snippet with an invalid ID."""
159 |     with pytest.raises(Exception):
    |          ^^^^^^^^^^^^^^^^^^^^^^^^ B017
160 |         library_manager.edit_snippet("badid", "Name", "Content")
    |

tests\desktop_ui\test_library_main_ui_new.py:182:7: D101 Missing docstring in public class
    |
182 | class TestLibraryMainWindowUI:
    |       ^^^^^^^^^^^^^^^^^^^^^^^ D101
183 |     def test_load_data_and_initial_state(self, main_window):
184 |         win = main_window
    |

tests\desktop_ui\test_library_main_ui_new.py:183:9: ANN201 Missing return type annotation for public function `test_load_data_and_initial_state`
    |
182 | class TestLibraryMainWindowUI:
183 |     def test_load_data_and_initial_state(self, main_window):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
184 |         win = main_window
185 |         # Should load with no categories/snippets
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:183:9: D102 Missing docstring in public method
    |
182 | class TestLibraryMainWindowUI:
183 |     def test_load_data_and_initial_state(self, main_window):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
184 |         win = main_window
185 |         # Should load with no categories/snippets
    |

tests\desktop_ui\test_library_main_ui_new.py:183:48: ANN001 Missing type annotation for function argument `main_window`
    |
182 | class TestLibraryMainWindowUI:
183 |     def test_load_data_and_initial_state(self, main_window):
    |                                                ^^^^^^^^^^^ ANN001
184 |         win = main_window
185 |         # Should load with no categories/snippets
    |

tests\desktop_ui\test_library_main_ui_new.py:190:9: ANN201 Missing return type annotation for public function `test_add_category`
    |
188 |         assert win.status.text() == ""
189 |
190 |     def test_add_category(self, main_window, monkeypatch):
    |         ^^^^^^^^^^^^^^^^^ ANN201
191 |         win = main_window
192 |         # Simulate dialog returning Accepted and a name
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:190:9: D102 Missing docstring in public method
    |
188 |         assert win.status.text() == ""
189 |
190 |     def test_add_category(self, main_window, monkeypatch):
    |         ^^^^^^^^^^^^^^^^^ D102
191 |         win = main_window
192 |         # Simulate dialog returning Accepted and a name
    |

tests\desktop_ui\test_library_main_ui_new.py:190:33: ANN001 Missing type annotation for function argument `main_window`
    |
188 |         assert win.status.text() == ""
189 |
190 |     def test_add_category(self, main_window, monkeypatch):
    |                                 ^^^^^^^^^^^ ANN001
191 |         win = main_window
192 |         # Simulate dialog returning Accepted and a name
    |

tests\desktop_ui\test_library_main_ui_new.py:190:46: ANN001 Missing type annotation for function argument `monkeypatch`
    |
188 |         assert win.status.text() == ""
189 |
190 |     def test_add_category(self, main_window, monkeypatch):
    |                                              ^^^^^^^^^^^ ANN001
191 |         win = main_window
192 |         # Simulate dialog returning Accepted and a name
    |

tests\desktop_ui\test_library_main_ui_new.py:202:9: ANN201 Missing return type annotation for public function `test_edit_category`
    |
200 |         assert win.categoryList.count() > 0
201 |
202 |     def test_edit_category(self, main_window, monkeypatch):
    |         ^^^^^^^^^^^^^^^^^^ ANN201
203 |         win = main_window
204 |         # Ensure there is at least one category to edit
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:202:9: D102 Missing docstring in public method
    |
200 |         assert win.categoryList.count() > 0
201 |
202 |     def test_edit_category(self, main_window, monkeypatch):
    |         ^^^^^^^^^^^^^^^^^^ D102
203 |         win = main_window
204 |         # Ensure there is at least one category to edit
    |

tests\desktop_ui\test_library_main_ui_new.py:202:34: ANN001 Missing type annotation for function argument `main_window`
    |
200 |         assert win.categoryList.count() > 0
201 |
202 |     def test_edit_category(self, main_window, monkeypatch):
    |                                  ^^^^^^^^^^^ ANN001
203 |         win = main_window
204 |         # Ensure there is at least one category to edit
    |

tests\desktop_ui\test_library_main_ui_new.py:202:47: ANN001 Missing type annotation for function argument `monkeypatch`
    |
200 |         assert win.categoryList.count() > 0
201 |
202 |     def test_edit_category(self, main_window, monkeypatch):
    |                                               ^^^^^^^^^^^ ANN001
203 |         win = main_window
204 |         # Ensure there is at least one category to edit
    |

tests\desktop_ui\test_library_main_ui_new.py:208:21: ANN202 Missing return type annotation for private function `exec_`
    |
207 |             class FakeAddDialog:
208 |                 def exec_(self):
    |                     ^^^^^ ANN202
209 |                     return 1
    |
    = help: Add return type annotation: `int`

tests\desktop_ui\test_library_main_ui_new.py:211:21: ANN202 Missing return type annotation for private function `get_value`
    |
209 |                     return 1
210 |
211 |                 def get_value(self):
    |                     ^^^^^^^^^ ANN202
212 |                     return "Initial Cat"
    |
    = help: Add return type annotation: `str`

tests\desktop_ui\test_library_main_ui_new.py:220:17: ANN202 Missing return type annotation for private function `exec_`
    |
219 |         class FakeEditDialog:
220 |             def exec_(self):
    |                 ^^^^^ ANN202
221 |                 return 1
    |
    = help: Add return type annotation: `int`

tests\desktop_ui\test_library_main_ui_new.py:223:17: ANN202 Missing return type annotation for private function `get_value`
    |
221 |                 return 1
222 |
223 |             def get_value(self):
    |                 ^^^^^^^^^ ANN202
224 |                 return "Renamed Cat"
    |
    = help: Add return type annotation: `str`

tests\desktop_ui\test_library_main_ui_new.py:231:9: ANN201 Missing return type annotation for public function `test_delete_category`
    |
229 |         assert win.status.text() == "Category updated."
230 |
231 |     def test_delete_category(self, main_window, monkeypatch):
    |         ^^^^^^^^^^^^^^^^^^^^ ANN201
232 |         win = main_window
233 |         win.categoryList.setCurrentRow(0)
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:231:9: D102 Missing docstring in public method
    |
229 |         assert win.status.text() == "Category updated."
230 |
231 |     def test_delete_category(self, main_window, monkeypatch):
    |         ^^^^^^^^^^^^^^^^^^^^ D102
232 |         win = main_window
233 |         win.categoryList.setCurrentRow(0)
    |

tests\desktop_ui\test_library_main_ui_new.py:231:36: ANN001 Missing type annotation for function argument `main_window`
    |
229 |         assert win.status.text() == "Category updated."
230 |
231 |     def test_delete_category(self, main_window, monkeypatch):
    |                                    ^^^^^^^^^^^ ANN001
232 |         win = main_window
233 |         win.categoryList.setCurrentRow(0)
    |

tests\desktop_ui\test_library_main_ui_new.py:231:49: ANN001 Missing type annotation for function argument `monkeypatch`
    |
229 |         assert win.status.text() == "Category updated."
230 |
231 |     def test_delete_category(self, main_window, monkeypatch):
    |                                                 ^^^^^^^^^^^ ANN001
232 |         win = main_window
233 |         win.categoryList.setCurrentRow(0)
    |

tests\desktop_ui\test_library_main_ui_new.py:241:9: ANN201 Missing return type annotation for public function `test_add_snippet`
    |
239 |         assert win.status.text() == "Category deleted."
240 |
241 |     def test_add_snippet(self, main_window, monkeypatch):
    |         ^^^^^^^^^^^^^^^^ ANN201
242 |         win = main_window
243 |         # Add a category first
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:241:9: D102 Missing docstring in public method
    |
239 |         assert win.status.text() == "Category deleted."
240 |
241 |     def test_add_snippet(self, main_window, monkeypatch):
    |         ^^^^^^^^^^^^^^^^ D102
242 |         win = main_window
243 |         # Add a category first
    |

tests\desktop_ui\test_library_main_ui_new.py:241:32: ANN001 Missing type annotation for function argument `main_window`
    |
239 |         assert win.status.text() == "Category deleted."
240 |
241 |     def test_add_snippet(self, main_window, monkeypatch):
    |                                ^^^^^^^^^^^ ANN001
242 |         win = main_window
243 |         # Add a category first
    |

tests\desktop_ui\test_library_main_ui_new.py:241:45: ANN001 Missing type annotation for function argument `monkeypatch`
    |
239 |         assert win.status.text() == "Category deleted."
240 |
241 |     def test_add_snippet(self, main_window, monkeypatch):
    |                                             ^^^^^^^^^^^ ANN001
242 |         win = main_window
243 |         # Add a category first
    |

tests\desktop_ui\test_library_main_ui_new.py:259:9: ANN201 Missing return type annotation for public function `test_edit_snippet`
    |
257 |         assert win.status.text() == "Snippet added."
258 |
259 |     def test_edit_snippet(self, main_window, monkeypatch):
    |         ^^^^^^^^^^^^^^^^^ ANN201
260 |         win = main_window
261 |         win.snippetList.setCurrentRow(0)
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:259:9: D102 Missing docstring in public method
    |
257 |         assert win.status.text() == "Snippet added."
258 |
259 |     def test_edit_snippet(self, main_window, monkeypatch):
    |         ^^^^^^^^^^^^^^^^^ D102
260 |         win = main_window
261 |         win.snippetList.setCurrentRow(0)
    |

tests\desktop_ui\test_library_main_ui_new.py:259:33: ANN001 Missing type annotation for function argument `main_window`
    |
257 |         assert win.status.text() == "Snippet added."
258 |
259 |     def test_edit_snippet(self, main_window, monkeypatch):
    |                                 ^^^^^^^^^^^ ANN001
260 |         win = main_window
261 |         win.snippetList.setCurrentRow(0)
    |

tests\desktop_ui\test_library_main_ui_new.py:259:46: ANN001 Missing type annotation for function argument `monkeypatch`
    |
257 |         assert win.status.text() == "Snippet added."
258 |
259 |     def test_edit_snippet(self, main_window, monkeypatch):
    |                                              ^^^^^^^^^^^ ANN001
260 |         win = main_window
261 |         win.snippetList.setCurrentRow(0)
    |

tests\desktop_ui\test_library_main_ui_new.py:271:9: ANN201 Missing return type annotation for public function `test_delete_snippet`
    |
269 |         assert win.status.text() == "Snippet updated."
270 |
271 |     def test_delete_snippet(self, main_window, monkeypatch):
    |         ^^^^^^^^^^^^^^^^^^^ ANN201
272 |         win = main_window
273 |         win.snippetList.setCurrentRow(0)
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:271:9: D102 Missing docstring in public method
    |
269 |         assert win.status.text() == "Snippet updated."
270 |
271 |     def test_delete_snippet(self, main_window, monkeypatch):
    |         ^^^^^^^^^^^^^^^^^^^ D102
272 |         win = main_window
273 |         win.snippetList.setCurrentRow(0)
    |

tests\desktop_ui\test_library_main_ui_new.py:271:35: ANN001 Missing type annotation for function argument `main_window`
    |
269 |         assert win.status.text() == "Snippet updated."
270 |
271 |     def test_delete_snippet(self, main_window, monkeypatch):
    |                                   ^^^^^^^^^^^ ANN001
272 |         win = main_window
273 |         win.snippetList.setCurrentRow(0)
    |

tests\desktop_ui\test_library_main_ui_new.py:271:48: ANN001 Missing type annotation for function argument `monkeypatch`
    |
269 |         assert win.status.text() == "Snippet updated."
270 |
271 |     def test_delete_snippet(self, main_window, monkeypatch):
    |                                                ^^^^^^^^^^^ ANN001
272 |         win = main_window
273 |         win.snippetList.setCurrentRow(0)
    |

tests\desktop_ui\test_library_main_ui_new.py:279:9: ANN201 Missing return type annotation for public function `test_filter_snippets`
    |
277 |         assert win.status.text() == "Snippet deleted."
278 |
279 |     def test_filter_snippets(self, main_window, monkeypatch):
    |         ^^^^^^^^^^^^^^^^^^^^ ANN201
280 |         win = main_window
281 |         # Add a snippet again
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:279:9: D102 Missing docstring in public method
    |
277 |         assert win.status.text() == "Snippet deleted."
278 |
279 |     def test_filter_snippets(self, main_window, monkeypatch):
    |         ^^^^^^^^^^^^^^^^^^^^ D102
280 |         win = main_window
281 |         # Add a snippet again
    |

tests\desktop_ui\test_library_main_ui_new.py:279:36: ANN001 Missing type annotation for function argument `main_window`
    |
277 |         assert win.status.text() == "Snippet deleted."
278 |
279 |     def test_filter_snippets(self, main_window, monkeypatch):
    |                                    ^^^^^^^^^^^ ANN001
280 |         win = main_window
281 |         # Add a snippet again
    |

tests\desktop_ui\test_library_main_ui_new.py:279:49: ANN001 Missing type annotation for function argument `monkeypatch`
    |
277 |         assert win.status.text() == "Snippet deleted."
278 |
279 |     def test_filter_snippets(self, main_window, monkeypatch):
    |                                                 ^^^^^^^^^^^ ANN001
280 |         win = main_window
281 |         # Add a snippet again
    |

tests\desktop_ui\test_library_main_ui_new.py:297:9: ANN201 Missing return type annotation for public function `test_show_error_and_info`
    |
295 |         assert win.snippetList.count() == 2
296 |
297 |     def test_show_error_and_info(self, main_window):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
298 |         win = main_window
299 |         win.show_error("ErrMsg")
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:297:9: D102 Missing docstring in public method
    |
295 |         assert win.snippetList.count() == 2
296 |
297 |     def test_show_error_and_info(self, main_window):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^ D102
298 |         win = main_window
299 |         win.show_error("ErrMsg")
    |

tests\desktop_ui\test_library_main_ui_new.py:297:40: ANN001 Missing type annotation for function argument `main_window`
    |
295 |         assert win.snippetList.count() == 2
296 |
297 |     def test_show_error_and_info(self, main_window):
    |                                        ^^^^^^^^^^^ ANN001
298 |         win = main_window
299 |         win.show_error("ErrMsg")
    |

tests\desktop_ui\test_library_main_ui_new.py:304:9: ANN201 Missing return type annotation for public function `test_update_snippet_buttons_state`
    |
302 |         assert win.status.text() == "InfoMsg"
303 |
304 |     def test_update_snippet_buttons_state(self, main_window):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
305 |         win = main_window
306 |         win.update_snippet_buttons_state(True)
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:304:9: D102 Missing docstring in public method
    |
302 |         assert win.status.text() == "InfoMsg"
303 |
304 |     def test_update_snippet_buttons_state(self, main_window):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
305 |         win = main_window
306 |         win.update_snippet_buttons_state(True)
    |

tests\desktop_ui\test_library_main_ui_new.py:304:49: ANN001 Missing type annotation for function argument `main_window`
    |
302 |         assert win.status.text() == "InfoMsg"
303 |
304 |     def test_update_snippet_buttons_state(self, main_window):
    |                                                 ^^^^^^^^^^^ ANN001
305 |         win = main_window
306 |         win.update_snippet_buttons_state(True)
    |

tests\desktop_ui\test_library_main_ui_new.py:315:9: ANN201 Missing return type annotation for public function `test_on_category_selection_changed_and_load_snippets`
    |
313 |         assert not win.delSnipBtn.isEnabled()
314 |
315 |     def test_on_category_selection_changed_and_load_snippets(self, main_window):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
316 |         win = main_window
317 |         win.categoryList.setCurrentRow(0)
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:315:9: D102 Missing docstring in public method
    |
313 |         assert not win.delSnipBtn.isEnabled()
314 |
315 |     def test_on_category_selection_changed_and_load_snippets(self, main_window):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
316 |         win = main_window
317 |         win.categoryList.setCurrentRow(0)
    |

tests\desktop_ui\test_library_main_ui_new.py:315:68: ANN001 Missing type annotation for function argument `main_window`
    |
313 |         assert not win.delSnipBtn.isEnabled()
314 |
315 |     def test_on_category_selection_changed_and_load_snippets(self, main_window):
    |                                                                    ^^^^^^^^^^^ ANN001
316 |         win = main_window
317 |         win.categoryList.setCurrentRow(0)
    |

tests\desktop_ui\test_library_main_ui_new.py:322:9: ANN201 Missing return type annotation for public function `test_on_snippet_selection_changed`
    |
320 |         assert win.snippetList.count() >= 0
321 |
322 |     def test_on_snippet_selection_changed(self, main_window):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
323 |         win = main_window
324 |         if win.snippetList.count() > 0:
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:322:9: D102 Missing docstring in public method
    |
320 |         assert win.snippetList.count() >= 0
321 |
322 |     def test_on_snippet_selection_changed(self, main_window):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
323 |         win = main_window
324 |         if win.snippetList.count() > 0:
    |

tests\desktop_ui\test_library_main_ui_new.py:322:49: ANN001 Missing type annotation for function argument `main_window`
    |
320 |         assert win.snippetList.count() >= 0
321 |
322 |     def test_on_snippet_selection_changed(self, main_window):
    |                                                 ^^^^^^^^^^^ ANN001
323 |         win = main_window
324 |         if win.snippetList.count() > 0:
    |

tests\desktop_ui\test_library_main_ui_new.py:329:9: ANN201 Missing return type annotation for public function `test_view_snippet`
    |
327 |             assert win.selected_snippet is not None
328 |
329 |     def test_view_snippet(self, main_window, monkeypatch):
    |         ^^^^^^^^^^^^^^^^^ ANN201
330 |         win = main_window
331 |         if win.snippetList.count() > 0:
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:329:9: D102 Missing docstring in public method
    |
327 |             assert win.selected_snippet is not None
328 |
329 |     def test_view_snippet(self, main_window, monkeypatch):
    |         ^^^^^^^^^^^^^^^^^ D102
330 |         win = main_window
331 |         if win.snippetList.count() > 0:
    |

tests\desktop_ui\test_library_main_ui_new.py:329:33: ANN001 Missing type annotation for function argument `main_window`
    |
327 |             assert win.selected_snippet is not None
328 |
329 |     def test_view_snippet(self, main_window, monkeypatch):
    |                                 ^^^^^^^^^^^ ANN001
330 |         win = main_window
331 |         if win.snippetList.count() > 0:
    |

tests\desktop_ui\test_library_main_ui_new.py:329:46: ANN001 Missing type annotation for function argument `monkeypatch`
    |
327 |             assert win.selected_snippet is not None
328 |
329 |     def test_view_snippet(self, main_window, monkeypatch):
    |                                              ^^^^^^^^^^^ ANN001
330 |         win = main_window
331 |         if win.snippetList.count() > 0:
    |

tests\desktop_ui\test_library_main_ui_new.py:339:9: ANN201 Missing return type annotation for public function `test_add_category_error`
    |
337 |             win.view_snippet(item)
338 |
339 |     def test_add_category_error(self, main_window, monkeypatch):
    |         ^^^^^^^^^^^^^^^^^^^^^^^ ANN201
340 |         win = main_window
341 |         # Simulate dialog accepted but error in save_category
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:339:9: D102 Missing docstring in public method
    |
337 |             win.view_snippet(item)
338 |
339 |     def test_add_category_error(self, main_window, monkeypatch):
    |         ^^^^^^^^^^^^^^^^^^^^^^^ D102
340 |         win = main_window
341 |         # Simulate dialog accepted but error in save_category
    |

tests\desktop_ui\test_library_main_ui_new.py:339:39: ANN001 Missing type annotation for function argument `main_window`
    |
337 |             win.view_snippet(item)
338 |
339 |     def test_add_category_error(self, main_window, monkeypatch):
    |                                       ^^^^^^^^^^^ ANN001
340 |         win = main_window
341 |         # Simulate dialog accepted but error in save_category
    |

tests\desktop_ui\test_library_main_ui_new.py:339:52: ANN001 Missing type annotation for function argument `monkeypatch`
    |
337 |             win.view_snippet(item)
338 |
339 |     def test_add_category_error(self, main_window, monkeypatch):
    |                                                    ^^^^^^^^^^^ ANN001
340 |         win = main_window
341 |         # Simulate dialog accepted but error in save_category
    |

tests\desktop_ui\test_library_main_ui_new.py:354:9: ANN201 Missing return type annotation for public function `test_add_snippet_error`
    |
352 |         assert "Failed to add category" in win.status.text()
353 |
354 |     def test_add_snippet_error(self, main_window, monkeypatch):
    |         ^^^^^^^^^^^^^^^^^^^^^^ ANN201
355 |         # Ensure a category exists and is selected
356 |         if not main_window.categories:
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:354:9: D102 Missing docstring in public method
    |
352 |         assert "Failed to add category" in win.status.text()
353 |
354 |     def test_add_snippet_error(self, main_window, monkeypatch):
    |         ^^^^^^^^^^^^^^^^^^^^^^ D102
355 |         # Ensure a category exists and is selected
356 |         if not main_window.categories:
    |

tests\desktop_ui\test_library_main_ui_new.py:354:38: ANN001 Missing type annotation for function argument `main_window`
    |
352 |         assert "Failed to add category" in win.status.text()
353 |
354 |     def test_add_snippet_error(self, main_window, monkeypatch):
    |                                      ^^^^^^^^^^^ ANN001
355 |         # Ensure a category exists and is selected
356 |         if not main_window.categories:
    |

tests\desktop_ui\test_library_main_ui_new.py:354:51: ANN001 Missing type annotation for function argument `monkeypatch`
    |
352 |         assert "Failed to add category" in win.status.text()
353 |
354 |     def test_add_snippet_error(self, main_window, monkeypatch):
    |                                                   ^^^^^^^^^^^ ANN001
355 |         # Ensure a category exists and is selected
356 |         if not main_window.categories:
    |

tests\desktop_ui\test_library_main_ui_new.py:359:21: ANN202 Missing return type annotation for private function `exec_`
    |
358 |             class FakeCatDialog:
359 |                 def exec_(self):
    |                     ^^^^^ ANN202
360 |                     return 1
    |
    = help: Add return type annotation: `int`

tests\desktop_ui\test_library_main_ui_new.py:362:21: ANN202 Missing return type annotation for private function `get_value`
    |
360 |                     return 1
361 |
362 |                 def get_value(self):
    |                     ^^^^^^^^^ ANN202
363 |                     return "CatForError"
    |
    = help: Add return type annotation: `str`

tests\desktop_ui\test_library_main_ui_new.py:370:17: ANN202 Missing return type annotation for private function `exec_`
    |
369 |         class FakeDialog:
370 |             def exec_(self):
    |                 ^^^^^ ANN202
371 |                 return 1
    |
    = help: Add return type annotation: `int`

tests\desktop_ui\test_library_main_ui_new.py:373:17: ANN202 Missing return type annotation for private function `get_values`
    |
371 |                 return 1
372 |
373 |             def get_values(self):
    |                 ^^^^^^^^^^ ANN202
374 |                 return ("ErrSnip", "X")
    |
    = help: Add return type annotation

tests\desktop_ui\test_library_main_ui_new.py:378:13: ANN202 Missing return type annotation for private function `fail_save_snippet`
    |
376 |         monkeypatch.setattr(library_main, "SnippetDialog", lambda *a, **k: FakeDialog())
377 |
378 |         def fail_save_snippet(snip):
    |             ^^^^^^^^^^^^^^^^^ ANN202
379 |             raise Exception("failsnip")
    |
    = help: Add return type annotation: `Never`

tests\desktop_ui\test_library_main_ui_new.py:378:31: ANN001 Missing type annotation for function argument `snip`
    |
376 |         monkeypatch.setattr(library_main, "SnippetDialog", lambda *a, **k: FakeDialog())
377 |
378 |         def fail_save_snippet(snip):
    |                               ^^^^ ANN001
379 |             raise Exception("failsnip")
    |

tests\desktop_ui\test_library_main_ui_new.py:385:9: ANN201 Missing return type annotation for public function `test_edit_category_error`
    |
383 |         assert "failsnip" in main_window.status.text()
384 |
385 |     def test_edit_category_error(self, main_window, monkeypatch):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
386 |         win = main_window
387 |         # Ensure a category exists and is selected
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:385:9: D102 Missing docstring in public method
    |
383 |         assert "failsnip" in main_window.status.text()
384 |
385 |     def test_edit_category_error(self, main_window, monkeypatch):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^ D102
386 |         win = main_window
387 |         # Ensure a category exists and is selected
    |

tests\desktop_ui\test_library_main_ui_new.py:385:40: ANN001 Missing type annotation for function argument `main_window`
    |
383 |         assert "failsnip" in main_window.status.text()
384 |
385 |     def test_edit_category_error(self, main_window, monkeypatch):
    |                                        ^^^^^^^^^^^ ANN001
386 |         win = main_window
387 |         # Ensure a category exists and is selected
    |

tests\desktop_ui\test_library_main_ui_new.py:385:53: ANN001 Missing type annotation for function argument `monkeypatch`
    |
383 |         assert "failsnip" in main_window.status.text()
384 |
385 |     def test_edit_category_error(self, main_window, monkeypatch):
    |                                                     ^^^^^^^^^^^ ANN001
386 |         win = main_window
387 |         # Ensure a category exists and is selected
    |

tests\desktop_ui\test_library_main_ui_new.py:391:21: ANN202 Missing return type annotation for private function `exec_`
    |
390 |             class FakeAddDialog:
391 |                 def exec_(self):
    |                     ^^^^^ ANN202
392 |                     return 1
    |
    = help: Add return type annotation: `int`

tests\desktop_ui\test_library_main_ui_new.py:394:21: ANN202 Missing return type annotation for private function `get_value`
    |
392 |                     return 1
393 |
394 |                 def get_value(self):
    |                     ^^^^^^^^^ ANN202
395 |                     return "ErrEditCat"
    |
    = help: Add return type annotation: `str`

tests\desktop_ui\test_library_main_ui_new.py:412:9: ANN201 Missing return type annotation for public function `test_edit_snippet_error`
    |
410 |         assert "Failed to update category" in win.status.text() or "failcat2" in win.status.text()
411 |
412 |     def test_edit_snippet_error(self, main_window, monkeypatch):
    |         ^^^^^^^^^^^^^^^^^^^^^^^ ANN201
413 |         win = main_window
414 |         # Ensure a snippet exists and is selected
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:412:9: D102 Missing docstring in public method
    |
410 |         assert "Failed to update category" in win.status.text() or "failcat2" in win.status.text()
411 |
412 |     def test_edit_snippet_error(self, main_window, monkeypatch):
    |         ^^^^^^^^^^^^^^^^^^^^^^^ D102
413 |         win = main_window
414 |         # Ensure a snippet exists and is selected
    |

tests\desktop_ui\test_library_main_ui_new.py:412:39: ANN001 Missing type annotation for function argument `main_window`
    |
410 |         assert "Failed to update category" in win.status.text() or "failcat2" in win.status.text()
411 |
412 |     def test_edit_snippet_error(self, main_window, monkeypatch):
    |                                       ^^^^^^^^^^^ ANN001
413 |         win = main_window
414 |         # Ensure a snippet exists and is selected
    |

tests\desktop_ui\test_library_main_ui_new.py:412:52: ANN001 Missing type annotation for function argument `monkeypatch`
    |
410 |         assert "Failed to update category" in win.status.text() or "failcat2" in win.status.text()
411 |
412 |     def test_edit_snippet_error(self, main_window, monkeypatch):
    |                                                    ^^^^^^^^^^^ ANN001
413 |         win = main_window
414 |         # Ensure a snippet exists and is selected
    |

tests\desktop_ui\test_library_main_ui_new.py:420:25: ANN202 Missing return type annotation for private function `exec_`
    |
419 |                 class FakeCatDialog:
420 |                     def exec_(self):
    |                         ^^^^^ ANN202
421 |                         return 1
    |
    = help: Add return type annotation: `int`

tests\desktop_ui\test_library_main_ui_new.py:423:25: ANN202 Missing return type annotation for private function `get_value`
    |
421 |                         return 1
422 |
423 |                     def get_value(self):
    |                         ^^^^^^^^^ ANN202
424 |                         return "CatForEditError"
    |
    = help: Add return type annotation: `str`

tests\desktop_ui\test_library_main_ui_new.py:431:21: ANN202 Missing return type annotation for private function `exec_`
    |
430 |             class FakeAddDialog:
431 |                 def exec_(self):
    |                     ^^^^^ ANN202
432 |                     return 1
    |
    = help: Add return type annotation: `int`

tests\desktop_ui\test_library_main_ui_new.py:434:21: ANN202 Missing return type annotation for private function `get_values`
    |
432 |                     return 1
433 |
434 |                 def get_values(self):
    |                     ^^^^^^^^^^ ANN202
435 |                     return ("SnippetToEditError", "ContentToEditError")
    |
    = help: Add return type annotation

tests\desktop_ui\test_library_main_ui_new.py:442:17: ANN202 Missing return type annotation for private function `exec_`
    |
441 |         class FakeDialog:
442 |             def exec_(self):
    |                 ^^^^^ ANN202
443 |                 return 1
    |
    = help: Add return type annotation: `int`

tests\desktop_ui\test_library_main_ui_new.py:445:17: ANN202 Missing return type annotation for private function `get_values`
    |
443 |                 return 1
444 |
445 |             def get_values(self):
    |                 ^^^^^^^^^^ ANN202
446 |                 return ("ErrEditSnip", "X")
    |
    = help: Add return type annotation

tests\desktop_ui\test_library_main_ui_new.py:450:13: ANN202 Missing return type annotation for private function `fail_save_snippet`
    |
448 |         monkeypatch.setattr(library_main, "SnippetDialog", lambda *a, **k: FakeDialog())
449 |
450 |         def fail_save_snippet(snip):
    |             ^^^^^^^^^^^^^^^^^ ANN202
451 |             raise Exception("failsnip2")
    |
    = help: Add return type annotation: `Never`

tests\desktop_ui\test_library_main_ui_new.py:450:31: ANN001 Missing type annotation for function argument `snip`
    |
448 |         monkeypatch.setattr(library_main, "SnippetDialog", lambda *a, **k: FakeDialog())
449 |
450 |         def fail_save_snippet(snip):
    |                               ^^^^ ANN001
451 |             raise Exception("failsnip2")
    |

tests\desktop_ui\test_library_main_ui_new.py:457:9: ANN201 Missing return type annotation for public function `test_delete_category_error`
    |
455 |         assert "Failed to update snippet" in win.status.text() or "failsnip2" in win.status.text()
456 |
457 |     def test_delete_category_error(self, main_window, monkeypatch):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
458 |         # Ensure a category exists and is selected
459 |         if not main_window.categories:
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:457:9: D102 Missing docstring in public method
    |
455 |         assert "Failed to update snippet" in win.status.text() or "failsnip2" in win.status.text()
456 |
457 |     def test_delete_category_error(self, main_window, monkeypatch):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
458 |         # Ensure a category exists and is selected
459 |         if not main_window.categories:
    |

tests\desktop_ui\test_library_main_ui_new.py:457:42: ANN001 Missing type annotation for function argument `main_window`
    |
455 |         assert "Failed to update snippet" in win.status.text() or "failsnip2" in win.status.text()
456 |
457 |     def test_delete_category_error(self, main_window, monkeypatch):
    |                                          ^^^^^^^^^^^ ANN001
458 |         # Ensure a category exists and is selected
459 |         if not main_window.categories:
    |

tests\desktop_ui\test_library_main_ui_new.py:457:55: ANN001 Missing type annotation for function argument `monkeypatch`
    |
455 |         assert "Failed to update snippet" in win.status.text() or "failsnip2" in win.status.text()
456 |
457 |     def test_delete_category_error(self, main_window, monkeypatch):
    |                                                       ^^^^^^^^^^^ ANN001
458 |         # Ensure a category exists and is selected
459 |         if not main_window.categories:
    |

tests\desktop_ui\test_library_main_ui_new.py:462:21: ANN202 Missing return type annotation for private function `exec_`
    |
461 |             class FakeCatDialog:
462 |                 def exec_(self):
    |                     ^^^^^ ANN202
463 |                     return 1
    |
    = help: Add return type annotation: `int`

tests\desktop_ui\test_library_main_ui_new.py:465:21: ANN202 Missing return type annotation for private function `get_value`
    |
463 |                     return 1
464 |
465 |                 def get_value(self):
    |                     ^^^^^^^^^ ANN202
466 |                     return "CatForDeleteError"
    |
    = help: Add return type annotation: `str`

tests\desktop_ui\test_library_main_ui_new.py:477:13: ANN202 Missing return type annotation for private function `fail_delete_category_by_id`
    |
475 |         )
476 |
477 |         def fail_delete_category_by_id(cid):
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN202
478 |             raise Exception("faildelcat")
    |
    = help: Add return type annotation: `Never`

tests\desktop_ui\test_library_main_ui_new.py:477:40: ANN001 Missing type annotation for function argument `cid`
    |
475 |         )
476 |
477 |         def fail_delete_category_by_id(cid):
    |                                        ^^^ ANN001
478 |             raise Exception("faildelcat")
    |

tests\desktop_ui\test_library_main_ui_new.py:489:9: ANN201 Missing return type annotation for public function `test_delete_snippet_error`
    |
487 |         )
488 |
489 |     def test_delete_snippet_error(self, main_window, monkeypatch):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
490 |         win = main_window
491 |         # Ensure a category exists and is selected
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:489:9: D102 Missing docstring in public method
    |
487 |         )
488 |
489 |     def test_delete_snippet_error(self, main_window, monkeypatch):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^ D102
490 |         win = main_window
491 |         # Ensure a category exists and is selected
    |

tests\desktop_ui\test_library_main_ui_new.py:489:41: ANN001 Missing type annotation for function argument `main_window`
    |
487 |         )
488 |
489 |     def test_delete_snippet_error(self, main_window, monkeypatch):
    |                                         ^^^^^^^^^^^ ANN001
490 |         win = main_window
491 |         # Ensure a category exists and is selected
    |

tests\desktop_ui\test_library_main_ui_new.py:489:54: ANN001 Missing type annotation for function argument `monkeypatch`
    |
487 |         )
488 |
489 |     def test_delete_snippet_error(self, main_window, monkeypatch):
    |                                                      ^^^^^^^^^^^ ANN001
490 |         win = main_window
491 |         # Ensure a category exists and is selected
    |

tests\desktop_ui\test_library_main_ui_new.py:495:21: ANN202 Missing return type annotation for private function `exec_`
    |
494 |             class FakeCatDialog:
495 |                 def exec_(self):
    |                     ^^^^^ ANN202
496 |                     return 1
    |
    = help: Add return type annotation: `int`

tests\desktop_ui\test_library_main_ui_new.py:498:21: ANN202 Missing return type annotation for private function `get_value`
    |
496 |                     return 1
497 |
498 |                 def get_value(self):
    |                     ^^^^^^^^^ ANN202
499 |                     return "CatForDeleteError"
    |
    = help: Add return type annotation: `str`

tests\desktop_ui\test_library_main_ui_new.py:508:21: ANN202 Missing return type annotation for private function `exec_`
    |
507 |             class FakeSnipDialog:
508 |                 def exec_(self):
    |                     ^^^^^ ANN202
509 |                     return 1
    |
    = help: Add return type annotation: `int`

tests\desktop_ui\test_library_main_ui_new.py:511:21: ANN202 Missing return type annotation for private function `get_values`
    |
509 |                     return 1
510 |
511 |                 def get_values(self):
    |                     ^^^^^^^^^^ ANN202
512 |                     return ("ToDelError", "X")
    |
    = help: Add return type annotation

tests\desktop_ui\test_library_main_ui_new.py:519:13: ANN202 Missing return type annotation for private function `fail_delete_snippet`
    |
517 |         monkeypatch.setattr("PySide6.QtWidgets.QMessageBox.question", lambda *a, **k: 16384)  # Yes
518 |
519 |         def fail_delete_snippet(sid):
    |             ^^^^^^^^^^^^^^^^^^^ ANN202
520 |             raise Exception("faildelsnip")
    |
    = help: Add return type annotation: `Never`

tests\desktop_ui\test_library_main_ui_new.py:519:33: ANN001 Missing type annotation for function argument `sid`
    |
517 |         monkeypatch.setattr("PySide6.QtWidgets.QMessageBox.question", lambda *a, **k: 16384)  # Yes
518 |
519 |         def fail_delete_snippet(sid):
    |                                 ^^^ ANN001
520 |             raise Exception("faildelsnip")
    |

tests\desktop_ui\test_library_main_ui_new.py:526:9: ANN201 Missing return type annotation for public function `test_load_data_error`
    |
524 |         assert "Failed to delete snippet" in win.status.text() or "faildelsnip" in win.status.text()
525 |
526 |     def test_load_data_error(self, main_window, monkeypatch):
    |         ^^^^^^^^^^^^^^^^^^^^ ANN201
527 |         win = main_window
528 |         monkeypatch.setattr(
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:526:9: D102 Missing docstring in public method
    |
524 |         assert "Failed to delete snippet" in win.status.text() or "faildelsnip" in win.status.text()
525 |
526 |     def test_load_data_error(self, main_window, monkeypatch):
    |         ^^^^^^^^^^^^^^^^^^^^ D102
527 |         win = main_window
528 |         monkeypatch.setattr(
    |

tests\desktop_ui\test_library_main_ui_new.py:526:36: ANN001 Missing type annotation for function argument `main_window`
    |
524 |         assert "Failed to delete snippet" in win.status.text() or "faildelsnip" in win.status.text()
525 |
526 |     def test_load_data_error(self, main_window, monkeypatch):
    |                                    ^^^^^^^^^^^ ANN001
527 |         win = main_window
528 |         monkeypatch.setattr(
    |

tests\desktop_ui\test_library_main_ui_new.py:526:49: ANN001 Missing type annotation for function argument `monkeypatch`
    |
524 |         assert "Failed to delete snippet" in win.status.text() or "faildelsnip" in win.status.text()
525 |
526 |     def test_load_data_error(self, main_window, monkeypatch):
    |                                                 ^^^^^^^^^^^ ANN001
527 |         win = main_window
528 |         monkeypatch.setattr(
    |

tests\desktop_ui\test_library_main_ui_new.py:536:9: ANN201 Missing return type annotation for public function `test_load_snippets_error`
    |
534 |         assert "Error loading data" in win.status.text()
535 |
536 |     def test_load_snippets_error(self, main_window, monkeypatch):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
537 |         win = main_window
538 |         win.categoryList.setCurrentRow(0)
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:536:9: D102 Missing docstring in public method
    |
534 |         assert "Error loading data" in win.status.text()
535 |
536 |     def test_load_snippets_error(self, main_window, monkeypatch):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^ D102
537 |         win = main_window
538 |         win.categoryList.setCurrentRow(0)
    |

tests\desktop_ui\test_library_main_ui_new.py:536:40: ANN001 Missing type annotation for function argument `main_window`
    |
534 |         assert "Error loading data" in win.status.text()
535 |
536 |     def test_load_snippets_error(self, main_window, monkeypatch):
    |                                        ^^^^^^^^^^^ ANN001
537 |         win = main_window
538 |         win.categoryList.setCurrentRow(0)
    |

tests\desktop_ui\test_library_main_ui_new.py:536:53: ANN001 Missing type annotation for function argument `monkeypatch`
    |
534 |         assert "Error loading data" in win.status.text()
535 |
536 |     def test_load_snippets_error(self, main_window, monkeypatch):
    |                                                     ^^^^^^^^^^^ ANN001
537 |         win = main_window
538 |         win.categoryList.setCurrentRow(0)
    |

tests\desktop_ui\test_library_main_ui_new.py:551:5: ANN201 Missing return type annotation for public function `test_window_initialization`
    |
551 | def test_window_initialization(main_window):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
552 |     """Test that the main window initializes with the correct default state.
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:551:32: ANN001 Missing type annotation for function argument `main_window`
    |
551 | def test_window_initialization(main_window):
    |                                ^^^^^^^^^^^ ANN001
552 |     """Test that the main window initializes with the correct default state.
    |

tests\desktop_ui\test_library_main_ui_new.py:597:5: ANN201 Missing return type annotation for public function `test_add_category_ui`
    |
597 | def test_add_category_ui(main_window, monkeypatch):
    |     ^^^^^^^^^^^^^^^^^^^^ ANN201
598 |     # Simulate CategoryDialog returning Accepted and a name
599 |     class FakeDialog:
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:597:5: D103 Missing docstring in public function
    |
597 | def test_add_category_ui(main_window, monkeypatch):
    |     ^^^^^^^^^^^^^^^^^^^^ D103
598 |     # Simulate CategoryDialog returning Accepted and a name
599 |     class FakeDialog:
    |

tests\desktop_ui\test_library_main_ui_new.py:597:26: ANN001 Missing type annotation for function argument `main_window`
    |
597 | def test_add_category_ui(main_window, monkeypatch):
    |                          ^^^^^^^^^^^ ANN001
598 |     # Simulate CategoryDialog returning Accepted and a name
599 |     class FakeDialog:
    |

tests\desktop_ui\test_library_main_ui_new.py:597:39: ANN001 Missing type annotation for function argument `monkeypatch`
    |
597 | def test_add_category_ui(main_window, monkeypatch):
    |                                       ^^^^^^^^^^^ ANN001
598 |     # Simulate CategoryDialog returning Accepted and a name
599 |     class FakeDialog:
    |

tests\desktop_ui\test_library_main_ui_new.py:600:13: ANN202 Missing return type annotation for private function `exec_`
    |
598 |     # Simulate CategoryDialog returning Accepted and a name
599 |     class FakeDialog:
600 |         def exec_(self):
    |             ^^^^^ ANN202
601 |             return 1  # Accepted
    |
    = help: Add return type annotation: `int`

tests\desktop_ui\test_library_main_ui_new.py:603:13: ANN202 Missing return type annotation for private function `get_value`
    |
601 |             return 1  # Accepted
602 |
603 |         def get_value(self):
    |             ^^^^^^^^^ ANN202
604 |             return "UI Cat"
    |
    = help: Add return type annotation: `str`

tests\desktop_ui\test_library_main_ui_new.py:612:5: ANN201 Missing return type annotation for public function `test_edit_category_ui`
    |
612 | def test_edit_category_ui(main_window, monkeypatch):
    |     ^^^^^^^^^^^^^^^^^^^^^ ANN201
613 |     # Ensure there is at least one category to edit
614 |     if not main_window.categories:
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:612:5: D103 Missing docstring in public function
    |
612 | def test_edit_category_ui(main_window, monkeypatch):
    |     ^^^^^^^^^^^^^^^^^^^^^ D103
613 |     # Ensure there is at least one category to edit
614 |     if not main_window.categories:
    |

tests\desktop_ui\test_library_main_ui_new.py:612:27: ANN001 Missing type annotation for function argument `main_window`
    |
612 | def test_edit_category_ui(main_window, monkeypatch):
    |                           ^^^^^^^^^^^ ANN001
613 |     # Ensure there is at least one category to edit
614 |     if not main_window.categories:
    |

tests\desktop_ui\test_library_main_ui_new.py:612:40: ANN001 Missing type annotation for function argument `monkeypatch`
    |
612 | def test_edit_category_ui(main_window, monkeypatch):
    |                                        ^^^^^^^^^^^ ANN001
613 |     # Ensure there is at least one category to edit
614 |     if not main_window.categories:
    |

tests\desktop_ui\test_library_main_ui_new.py:617:17: ANN202 Missing return type annotation for private function `exec_`
    |
616 |         class FakeAddDialog:
617 |             def exec_(self):
    |                 ^^^^^ ANN202
618 |                 return 1
    |
    = help: Add return type annotation: `int`

tests\desktop_ui\test_library_main_ui_new.py:620:17: ANN202 Missing return type annotation for private function `get_value`
    |
618 |                 return 1
619 |
620 |             def get_value(self):
    |                 ^^^^^^^^^ ANN202
621 |                 return "Initial Cat"
    |
    = help: Add return type annotation: `str`

tests\desktop_ui\test_library_main_ui_new.py:629:13: ANN202 Missing return type annotation for private function `exec_`
    |
628 |     class FakeEditDialog:
629 |         def exec_(self):
    |             ^^^^^ ANN202
630 |             return 1
    |
    = help: Add return type annotation: `int`

tests\desktop_ui\test_library_main_ui_new.py:632:13: ANN202 Missing return type annotation for private function `get_value`
    |
630 |             return 1
631 |
632 |         def get_value(self):
    |             ^^^^^^^^^ ANN202
633 |             return "Renamed Cat"
    |
    = help: Add return type annotation: `str`

tests\desktop_ui\test_library_main_ui_new.py:641:5: ANN201 Missing return type annotation for public function `test_delete_category_ui`
    |
641 | def test_delete_category_ui(main_window, monkeypatch):
    |     ^^^^^^^^^^^^^^^^^^^^^^^ ANN201
642 |     # Add a category to delete
643 |     cat = library_main.Category(category_name="ToDelete", description="")
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:641:5: D103 Missing docstring in public function
    |
641 | def test_delete_category_ui(main_window, monkeypatch):
    |     ^^^^^^^^^^^^^^^^^^^^^^^ D103
642 |     # Add a category to delete
643 |     cat = library_main.Category(category_name="ToDelete", description="")
    |

tests\desktop_ui\test_library_main_ui_new.py:641:29: ANN001 Missing type annotation for function argument `main_window`
    |
641 | def test_delete_category_ui(main_window, monkeypatch):
    |                             ^^^^^^^^^^^ ANN001
642 |     # Add a category to delete
643 |     cat = library_main.Category(category_name="ToDelete", description="")
    |

tests\desktop_ui\test_library_main_ui_new.py:641:42: ANN001 Missing type annotation for function argument `monkeypatch`
    |
641 | def test_delete_category_ui(main_window, monkeypatch):
    |                                          ^^^^^^^^^^^ ANN001
642 |     # Add a category to delete
643 |     cat = library_main.Category(category_name="ToDelete", description="")
    |

tests\desktop_ui\test_library_main_ui_new.py:660:5: ANN201 Missing return type annotation for public function `test_add_snippet_ui`
    |
660 | def test_add_snippet_ui(main_window, monkeypatch):
    |     ^^^^^^^^^^^^^^^^^^^ ANN201
661 |     # Ensure a category exists and is selected
662 |     if not main_window.categories:
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:660:5: D103 Missing docstring in public function
    |
660 | def test_add_snippet_ui(main_window, monkeypatch):
    |     ^^^^^^^^^^^^^^^^^^^ D103
661 |     # Ensure a category exists and is selected
662 |     if not main_window.categories:
    |

tests\desktop_ui\test_library_main_ui_new.py:660:25: ANN001 Missing type annotation for function argument `main_window`
    |
660 | def test_add_snippet_ui(main_window, monkeypatch):
    |                         ^^^^^^^^^^^ ANN001
661 |     # Ensure a category exists and is selected
662 |     if not main_window.categories:
    |

tests\desktop_ui\test_library_main_ui_new.py:660:38: ANN001 Missing type annotation for function argument `monkeypatch`
    |
660 | def test_add_snippet_ui(main_window, monkeypatch):
    |                                      ^^^^^^^^^^^ ANN001
661 |     # Ensure a category exists and is selected
662 |     if not main_window.categories:
    |

tests\desktop_ui\test_library_main_ui_new.py:665:17: ANN202 Missing return type annotation for private function `exec_`
    |
664 |         class FakeCatDialog:
665 |             def exec_(self):
    |                 ^^^^^ ANN202
666 |                 return 1
    |
    = help: Add return type annotation: `int`

tests\desktop_ui\test_library_main_ui_new.py:668:17: ANN202 Missing return type annotation for private function `get_value`
    |
666 |                 return 1
667 |
668 |             def get_value(self):
    |                 ^^^^^^^^^ ANN202
669 |                 return "CatForSnippet"
    |
    = help: Add return type annotation: `str`

tests\desktop_ui\test_library_main_ui_new.py:676:13: ANN202 Missing return type annotation for private function `exec_`
    |
675 |     class FakeDialog:
676 |         def exec_(self):
    |             ^^^^^ ANN202
677 |             return 1
    |
    = help: Add return type annotation: `int`

tests\desktop_ui\test_library_main_ui_new.py:679:13: ANN202 Missing return type annotation for private function `get_values`
    |
677 |             return 1
678 |
679 |         def get_values(self):
    |             ^^^^^^^^^^ ANN202
680 |             return ("SnippetA", "ContentA")
    |
    = help: Add return type annotation

tests\desktop_ui\test_library_main_ui_new.py:688:5: ANN201 Missing return type annotation for public function `test_edit_snippet_ui`
    |
688 | def test_edit_snippet_ui(main_window, monkeypatch):
    |     ^^^^^^^^^^^^^^^^^^^^ ANN201
689 |     # Ensure there is at least one snippet to edit
690 |     if not main_window.snippets:
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:688:5: D103 Missing docstring in public function
    |
688 | def test_edit_snippet_ui(main_window, monkeypatch):
    |     ^^^^^^^^^^^^^^^^^^^^ D103
689 |     # Ensure there is at least one snippet to edit
690 |     if not main_window.snippets:
    |

tests\desktop_ui\test_library_main_ui_new.py:688:26: ANN001 Missing type annotation for function argument `main_window`
    |
688 | def test_edit_snippet_ui(main_window, monkeypatch):
    |                          ^^^^^^^^^^^ ANN001
689 |     # Ensure there is at least one snippet to edit
690 |     if not main_window.snippets:
    |

tests\desktop_ui\test_library_main_ui_new.py:688:39: ANN001 Missing type annotation for function argument `monkeypatch`
    |
688 | def test_edit_snippet_ui(main_window, monkeypatch):
    |                                       ^^^^^^^^^^^ ANN001
689 |     # Ensure there is at least one snippet to edit
690 |     if not main_window.snippets:
    |

tests\desktop_ui\test_library_main_ui_new.py:695:21: ANN202 Missing return type annotation for private function `exec_`
    |
694 |             class FakeCatDialog:
695 |                 def exec_(self):
    |                     ^^^^^ ANN202
696 |                     return 1
    |
    = help: Add return type annotation: `int`

tests\desktop_ui\test_library_main_ui_new.py:698:21: ANN202 Missing return type annotation for private function `get_value`
    |
696 |                     return 1
697 |
698 |                 def get_value(self):
    |                     ^^^^^^^^^ ANN202
699 |                     return "CatForEdit"
    |
    = help: Add return type annotation: `str`

tests\desktop_ui\test_library_main_ui_new.py:706:17: ANN202 Missing return type annotation for private function `exec_`
    |
705 |         class FakeAddDialog:
706 |             def exec_(self):
    |                 ^^^^^ ANN202
707 |                 return 1
    |
    = help: Add return type annotation: `int`

tests\desktop_ui\test_library_main_ui_new.py:709:17: ANN202 Missing return type annotation for private function `get_values`
    |
707 |                 return 1
708 |
709 |             def get_values(self):
    |                 ^^^^^^^^^^ ANN202
710 |                 return ("SnippetToEdit", "ContentToEdit")
    |
    = help: Add return type annotation

tests\desktop_ui\test_library_main_ui_new.py:717:13: ANN202 Missing return type annotation for private function `exec_`
    |
716 |     class FakeEditDialog:
717 |         def exec_(self):
    |             ^^^^^ ANN202
718 |             return 1
    |
    = help: Add return type annotation: `int`

tests\desktop_ui\test_library_main_ui_new.py:720:13: ANN202 Missing return type annotation for private function `get_values`
    |
718 |             return 1
719 |
720 |         def get_values(self):
    |             ^^^^^^^^^^ ANN202
721 |             return ("SnippetA-Edit", "ContentA-Edit")
    |
    = help: Add return type annotation

tests\desktop_ui\test_library_main_ui_new.py:729:5: ANN201 Missing return type annotation for public function `test_delete_snippet_ui`
    |
729 | def test_delete_snippet_ui(main_window, monkeypatch):
    |     ^^^^^^^^^^^^^^^^^^^^^^ ANN201
730 |     # Ensure a category exists and is selected
731 |     if not main_window.categories:
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:729:5: D103 Missing docstring in public function
    |
729 | def test_delete_snippet_ui(main_window, monkeypatch):
    |     ^^^^^^^^^^^^^^^^^^^^^^ D103
730 |     # Ensure a category exists and is selected
731 |     if not main_window.categories:
    |

tests\desktop_ui\test_library_main_ui_new.py:729:28: ANN001 Missing type annotation for function argument `main_window`
    |
729 | def test_delete_snippet_ui(main_window, monkeypatch):
    |                            ^^^^^^^^^^^ ANN001
730 |     # Ensure a category exists and is selected
731 |     if not main_window.categories:
    |

tests\desktop_ui\test_library_main_ui_new.py:729:41: ANN001 Missing type annotation for function argument `monkeypatch`
    |
729 | def test_delete_snippet_ui(main_window, monkeypatch):
    |                                         ^^^^^^^^^^^ ANN001
730 |     # Ensure a category exists and is selected
731 |     if not main_window.categories:
    |

tests\desktop_ui\test_library_main_ui_new.py:734:17: ANN202 Missing return type annotation for private function `exec_`
    |
733 |         class FakeCatDialog:
734 |             def exec_(self):
    |                 ^^^^^ ANN202
735 |                 return 1
    |
    = help: Add return type annotation: `int`

tests\desktop_ui\test_library_main_ui_new.py:737:17: ANN202 Missing return type annotation for private function `get_value`
    |
735 |                 return 1
736 |
737 |             def get_value(self):
    |                 ^^^^^^^^^ ANN202
738 |                 return "CatForDelete"
    |
    = help: Add return type annotation: `str`

tests\desktop_ui\test_library_main_ui_new.py:747:17: ANN202 Missing return type annotation for private function `exec_`
    |
746 |         class FakeSnipDialog:
747 |             def exec_(self):
    |                 ^^^^^ ANN202
748 |                 return 1
    |
    = help: Add return type annotation: `int`

tests\desktop_ui\test_library_main_ui_new.py:750:17: ANN202 Missing return type annotation for private function `get_values`
    |
748 |                 return 1
749 |
750 |             def get_values(self):
    |                 ^^^^^^^^^^ ANN202
751 |                 return ("ToDel", "X")
    |
    = help: Add return type annotation

tests\desktop_ui\test_library_main_ui_new.py:766:5: ANN201 Missing return type annotation for public function `test_filter_snippets`
    |
766 | def test_filter_snippets(main_window):
    |     ^^^^^^^^^^^^^^^^^^^^ ANN201
767 |     main_window.search_input.setText("Edit")
768 |     # Should only show snippets with 'Edit' in name
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:766:5: D103 Missing docstring in public function
    |
766 | def test_filter_snippets(main_window):
    |     ^^^^^^^^^^^^^^^^^^^^ D103
767 |     main_window.search_input.setText("Edit")
768 |     # Should only show snippets with 'Edit' in name
    |

tests\desktop_ui\test_library_main_ui_new.py:766:26: ANN001 Missing type annotation for function argument `main_window`
    |
766 | def test_filter_snippets(main_window):
    |                          ^^^^^^^^^^^ ANN001
767 |     main_window.search_input.setText("Edit")
768 |     # Should only show snippets with 'Edit' in name
    |

tests\desktop_ui\test_library_main_ui_new.py:775:5: ANN201 Missing return type annotation for public function `test_show_error_and_info`
    |
775 | def test_show_error_and_info(main_window):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
776 |     main_window.show_error("errormsg")
777 |     assert main_window.status.text() == "errormsg"
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:775:5: D103 Missing docstring in public function
    |
775 | def test_show_error_and_info(main_window):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^ D103
776 |     main_window.show_error("errormsg")
777 |     assert main_window.status.text() == "errormsg"
    |

tests\desktop_ui\test_library_main_ui_new.py:775:30: ANN001 Missing type annotation for function argument `main_window`
    |
775 | def test_show_error_and_info(main_window):
    |                              ^^^^^^^^^^^ ANN001
776 |     main_window.show_error("errormsg")
777 |     assert main_window.status.text() == "errormsg"
    |

tests\desktop_ui\test_library_main_ui_new.py:782:5: ANN201 Missing return type annotation for public function `test_update_snippet_buttons_state`
    |
782 | def test_update_snippet_buttons_state(main_window):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
783 |     main_window.update_snippet_buttons_state(True)
784 |     assert main_window.addSnipBtn.isEnabled()
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:782:5: D103 Missing docstring in public function
    |
782 | def test_update_snippet_buttons_state(main_window):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D103
783 |     main_window.update_snippet_buttons_state(True)
784 |     assert main_window.addSnipBtn.isEnabled()
    |

tests\desktop_ui\test_library_main_ui_new.py:782:39: ANN001 Missing type annotation for function argument `main_window`
    |
782 | def test_update_snippet_buttons_state(main_window):
    |                                       ^^^^^^^^^^^ ANN001
783 |     main_window.update_snippet_buttons_state(True)
784 |     assert main_window.addSnipBtn.isEnabled()
    |

tests\desktop_ui\test_library_main_ui_new.py:789:5: ANN201 Missing return type annotation for public function `test_add_category_error`
    |
789 | def test_add_category_error(monkeypatch, main_window):
    |     ^^^^^^^^^^^^^^^^^^^^^^^ ANN201
790 |     class FakeDialog:
791 |         def exec_(self):
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:789:5: D103 Missing docstring in public function
    |
789 | def test_add_category_error(monkeypatch, main_window):
    |     ^^^^^^^^^^^^^^^^^^^^^^^ D103
790 |     class FakeDialog:
791 |         def exec_(self):
    |

tests\desktop_ui\test_library_main_ui_new.py:789:29: ANN001 Missing type annotation for function argument `monkeypatch`
    |
789 | def test_add_category_error(monkeypatch, main_window):
    |                             ^^^^^^^^^^^ ANN001
790 |     class FakeDialog:
791 |         def exec_(self):
    |

tests\desktop_ui\test_library_main_ui_new.py:789:42: ANN001 Missing type annotation for function argument `main_window`
    |
789 | def test_add_category_error(monkeypatch, main_window):
    |                                          ^^^^^^^^^^^ ANN001
790 |     class FakeDialog:
791 |         def exec_(self):
    |

tests\desktop_ui\test_library_main_ui_new.py:791:13: ANN202 Missing return type annotation for private function `exec_`
    |
789 | def test_add_category_error(monkeypatch, main_window):
790 |     class FakeDialog:
791 |         def exec_(self):
    |             ^^^^^ ANN202
792 |             return 1
    |
    = help: Add return type annotation: `int`

tests\desktop_ui\test_library_main_ui_new.py:794:13: ANN202 Missing return type annotation for private function `get_value`
    |
792 |             return 1
793 |
794 |         def get_value(self):
    |             ^^^^^^^^^ ANN202
795 |             return "ErrorCat"
    |
    = help: Add return type annotation: `str`

tests\desktop_ui\test_library_main_ui_new.py:799:9: ANN202 Missing return type annotation for private function `fail_save_category`
    |
797 |     monkeypatch.setattr(library_main, "CategoryDialog", lambda *a, **k: FakeDialog())
798 |
799 |     def fail_save_category(cat):
    |         ^^^^^^^^^^^^^^^^^^ ANN202
800 |         raise Exception("failcat")
    |
    = help: Add return type annotation: `Never`

tests\desktop_ui\test_library_main_ui_new.py:799:28: ANN001 Missing type annotation for function argument `cat`
    |
797 |     monkeypatch.setattr(library_main, "CategoryDialog", lambda *a, **k: FakeDialog())
798 |
799 |     def fail_save_category(cat):
    |                            ^^^ ANN001
800 |         raise Exception("failcat")
    |

tests\desktop_ui\test_library_main_ui_new.py:807:5: ANN201 Missing return type annotation for public function `test_add_snippet_error`
    |
807 | def test_add_snippet_error(monkeypatch, main_window):
    |     ^^^^^^^^^^^^^^^^^^^^^^ ANN201
808 |     # Ensure a category exists and is selected
809 |     if not main_window.categories:
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:807:5: D103 Missing docstring in public function
    |
807 | def test_add_snippet_error(monkeypatch, main_window):
    |     ^^^^^^^^^^^^^^^^^^^^^^ D103
808 |     # Ensure a category exists and is selected
809 |     if not main_window.categories:
    |

tests\desktop_ui\test_library_main_ui_new.py:807:28: ANN001 Missing type annotation for function argument `monkeypatch`
    |
807 | def test_add_snippet_error(monkeypatch, main_window):
    |                            ^^^^^^^^^^^ ANN001
808 |     # Ensure a category exists and is selected
809 |     if not main_window.categories:
    |

tests\desktop_ui\test_library_main_ui_new.py:807:41: ANN001 Missing type annotation for function argument `main_window`
    |
807 | def test_add_snippet_error(monkeypatch, main_window):
    |                                         ^^^^^^^^^^^ ANN001
808 |     # Ensure a category exists and is selected
809 |     if not main_window.categories:
    |

tests\desktop_ui\test_library_main_ui_new.py:812:17: ANN202 Missing return type annotation for private function `exec_`
    |
811 |         class FakeCatDialog:
812 |             def exec_(self):
    |                 ^^^^^ ANN202
813 |                 return 1
    |
    = help: Add return type annotation: `int`

tests\desktop_ui\test_library_main_ui_new.py:815:17: ANN202 Missing return type annotation for private function `get_value`
    |
813 |                 return 1
814 |
815 |             def get_value(self):
    |                 ^^^^^^^^^ ANN202
816 |                 return "CatForError"
    |
    = help: Add return type annotation: `str`

tests\desktop_ui\test_library_main_ui_new.py:823:13: ANN202 Missing return type annotation for private function `exec_`
    |
822 |     class FakeDialog:
823 |         def exec_(self):
    |             ^^^^^ ANN202
824 |             return 1
    |
    = help: Add return type annotation: `int`

tests\desktop_ui\test_library_main_ui_new.py:826:13: ANN202 Missing return type annotation for private function `get_values`
    |
824 |             return 1
825 |
826 |         def get_values(self):
    |             ^^^^^^^^^^ ANN202
827 |             return ("ErrSnip", "X")
    |
    = help: Add return type annotation

tests\desktop_ui\test_library_main_ui_new.py:831:9: ANN202 Missing return type annotation for private function `fail_save_snippet`
    |
829 |     monkeypatch.setattr(library_main, "SnippetDialog", lambda *a, **k: FakeDialog())
830 |
831 |     def fail_save_snippet(snip):
    |         ^^^^^^^^^^^^^^^^^ ANN202
832 |         raise Exception("failsnip")
    |
    = help: Add return type annotation: `Never`

tests\desktop_ui\test_library_main_ui_new.py:831:27: ANN001 Missing type annotation for function argument `snip`
    |
829 |     monkeypatch.setattr(library_main, "SnippetDialog", lambda *a, **k: FakeDialog())
830 |
831 |     def fail_save_snippet(snip):
    |                           ^^^^ ANN001
832 |         raise Exception("failsnip")
    |

tests\desktop_ui\test_library_main_ui_new.py:839:5: ANN201 Missing return type annotation for public function `test_edit_category_no_selection`
    |
839 | def test_edit_category_no_selection(main_window):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
840 |     main_window.categoryList.clearSelection()
841 |     main_window.edit_category()
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:839:5: D103 Missing docstring in public function
    |
839 | def test_edit_category_no_selection(main_window):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D103
840 |     main_window.categoryList.clearSelection()
841 |     main_window.edit_category()
    |

tests\desktop_ui\test_library_main_ui_new.py:839:37: ANN001 Missing type annotation for function argument `main_window`
    |
839 | def test_edit_category_no_selection(main_window):
    |                                     ^^^^^^^^^^^ ANN001
840 |     main_window.categoryList.clearSelection()
841 |     main_window.edit_category()
    |

tests\desktop_ui\test_library_main_ui_new.py:845:5: ANN201 Missing return type annotation for public function `test_delete_category_no_selection`
    |
845 | def test_delete_category_no_selection(main_window):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
846 |     main_window.categoryList.clearSelection()
847 |     main_window.delete_category()
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:845:5: D103 Missing docstring in public function
    |
845 | def test_delete_category_no_selection(main_window):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D103
846 |     main_window.categoryList.clearSelection()
847 |     main_window.delete_category()
    |

tests\desktop_ui\test_library_main_ui_new.py:845:39: ANN001 Missing type annotation for function argument `main_window`
    |
845 | def test_delete_category_no_selection(main_window):
    |                                       ^^^^^^^^^^^ ANN001
846 |     main_window.categoryList.clearSelection()
847 |     main_window.delete_category()
    |

tests\desktop_ui\test_library_main_ui_new.py:851:5: ANN201 Missing return type annotation for public function `test_add_snippet_no_category`
    |
851 | def test_add_snippet_no_category(main_window):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
852 |     main_window.selected_category = None
853 |     main_window.add_snippet()
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:851:5: D103 Missing docstring in public function
    |
851 | def test_add_snippet_no_category(main_window):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D103
852 |     main_window.selected_category = None
853 |     main_window.add_snippet()
    |

tests\desktop_ui\test_library_main_ui_new.py:851:34: ANN001 Missing type annotation for function argument `main_window`
    |
851 | def test_add_snippet_no_category(main_window):
    |                                  ^^^^^^^^^^^ ANN001
852 |     main_window.selected_category = None
853 |     main_window.add_snippet()
    |

tests\desktop_ui\test_library_main_ui_new.py:857:5: ANN201 Missing return type annotation for public function `test_edit_snippet_no_selection`
    |
857 | def test_edit_snippet_no_selection(main_window):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
858 |     main_window.snippetList.clearSelection()
859 |     main_window.edit_snippet()
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:857:5: D103 Missing docstring in public function
    |
857 | def test_edit_snippet_no_selection(main_window):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D103
858 |     main_window.snippetList.clearSelection()
859 |     main_window.edit_snippet()
    |

tests\desktop_ui\test_library_main_ui_new.py:857:36: ANN001 Missing type annotation for function argument `main_window`
    |
857 | def test_edit_snippet_no_selection(main_window):
    |                                    ^^^^^^^^^^^ ANN001
858 |     main_window.snippetList.clearSelection()
859 |     main_window.edit_snippet()
    |

tests\desktop_ui\test_library_main_ui_new.py:863:5: ANN201 Missing return type annotation for public function `test_delete_snippet_no_selection`
    |
863 | def test_delete_snippet_no_selection(main_window):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
864 |     main_window.snippetList.clearSelection()
865 |     main_window.delete_snippet()
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:863:5: D103 Missing docstring in public function
    |
863 | def test_delete_snippet_no_selection(main_window):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D103
864 |     main_window.snippetList.clearSelection()
865 |     main_window.delete_snippet()
    |

tests\desktop_ui\test_library_main_ui_new.py:863:38: ANN001 Missing type annotation for function argument `main_window`
    |
863 | def test_delete_snippet_no_selection(main_window):
    |                                      ^^^^^^^^^^^ ANN001
864 |     main_window.snippetList.clearSelection()
865 |     main_window.delete_snippet()
    |

tests\desktop_ui\test_library_main_ui_new.py:869:5: ANN201 Missing return type annotation for public function `test_edit_category_error`
    |
869 | def test_edit_category_error(monkeypatch, main_window):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
870 |     # Ensure a category exists and is selected
871 |     if not main_window.categories:
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:869:5: D103 Missing docstring in public function
    |
869 | def test_edit_category_error(monkeypatch, main_window):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^ D103
870 |     # Ensure a category exists and is selected
871 |     if not main_window.categories:
    |

tests\desktop_ui\test_library_main_ui_new.py:869:30: ANN001 Missing type annotation for function argument `monkeypatch`
    |
869 | def test_edit_category_error(monkeypatch, main_window):
    |                              ^^^^^^^^^^^ ANN001
870 |     # Ensure a category exists and is selected
871 |     if not main_window.categories:
    |

tests\desktop_ui\test_library_main_ui_new.py:869:43: ANN001 Missing type annotation for function argument `main_window`
    |
869 | def test_edit_category_error(monkeypatch, main_window):
    |                                           ^^^^^^^^^^^ ANN001
870 |     # Ensure a category exists and is selected
871 |     if not main_window.categories:
    |

tests\desktop_ui\test_library_main_ui_new.py:874:17: ANN202 Missing return type annotation for private function `exec_`
    |
873 |         class FakeCatDialog:
874 |             def exec_(self):
    |                 ^^^^^ ANN202
875 |                 return 1
    |
    = help: Add return type annotation: `int`

tests\desktop_ui\test_library_main_ui_new.py:877:17: ANN202 Missing return type annotation for private function `get_value`
    |
875 |                 return 1
876 |
877 |             def get_value(self):
    |                 ^^^^^^^^^ ANN202
878 |                 return "ErrEditCat"
    |
    = help: Add return type annotation: `str`

tests\desktop_ui\test_library_main_ui_new.py:885:13: ANN202 Missing return type annotation for private function `exec_`
    |
884 |     class FakeDialog:
885 |         def exec_(self):
    |             ^^^^^ ANN202
886 |             return 1
    |
    = help: Add return type annotation: `int`

tests\desktop_ui\test_library_main_ui_new.py:888:13: ANN202 Missing return type annotation for private function `get_value`
    |
886 |             return 1
887 |
888 |         def get_value(self):
    |             ^^^^^^^^^ ANN202
889 |             return "ErrEditCat"
    |
    = help: Add return type annotation: `str`

tests\desktop_ui\test_library_main_ui_new.py:893:9: ANN202 Missing return type annotation for private function `fail_save_category`
    |
891 |     monkeypatch.setattr(library_main, "CategoryDialog", lambda *a, **k: FakeDialog())
892 |
893 |     def fail_save_category(cat):
    |         ^^^^^^^^^^^^^^^^^^ ANN202
894 |         raise Exception("failcat2")
    |
    = help: Add return type annotation: `Never`

tests\desktop_ui\test_library_main_ui_new.py:893:28: ANN001 Missing type annotation for function argument `cat`
    |
891 |     monkeypatch.setattr(library_main, "CategoryDialog", lambda *a, **k: FakeDialog())
892 |
893 |     def fail_save_category(cat):
    |                            ^^^ ANN001
894 |         raise Exception("failcat2")
    |

tests\desktop_ui\test_library_main_ui_new.py:904:5: ANN201 Missing return type annotation for public function `test_edit_snippet_error`
    |
904 | def test_edit_snippet_error(monkeypatch, main_window):
    |     ^^^^^^^^^^^^^^^^^^^^^^^ ANN201
905 |     # Ensure a snippet exists and is selected
906 |     if not main_window.snippets:
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:904:5: D103 Missing docstring in public function
    |
904 | def test_edit_snippet_error(monkeypatch, main_window):
    |     ^^^^^^^^^^^^^^^^^^^^^^^ D103
905 |     # Ensure a snippet exists and is selected
906 |     if not main_window.snippets:
    |

tests\desktop_ui\test_library_main_ui_new.py:904:29: ANN001 Missing type annotation for function argument `monkeypatch`
    |
904 | def test_edit_snippet_error(monkeypatch, main_window):
    |                             ^^^^^^^^^^^ ANN001
905 |     # Ensure a snippet exists and is selected
906 |     if not main_window.snippets:
    |

tests\desktop_ui\test_library_main_ui_new.py:904:42: ANN001 Missing type annotation for function argument `main_window`
    |
904 | def test_edit_snippet_error(monkeypatch, main_window):
    |                                          ^^^^^^^^^^^ ANN001
905 |     # Ensure a snippet exists and is selected
906 |     if not main_window.snippets:
    |

tests\desktop_ui\test_library_main_ui_new.py:911:21: ANN202 Missing return type annotation for private function `exec_`
    |
910 |             class FakeCatDialog:
911 |                 def exec_(self):
    |                     ^^^^^ ANN202
912 |                     return 1
    |
    = help: Add return type annotation: `int`

tests\desktop_ui\test_library_main_ui_new.py:914:21: ANN202 Missing return type annotation for private function `get_value`
    |
912 |                     return 1
913 |
914 |                 def get_value(self):
    |                     ^^^^^^^^^ ANN202
915 |                     return "CatForEditError"
    |
    = help: Add return type annotation: `str`

tests\desktop_ui\test_library_main_ui_new.py:922:17: ANN202 Missing return type annotation for private function `exec_`
    |
921 |         class FakeAddDialog:
922 |             def exec_(self):
    |                 ^^^^^ ANN202
923 |                 return 1
    |
    = help: Add return type annotation: `int`

tests\desktop_ui\test_library_main_ui_new.py:925:17: ANN202 Missing return type annotation for private function `get_values`
    |
923 |                 return 1
924 |
925 |             def get_values(self):
    |                 ^^^^^^^^^^ ANN202
926 |                 return ("SnippetToEditError", "ContentToEditError")
    |
    = help: Add return type annotation

tests\desktop_ui\test_library_main_ui_new.py:933:13: ANN202 Missing return type annotation for private function `exec_`
    |
932 |     class FakeDialog:
933 |         def exec_(self):
    |             ^^^^^ ANN202
934 |             return 1
    |
    = help: Add return type annotation: `int`

tests\desktop_ui\test_library_main_ui_new.py:936:13: ANN202 Missing return type annotation for private function `get_values`
    |
934 |             return 1
935 |
936 |         def get_values(self):
    |             ^^^^^^^^^^ ANN202
937 |             return ("ErrEditSnip", "X")
    |
    = help: Add return type annotation

tests\desktop_ui\test_library_main_ui_new.py:941:9: ANN202 Missing return type annotation for private function `fail_save_snippet`
    |
939 |     monkeypatch.setattr(library_main, "SnippetDialog", lambda *a, **k: FakeDialog())
940 |
941 |     def fail_save_snippet(snip):
    |         ^^^^^^^^^^^^^^^^^ ANN202
942 |         raise Exception("failsnip2")
    |
    = help: Add return type annotation: `Never`

tests\desktop_ui\test_library_main_ui_new.py:941:27: ANN001 Missing type annotation for function argument `snip`
    |
939 |     monkeypatch.setattr(library_main, "SnippetDialog", lambda *a, **k: FakeDialog())
940 |
941 |     def fail_save_snippet(snip):
    |                           ^^^^ ANN001
942 |         raise Exception("failsnip2")
    |

tests\desktop_ui\test_library_main_ui_new.py:952:5: ANN201 Missing return type annotation for public function `test_delete_category_error`
    |
952 | def test_delete_category_error(monkeypatch, main_window):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
953 |     # Ensure a category exists and is selected
954 |     if not main_window.categories:
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:952:5: D103 Missing docstring in public function
    |
952 | def test_delete_category_error(monkeypatch, main_window):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ D103
953 |     # Ensure a category exists and is selected
954 |     if not main_window.categories:
    |

tests\desktop_ui\test_library_main_ui_new.py:952:32: ANN001 Missing type annotation for function argument `monkeypatch`
    |
952 | def test_delete_category_error(monkeypatch, main_window):
    |                                ^^^^^^^^^^^ ANN001
953 |     # Ensure a category exists and is selected
954 |     if not main_window.categories:
    |

tests\desktop_ui\test_library_main_ui_new.py:952:45: ANN001 Missing type annotation for function argument `main_window`
    |
952 | def test_delete_category_error(monkeypatch, main_window):
    |                                             ^^^^^^^^^^^ ANN001
953 |     # Ensure a category exists and is selected
954 |     if not main_window.categories:
    |

tests\desktop_ui\test_library_main_ui_new.py:957:17: ANN202 Missing return type annotation for private function `exec_`
    |
956 |         class FakeCatDialog:
957 |             def exec_(self):
    |                 ^^^^^ ANN202
958 |                 return 1
    |
    = help: Add return type annotation: `int`

tests\desktop_ui\test_library_main_ui_new.py:960:17: ANN202 Missing return type annotation for private function `get_value`
    |
958 |                 return 1
959 |
960 |             def get_value(self):
    |                 ^^^^^^^^^ ANN202
961 |                 return "CatForDelete"
    |
    = help: Add return type annotation: `str`

tests\desktop_ui\test_library_main_ui_new.py:972:9: ANN202 Missing return type annotation for private function `fail_delete_category_by_id`
    |
970 |     )
971 |
972 |     def fail_delete_category_by_id(cid):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN202
973 |         raise Exception("faildelcat")
    |
    = help: Add return type annotation: `Never`

tests\desktop_ui\test_library_main_ui_new.py:972:36: ANN001 Missing type annotation for function argument `cid`
    |
970 |     )
971 |
972 |     def fail_delete_category_by_id(cid):
    |                                    ^^^ ANN001
973 |         raise Exception("faildelcat")
    |

tests\desktop_ui\test_library_main_ui_new.py:982:5: ANN201 Missing return type annotation for public function `test_delete_snippet_error`
    |
982 | def test_delete_snippet_error(monkeypatch, main_window):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
983 |     # Ensure a category exists and is selected
984 |     if not main_window.categories:
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:982:5: D103 Missing docstring in public function
    |
982 | def test_delete_snippet_error(monkeypatch, main_window):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^ D103
983 |     # Ensure a category exists and is selected
984 |     if not main_window.categories:
    |

tests\desktop_ui\test_library_main_ui_new.py:982:31: ANN001 Missing type annotation for function argument `monkeypatch`
    |
982 | def test_delete_snippet_error(monkeypatch, main_window):
    |                               ^^^^^^^^^^^ ANN001
983 |     # Ensure a category exists and is selected
984 |     if not main_window.categories:
    |

tests\desktop_ui\test_library_main_ui_new.py:982:44: ANN001 Missing type annotation for function argument `main_window`
    |
982 | def test_delete_snippet_error(monkeypatch, main_window):
    |                                            ^^^^^^^^^^^ ANN001
983 |     # Ensure a category exists and is selected
984 |     if not main_window.categories:
    |

tests\desktop_ui\test_library_main_ui_new.py:987:17: ANN202 Missing return type annotation for private function `exec_`
    |
986 |         class FakeCatDialog:
987 |             def exec_(self):
    |                 ^^^^^ ANN202
988 |                 return 1
    |
    = help: Add return type annotation: `int`

tests\desktop_ui\test_library_main_ui_new.py:990:17: ANN202 Missing return type annotation for private function `get_value`
    |
988 |                 return 1
989 |
990 |             def get_value(self):
    |                 ^^^^^^^^^ ANN202
991 |                 return "CatForDeleteError"
    |
    = help: Add return type annotation: `str`

tests\desktop_ui\test_library_main_ui_new.py:1000:17: ANN202 Missing return type annotation for private function `exec_`
     |
 999 |         class FakeSnipDialog:
1000 |             def exec_(self):
     |                 ^^^^^ ANN202
1001 |                 return 1
     |
     = help: Add return type annotation: `int`

tests\desktop_ui\test_library_main_ui_new.py:1003:17: ANN202 Missing return type annotation for private function `get_values`
     |
1001 |                 return 1
1002 |
1003 |             def get_values(self):
     |                 ^^^^^^^^^^ ANN202
1004 |                 return ("ToDelError", "X")
     |
     = help: Add return type annotation

tests\desktop_ui\test_library_main_ui_new.py:1015:9: ANN202 Missing return type annotation for private function `fail_delete_snippet`
     |
1013 |     )
1014 |
1015 |     def fail_delete_snippet(sid):
     |         ^^^^^^^^^^^^^^^^^^^ ANN202
1016 |         raise Exception("faildelsnip")
     |
     = help: Add return type annotation: `Never`

tests\desktop_ui\test_library_main_ui_new.py:1015:29: ANN001 Missing type annotation for function argument `sid`
     |
1013 |     )
1014 |
1015 |     def fail_delete_snippet(sid):
     |                             ^^^ ANN001
1016 |         raise Exception("faildelsnip")
     |

tests\desktop_ui\test_library_main_ui_new.py:1026:5: ANN201 Missing return type annotation for public function `test_view_snippet_dialog`
     |
1026 | def test_view_snippet_dialog(monkeypatch, main_window):
     |     ^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
1027 |     # Ensure a category exists and is selected
1028 |     if not main_window.categories:
     |
     = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:1026:5: D103 Missing docstring in public function
     |
1026 | def test_view_snippet_dialog(monkeypatch, main_window):
     |     ^^^^^^^^^^^^^^^^^^^^^^^^ D103
1027 |     # Ensure a category exists and is selected
1028 |     if not main_window.categories:
     |

tests\desktop_ui\test_library_main_ui_new.py:1026:30: ANN001 Missing type annotation for function argument `monkeypatch`
     |
1026 | def test_view_snippet_dialog(monkeypatch, main_window):
     |                              ^^^^^^^^^^^ ANN001
1027 |     # Ensure a category exists and is selected
1028 |     if not main_window.categories:
     |

tests\desktop_ui\test_library_main_ui_new.py:1026:43: ANN001 Missing type annotation for function argument `main_window`
     |
1026 | def test_view_snippet_dialog(monkeypatch, main_window):
     |                                           ^^^^^^^^^^^ ANN001
1027 |     # Ensure a category exists and is selected
1028 |     if not main_window.categories:
     |

tests\desktop_ui\test_library_main_ui_new.py:1031:17: ANN202 Missing return type annotation for private function `exec_`
     |
1030 |         class FakeCatDialog:
1031 |             def exec_(self):
     |                 ^^^^^ ANN202
1032 |                 return 1
     |
     = help: Add return type annotation: `int`

tests\desktop_ui\test_library_main_ui_new.py:1034:17: ANN202 Missing return type annotation for private function `get_value`
     |
1032 |                 return 1
1033 |
1034 |             def get_value(self):
     |                 ^^^^^^^^^ ANN202
1035 |                 return "CatForView"
     |
     = help: Add return type annotation: `str`

tests\desktop_ui\test_library_main_ui_new.py:1044:17: ANN202 Missing return type annotation for private function `exec_`
     |
1043 |         class FakeSnipDialog:
1044 |             def exec_(self):
     |                 ^^^^^ ANN202
1045 |                 return 1
     |
     = help: Add return type annotation: `int`

tests\desktop_ui\test_library_main_ui_new.py:1047:17: ANN202 Missing return type annotation for private function `get_values`
     |
1045 |                 return 1
1046 |
1047 |             def get_values(self):
     |                 ^^^^^^^^^^ ANN202
1048 |                 return ("ViewMe", "Content")
     |
     = help: Add return type annotation

tests\desktop_ui\test_library_main_ui_new.py:1056:13: ANN204 Missing return type annotation for special method `__init__`
     |
1055 |     class FakeViewDialog:
1056 |         def __init__(self, **kwargs):
     |             ^^^^^^^^ ANN204
1057 |             called["shown"] = True
     |
     = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:1056:28: ANN003 Missing type annotation for `**kwargs`
     |
1055 |     class FakeViewDialog:
1056 |         def __init__(self, **kwargs):
     |                            ^^^^^^^^ ANN003
1057 |             called["shown"] = True
     |

tests\desktop_ui\test_library_main_ui_new.py:1059:13: ANN202 Missing return type annotation for private function `exec_`
     |
1057 |             called["shown"] = True
1058 |
1059 |         def exec_(self):
     |             ^^^^^ ANN202
1060 |             called["exec"] = True
     |
     = help: Add return type annotation: `None`

tests\desktop_ui\test_ngram_heatmap_dialog.py:1:1: D212 [*] Multi-line docstring summary should start at the first line
  |
1 | / """
2 | | Test suite for NGram Heatmap Dialog.
3 | |
4 | | This module tests the modal dialog functionality, UI initialization,
5 | | and interaction with the NGramAnalyticsService.
6 | | """
  | |___^ D212
7 |
8 |   import os
  |
  = help: Remove whitespace after opening quotes

tests\desktop_ui\test_ngram_heatmap_dialog.py:8:1: I001 [*] Import block is un-sorted or un-formatted
   |
 6 |   """
 7 |
 8 | / import os
 9 | | import sys
10 | | from unittest.mock import Mock, patch, MagicMock
11 | |
12 | | import pytest
13 | | from PySide6 import QtWidgets, QtCore
   | |_____________________________________^ I001
14 |
15 |   # Ensure project root is in sys.path
   |
   = help: Organize imports

tests\desktop_ui\test_ngram_heatmap_dialog.py:18:1: I001 [*] Import block is un-sorted or un-formatted
   |
16 |   sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), "..", "..")))
17 |
18 | / from desktop_ui.ngram_heatmap_screen import NGramHeatmapDialog
19 | | from models.ngram_analytics_service import NGramHeatmapData
20 | | from models.user import User
21 | | from models.keyboard import Keyboard
   | |____________________________________^ I001
   |
   = help: Organize imports

tests\desktop_ui\test_typing_drill.py:1:1: D100 Missing docstring in public module
tests\desktop_ui\test_users_and_keyboards.py:1:1: D212 [*] Multi-line docstring summary should start at the first line
  |
1 | / """
2 | | Tests for the UsersAndKeyboards dialog in the AI Typing Trainer application.
3 | |
4 | | Updated to use PySide6 instead of PyQt5.
5 | | """
  | |___^ D212
6 |   import pytest
7 |   from typing import Generator, List, Tuple
  |
  = help: Remove whitespace after opening quotes

tests\desktop_ui\test_users_and_keyboards.py:6:1: I001 [*] Import block is un-sorted or un-formatted
   |
 4 |   Updated to use PySide6 instead of PyQt5.
 5 |   """
 6 | / import pytest
 7 | | from typing import Generator, List, Tuple
 8 | | from unittest.mock import MagicMock, patch
 9 | | from PySide6 import QtCore, QtWidgets
10 | | from PySide6.QtCore import Qt
11 | | from pytestqt.qtbot import QtBot
12 | |
13 | | from db.database_manager import DatabaseManager
14 | | from desktop_ui.users_and_keyboards import UsersAndKeyboards
15 | | from models.keyboard import Keyboard
16 | | from models.keyboard_manager import KeyboardManager
17 | | from models.user import User
18 | | from models.user_manager import UserManager
   | |___________________________________________^ I001
19 |
20 |   # Test data constants
   |
   = help: Organize imports

tests\desktop_ui\test_users_and_keyboards.py:191:5: D212 [*] Multi-line docstring summary should start at the first line
    |
189 |       mock_keyboard_manager: MagicMock,
190 |   ) -> Generator[Tuple[UsersAndKeyboards, MagicMock, MagicMock], None, None]:
191 | /     """
192 | |     Create and return a UsersAndKeyboards dialog for testing.
193 | |
194 | |     Yields:
195 | |         A tuple containing the dialog and the mock managers.
196 | |     """
    | |_______^ D212
197 |       with (
198 |           patch("desktop_ui.users_and_keyboards.UserManager", return_value=mock_user_manager),
    |
    = help: Remove whitespace after opening quotes

tests\helpers\__init__.py:1:1: D212 [*] Multi-line docstring summary should start at the first line
  |
1 | / """
2 | | Helper functions and fixtures for testing database operations.
3 | |
4 | | This module provides reusable test fixtures and utilities for database testing
5 | | across the test suite. These helpers ensure consistent database setup and
6 | | tear down for all tests.
7 | | """
  | |___^ D212
8 |
9 |   # Import db_helpers to make fixtures available at the package level
  |
  = help: Remove whitespace after opening quotes

tests\helpers\db_helpers.py:1:1: D212 [*] Multi-line docstring summary should start at the first line
  |
1 | / """
2 | | Database testing helpers and fixtures.
3 | |
4 | | This module provides reusable fixtures and helper functions for testing database operations.
5 | | It includes fixtures for creating temporary databases and handling database connections.
6 | | """
  | |___^ D212
7 |
8 |   import os
  |
  = help: Remove whitespace after opening quotes

tests\helpers\db_helpers.py:20:5: D212 [*] Multi-line docstring summary should start at the first line
   |
18 |   @pytest.fixture(scope="function")
19 |   def temp_db() -> Generator[str, None, None]:
20 | /     """
21 | |     Create a temporary database file for testing.
22 | |
23 | |     Yields:
24 | |         str: Path to the temporary database file
25 | |
26 | |     The database file is automatically deleted after the test completes.
27 | |     """
   | |_______^ D212
28 |       with tempfile.NamedTemporaryFile(delete=False, suffix=".db") as tmp:
29 |           db_path = tmp.name
   |
   = help: Remove whitespace after opening quotes

tests\helpers\db_helpers.py:42:5: D212 [*] Multi-line docstring summary should start at the first line
   |
40 |   @pytest.fixture(scope="function")
41 |   def db_manager(temp_db: str) -> DatabaseManager:
42 | /     """
43 | |     Create a DatabaseManager instance with a temporary database.
44 | |
45 | |     Args:
46 | |         temp_db: Path to the temporary database file (provided by temp_db fixture)
47 | |
48 | |     Returns:
49 | |         DatabaseManager: A new DatabaseManager instance
50 | |     """
   | |_______^ D212
51 |       return DatabaseManager(temp_db)
   |
   = help: Remove whitespace after opening quotes

tests\helpers\db_helpers.py:56:5: D212 [*] Multi-line docstring summary should start at the first line
   |
54 |   @pytest.fixture(scope="function")
55 |   def db_with_tables(db_manager: DatabaseManager) -> DatabaseManager:
56 | /     """
57 | |     Create a database with all tables initialized.
58 | |
59 | |     Args:
60 | |         db_manager: DatabaseManager instance (provided by db_manager fixture)
61 | |
62 | |     Returns:
63 | |         DatabaseManager: The same DatabaseManager instance with tables initialized
64 | |     """
   | |_______^ D212
65 |       db_manager.init_tables()
66 |       return db_manager
   |
   = help: Remove whitespace after opening quotes

tests\helpers\db_helpers.py:70:5: D212 [*] Multi-line docstring summary should start at the first line
   |
69 |   def create_connection_error_db() -> str:
70 | /     """
71 | |     Create a database path that will cause a connection error.
72 | |
73 | |     Returns:
74 | |         str: A path that will cause a connection error when used
75 | |     """
   | |_______^ D212
76 |       with tempfile.TemporaryDirectory() as temp_dir:
77 |           return str(Path(temp_dir) / "nonexistent" / "database.db")
   |
   = help: Remove whitespace after opening quotes

tests\models\__init__.py:1:1: D104 Missing docstring in public package
tests\models\conftest.py:1:1: D100 Missing docstring in public module
tests\models\conftest.py:35:5: D212 [*] Multi-line docstring summary should start at the first line
   |
33 |   @pytest.fixture(scope="function")
34 |   def temp_db() -> Generator[str, None, None]:
35 | /     """
36 | |     Create a temporary database file for testing.
37 | |
38 | |     Yields:
39 | |         str: Path to the temporary database file
40 | |
41 | |     The database file is automatically deleted after the test completes.
42 | |     """
   | |_______^ D212
43 |       with tempfile.NamedTemporaryFile(delete=False, suffix=".db") as tmp:
44 |           db_path = tmp.name
   |
   = help: Remove whitespace after opening quotes

tests\models\conftest.py:57:5: D212 [*] Multi-line docstring summary should start at the first line
   |
55 |   @pytest.fixture(scope="function")
56 |   def db_manager(temp_db: str) -> DatabaseManager:
57 | /     """
58 | |     Create a DatabaseManager instance with a temporary database using LOCAL connection type.
59 | |
60 | |     Args:
61 | |         temp_db: Path to the temporary database file (provided by temp_db fixture)
62 | |
63 | |     Returns:
64 | |         DatabaseManager: A new DatabaseManager instance with LOCAL connection type
65 | |     """
   | |_______^ D212
66 |       return DatabaseManager(temp_db, connection_type=ConnectionType.LOCAL)
   |
   = help: Remove whitespace after opening quotes

tests\models\conftest.py:71:5: D212 [*] Multi-line docstring summary should start at the first line
   |
69 |   @pytest.fixture(scope="function")
70 |   def db_with_tables(db_manager: DatabaseManager) -> DatabaseManager:
71 | /     """
72 | |     Create a database with all tables initialized.
73 | |
74 | |     Args:
75 | |         db_manager: DatabaseManager instance (provided by db_manager fixture)
76 | |
77 | |     Returns:
78 | |         DatabaseManager: The same DatabaseManager instance with tables initialized
79 | |     """
   | |_______^ D212
80 |       db_manager.init_tables()
81 |       return db_manager
   |
   = help: Remove whitespace after opening quotes

tests\models\conftest.py:85:5: D212 [*] Multi-line docstring summary should start at the first line
   |
84 |   def create_connection_error_db() -> str:
85 | /     """
86 | |     Create a database path that will cause a connection error.
87 | |
88 | |     Returns:
89 | |         str: A path that will cause a connection error when used
90 | |     """
   | |_______^ D212
91 |       with tempfile.TemporaryDirectory() as temp_dir:
92 |           return str(Path(temp_dir) / "nonexistent" / "database.db")
   |
   = help: Remove whitespace after opening quotes

tests\models\conftest.py:97:5: D205 1 blank line required between summary line and description
    |
 95 |   @pytest.fixture(scope="function")
 96 |   def test_user(db_with_tables: DatabaseManager) -> User:
 97 | /     """
 98 | |     Creates and saves a test user, returning the User object.
 99 | |     This fixture is function-scoped to ensure a fresh user for each test,
100 | |     preventing side effects between tests.
101 | |     """
    | |_______^ D205
102 |       user_manager = UserManager(db_with_tables)
103 |       user = User(
    |
    = help: Insert single blank line

tests\models\conftest.py:97:5: D212 [*] Multi-line docstring summary should start at the first line
    |
 95 |   @pytest.fixture(scope="function")
 96 |   def test_user(db_with_tables: DatabaseManager) -> User:
 97 | /     """
 98 | |     Creates and saves a test user, returning the User object.
 99 | |     This fixture is function-scoped to ensure a fresh user for each test,
100 | |     preventing side effects between tests.
101 | |     """
    | |_______^ D212
102 |       user_manager = UserManager(db_with_tables)
103 |       user = User(
    |
    = help: Remove whitespace after opening quotes

tests\models\conftest.py:114:5: D205 1 blank line required between summary line and description
    |
112 |   @pytest.fixture(scope="function")
113 |   def test_keyboard(db_with_tables: DatabaseManager, test_user: User) -> Keyboard:
114 | /     """
115 | |     Creates and saves a test keyboard associated with the test_user,
116 | |     returning the Keyboard object.
117 | |     This fixture is function-scoped for test isolation.
118 | |     """
    | |_______^ D205
119 |       keyboard_manager = KeyboardManager(db_with_tables)
120 |       keyboard = Keyboard(
    |
    = help: Insert single blank line

tests\models\conftest.py:114:5: D212 [*] Multi-line docstring summary should start at the first line
    |
112 |   @pytest.fixture(scope="function")
113 |   def test_keyboard(db_with_tables: DatabaseManager, test_user: User) -> Keyboard:
114 | /     """
115 | |     Creates and saves a test keyboard associated with the test_user,
116 | |     returning the Keyboard object.
117 | |     This fixture is function-scoped for test isolation.
118 | |     """
    | |_______^ D212
119 |       keyboard_manager = KeyboardManager(db_with_tables)
120 |       keyboard = Keyboard(
    |
    = help: Remove whitespace after opening quotes

tests\models\debug_session_test.py:1:1: D200 One-line docstring should fit on one line
  |
1 | / """
2 | | Temporary debug test for the session creation tests.
3 | | """
  | |___^ D200
4 |
5 |   from datetime import datetime
  |
  = help: Reformat to one line

tests\models\debug_session_test.py:1:1: D212 [*] Multi-line docstring summary should start at the first line
  |
1 | / """
2 | | Temporary debug test for the session creation tests.
3 | | """
  | |___^ D212
4 |
5 |   from datetime import datetime
  |
  = help: Remove whitespace after opening quotes

tests\models\debug_session_tests.py:15:5: D103 Missing docstring in public function
   |
14 | @pytest.fixture
15 | def valid_session_dict_fixture() -> Dict[str, object]:
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ D103
16 |     now = datetime.now()
17 |     return {
   |

tests\models\debug_session_tests.py:119:13: F841 Local variable `s` is assigned to but never used
    |
118 |         try:
119 |             s = Session.from_dict(data)
    |             ^ F841
120 |             print(f"Case {idx} passed successfully")
121 |             if expected_exception_type:
    |
    = help: Remove assignment to unused variable `s`

tests\models\debug_snippet_specific.py:1:1: D200 One-line docstring should fit on one line
  |
1 | / """
2 | | Script to debug tests in test_snippet.py with improved error reporting
3 | | """
  | |___^ D200
4 |   import sys
  |
  = help: Reformat to one line

tests\models\debug_snippet_specific.py:1:1: D212 [*] Multi-line docstring summary should start at the first line
  |
1 | / """
2 | | Script to debug tests in test_snippet.py with improved error reporting
3 | | """
  | |___^ D212
4 |   import sys
  |
  = help: Remove whitespace after opening quotes

tests\models\debug_snippet_specific.py:1:1: D415 First line should end with a period, question mark, or exclamation point
  |
1 | / """
2 | | Script to debug tests in test_snippet.py with improved error reporting
3 | | """
  | |___^ D415
4 |   import sys
  |
  = help: Add closing punctuation

tests\models\debug_test_snippet_manager.py:1:1: D200 One-line docstring should fit on one line
  |
1 | / """
2 | | Debug script to run specific tests from test_snippet_manager.py and get detailed output
3 | | """
  | |___^ D200
4 |   import sys
  |
  = help: Reformat to one line

tests\models\debug_test_snippet_manager.py:1:1: D212 [*] Multi-line docstring summary should start at the first line
  |
1 | / """
2 | | Debug script to run specific tests from test_snippet_manager.py and get detailed output
3 | | """
  | |___^ D212
4 |   import sys
  |
  = help: Remove whitespace after opening quotes

tests\models\debug_test_snippet_manager.py:1:1: D415 First line should end with a period, question mark, or exclamation point
  |
1 | / """
2 | | Debug script to run specific tests from test_snippet_manager.py and get detailed output
3 | | """
  | |___^ D415
4 |   import sys
  |
  = help: Add closing punctuation

tests\models\debug_test_snippet_manager.py:11:121: E501 Line too long (121 > 120)
   |
 9 |     # Run the tests with detailed error reporting
10 |     # Run a specific test that might be failing
11 |     test_path = "tests/models/test_snippet_manager.py::TestCreateSnippet::test_create_snippet_pydantic_validation_errors"
   |                                                                                                                         ^ E501
12 |     print(f"\nRunning test: {test_path}\n")
13 |     exit_code = pytest.main([test_path, "-vv"])
   |

tests\models\import_test.py:10:39: F401 `models.ngram_analyzer.NGram` imported but unused; consider using `importlib.util.find_spec` to test for availability
   |
 8 | try:
 9 |     # Import and print what's available in the module
10 |     from models.ngram_analyzer import NGram, NGramAnalyzer
   |                                       ^^^^^ F401
11 |
12 |     print("Successfully imported NGramAnalyzer and NGram")
   |
   = help: Remove unused import

tests\models\import_test.py:10:46: F401 `models.ngram_analyzer.NGramAnalyzer` imported but unused; consider using `importlib.util.find_spec` to test for availability
   |
 8 | try:
 9 |     # Import and print what's available in the module
10 |     from models.ngram_analyzer import NGram, NGramAnalyzer
   |                                              ^^^^^^^^^^^^^ F401
11 |
12 |     print("Successfully imported NGramAnalyzer and NGram")
   |
   = help: Remove unused import

tests\models\import_test.py:16:43: F401 `models.ngram_analyzer.NGramStats` imported but unused; consider using `importlib.util.find_spec` to test for availability
   |
14 |     # Try to access the required imports that are failing
15 |     try:
16 |         from models.ngram_analyzer import NGramStats
   |                                           ^^^^^^^^^^ F401
17 |         print("NGramStats exists")
18 |     except ImportError:
   |
   = help: Remove unused import: `models.ngram_analyzer.NGramStats`

tests\models\import_test.py:22:43: F401 `models.ngram_analyzer.Session` imported but unused; consider using `importlib.util.find_spec` to test for availability
   |
21 |     try:
22 |         from models.ngram_analyzer import Session
   |                                           ^^^^^^^ F401
23 |         print("Session exists")
24 |     except ImportError:
   |
   = help: Remove unused import: `models.ngram_analyzer.Session`

tests\models\test_category.py:1:1: D205 1 blank line required between summary line and description
  |
1 | / """
2 | | Unit tests for the Category Pydantic model in models.category.
3 | | Focuses on validation logic within the Category model itself.
4 | | """
  | |___^ D205
5 |
6 |   # Standard library imports
  |
  = help: Insert single blank line

tests\models\test_category.py:1:1: D212 [*] Multi-line docstring summary should start at the first line
  |
1 | / """
2 | | Unit tests for the Category Pydantic model in models.category.
3 | | Focuses on validation logic within the Category model itself.
4 | | """
  | |___^ D212
5 |
6 |   # Standard library imports
  |
  = help: Remove whitespace after opening quotes

tests\models\test_category.py:40:9: D200 One-line docstring should fit on one line
   |
38 |       )
39 |       def test_category_name_validation(self, name: str, expected_error_message_part: str) -> None:
40 | /         """
41 | |         Test objective: Verify Category model's name validation for format, length, and ASCII.
42 | |         """
   | |___________^ D200
43 |           with pytest.raises(ValidationError) as exc_info:
44 |               Category(category_id=str(uuid.uuid4()), category_name=name)
   |
   = help: Reformat to one line

tests\models\test_category.py:40:9: D212 [*] Multi-line docstring summary should start at the first line
   |
38 |       )
39 |       def test_category_name_validation(self, name: str, expected_error_message_part: str) -> None:
40 | /         """
41 | |         Test objective: Verify Category model's name validation for format, length, and ASCII.
42 | |         """
   | |___________^ D212
43 |           with pytest.raises(ValidationError) as exc_info:
44 |               Category(category_id=str(uuid.uuid4()), category_name=name)
   |
   = help: Remove whitespace after opening quotes

tests\models\test_category_manager.py:1:1: D205 1 blank line required between summary line and description
  |
1 | / """
2 | | Unit tests for models.category_manager.CategoryManager.
3 | | Covers CRUD, validation (including DB uniqueness), cascade deletion, and error handling.
4 | | """
  | |___^ D205
5 |
6 |   import uuid
  |
  = help: Insert single blank line

tests\models\test_category_manager.py:1:1: D212 [*] Multi-line docstring summary should start at the first line
  |
1 | / """
2 | | Unit tests for models.category_manager.CategoryManager.
3 | | Covers CRUD, validation (including DB uniqueness), cascade deletion, and error handling.
4 | | """
  | |___^ D212
5 |
6 |   import uuid
  |
  = help: Remove whitespace after opening quotes

tests\models\test_category_manager.py:19:5: D200 One-line docstring should fit on one line
   |
17 |   @pytest.fixture(scope="function")
18 |   def category_mgr(db_with_tables: DatabaseManager) -> CategoryManager:
19 | /     """
20 | |     Fixture: Provides a CategoryManager with a fresh, initialized database.
21 | |     """
   | |_______^ D200
22 |       return CategoryManager(db_with_tables)
   |
   = help: Reformat to one line

tests\models\test_category_manager.py:19:5: D212 [*] Multi-line docstring summary should start at the first line
   |
17 |   @pytest.fixture(scope="function")
18 |   def category_mgr(db_with_tables: DatabaseManager) -> CategoryManager:
19 | /     """
20 | |     Fixture: Provides a CategoryManager with a fresh, initialized database.
21 | |     """
   | |_______^ D212
22 |       return CategoryManager(db_with_tables)
   |
   = help: Remove whitespace after opening quotes

tests\models\test_category_manager.py:27:5: D200 One-line docstring should fit on one line
   |
25 |   @pytest.fixture(scope="function")
26 |   def snippet_mgr(db_with_tables: DatabaseManager) -> SnippetManager:
27 | /     """
28 | |     Fixture: Provides a SnippetManager with a fresh, initialized database.
29 | |     """
   | |_______^ D200
30 |       return SnippetManager(db_with_tables)
   |
   = help: Reformat to one line

tests\models\test_category_manager.py:27:5: D212 [*] Multi-line docstring summary should start at the first line
   |
25 |   @pytest.fixture(scope="function")
26 |   def snippet_mgr(db_with_tables: DatabaseManager) -> SnippetManager:
27 | /     """
28 | |     Fixture: Provides a SnippetManager with a fresh, initialized database.
29 | |     """
   | |_______^ D212
30 |       return SnippetManager(db_with_tables)
   |
   = help: Remove whitespace after opening quotes

tests\models\test_category_manager.py:37:9: D200 One-line docstring should fit on one line
   |
36 |       def test_create_category_valid(self, category_mgr: CategoryManager) -> None:
37 | /         """
38 | |         Test objective: Create a category with a valid name and verify persistence.
39 | |         """
   | |___________^ D200
40 |           category = Category(category_name="Alpha", description="")
41 |           assert category_mgr.save_category(category)
   |
   = help: Reformat to one line

tests\models\test_category_manager.py:37:9: D212 [*] Multi-line docstring summary should start at the first line
   |
36 |       def test_create_category_valid(self, category_mgr: CategoryManager) -> None:
37 | /         """
38 | |         Test objective: Create a category with a valid name and verify persistence.
39 | |         """
   | |___________^ D212
40 |           category = Category(category_name="Alpha", description="")
41 |           assert category_mgr.save_category(category)
   |
   = help: Remove whitespace after opening quotes

tests\models\test_category_manager.py:60:9: D200 One-line docstring should fit on one line
   |
58 |           self, category_mgr: CategoryManager, name: str, err_msg_part: str
59 |       ) -> None:
60 | /         """
61 | |         Test objective: Attempt to create a category with an invalid name format.
62 | |         """
   | |___________^ D200
63 |           with pytest.raises((ValueError, CategoryValidationError)) as e:
64 |               category = Category(category_name=name, description="")
   |
   = help: Reformat to one line

tests\models\test_category_manager.py:60:9: D212 [*] Multi-line docstring summary should start at the first line
   |
58 |           self, category_mgr: CategoryManager, name: str, err_msg_part: str
59 |       ) -> None:
60 | /         """
61 | |         Test objective: Attempt to create a category with an invalid name format.
62 | |         """
   | |___________^ D212
63 |           with pytest.raises((ValueError, CategoryValidationError)) as e:
64 |               category = Category(category_name=name, description="")
   |
   = help: Remove whitespace after opening quotes

tests\models\test_category_manager.py:69:9: D200 One-line docstring should fit on one line
   |
68 |       def test_create_category_duplicate_name(self, category_mgr: CategoryManager) -> None:
69 | /         """
70 | |         Test objective: Attempt to create a category with a duplicate name.
71 | |         """
   | |___________^ D200
72 |           category1 = Category(category_name="UniqueName", description="")
73 |           category_mgr.save_category(category1)
   |
   = help: Reformat to one line

tests\models\test_category_manager.py:69:9: D212 [*] Multi-line docstring summary should start at the first line
   |
68 |       def test_create_category_duplicate_name(self, category_mgr: CategoryManager) -> None:
69 | /         """
70 | |         Test objective: Attempt to create a category with a duplicate name.
71 | |         """
   | |___________^ D212
72 |           category1 = Category(category_name="UniqueName", description="")
73 |           category_mgr.save_category(category1)
   |
   = help: Remove whitespace after opening quotes

tests\models\test_category_manager.py:80:9: D200 One-line docstring should fit on one line
   |
79 |       def test_get_category_by_id(self, category_mgr: CategoryManager) -> None:
80 | /         """
81 | |         Test objective: Retrieve a category by its ID.
82 | |         """
   | |___________^ D200
83 |           category = Category(category_name="Test Category", description="")
84 |           category_mgr.save_category(category)
   |
   = help: Reformat to one line

tests\models\test_category_manager.py:80:9: D212 [*] Multi-line docstring summary should start at the first line
   |
79 |       def test_get_category_by_id(self, category_mgr: CategoryManager) -> None:
80 | /         """
81 | |         Test objective: Retrieve a category by its ID.
82 | |         """
   | |___________^ D212
83 |           category = Category(category_name="Test Category", description="")
84 |           category_mgr.save_category(category)
   |
   = help: Remove whitespace after opening quotes

tests\models\test_category_manager.py:91:9: D200 One-line docstring should fit on one line
   |
90 |       def test_get_category_by_id_not_found(self, category_mgr: CategoryManager) -> None:
91 | /         """
92 | |         Test objective: Attempt to retrieve a non-existent category by ID.
93 | |         """
   | |___________^ D200
94 |           with pytest.raises(CategoryNotFound):
95 |               category_mgr.get_category_by_id(str(uuid.uuid4()))
   |
   = help: Reformat to one line

tests\models\test_category_manager.py:91:9: D212 [*] Multi-line docstring summary should start at the first line
   |
90 |       def test_get_category_by_id_not_found(self, category_mgr: CategoryManager) -> None:
91 | /         """
92 | |         Test objective: Attempt to retrieve a non-existent category by ID.
93 | |         """
   | |___________^ D212
94 |           with pytest.raises(CategoryNotFound):
95 |               category_mgr.get_category_by_id(str(uuid.uuid4()))
   |
   = help: Remove whitespace after opening quotes

tests\models\test_category_manager.py:98:9: D200 One-line docstring should fit on one line
    |
 97 |       def test_get_category_by_id_invalid_uuid(self, category_mgr: CategoryManager) -> None:
 98 | /         """
 99 | |         Test objective: Attempt to retrieve a category with an invalid (non-UUID) ID string.
100 | |         """
    | |___________^ D200
101 |           with pytest.raises(CategoryNotFound):
102 |               category_mgr.get_category_by_id("not-a-uuid")
    |
    = help: Reformat to one line

tests\models\test_category_manager.py:98:9: D212 [*] Multi-line docstring summary should start at the first line
    |
 97 |       def test_get_category_by_id_invalid_uuid(self, category_mgr: CategoryManager) -> None:
 98 | /         """
 99 | |         Test objective: Attempt to retrieve a category with an invalid (non-UUID) ID string.
100 | |         """
    | |___________^ D212
101 |           with pytest.raises(CategoryNotFound):
102 |               category_mgr.get_category_by_id("not-a-uuid")
    |
    = help: Remove whitespace after opening quotes

tests\models\test_category_manager.py:105:9: D200 One-line docstring should fit on one line
    |
104 |       def test_get_category_by_name(self, category_mgr: CategoryManager) -> None:
105 | /         """
106 | |         Test objective: Retrieve a category by its name.
107 | |         """
    | |___________^ D200
108 |           cat_name = "Named Category"
109 |           category = Category(category_name=cat_name, description="")
    |
    = help: Reformat to one line

tests\models\test_category_manager.py:105:9: D212 [*] Multi-line docstring summary should start at the first line
    |
104 |       def test_get_category_by_name(self, category_mgr: CategoryManager) -> None:
105 | /         """
106 | |         Test objective: Retrieve a category by its name.
107 | |         """
    | |___________^ D212
108 |           cat_name = "Named Category"
109 |           category = Category(category_name=cat_name, description="")
    |
    = help: Remove whitespace after opening quotes

tests\models\test_category_manager.py:117:9: D200 One-line docstring should fit on one line
    |
116 |       def test_get_category_by_name_not_found(self, category_mgr: CategoryManager) -> None:
117 | /         """
118 | |         Test objective: Attempt to retrieve a non-existent category by name.
119 | |         """
    | |___________^ D200
120 |           with pytest.raises(CategoryNotFound):
121 |               category_mgr.get_category_by_name("NonExistent Name")
    |
    = help: Reformat to one line

tests\models\test_category_manager.py:117:9: D212 [*] Multi-line docstring summary should start at the first line
    |
116 |       def test_get_category_by_name_not_found(self, category_mgr: CategoryManager) -> None:
117 | /         """
118 | |         Test objective: Attempt to retrieve a non-existent category by name.
119 | |         """
    | |___________^ D212
120 |           with pytest.raises(CategoryNotFound):
121 |               category_mgr.get_category_by_name("NonExistent Name")
    |
    = help: Remove whitespace after opening quotes

tests\models\test_category_manager.py:124:9: D200 One-line docstring should fit on one line
    |
123 |       def test_get_category_by_name_case_sensitive(self, category_mgr: CategoryManager) -> None:
124 | /         """
125 | |         Test objective: Verify category name retrieval is case-sensitive.
126 | |         """
    | |___________^ D200
127 |           cat_name = "CaseSensitive"
128 |           category = Category(category_name=cat_name, description="")
    |
    = help: Reformat to one line

tests\models\test_category_manager.py:124:9: D212 [*] Multi-line docstring summary should start at the first line
    |
123 |       def test_get_category_by_name_case_sensitive(self, category_mgr: CategoryManager) -> None:
124 | /         """
125 | |         Test objective: Verify category name retrieval is case-sensitive.
126 | |         """
    | |___________^ D212
127 |           cat_name = "CaseSensitive"
128 |           category = Category(category_name=cat_name, description="")
    |
    = help: Remove whitespace after opening quotes

tests\models\test_category_manager.py:141:9: D200 One-line docstring should fit on one line
    |
140 |       def test_list_all_categories_empty(self, category_mgr: CategoryManager) -> None:
141 | /         """
142 | |         Test objective: List categories when none exist.
143 | |         """
    | |___________^ D200
144 |           cats = category_mgr.list_all_categories()
145 |           assert len(cats) == 0
    |
    = help: Reformat to one line

tests\models\test_category_manager.py:141:9: D212 [*] Multi-line docstring summary should start at the first line
    |
140 |       def test_list_all_categories_empty(self, category_mgr: CategoryManager) -> None:
141 | /         """
142 | |         Test objective: List categories when none exist.
143 | |         """
    | |___________^ D212
144 |           cats = category_mgr.list_all_categories()
145 |           assert len(cats) == 0
    |
    = help: Remove whitespace after opening quotes

tests\models\test_category_manager.py:148:9: D200 One-line docstring should fit on one line
    |
147 |       def test_list_all_categories_populated(self, category_mgr: CategoryManager) -> None:
148 | /         """
149 | |         Test objective: List categories when multiple exist, ensuring order.
150 | |         """
    | |___________^ D200
151 |           names = ["Charlie", "Alpha", "Beta"]
152 |           for n in names:
    |
    = help: Reformat to one line

tests\models\test_category_manager.py:148:9: D212 [*] Multi-line docstring summary should start at the first line
    |
147 |       def test_list_all_categories_populated(self, category_mgr: CategoryManager) -> None:
148 | /         """
149 | |         Test objective: List categories when multiple exist, ensuring order.
150 | |         """
    | |___________^ D212
151 |           names = ["Charlie", "Alpha", "Beta"]
152 |           for n in names:
    |
    = help: Remove whitespace after opening quotes

tests\models\test_category_manager.py:160:9: D200 One-line docstring should fit on one line
    |
159 |       def test_update_category_valid_name(self, category_mgr: CategoryManager) -> None:
160 | /         """
161 | |         Test objective: Update a category's name successfully using save_category.
162 | |         """
    | |___________^ D200
163 |           category = Category(category_name="Original Name", description="")
164 |           category_mgr.save_category(category)
    |
    = help: Reformat to one line

tests\models\test_category_manager.py:160:9: D212 [*] Multi-line docstring summary should start at the first line
    |
159 |       def test_update_category_valid_name(self, category_mgr: CategoryManager) -> None:
160 | /         """
161 | |         Test objective: Update a category's name successfully using save_category.
162 | |         """
    | |___________^ D212
163 |           category = Category(category_name="Original Name", description="")
164 |           category_mgr.save_category(category)
    |
    = help: Remove whitespace after opening quotes

tests\models\test_category_manager.py:181:9: D205 1 blank line required between summary line and description
    |
179 |           self, category_mgr: CategoryManager, new_name: str, err_msg_part: str
180 |       ) -> None:
181 | /         """
182 | |         Test objective: Attempt to update a category with an invalid new name format using
183 | |         save_category.
184 | |         """
    | |___________^ D205
185 |           category = Category(category_name="ValidOriginal", description="")
186 |           category_mgr.save_category(category)
    |
    = help: Insert single blank line

tests\models\test_category_manager.py:181:9: D212 [*] Multi-line docstring summary should start at the first line
    |
179 |           self, category_mgr: CategoryManager, new_name: str, err_msg_part: str
180 |       ) -> None:
181 | /         """
182 | |         Test objective: Attempt to update a category with an invalid new name format using
183 | |         save_category.
184 | |         """
    | |___________^ D212
185 |           category = Category(category_name="ValidOriginal", description="")
186 |           category_mgr.save_category(category)
    |
    = help: Remove whitespace after opening quotes

tests\models\test_category_manager.py:193:9: D205 1 blank line required between summary line and description
    |
192 |       def test_update_category_to_duplicate_name(self, category_mgr: CategoryManager) -> None:
193 | /         """
194 | |         Test objective: Attempt to update a category name to an existing different category's name
195 | |         using save_category.
196 | |         """
    | |___________^ D205
197 |           category1 = Category(category_name="ExistingName", description="")
198 |           category2 = Category(category_name="ToBeUpdated", description="")
    |
    = help: Insert single blank line

tests\models\test_category_manager.py:193:9: D212 [*] Multi-line docstring summary should start at the first line
    |
192 |       def test_update_category_to_duplicate_name(self, category_mgr: CategoryManager) -> None:
193 | /         """
194 | |         Test objective: Attempt to update a category name to an existing different category's name
195 | |         using save_category.
196 | |         """
    | |___________^ D212
197 |           category1 = Category(category_name="ExistingName", description="")
198 |           category2 = Category(category_name="ToBeUpdated", description="")
    |
    = help: Remove whitespace after opening quotes

tests\models\test_category_manager.py:207:9: D205 1 blank line required between summary line and description
    |
206 |       def test_update_category_to_case_variant_duplicate(self, category_mgr: CategoryManager) -> None:
207 | /         """
208 | |         Test objective: Attempt to update a category name to a case-variant of an existing name
209 | |         using save_category.
210 | |         """
    | |___________^ D205
211 |           category1 = Category(category_name="CaseName", description="")
212 |           category2 = Category(category_name="OtherName", description="")
    |
    = help: Insert single blank line

tests\models\test_category_manager.py:207:9: D212 [*] Multi-line docstring summary should start at the first line
    |
206 |       def test_update_category_to_case_variant_duplicate(self, category_mgr: CategoryManager) -> None:
207 | /         """
208 | |         Test objective: Attempt to update a category name to a case-variant of an existing name
209 | |         using save_category.
210 | |         """
    | |___________^ D212
211 |           category1 = Category(category_name="CaseName", description="")
212 |           category2 = Category(category_name="OtherName", description="")
    |
    = help: Remove whitespace after opening quotes

tests\models\test_category_manager.py:224:9: D205 1 blank line required between summary line and description
    |
223 |       def test_update_category_to_same_name(self, category_mgr: CategoryManager) -> None:
224 | /         """
225 | |         Test objective: Update a category to its current name (should be a no-op) using
226 | |         save_category.
227 | |         """
    | |___________^ D205
228 |           cat_name = "SameName"
229 |           category = Category(category_name=cat_name, description="")
    |
    = help: Insert single blank line

tests\models\test_category_manager.py:224:9: D212 [*] Multi-line docstring summary should start at the first line
    |
223 |       def test_update_category_to_same_name(self, category_mgr: CategoryManager) -> None:
224 | /         """
225 | |         Test objective: Update a category to its current name (should be a no-op) using
226 | |         save_category.
227 | |         """
    | |___________^ D212
228 |           cat_name = "SameName"
229 |           category = Category(category_name=cat_name, description="")
    |
    = help: Remove whitespace after opening quotes

tests\models\test_category_manager.py:237:9: D200 One-line docstring should fit on one line
    |
236 |       def test_delete_category_by_id(self, category_mgr: CategoryManager) -> None:
237 | /         """
238 | |         Test objective: Delete an existing category.
239 | |         """
    | |___________^ D200
240 |           category = Category(category_name="ToDelete", description="")
241 |           category_mgr.save_category(category)
    |
    = help: Reformat to one line

tests\models\test_category_manager.py:237:9: D212 [*] Multi-line docstring summary should start at the first line
    |
236 |       def test_delete_category_by_id(self, category_mgr: CategoryManager) -> None:
237 | /         """
238 | |         Test objective: Delete an existing category.
239 | |         """
    | |___________^ D212
240 |           category = Category(category_name="ToDelete", description="")
241 |           category_mgr.save_category(category)
    |
    = help: Remove whitespace after opening quotes

tests\models\test_category_manager.py:247:9: D200 One-line docstring should fit on one line
    |
246 |       def test_delete_category_by_id_invalid_uuid(self, category_mgr: CategoryManager) -> None:
247 | /         """
248 | |         Test objective: Attempt to delete a category with an invalid (non-UUID) ID string.
249 | |         """
    | |___________^ D200
250 |           assert category_mgr.delete_category_by_id("not-a-uuid") is False
    |
    = help: Reformat to one line

tests\models\test_category_manager.py:247:9: D212 [*] Multi-line docstring summary should start at the first line
    |
246 |       def test_delete_category_by_id_invalid_uuid(self, category_mgr: CategoryManager) -> None:
247 | /         """
248 | |         Test objective: Attempt to delete a category with an invalid (non-UUID) ID string.
249 | |         """
    | |___________^ D212
250 |           assert category_mgr.delete_category_by_id("not-a-uuid") is False
    |
    = help: Remove whitespace after opening quotes

tests\models\test_category_manager.py:253:9: D200 One-line docstring should fit on one line
    |
252 |       def test_delete_nonexistent_category(self, category_mgr: CategoryManager) -> None:
253 | /         """
254 | |         Test objective: Attempt to delete a non-existent category.
255 | |         """
    | |___________^ D200
256 |           assert category_mgr.delete_category(str(uuid.uuid4())) is False
    |
    = help: Reformat to one line

tests\models\test_category_manager.py:253:9: D212 [*] Multi-line docstring summary should start at the first line
    |
252 |       def test_delete_nonexistent_category(self, category_mgr: CategoryManager) -> None:
253 | /         """
254 | |         Test objective: Attempt to delete a non-existent category.
255 | |         """
    | |___________^ D212
256 |           assert category_mgr.delete_category(str(uuid.uuid4())) is False
    |
    = help: Remove whitespace after opening quotes

tests\models\test_category_manager.py:259:9: D200 One-line docstring should fit on one line
    |
258 |       def test_delete_all_categories(self, category_mgr: CategoryManager) -> None:
259 | /         """
260 | |         Test objective: Delete all categories and verify the action.
261 | |         """
    | |___________^ D200
262 |           category_mgr.save_category(Category(category_name="A", description=""))
263 |           category_mgr.save_category(Category(category_name="B", description=""))
    |
    = help: Reformat to one line

tests\models\test_category_manager.py:259:9: D212 [*] Multi-line docstring summary should start at the first line
    |
258 |       def test_delete_all_categories(self, category_mgr: CategoryManager) -> None:
259 | /         """
260 | |         Test objective: Delete all categories and verify the action.
261 | |         """
    | |___________^ D212
262 |           category_mgr.save_category(Category(category_name="A", description=""))
263 |           category_mgr.save_category(Category(category_name="B", description=""))
    |
    = help: Remove whitespace after opening quotes

tests\models\test_category_manager.py:271:9: D200 One-line docstring should fit on one line
    |
270 |       def test_category_validation_blank_and_duplicate(self, category_mgr: CategoryManager) -> None:
271 | /         """
272 | |         Test objective: Destructively test blank and duplicate category names.
273 | |         """
    | |___________^ D200
274 |           # Blank
275 |           with pytest.raises((ValueError, CategoryValidationError)):
    |
    = help: Reformat to one line

tests\models\test_category_manager.py:271:9: D212 [*] Multi-line docstring summary should start at the first line
    |
270 |       def test_category_validation_blank_and_duplicate(self, category_mgr: CategoryManager) -> None:
271 | /         """
272 | |         Test objective: Destructively test blank and duplicate category names.
273 | |         """
    | |___________^ D212
274 |           # Blank
275 |           with pytest.raises((ValueError, CategoryValidationError)):
    |
    = help: Remove whitespace after opening quotes

tests\models\test_category_manager.py:284:9: D205 1 blank line required between summary line and description
    |
283 |       def test_save_category_non_string_name(self, category_mgr: CategoryManager) -> None:
284 | /         """
285 | |         Test objective: Attempt to save a category with a non-string name (should
286 | |         raise ValueError or CategoryValidationError).
287 | |         """
    | |___________^ D205
288 |           with pytest.raises((ValueError, CategoryValidationError, ValidationError)):
289 |               Category(category_name=12345, description="")
    |
    = help: Insert single blank line

tests\models\test_category_manager.py:284:9: D212 [*] Multi-line docstring summary should start at the first line
    |
283 |       def test_save_category_non_string_name(self, category_mgr: CategoryManager) -> None:
284 | /         """
285 | |         Test objective: Attempt to save a category with a non-string name (should
286 | |         raise ValueError or CategoryValidationError).
287 | |         """
    | |___________^ D212
288 |           with pytest.raises((ValueError, CategoryValidationError, ValidationError)):
289 |               Category(category_name=12345, description="")
    |
    = help: Remove whitespace after opening quotes

tests\models\test_dynamic_content_manager.py:1:1: D205 1 blank line required between summary line and description
  |
1 | / """
2 | | Unit tests for models.dynamic_content_manager.DynamicContentManager.
3 | | Covers initialization, validation, content generation modes, and error handling.
4 | | """
  | |___^ D205
5 |
6 |   import pytest
  |
  = help: Insert single blank line

tests\models\test_dynamic_content_manager.py:1:1: D212 [*] Multi-line docstring summary should start at the first line
  |
1 | / """
2 | | Unit tests for models.dynamic_content_manager.DynamicContentManager.
3 | | Covers initialization, validation, content generation modes, and error handling.
4 | | """
  | |___^ D212
5 |
6 |   import pytest
  |
  = help: Remove whitespace after opening quotes

tests\models\test_dynamic_content_manager.py:6:1: I001 [*] Import block is un-sorted or un-formatted
   |
 4 |   """
 5 |
 6 | / import pytest
 7 | | import random
 8 | | from unittest.mock import patch
 9 | | from typing import List, cast
10 | |
11 | | from models.dynamic_content_manager import DynamicContentManager, ContentMode
12 | | from models.llm_ngram_service import LLMNgramService
   | |____________________________________________________^ I001
   |
   = help: Organize imports

tests\models\test_keyboard.py:1:1: D100 Missing docstring in public module
tests\models\test_keyboard.py:9:5: D103 Missing docstring in public function
   |
 9 | def test_keyboard_valid() -> None:
   |     ^^^^^^^^^^^^^^^^^^^ D103
10 |     k = Keyboard(
11 |         keyboard_id=str(uuid4()),
   |

tests\models\test_keyboard.py:20:5: D103 Missing docstring in public function
   |
20 | def test_keyboard_empty_name() -> None:
   |     ^^^^^^^^^^^^^^^^^^^^^^^^ D103
21 |     with pytest.raises(ValidationError):
22 |         Keyboard(keyboard_id=str(uuid4()), user_id=str(uuid4()), keyboard_name="  ")
   |

tests\models\test_keyboard.py:25:5: D103 Missing docstring in public function
   |
25 | def test_keyboard_name_strip() -> None:
   |     ^^^^^^^^^^^^^^^^^^^^^^^^ D103
26 |     k = Keyboard(keyboard_id=str(uuid4()), user_id=str(uuid4()), keyboard_name="  Test  ")
27 |     assert k.keyboard_name == "Test"
   |

tests\models\test_keyboard.py:30:5: D103 Missing docstring in public function
   |
30 | def test_keyboard_default_target_ms() -> None:
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D103
31 |     # Test that default value of 600 is used when not specified
32 |     k = Keyboard(keyboard_id=str(uuid4()), user_id=str(uuid4()), keyboard_name="Test")
   |

tests\models\test_keyboard.py:36:5: D103 Missing docstring in public function
   |
36 | def test_keyboard_custom_target_ms() -> None:
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D103
37 |     # Test that custom value is stored correctly
38 |     k = Keyboard(
   |

tests\models\test_keyboard.py:47:5: D103 Missing docstring in public function
   |
47 | def test_keyboard_target_ms_too_low() -> None:
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D103
48 |     # Test that validator rejects values below 50
49 |     with pytest.raises(ValidationError) as excinfo:
   |

tests\models\test_keyboard.py:59:5: D103 Missing docstring in public function
   |
59 | def test_keyboard_target_ms_too_high() -> None:
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D103
60 |     # Test that validator rejects values above 5000
61 |     with pytest.raises(ValidationError) as excinfo:
   |

tests\models\test_keyboard.py:71:5: D103 Missing docstring in public function
   |
71 | def test_keyboard_target_ms_none() -> None:
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D103
72 |     # Test that validator rejects None values
73 |     with pytest.raises(ValidationError) as excinfo:
   |

tests\models\test_keyboard.py:73:44: F841 Local variable `excinfo` is assigned to but never used
   |
71 | def test_keyboard_target_ms_none() -> None:
72 |     # Test that validator rejects None values
73 |     with pytest.raises(ValidationError) as excinfo:
   |                                            ^^^^^^^ F841
74 |         # We need to use a dict and model_validate to bypass Pydantic's type checking
75 |         # and test our explicit None validator
   |
   = help: Remove assignment to unused variable `excinfo`

tests\models\test_keyboard_manager.py:1:1: D100 Missing docstring in public module
tests\models\test_keyboard_manager.py:11:5: D103 Missing docstring in public function
   |
10 | @pytest.fixture
11 | def keyboard_manager(db_with_tables: DatabaseManager) -> KeyboardManager:
   |     ^^^^^^^^^^^^^^^^ D103
12 |     return KeyboardManager(db_with_tables)
   |

tests\models\test_keyboard_manager.py:15:5: D103 Missing docstring in public function
   |
15 | def test_create_keyboard(keyboard_manager: KeyboardManager, test_user: User) -> None:
   |     ^^^^^^^^^^^^^^^^^^^^ D103
16 |     k = Keyboard(user_id=str(test_user.user_id), keyboard_name="Alpha")
17 |     assert keyboard_manager.save_keyboard(k)
   |

tests\models\test_keyboard_manager.py:24:5: D103 Missing docstring in public function
   |
24 | def test_get_keyboard(keyboard_manager: KeyboardManager, test_user: User) -> None:
   |     ^^^^^^^^^^^^^^^^^ D103
25 |     k = Keyboard(user_id=str(test_user.user_id), keyboard_name="Beta")
26 |     keyboard_manager.save_keyboard(k)
   |

tests\models\test_keyboard_manager.py:32:5: D103 Missing docstring in public function
   |
32 | def test_update_keyboard_name(keyboard_manager: KeyboardManager, test_user: User) -> None:
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^ D103
33 |     k = Keyboard(user_id=str(test_user.user_id), keyboard_name="Gamma")
34 |     keyboard_manager.save_keyboard(k)
   |

tests\models\test_keyboard_manager.py:74:5: D103 Missing docstring in public function
   |
74 | def test_delete_keyboard(keyboard_manager: KeyboardManager, test_user: User) -> None:
   |     ^^^^^^^^^^^^^^^^^^^^ D103
75 |     k = Keyboard(user_id=str(test_user.user_id), keyboard_name="Zeta")
76 |     keyboard_manager.save_keyboard(k)
   |

tests\models\test_keystroke.py:1:1: D205 1 blank line required between summary line and description
  |
1 | / """
2 | | Comprehensive tests for the Keystroke Pydantic model.
3 | | Tests cover creation, serialization, validation, and edge cases.
4 | | Based on Keystroke.md specification requirements.
5 | | """
  | |___^ D205
6 |
7 |   import datetime
  |
  = help: Insert single blank line

tests\models\test_keystroke.py:1:1: D212 [*] Multi-line docstring summary should start at the first line
  |
1 | / """
2 | | Comprehensive tests for the Keystroke Pydantic model.
3 | | Tests cover creation, serialization, validation, and edge cases.
4 | | Based on Keystroke.md specification requirements.
5 | | """
  | |___^ D212
6 |
7 |   import datetime
  |
  = help: Remove whitespace after opening quotes

tests\models\test_keystroke_manager.py:1:1: D212 [*] Multi-line docstring summary should start at the first line
  |
1 | / """
2 | | Comprehensive tests for the KeystrokeManager class.
3 | |
4 | | This module provides extensive test coverage for the KeystrokeManager class,
5 | | including all methods, edge cases, error conditions, and integration scenarios.
6 | | Tests aim for >95% coverage and validate the manager's behavior under various conditions.
7 | | """
  | |___^ D212
8 |
9 |   import os
  |
  = help: Remove whitespace after opening quotes

tests\models\test_keystroke_manager.py:546:9: D102 Missing docstring in public method
    |
545 |     @pytest.fixture
546 |     def integration_manager(self) -> KeystrokeManager:
    |         ^^^^^^^^^^^^^^^^^^^ D102
547 |         db = DatabaseManager(":memory:")
548 |         db.init_tables()
    |

tests\models\test_keystroke_manager.py:602:121: E501 Line too long (246 > 120)
    |
600 | ΓÇª
601 | ΓÇª
602 | ΓÇªpet_index_end, content, start_time, end_time, actual_chars, errors, ms_per_keystroke) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)",
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
603 | ΓÇª
604 | ΓÇª
    |

tests\models\test_keystroke_manager.py:684:121: E501 Line too long (250 > 120)
    |
682 | ΓÇª
683 | ΓÇª
684 | ΓÇªsnippet_index_end, content, start_time, end_time, actual_chars, errors, ms_per_keystroke) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)",
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
685 | ΓÇª
686 | ΓÇª
    |

tests\models\test_keystroke_manager.py:1042:5: D103 Missing docstring in public function
     |
1041 | @pytest.fixture(scope="module")
1042 | def test_user(request: pytest.FixtureRequest) -> str:
     |     ^^^^^^^^^ D103
1043 |     db: DatabaseManager = getattr(request, "db", None)
1044 |     if db is None:
     |

tests\models\test_keystroke_manager.py:1056:5: D103 Missing docstring in public function
     |
1055 | @pytest.fixture(scope="module")
1056 | def test_keyboard(request: pytest.FixtureRequest, test_user: str) -> str:
     |     ^^^^^^^^^^^^^ D103
1057 |     db: DatabaseManager = getattr(request, "db", None)
1058 |     if db is None:
     |

tests\models\test_keystroke_manager.py:1070:5: D103 Missing docstring in public function
     |
1069 | @pytest.fixture(scope="module")
1070 | def test_session(request: pytest.FixtureRequest, test_user: str, test_keyboard: str) -> str:
     |     ^^^^^^^^^^^^ D103
1071 |     db: DatabaseManager = getattr(request, "db", None)
1072 |     if db is None:
     |

tests\models\test_keystroke_manager.py:1109:5: D103 Missing docstring in public function
     |
1108 | @pytest.fixture
1109 | def manager(test_db_path: str) -> KeystrokeManager:
     |     ^^^^^^^ D103
1110 |     db = DatabaseManager(test_db_path)
1111 |     return KeystrokeManager(db_manager=db)
     |

tests\models\test_llm_ngram_service.py:1:1: D100 Missing docstring in public module
tests\models\test_llm_ngram_service.py:1:1: I001 [*] Import block is un-sorted or un-formatted
  |
1 | / from unittest.mock import patch
2 | | import pytest
3 | |
4 | | from models.llm_ngram_service import LLMMissingAPIKeyError, LLMNgramService
  | |___________________________________________________________________________^ I001
  |
  = help: Organize imports

tests\models\test_llm_ngram_service.py:7:5: ANN201 Missing return type annotation for public function `test_missing_api_key`
  |
7 | def test_missing_api_key():
  |     ^^^^^^^^^^^^^^^^^^^^ ANN201
8 |     with pytest.raises(LLMMissingAPIKeyError):
9 |         LLMNgramService(api_key=None)  # type: ignore
  |
  = help: Add return type annotation: `None`

tests\models\test_llm_ngram_service.py:7:5: D103 Missing docstring in public function
  |
7 | def test_missing_api_key():
  |     ^^^^^^^^^^^^^^^^^^^^ D103
8 |     with pytest.raises(LLMMissingAPIKeyError):
9 |         LLMNgramService(api_key=None)  # type: ignore
  |

tests\models\test_llm_ngram_service.py:12:5: ANN201 Missing return type annotation for public function `test_invalid_ngrams`
   |
12 | def test_invalid_ngrams():
   |     ^^^^^^^^^^^^^^^^^^^ ANN201
13 |     svc = LLMNgramService(api_key="sk-test")
14 |     with pytest.raises(ValueError):
   |
   = help: Add return type annotation: `None`

tests\models\test_llm_ngram_service.py:12:5: D103 Missing docstring in public function
   |
12 | def test_invalid_ngrams():
   |     ^^^^^^^^^^^^^^^^^^^ D103
13 |     svc = LLMNgramService(api_key="sk-test")
14 |     with pytest.raises(ValueError):
   |

tests\models\test_llm_ngram_service.py:20:5: D103 Missing docstring in public function
   |
20 | def test_llm_success() -> None:
   |     ^^^^^^^^^^^^^^^^ D103
21 |     svc = LLMNgramService(api_key="sk-test")
22 |     with patch.object(
   |

tests\models\test_llm_ngram_service.py:29:5: D103 Missing docstring in public function
   |
29 | def test_llm_trims_to_max_length() -> None:
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D103
30 |     svc = LLMNgramService(api_key="sk-test")
31 |     long_text = "one two three four five six seven eight nine ten"
   |

tests\models\test_next_session_position.py:1:1: D200 One-line docstring should fit on one line
  |
1 | / """
2 | | Tests for determining the next session position based on previous sessions.
3 | | """
  | |___^ D200
4 |
5 |   import datetime
  |
  = help: Reformat to one line

tests\models\test_next_session_position.py:1:1: D212 [*] Multi-line docstring summary should start at the first line
  |
1 | / """
2 | | Tests for determining the next session position based on previous sessions.
3 | | """
  | |___^ D212
4 |
5 |   import datetime
  |
  = help: Remove whitespace after opening quotes

tests\models\test_next_session_position.py:18:1: E402 Module level import not at top of file
   |
16 |     sys.path.insert(0, project_root)
17 |
18 | from db.database_manager import DatabaseManager
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
19 | from models.session import Session
20 | from models.session_manager import SessionManager
   |

tests\models\test_next_session_position.py:19:1: E402 Module level import not at top of file
   |
18 | from db.database_manager import DatabaseManager
19 | from models.session import Session
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
20 | from models.session_manager import SessionManager
   |

tests\models\test_next_session_position.py:20:1: E402 Module level import not at top of file
   |
18 | from db.database_manager import DatabaseManager
19 | from models.session import Session
20 | from models.session_manager import SessionManager
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
   |

tests\models\test_next_session_position.py:24:5: ANN201 Missing return type annotation for public function `temp_db`
   |
23 | @pytest.fixture
24 | def temp_db():
   |     ^^^^^^^ ANN201
25 |     """Create a temporary in-memory database for testing."""
26 |     db_manager = DatabaseManager(":memory:")
   |
   = help: Add return type annotation

tests\models\test_next_session_position.py:151:5: F841 Local variable `snippet_length` is assigned to but never used
    |
149 |     session_manager = temp_db["session_manager"]
150 |     snippet_id = temp_db["snippet_id"]
151 |     snippet_length = len(temp_db["snippet_content"])
    |     ^^^^^^^^^^^^^^ F841
152 |
153 |     # Create a session with end position beyond actual snippet length (simulating content change)
    |
    = help: Remove assignment to unused variable `snippet_length`

tests\models\test_ngram.py:1:1: D100 Missing docstring in public module
tests\models\test_ngram.py:1:1: I001 [*] Import block is un-sorted or un-formatted
   |
 1 | / import uuid
 2 | | from datetime import datetime, timedelta, timezone
 3 | |
 4 | | import pytest
 5 | |
 6 | | from models.ngram import (
 7 | |     ErrorNGram,
 8 | |     Keystroke,
 9 | |     MIN_NGRAM_SIZE,
10 | |     MAX_NGRAM_SIZE,
11 | |     SpeedMode,
12 | |     SpeedNGram,
13 | |     has_sequence_separators,
14 | |     is_valid_ngram_text,
15 | |     nfc,
16 | | )
   | |_^ I001
   |
   = help: Organize imports

tests\models\test_ngram.py:9:5: F401 [*] `models.ngram.MIN_NGRAM_SIZE` imported but unused
   |
 7 |     ErrorNGram,
 8 |     Keystroke,
 9 |     MIN_NGRAM_SIZE,
   |     ^^^^^^^^^^^^^^ F401
10 |     MAX_NGRAM_SIZE,
11 |     SpeedMode,
   |
   = help: Remove unused import

tests\models\test_ngram.py:15:5: F401 [*] `models.ngram.nfc` imported but unused
   |
13 |     has_sequence_separators,
14 |     is_valid_ngram_text,
15 |     nfc,
   |     ^^^ F401
16 | )
   |
   = help: Remove unused import

tests\models\test_ngram.py:19:5: D103 Missing docstring in public function
   |
19 | def ts(ms: int) -> datetime:
   |     ^^ D103
20 |     return datetime(2025, 1, 1, 8, 0, 0, tzinfo=timezone.utc) + timedelta(milliseconds=ms)
   |

tests\models\test_ngram.py:23:7: D101 Missing docstring in public class
   |
23 | class TestKeystroke:
   |       ^^^^^^^^^^^^^ D101
24 |     def test_keystroke_basic(self):
25 |         k = Keystroke(keystroke_time=ts(0), text_index=0, expected_char="a", keystroke_char="a", is_error=False)
   |

tests\models\test_ngram.py:24:9: ANN201 Missing return type annotation for public function `test_keystroke_basic`
   |
23 | class TestKeystroke:
24 |     def test_keystroke_basic(self):
   |         ^^^^^^^^^^^^^^^^^^^^ ANN201
25 |         k = Keystroke(keystroke_time=ts(0), text_index=0, expected_char="a", keystroke_char="a", is_error=False)
26 |         assert k.expected_char == "a"
   |
   = help: Add return type annotation: `None`

tests\models\test_ngram.py:24:9: D102 Missing docstring in public method
   |
23 | class TestKeystroke:
24 |     def test_keystroke_basic(self):
   |         ^^^^^^^^^^^^^^^^^^^^ D102
25 |         k = Keystroke(keystroke_time=ts(0), text_index=0, expected_char="a", keystroke_char="a", is_error=False)
26 |         assert k.expected_char == "a"
   |

tests\models\test_ngram.py:29:9: ANN201 Missing return type annotation for public function `test_keystroke_nfc_single_char`
   |
27 |         assert k.keystroke_char == "a"
28 |
29 |     def test_keystroke_nfc_single_char(self):
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
30 |         # composed e + ╠ü
31 |         k = Keystroke(keystroke_time=ts(0), text_index=0, expected_char="e\u0301", keystroke_char="├⌐", is_error=False)
   |
   = help: Add return type annotation: `None`

tests\models\test_ngram.py:29:9: D102 Missing docstring in public method
   |
27 |         assert k.keystroke_char == "a"
28 |
29 |     def test_keystroke_nfc_single_char(self):
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
30 |         # composed e + ╠ü
31 |         k = Keystroke(keystroke_time=ts(0), text_index=0, expected_char="e\u0301", keystroke_char="├⌐", is_error=False)
   |

tests\models\test_ngram.py:36:7: D101 Missing docstring in public class
   |
36 | class TestNGramTextRules:
   |       ^^^^^^^^^^^^^^^^^^ D101
37 |     def test_has_sequence_separators(self):
38 |         assert has_sequence_separators("a b") is True
   |

tests\models\test_ngram.py:37:9: ANN201 Missing return type annotation for public function `test_has_sequence_separators`
   |
36 | class TestNGramTextRules:
37 |     def test_has_sequence_separators(self):
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
38 |         assert has_sequence_separators("a b") is True
39 |         assert has_sequence_separators("ab") is False
   |
   = help: Add return type annotation: `None`

tests\models\test_ngram.py:37:9: D102 Missing docstring in public method
   |
36 | class TestNGramTextRules:
37 |     def test_has_sequence_separators(self):
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
38 |         assert has_sequence_separators("a b") is True
39 |         assert has_sequence_separators("ab") is False
   |

tests\models\test_ngram.py:41:9: ANN201 Missing return type annotation for public function `test_is_valid_ngram_text`
   |
39 |         assert has_sequence_separators("ab") is False
40 |
41 |     def test_is_valid_ngram_text(self):
   |         ^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
42 |         assert is_valid_ngram_text("ab") is True
43 |         assert is_valid_ngram_text("a") is False  # too short
   |
   = help: Add return type annotation: `None`

tests\models\test_ngram.py:41:9: D102 Missing docstring in public method
   |
39 |         assert has_sequence_separators("ab") is False
40 |
41 |     def test_is_valid_ngram_text(self):
   |         ^^^^^^^^^^^^^^^^^^^^^^^^ D102
42 |         assert is_valid_ngram_text("ab") is True
43 |         assert is_valid_ngram_text("a") is False  # too short
   |

tests\models\test_ngram.py:47:7: D101 Missing docstring in public class
   |
47 | class TestSpeedNGram:
   |       ^^^^^^^^^^^^^^ D101
48 |     def test_speed_ngram_computes_ms_per_keystroke(self):
49 |         ng = SpeedNGram(
   |

tests\models\test_ngram.py:48:9: ANN201 Missing return type annotation for public function `test_speed_ngram_computes_ms_per_keystroke`
   |
47 | class TestSpeedNGram:
48 |     def test_speed_ngram_computes_ms_per_keystroke(self):
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
49 |         ng = SpeedNGram(
50 |             id=uuid.uuid4(),
   |
   = help: Add return type annotation: `None`

tests\models\test_ngram.py:48:9: D102 Missing docstring in public method
   |
47 | class TestSpeedNGram:
48 |     def test_speed_ngram_computes_ms_per_keystroke(self):
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
49 |         ng = SpeedNGram(
50 |             id=uuid.uuid4(),
   |

tests\models\test_ngram.py:60:9: ANN201 Missing return type annotation for public function `test_speed_ngram_rejects_separators`
   |
58 |         assert ng.ms_per_keystroke == pytest.approx(50.0)
59 |
60 |     def test_speed_ngram_rejects_separators(self):
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
61 |         with pytest.raises(Exception):
62 |             SpeedNGram(
   |
   = help: Add return type annotation: `None`

tests\models\test_ngram.py:60:9: D102 Missing docstring in public method
   |
58 |         assert ng.ms_per_keystroke == pytest.approx(50.0)
59 |
60 |     def test_speed_ngram_rejects_separators(self):
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
61 |         with pytest.raises(Exception):
62 |             SpeedNGram(
   |

tests\models\test_ngram.py:61:14: B017 Do not assert blind exception: `Exception`
   |
60 |     def test_speed_ngram_rejects_separators(self):
61 |         with pytest.raises(Exception):
   |              ^^^^^^^^^^^^^^^^^^^^^^^^ B017
62 |             SpeedNGram(
63 |                 id=uuid.uuid4(),
   |

tests\models\test_ngram.py:71:9: ANN201 Missing return type annotation for public function `test_speed_ngram_invalid_size`
   |
69 |             )
70 |
71 |     def test_speed_ngram_invalid_size(self):
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
72 |         with pytest.raises(Exception):
73 |             SpeedNGram(
   |
   = help: Add return type annotation: `None`

tests\models\test_ngram.py:71:9: D102 Missing docstring in public method
   |
69 |             )
70 |
71 |     def test_speed_ngram_invalid_size(self):
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
72 |         with pytest.raises(Exception):
73 |             SpeedNGram(
   |

tests\models\test_ngram.py:72:14: B017 Do not assert blind exception: `Exception`
   |
71 |     def test_speed_ngram_invalid_size(self):
72 |         with pytest.raises(Exception):
   |              ^^^^^^^^^^^^^^^^^^^^^^^^ B017
73 |             SpeedNGram(
74 |                 id=uuid.uuid4(),
   |

tests\models\test_ngram.py:82:9: ANN201 Missing return type annotation for public function `test_speed_ngram_at_max_size`
   |
80 |             )
81 |
82 |     def test_speed_ngram_at_max_size(self):
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
83 |         text = "a" * MAX_NGRAM_SIZE
84 |         ng = SpeedNGram(
   |
   = help: Add return type annotation: `None`

tests\models\test_ngram.py:82:9: D102 Missing docstring in public method
   |
80 |             )
81 |
82 |     def test_speed_ngram_at_max_size(self):
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
83 |         text = "a" * MAX_NGRAM_SIZE
84 |         ng = SpeedNGram(
   |

tests\models\test_ngram.py:96:9: ANN201 Missing return type annotation for public function `test_speed_ngram_rejects_over_max`
   |
94 |         assert ng.ms_per_keystroke == pytest.approx(10.0)
95 |
96 |     def test_speed_ngram_rejects_over_max(self):
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
97 |         text = "a" * (MAX_NGRAM_SIZE + 1)
98 |         with pytest.raises(Exception):
   |
   = help: Add return type annotation: `None`

tests\models\test_ngram.py:96:9: D102 Missing docstring in public method
   |
94 |         assert ng.ms_per_keystroke == pytest.approx(10.0)
95 |
96 |     def test_speed_ngram_rejects_over_max(self):
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
97 |         text = "a" * (MAX_NGRAM_SIZE + 1)
98 |         with pytest.raises(Exception):
   |

tests\models\test_ngram.py:98:14: B017 Do not assert blind exception: `Exception`
    |
 96 |     def test_speed_ngram_rejects_over_max(self):
 97 |         text = "a" * (MAX_NGRAM_SIZE + 1)
 98 |         with pytest.raises(Exception):
    |              ^^^^^^^^^^^^^^^^^^^^^^^^ B017
 99 |             SpeedNGram(
100 |                 id=uuid.uuid4(),
    |

tests\models\test_ngram.py:109:7: D101 Missing docstring in public class
    |
109 | class TestErrorNGram:
    |       ^^^^^^^^^^^^^^ D101
110 |     def test_error_ngram_pattern_last_char_only(self):
111 |         # differs only on last char
    |

tests\models\test_ngram.py:110:9: ANN201 Missing return type annotation for public function `test_error_ngram_pattern_last_char_only`
    |
109 | class TestErrorNGram:
110 |     def test_error_ngram_pattern_last_char_only(self):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
111 |         # differs only on last char
112 |         ErrorNGram(
    |
    = help: Add return type annotation: `None`

tests\models\test_ngram.py:110:9: D102 Missing docstring in public method
    |
109 | class TestErrorNGram:
110 |     def test_error_ngram_pattern_last_char_only(self):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
111 |         # differs only on last char
112 |         ErrorNGram(
    |

tests\models\test_ngram.py:121:9: ANN201 Missing return type annotation for public function `test_error_ngram_pattern_invalid_first_char`
    |
119 |         )
120 |
121 |     def test_error_ngram_pattern_invalid_first_char(self):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
122 |         with pytest.raises(Exception):
123 |             ErrorNGram(
    |
    = help: Add return type annotation: `None`

tests\models\test_ngram.py:121:9: D102 Missing docstring in public method
    |
119 |         )
120 |
121 |     def test_error_ngram_pattern_invalid_first_char(self):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
122 |         with pytest.raises(Exception):
123 |             ErrorNGram(
    |

tests\models\test_ngram.py:122:14: B017 Do not assert blind exception: `Exception`
    |
121 |     def test_error_ngram_pattern_invalid_first_char(self):
122 |         with pytest.raises(Exception):
    |              ^^^^^^^^^^^^^^^^^^^^^^^^ B017
123 |             ErrorNGram(
124 |                 id=uuid.uuid4(),
    |

tests\models\test_ngram.py:132:9: ANN201 Missing return type annotation for public function `test_error_ngram_rejects_separators`
    |
130 |             )
131 |
132 |     def test_error_ngram_rejects_separators(self):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
133 |         with pytest.raises(Exception):
134 |             ErrorNGram(
    |
    = help: Add return type annotation: `None`

tests\models\test_ngram.py:132:9: D102 Missing docstring in public method
    |
130 |             )
131 |
132 |     def test_error_ngram_rejects_separators(self):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
133 |         with pytest.raises(Exception):
134 |             ErrorNGram(
    |

tests\models\test_ngram.py:133:14: B017 Do not assert blind exception: `Exception`
    |
132 |     def test_error_ngram_rejects_separators(self):
133 |         with pytest.raises(Exception):
    |              ^^^^^^^^^^^^^^^^^^^^^^^^ B017
134 |             ErrorNGram(
135 |                 id=uuid.uuid4(),
    |

tests\models\test_ngram.py:143:9: ANN201 Missing return type annotation for public function `test_error_ngram_at_max_size`
    |
141 |             )
142 |
143 |     def test_error_ngram_at_max_size(self):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
144 |         exp = "a" * (MAX_NGRAM_SIZE - 1) + "b"
145 |         act = "a" * (MAX_NGRAM_SIZE - 1) + "x"
    |
    = help: Add return type annotation: `None`

tests\models\test_ngram.py:143:9: D102 Missing docstring in public method
    |
141 |             )
142 |
143 |     def test_error_ngram_at_max_size(self):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
144 |         exp = "a" * (MAX_NGRAM_SIZE - 1) + "b"
145 |         act = "a" * (MAX_NGRAM_SIZE - 1) + "x"
    |

tests\models\test_ngram.py:156:9: ANN201 Missing return type annotation for public function `test_error_ngram_rejects_over_max`
    |
154 |         assert e.size == MAX_NGRAM_SIZE
155 |
156 |     def test_error_ngram_rejects_over_max(self):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
157 |         exp = "a" * MAX_NGRAM_SIZE + "b"
158 |         act = "a" * MAX_NGRAM_SIZE + "x"
    |
    = help: Add return type annotation: `None`

tests\models\test_ngram.py:156:9: D102 Missing docstring in public method
    |
154 |         assert e.size == MAX_NGRAM_SIZE
155 |
156 |     def test_error_ngram_rejects_over_max(self):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
157 |         exp = "a" * MAX_NGRAM_SIZE + "b"
158 |         act = "a" * MAX_NGRAM_SIZE + "x"
    |

tests\models\test_ngram.py:159:14: B017 Do not assert blind exception: `Exception`
    |
157 |         exp = "a" * MAX_NGRAM_SIZE + "b"
158 |         act = "a" * MAX_NGRAM_SIZE + "x"
159 |         with pytest.raises(Exception):
    |              ^^^^^^^^^^^^^^^^^^^^^^^^ B017
160 |             ErrorNGram(
161 |                 id=uuid.uuid4(),
    |

tests\models\test_ngram_analytics_service.py:1:1: D212 [*] Multi-line docstring summary should start at the first line
  |
1 | / """
2 | | Tests for NGramAnalyticsService class.
3 | |
4 | | This module contains comprehensive tests for the NGramAnalyticsService class,
5 | | including tests for decaying average calculations, performance summaries,
6 | | historical analysis, and analytics methods moved from NGramManager.
7 | | """
  | |___^ D212
8 |
9 |   import sys
  |
  = help: Remove whitespace after opening quotes

tests\models\test_ngram_analytics_service.py:19:1: I001 [*] Import block is un-sorted or un-formatted
   |
17 |   sys.path.insert(0, "d:\\SeanDevLocal\\AITypingTrainer")
18 |
19 | / from db.database_manager import DatabaseManager
20 | | from models.ngram_analytics_service import (
21 | |     DecayingAverageCalculator,
22 | |     NGramAnalyticsService,
23 | |     NGramHeatmapData,
24 | |     NGramHistoricalData,
25 | |     NGramPerformanceData,
26 | | )
27 | | from models.ngram_manager import NGramManager
28 | |
29 | | # Import fixtures and types from conftest
30 | | # Note: do not import unused test-only types from conftest; prior names
31 | | # (MockNGramSpeedData, MockSessionData, ngram_speed_test_data) no longer exist.
32 | | from tests.models.conftest import MockNGramSpeedData, MockSessionData
   | |_____________________________________________________________________^ I001
   |
   = help: Organize imports

tests\models\test_ngram_analytics_service.py:42:9: D212 [*] Multi-line docstring summary should start at the first line
   |
41 |       def test_calculate_decaying_average_basic(self) -> None:
42 | /         """
43 | |         Test objective: Verify basic decaying average calculation.
44 | |
45 | |         Tests that the calculator properly computes a decaying average
46 | |         where more recent values have higher weights.
47 | |         """
   | |___________^ D212
48 |           calc = DecayingAverageCalculator(decay_factor=0.9, max_samples=20)
   |
   = help: Remove whitespace after opening quotes

tests\models\test_ngram_analytics_service.py:69:9: D212 [*] Multi-line docstring summary should start at the first line
   |
68 |       def test_calculate_decaying_average_single_value(self) -> None:
69 | /         """
70 | |         Test objective: Verify decaying average with single value.
71 | |
72 | |         Tests that a single value returns itself as the average.
73 | |         """
   | |___________^ D212
74 |           calc = DecayingAverageCalculator(decay_factor=0.9, max_samples=20)
   |
   = help: Remove whitespace after opening quotes

tests\models\test_ngram_analytics_service.py:83:9: D212 [*] Multi-line docstring summary should start at the first line
   |
82 |       def test_calculate_decaying_average_empty_values(self) -> None:
83 | /         """
84 | |         Test objective: Verify decaying average with empty input.
85 | |
86 | |         Tests that empty input returns 0.0.
87 | |         """
   | |___________^ D212
88 |           calc = DecayingAverageCalculator(decay_factor=0.9, max_samples=20)
   |
   = help: Remove whitespace after opening quotes

tests\models\test_ngram_analytics_service.py:94:9: D212 [*] Multi-line docstring summary should start at the first line
   |
93 |       def test_calculate_decaying_average_max_samples(self) -> None:
94 | /         """
95 | |         Test objective: Verify decaying average respects max_samples limit.
96 | |
97 | |         Tests that only the most recent max_samples values are used.
98 | |         """
   | |___________^ D212
99 |           calc = DecayingAverageCalculator(decay_factor=0.9, max_samples=3)
   |
   = help: Remove whitespace after opening quotes

tests\models\test_ngram_analytics_service.py:123:9: D212 [*] Multi-line docstring summary should start at the first line
    |
122 |       def test_init_with_valid_dependencies(self, db_with_tables: DatabaseManager) -> None:
123 | /         """
124 | |         Test objective: Verify NGramAnalyticsService initialization.
125 | |
126 | |         Tests that the service initializes properly with valid dependencies.
127 | |         """
    | |___________^ D212
128 |           ngram_manager = NGramManager()
129 |           service = NGramAnalyticsService(db_with_tables, ngram_manager)
    |
    = help: Remove whitespace after opening quotes

tests\models\test_ngram_analytics_service.py:136:9: D212 [*] Multi-line docstring summary should start at the first line
    |
135 |       def test_init_with_none_dependencies(self) -> None:
136 | /         """
137 | |         Test objective: Verify NGramAnalyticsService handles None dependencies.
138 | |
139 | |         Tests that the service handles None dependencies gracefully.
140 | |         """
    | |___________^ D212
141 |           service = NGramAnalyticsService(None, None)
    |
    = help: Remove whitespace after opening quotes

tests\models\test_ngram_analytics_service.py:151:9: D212 [*] Multi-line docstring summary should start at the first line
    |
149 |           ngram_speed_test_data: Tuple[DatabaseManager, NGramAnalyticsService, str, str, str],
150 |       ) -> None:
151 | /         """
152 | |         Test objective: Verify speed summaries refresh functionality.
153 | |
154 | |         Tests that speed summaries are properly calculated and stored
155 | |         in the summary table.
156 | |         """
    | |___________^ D212
157 |           db, service, _session_id, user_id, keyboard_id = ngram_speed_test_data
158 |           # Run refresh on preloaded mock data
    |
    = help: Remove whitespace after opening quotes

tests\models\test_ngram_analytics_service.py:171:9: D212 [*] Multi-line docstring summary should start at the first line
    |
169 |           self, db_with_tables: DatabaseManager
170 |       ) -> None:
171 | /         """
172 | |         Test objective: Verify speed heatmap data retrieval.
173 | |
174 | |         Tests that heatmap data is properly retrieved with correct
175 | |         performance calculations and color coding.
176 | |         """
    | |___________^ D212
177 |           ngram_manager = NGramManager()
178 |           service = NGramAnalyticsService(db_with_tables, ngram_manager)
    |
    = help: Remove whitespace after opening quotes

tests\models\test_ngram_analytics_service.py:193:9: D212 [*] Multi-line docstring summary should start at the first line
    |
191 |           self, db_with_tables: DatabaseManager
192 |       ) -> None:
193 | /         """
194 | |         Test objective: Verify performance trends calculation.
195 | |
196 | |         Tests that historical performance trends are properly calculated
197 | |         over the specified time window.
198 | |         """
    | |___________^ D212
199 |           ngram_manager = NGramManager(temp_db)
200 |           service = NGramAnalyticsService(temp_db, ngram_manager)
    |
    = help: Remove whitespace after opening quotes

tests\models\test_ngram_analytics_service.py:199:38: F821 Undefined name `temp_db`
    |
197 |         over the specified time window.
198 |         """
199 |         ngram_manager = NGramManager(temp_db)
    |                                      ^^^^^^^ F821
200 |         service = NGramAnalyticsService(temp_db, ngram_manager)
    |

tests\models\test_ngram_analytics_service.py:200:41: F821 Undefined name `temp_db`
    |
198 |         """
199 |         ngram_manager = NGramManager(temp_db)
200 |         service = NGramAnalyticsService(temp_db, ngram_manager)
    |                                         ^^^^^^^ F821
201 |
202 |         # TODO: Set up test data
    |

tests\models\test_ngram_analytics_service.py:216:9: D212 [*] Multi-line docstring summary should start at the first line
    |
214 |           ngram_speed_test_data: Tuple[DatabaseManager, NGramAnalyticsService, str, str, str]
215 |       ) -> None:
216 | /         """
217 | |         Test objective: Verify slowest_n method moved from NGramManager.
218 | |
219 | |         Tests that the slowest_n method works correctly in the analytics service
220 | |         with proper parameter handling and filtering.
221 | |         """
    | |___________^ D212
222 |           temp_db, service, session_id, user_id, keyboard_id = ngram_speed_test_data
    |
    = help: Remove whitespace after opening quotes

tests\models\test_ngram_analytics_service.py:259:9: D212 [*] Multi-line docstring summary should start at the first line
    |
257 |           self, db_with_tables: DatabaseManager
258 |       ) -> None:
259 | /         """
260 | |         Test objective: Verify error_n method moved from NGramManager.
261 | |
262 | |         Tests that the error_n method works correctly in the analytics service
263 | |         with proper parameter handling and filtering.
264 | |         """
    | |___________^ D212
265 |           ngram_manager = NGramManager(temp_db)
266 |           service = NGramAnalyticsService(temp_db, ngram_manager)
    |
    = help: Remove whitespace after opening quotes

tests\models\test_ngram_analytics_service.py:265:38: F821 Undefined name `temp_db`
    |
263 |         with proper parameter handling and filtering.
264 |         """
265 |         ngram_manager = NGramManager(temp_db)
    |                                      ^^^^^^^ F821
266 |         service = NGramAnalyticsService(temp_db, ngram_manager)
    |

tests\models\test_ngram_analytics_service.py:266:41: F821 Undefined name `temp_db`
    |
264 |         """
265 |         ngram_manager = NGramManager(temp_db)
266 |         service = NGramAnalyticsService(temp_db, ngram_manager)
    |                                         ^^^^^^^ F821
267 |
268 |         # Set up test data - create practice session and n-gram error data
    |

tests\models\test_ngram_analytics_service.py:274:9: F821 Undefined name `temp_db`
    |
273 |         # Insert test session with all required fields
274 |         temp_db.execute(
    |         ^^^^^^^ F821
275 |             """INSERT INTO practice_sessions 
276 |             (session_id, user_id, keyboard_id, snippet_id, snippet_index_start, snippet_index_end, 
    |

tests\models\test_ngram_analytics_service.py:296:9: F821 Undefined name `temp_db`
    |
295 |         # Insert test n-gram error data
296 |         temp_db.execute(
    |         ^^^^^^^ F821
297 |             "INSERT INTO session_ngram_errors (session_id, ngram_text, ngram_size) VALUES (?, ?, ?)",
298 |             (session_id, "th", 2),
    |

tests\models\test_ngram_analytics_service.py:300:9: F821 Undefined name `temp_db`
    |
298 |             (session_id, "th", 2),
299 |         )
300 |         temp_db.execute(
    |         ^^^^^^^ F821
301 |             "INSERT INTO session_ngram_errors (session_id, ngram_text, ngram_size) VALUES (?, ?, ?)",
302 |             (session_id, "the", 3),
    |

tests\models\test_ngram_analytics_service.py:304:9: F821 Undefined name `temp_db`
    |
302 |             (session_id, "the", 3),
303 |         )
304 |         temp_db.execute(
    |         ^^^^^^^ F821
305 |             "INSERT INTO session_ngram_errors (session_id, ngram_text, ngram_size) VALUES (?, ?, ?)",
306 |             (session_id, "er", 2),
    |

tests\models\test_ngram_analytics_service.py:309:9: F821 Undefined name `temp_db`
    |
307 |         )
308 |         # Add more occurrences to meet minimum count requirement
309 |         temp_db.execute(
    |         ^^^^^^^ F821
310 |             "INSERT INTO session_ngram_errors (session_id, ngram_text, ngram_size) VALUES (?, ?, ?)",
311 |             (session_id, "th", 2),
    |

tests\models\test_ngram_analytics_service.py:313:9: F821 Undefined name `temp_db`
    |
311 |             (session_id, "th", 2),
312 |         )
313 |         temp_db.execute(
    |         ^^^^^^^ F821
314 |             "INSERT INTO session_ngram_errors (session_id, ngram_text, ngram_size) VALUES (?, ?, ?)",
315 |             (session_id, "the", 3),
    |

tests\models\test_ngram_analytics_service.py:355:9: D212 [*] Multi-line docstring summary should start at the first line
    |
353 |           mock_ngram_data: List[MockNGramSpeedData],
354 |       ) -> None:
355 | /         """
356 | |         Test objective: Verify dual-insert creates records in both current and history tables.
357 | |
358 | |         Tests that when refresh_speed_summaries is called, records are created
359 | |         in both ngram_speed_summary_curr and ngram_speed_summary_hist tables.
360 | |         """
    | |___________^ D212
361 |           ngram_manager = NGramManager(temp_db)
362 |           service = NGramAnalyticsService(temp_db, ngram_manager)
    |
    = help: Remove whitespace after opening quotes

tests\models\test_ngram_analytics_service.py:428:9: D212 [*] Multi-line docstring summary should start at the first line
    |
426 |           mock_ngram_data: List[MockNGramSpeedData],
427 |       ) -> None:
428 | /         """
429 | |         Test objective: Verify history table contains all records over multiple refreshes.
430 | |
431 | |         Tests that the history table accumulates all records from multiple
432 | |         refresh operations while current table only contains latest values.
433 | |         """
    | |___________^ D212
434 |           ngram_manager = NGramManager(temp_db)
435 |           service = NGramAnalyticsService(temp_db, ngram_manager)
    |
    = help: Remove whitespace after opening quotes

tests\models\test_ngram_analytics_service.py:538:9: D212 [*] Multi-line docstring summary should start at the first line
    |
536 |           mock_ngram_data: List[MockNGramSpeedData],
537 |       ) -> None:
538 | /         """
539 | |         Test objective: Verify history retrieval functionality.
540 | |
541 | |         Tests that historical data can be retrieved properly with correct
542 | |         timestamps and performance metrics.
543 | |         """
    | |___________^ D212
544 |           ngram_manager = NGramManager(temp_db)
545 |           service = NGramAnalyticsService(temp_db, ngram_manager)
    |
    = help: Remove whitespace after opening quotes

tests\models\test_ngram_analytics_service.py:607:9: D212 [*] Multi-line docstring summary should start at the first line
    |
605 |           self, temp_db: DatabaseManager
606 |       ) -> None:
607 | /         """
608 | |         Test objective: Verify history table schema matches current table.
609 | |
610 | |         Tests that the history table has the same essential columns as
611 | |         the current table plus additional history-specific fields.
612 | |         """
    | |___________^ D212
613 |           ngram_manager = NGramManager(temp_db)
614 |           service = NGramAnalyticsService(temp_db, ngram_manager)
    |
    = help: Remove whitespace after opening quotes

tests\models\test_ngram_analytics_service.py:614:9: F841 Local variable `service` is assigned to but never used
    |
612 |         """
613 |         ngram_manager = NGramManager(temp_db)
614 |         service = NGramAnalyticsService(temp_db, ngram_manager)
    |         ^^^^^^^ F841
615 |
616 |         # Verify table schemas are compatible
    |
    = help: Remove assignment to unused variable `service`

tests\models\test_ngram_analytics_service.py:652:9: D212 [*] Multi-line docstring summary should start at the first line
    |
651 |       def test_valid_performance_data(self) -> None:
652 | /         """
653 | |         Test objective: Verify NGramPerformanceData model validation.
654 | |
655 | |         Tests that the model properly validates correct performance data.
656 | |         """
    | |___________^ D212
657 |           data = NGramPerformanceData(
658 |               ngram_text="th",
    |
    = help: Remove whitespace after opening quotes

tests\models\test_ngram_analytics_service.py:675:9: D212 [*] Multi-line docstring summary should start at the first line
    |
674 |       def test_invalid_performance_data(self) -> None:
675 | /         """
676 | |         Test objective: Verify NGramPerformanceData model validation errors.
677 | |
678 | |         Tests that the model properly rejects invalid performance data.
679 | |         """
    | |___________^ D212
680 |           with pytest.raises(ValidationError):
681 |               NGramPerformanceData(
    |
    = help: Remove whitespace after opening quotes

tests\models\test_ngram_analytics_service.py:696:9: D212 [*] Multi-line docstring summary should start at the first line
    |
695 |       def test_valid_heatmap_data(self) -> None:
696 | /         """
697 | |         Test objective: Verify NGramHeatmapData model validation.
698 | |
699 | |         Tests that the model properly validates correct heatmap data.
700 | |         """
    | |___________^ D212
701 |           data = NGramHeatmapData(
702 |               ngram_text="th",
    |
    = help: Remove whitespace after opening quotes

tests\models\test_ngram_analytics_service_session_methods.py:1:1: D212 [*] Multi-line docstring summary should start at the first line
   |
 1 | / """
 2 | | Comprehensive tests for NGramAnalyticsService session-level methods.
 3 | |
 4 | | Tests the three new methods:
 5 | | - SummarizeSessionNgrams
 6 | | - AddSpeedSummaryForSession  
 7 | | - CatchupSpeedSummary
 8 | |
 9 | | These tests use real database connections and do not mock database operations
10 | | as per the requirement to test database pushdown functionality.
11 | | """
   | |___^ D212
12 |
13 |   import uuid
   |
   = help: Remove whitespace after opening quotes

tests\models\test_ngram_analytics_service_session_methods.py:63:9: ANN201 Missing return type annotation for public function `test_summarize_with_ngram_speed_only`
   |
61 |         (3, 3),  # Multiple ngram speed entries
62 |     ])
63 |     def test_summarize_with_ngram_speed_only(
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
64 |         self, 
65 |         analytics_service: NGramAnalyticsService,
   |
   = help: Add return type annotation: `None`

tests\models\test_ngram_analytics_service_session_methods.py:111:9: ANN201 Missing return type annotation for public function `test_summarize_with_ngram_errors_only`
    |
109 |         (2, 2),  # Multiple error entries
110 |     ])
111 |     def test_summarize_with_ngram_errors_only(
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
112 |         self,
113 |         analytics_service: NGramAnalyticsService,
    |
    = help: Add return type annotation: `None`

tests\models\test_ngram_analytics_service_session_methods.py:133:13: B007 Loop control variable `i` not used within loop body
    |
131 |         # Create error data
132 |         error_data = []
133 |         for i in range(error_count):
    |             ^ B007
134 |             error_data.append({
135 |                 'ngram_size': 2,
    |
    = help: Rename unused `i` to `_i`

tests\models\test_ngram_analytics_service_session_methods.py:156:9: ANN201 Missing return type annotation for public function `test_summarize_with_speed_and_errors`
    |
154 |         assert summary_records[0]['error_count'] == expected_errors
155 |     
156 |     def test_summarize_with_speed_and_errors(
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
157 |         self,
158 |         analytics_service: NGramAnalyticsService,
    |
    = help: Add return type annotation: `None`

tests\models\test_ngram_analytics_service_session_methods.py:217:9: ANN201 Missing return type annotation for public function `test_summarize_with_keystrokes`
    |
215 |         (3, 3),  # Multiple keystrokes
216 |     ])
217 |     def test_summarize_with_keystrokes(
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
218 |         self,
219 |         analytics_service: NGramAnalyticsService,
    |
    = help: Add return type annotation: `None`

tests\models\test_ngram_analytics_service_session_methods.py:262:9: ANN201 Missing return type annotation for public function `test_no_sessions_missing`
    |
260 |             assert record['avg_ms_per_keystroke'] > 0
261 |     
262 |     def test_no_sessions_missing(
    |         ^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
263 |         self,
264 |         analytics_service: NGramAnalyticsService,
    |
    = help: Add return type annotation: `None`

tests\models\test_ngram_analytics_service_session_methods.py:293:9: ANN201 Missing return type annotation for public function `test_sessions_missing_no_data`
    |
291 |         assert result == 0
292 |     
293 |     def test_sessions_missing_no_data(
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
294 |         self,
295 |         analytics_service: NGramAnalyticsService,
    |
    = help: Add return type annotation: `None`

tests\models\test_ngram_analytics_service_session_methods.py:311:9: ANN201 Missing return type annotation for public function `test_single_session_processing`
    |
309 |     """Test cases for AddSpeedSummaryForSession method."""
310 |     
311 |     def test_single_session_processing(
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
312 |         self,
313 |         analytics_service: NGramAnalyticsService,
    |
    = help: Add return type annotation: `None`

tests\models\test_ngram_analytics_service_session_methods.py:346:9: ANN201 Missing return type annotation for public function `test_nonexistent_session`
    |
344 |         assert result['curr_updated'] >= 0
345 |     
346 |     def test_nonexistent_session(
    |         ^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
347 |         self,
348 |         analytics_service: NGramAnalyticsService
    |
    = help: Add return type annotation: `None`

tests\models\test_ngram_analytics_service_session_methods.py:356:9: ANN201 Missing return type annotation for public function `test_multiple_ngrams_processing`
    |
354 |             analytics_service.add_speed_summary_for_session(fake_session_id)
355 |     
356 |     def test_multiple_ngrams_processing(
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
357 |         self,
358 |         analytics_service: NGramAnalyticsService,
    |
    = help: Add return type annotation: `None`

tests\models\test_ngram_analytics_service_session_methods.py:405:9: ANN201 Missing return type annotation for public function `test_empty_database_catchup`
    |
403 |     """Test cases for CatchupSpeedSummary method."""
404 |     
405 |     def test_empty_database_catchup(
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
406 |         self,
407 |         analytics_service: NGramAnalyticsService
    |
    = help: Add return type annotation: `None`

tests\models\test_ngram_analytics_service_session_methods.py:417:9: ANN201 Missing return type annotation for public function `test_single_session_catchup`
    |
415 |         assert result['total_curr_updated'] == 0
416 |     
417 |     def test_single_session_catchup(
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
418 |         self,
419 |         analytics_service: NGramAnalyticsService,
    |
    = help: Add return type annotation: `None`

tests\models\test_ngram_analytics_service_session_methods.py:451:9: ANN201 Missing return type annotation for public function `test_multiple_sessions_catchup`
    |
449 |         assert result['total_curr_updated'] >= 0
450 |     
451 |     def test_multiple_sessions_catchup(
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
452 |         self,
453 |         analytics_service: NGramAnalyticsService,
    |
    = help: Add return type annotation: `None`

tests\models\test_ngram_analytics_service_session_methods.py:486:9: ANN201 Missing return type annotation for public function `test_catchup_with_session_errors`
    |
484 |         # (verified by the method's internal logging)
485 |     
486 |     def test_catchup_with_session_errors(
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
487 |         self,
488 |         analytics_service: NGramAnalyticsService,
    |
    = help: Add return type annotation: `None`

tests\models\test_ngram_analytics_service_session_methods.py:524:9: ANN201 Missing return type annotation for public function `test_full_workflow_integration`
    |
522 |     """Integration tests combining multiple methods."""
523 |     
524 |     def test_full_workflow_integration(
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
525 |         self,
526 |         analytics_service: NGramAnalyticsService,
    |
    = help: Add return type annotation: `None`

tests\models\test_ngram_clean.py:1:1: D100 Missing docstring in public module
tests\models\test_ngram_error.py:1:1: D100 Missing docstring in public module
tests\models\test_ngram_manager.py:1:1: D100 Missing docstring in public module
tests\models\test_ngram_manager.py:1:1: I001 [*] Import block is un-sorted or un-formatted
  |
1 | / import uuid
2 | | from datetime import datetime, timedelta, timezone
3 | | import sqlite3
4 | | import pytest
5 | |
6 | | from models.ngram_manager import NGramManager
7 | | from models.ngram import Keystroke, SpeedMode, MAX_NGRAM_SIZE
  | |_____________________________________________________________^ I001
  |
  = help: Organize imports

tests\models\test_ngram_manager.py:3:8: F401 [*] `sqlite3` imported but unused
  |
1 | import uuid
2 | from datetime import datetime, timedelta, timezone
3 | import sqlite3
  |        ^^^^^^^ F401
4 | import pytest
  |
  = help: Remove unused import: `sqlite3`

tests\models\test_ngram_manager.py:7:37: F401 [*] `models.ngram.SpeedMode` imported but unused
  |
6 | from models.ngram_manager import NGramManager
7 | from models.ngram import Keystroke, SpeedMode, MAX_NGRAM_SIZE
  |                                     ^^^^^^^^^ F401
  |
  = help: Remove unused import

tests\models\test_ngram_manager.py:7:48: F401 [*] `models.ngram.MAX_NGRAM_SIZE` imported but unused
  |
6 | from models.ngram_manager import NGramManager
7 | from models.ngram import Keystroke, SpeedMode, MAX_NGRAM_SIZE
  |                                                ^^^^^^^^^^^^^^ F401
  |
  = help: Remove unused import

tests\models\test_ngram_manager.py:10:5: D103 Missing docstring in public function
   |
10 | def ts(ms: int) -> datetime:
   |     ^^ D103
11 |     return datetime(2025, 1, 1, 8, 0, 0, tzinfo=timezone.utc) + timedelta(milliseconds=ms)
   |

tests\models\test_ngram_manager.py:14:5: ANN201 Missing return type annotation for public function `make_k`
   |
14 | def make_k(text: str, start_ms: int = 0, step_ms: int = 100):
   |     ^^^^^^ ANN201
15 |     # Build keystrokes for expected text with perfect typing
16 |     ks = []
   |
   = help: Add return type annotation

tests\models\test_ngram_manager.py:14:5: D103 Missing docstring in public function
   |
14 | def make_k(text: str, start_ms: int = 0, step_ms: int = 100):
   |     ^^^^^^ D103
15 |     # Build keystrokes for expected text with perfect typing
16 |     ks = []
   |

tests\models\test_ngram_manager.py:24:7: D101 Missing docstring in public class
   |
24 | class TestAnalyzeBasic:
   |       ^^^^^^^^^^^^^^^^ D101
25 |     def test_clean_windows_and_gross_up(self):
26 |         mgr = NGramManager()
   |

tests\models\test_ngram_manager.py:25:9: ANN201 Missing return type annotation for public function `test_clean_windows_and_gross_up`
   |
24 | class TestAnalyzeBasic:
25 |     def test_clean_windows_and_gross_up(self):
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
26 |         mgr = NGramManager()
27 |         expected = "Then"  # no separators
   |
   = help: Add return type annotation: `None`

tests\models\test_ngram_manager.py:25:9: D102 Missing docstring in public method
   |
24 | class TestAnalyzeBasic:
25 |     def test_clean_windows_and_gross_up(self):
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
26 |         mgr = NGramManager()
27 |         expected = "Then"  # no separators
   |

tests\models\test_ngram_manager.py:43:9: ANN201 Missing return type annotation for public function `test_ignored_zero_duration`
   |
41 |         assert first4.duration_ms == pytest.approx(2666.6666666667, rel=1e-3)
42 |
43 |     def test_ignored_zero_duration(self):
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
44 |         mgr = NGramManager()
45 |         expected = "ab"
   |
   = help: Add return type annotation: `None`

tests\models\test_ngram_manager.py:43:9: D102 Missing docstring in public method
   |
41 |         assert first4.duration_ms == pytest.approx(2666.6666666667, rel=1e-3)
42 |
43 |     def test_ignored_zero_duration(self):
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
44 |         mgr = NGramManager()
45 |         expected = "ab"
   |

tests\models\test_ngram_manager.py:53:9: ANN201 Missing return type annotation for public function `test_separators_split_runs`
   |
51 |         assert speed == [] and errors == []
52 |
53 |     def test_separators_split_runs(self):
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
54 |         mgr = NGramManager()
55 |         expected = "hi there"  # space splits
   |
   = help: Add return type annotation: `None`

tests\models\test_ngram_manager.py:53:9: D102 Missing docstring in public method
   |
51 |         assert speed == [] and errors == []
52 |
53 |     def test_separators_split_runs(self):
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
54 |         mgr = NGramManager()
55 |         expected = "hi there"  # space splits
   |

tests\models\test_ngram_manager.py:63:7: D101 Missing docstring in public class
   |
63 | class TestErrorClassification:
   |       ^^^^^^^^^^^^^^^^^^^^^^^ D101
64 |     def test_error_last_only(self):
65 |         mgr = NGramManager()
   |

tests\models\test_ngram_manager.py:64:9: ANN201 Missing return type annotation for public function `test_error_last_only`
   |
63 | class TestErrorClassification:
64 |     def test_error_last_only(self):
   |         ^^^^^^^^^^^^^^^^^^^^ ANN201
65 |         mgr = NGramManager()
66 |         expected = "th"
   |
   = help: Add return type annotation: `None`

tests\models\test_ngram_manager.py:64:9: D102 Missing docstring in public method
   |
63 | class TestErrorClassification:
64 |     def test_error_last_only(self):
   |         ^^^^^^^^^^^^^^^^^^^^ D102
65 |         mgr = NGramManager()
66 |         expected = "th"
   |

tests\models\test_ngram_manager.py:80:9: ANN201 Missing return type annotation for public function `test_error_not_last_is_ignored`
   |
78 |         assert err.duration_ms > 0
79 |
80 |     def test_error_not_last_is_ignored(self):
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
81 |         mgr = NGramManager()
82 |         expected = "th"
   |
   = help: Add return type annotation: `None`

tests\models\test_ngram_manager.py:80:9: D102 Missing docstring in public method
   |
78 |         assert err.duration_ms > 0
79 |
80 |     def test_error_not_last_is_ignored(self):
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
81 |         mgr = NGramManager()
82 |         expected = "th"
   |

tests\models\test_ngram_orchestrator_process_end_of_session.py:1:1: D212 [*] Multi-line docstring summary should start at the first line
  |
1 | / """
2 | | Integration-style tests for NGramAnalyticsService.process_end_of_session orchestrator.
3 | |
4 | | Validates strict sequencing and DB side effects on the success path using real DB.
5 | | """
  | |___^ D212
6 |
7 |   import uuid
  |
  = help: Remove whitespace after opening quotes

tests\models\test_ngram_orchestrator_process_end_of_session.py:36:5: ANN201 Missing return type annotation for public function `test_process_end_of_session_success_path`
   |
36 | def test_process_end_of_session_success_path(db_with_tables, test_user, test_keyboard):
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
37 |     # Arrange: create snippet (for FK completeness) and a new Session not yet in DB
38 |     from tests.models.conftest import TestSessionMethodsFixtures
   |
   = help: Add return type annotation: `None`

tests\models\test_ngram_orchestrator_process_end_of_session.py:36:5: D103 Missing docstring in public function
   |
36 | def test_process_end_of_session_success_path(db_with_tables, test_user, test_keyboard):
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D103
37 |     # Arrange: create snippet (for FK completeness) and a new Session not yet in DB
38 |     from tests.models.conftest import TestSessionMethodsFixtures
   |

tests\models\test_ngram_orchestrator_process_end_of_session.py:36:46: ANN001 Missing type annotation for function argument `db_with_tables`
   |
36 | def test_process_end_of_session_success_path(db_with_tables, test_user, test_keyboard):
   |                                              ^^^^^^^^^^^^^^ ANN001
37 |     # Arrange: create snippet (for FK completeness) and a new Session not yet in DB
38 |     from tests.models.conftest import TestSessionMethodsFixtures
   |

tests\models\test_ngram_orchestrator_process_end_of_session.py:36:62: ANN001 Missing type annotation for function argument `test_user`
   |
36 | def test_process_end_of_session_success_path(db_with_tables, test_user, test_keyboard):
   |                                                              ^^^^^^^^^ ANN001
37 |     # Arrange: create snippet (for FK completeness) and a new Session not yet in DB
38 |     from tests.models.conftest import TestSessionMethodsFixtures
   |

tests\models\test_ngram_orchestrator_process_end_of_session.py:36:73: ANN001 Missing type annotation for function argument `test_keyboard`
   |
36 | def test_process_end_of_session_success_path(db_with_tables, test_user, test_keyboard):
   |                                                                         ^^^^^^^^^^^^^ ANN001
37 |     # Arrange: create snippet (for FK completeness) and a new Session not yet in DB
38 |     from tests.models.conftest import TestSessionMethodsFixtures
   |

tests\models\test_ngram_orchestrator_process_end_of_session.py:124:5: ANN201 Missing return type annotation for public function `test_process_end_of_session_session_save_failure`
    |
124 | def test_process_end_of_session_session_save_failure(db_with_tables, test_user):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
125 |     """Fails at step 1: session save should raise due to FK violation (invalid keyboard_id)."""
126 |     from tests.models.conftest import TestSessionMethodsFixtures
    |
    = help: Add return type annotation: `None`

tests\models\test_ngram_orchestrator_process_end_of_session.py:124:54: ANN001 Missing type annotation for function argument `db_with_tables`
    |
124 | def test_process_end_of_session_session_save_failure(db_with_tables, test_user):
    |                                                      ^^^^^^^^^^^^^^ ANN001
125 |     """Fails at step 1: session save should raise due to FK violation (invalid keyboard_id)."""
126 |     from tests.models.conftest import TestSessionMethodsFixtures
    |

tests\models\test_ngram_orchestrator_process_end_of_session.py:124:70: ANN001 Missing type annotation for function argument `test_user`
    |
124 | def test_process_end_of_session_session_save_failure(db_with_tables, test_user):
    |                                                                      ^^^^^^^^^ ANN001
125 |     """Fails at step 1: session save should raise due to FK violation (invalid keyboard_id)."""
126 |     from tests.models.conftest import TestSessionMethodsFixtures
    |

tests\models\test_ngram_orchestrator_process_end_of_session.py:166:5: ANN201 Missing return type annotation for public function `test_process_end_of_session_keystrokes_save_failure`
    |
166 | def test_process_end_of_session_keystrokes_save_failure(db_with_tables, test_user, test_keyboard):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
167 |     """Fails at step 2: keystrokes save should return False due to invalid keystroke session_id."""
168 |     from tests.models.conftest import TestSessionMethodsFixtures
    |
    = help: Add return type annotation: `None`

tests\models\test_ngram_orchestrator_process_end_of_session.py:166:57: ANN001 Missing type annotation for function argument `db_with_tables`
    |
166 | def test_process_end_of_session_keystrokes_save_failure(db_with_tables, test_user, test_keyboard):
    |                                                         ^^^^^^^^^^^^^^ ANN001
167 |     """Fails at step 2: keystrokes save should return False due to invalid keystroke session_id."""
168 |     from tests.models.conftest import TestSessionMethodsFixtures
    |

tests\models\test_ngram_orchestrator_process_end_of_session.py:166:73: ANN001 Missing type annotation for function argument `test_user`
    |
166 | def test_process_end_of_session_keystrokes_save_failure(db_with_tables, test_user, test_keyboard):
    |                                                                         ^^^^^^^^^ ANN001
167 |     """Fails at step 2: keystrokes save should return False due to invalid keystroke session_id."""
168 |     from tests.models.conftest import TestSessionMethodsFixtures
    |

tests\models\test_ngram_orchestrator_process_end_of_session.py:166:84: ANN001 Missing type annotation for function argument `test_keyboard`
    |
166 | def test_process_end_of_session_keystrokes_save_failure(db_with_tables, test_user, test_keyboard):
    |                                                                                    ^^^^^^^^^^^^^ ANN001
167 |     """Fails at step 2: keystrokes save should return False due to invalid keystroke session_id."""
168 |     from tests.models.conftest import TestSessionMethodsFixtures
    |

tests\models\test_ngram_orchestrator_process_end_of_session.py:215:5: ANN201 Missing return type annotation for public function `test_process_end_of_session_summarization_failure`
    |
215 | def test_process_end_of_session_summarization_failure(db_with_tables, test_user, test_keyboard):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
216 |     """Fails at step 4: drop summary table to force summarization SQL to fail after n-grams."""
217 |     from tests.models.conftest import TestSessionMethodsFixtures
    |
    = help: Add return type annotation: `None`

tests\models\test_ngram_orchestrator_process_end_of_session.py:215:55: ANN001 Missing type annotation for function argument `db_with_tables`
    |
215 | def test_process_end_of_session_summarization_failure(db_with_tables, test_user, test_keyboard):
    |                                                       ^^^^^^^^^^^^^^ ANN001
216 |     """Fails at step 4: drop summary table to force summarization SQL to fail after n-grams."""
217 |     from tests.models.conftest import TestSessionMethodsFixtures
    |

tests\models\test_ngram_orchestrator_process_end_of_session.py:215:71: ANN001 Missing type annotation for function argument `test_user`
    |
215 | def test_process_end_of_session_summarization_failure(db_with_tables, test_user, test_keyboard):
    |                                                                       ^^^^^^^^^ ANN001
216 |     """Fails at step 4: drop summary table to force summarization SQL to fail after n-grams."""
217 |     from tests.models.conftest import TestSessionMethodsFixtures
    |

tests\models\test_ngram_orchestrator_process_end_of_session.py:215:82: ANN001 Missing type annotation for function argument `test_keyboard`
    |
215 | def test_process_end_of_session_summarization_failure(db_with_tables, test_user, test_keyboard):
    |                                                                                  ^^^^^^^^^^^^^ ANN001
216 |     """Fails at step 4: drop summary table to force summarization SQL to fail after n-grams."""
217 |     from tests.models.conftest import TestSessionMethodsFixtures
    |

tests\models\test_ngram_persist.py:1:1: D100 Missing docstring in public module
tests\models\test_practice_session_extensions.py:1:1: D100 Missing docstring in public module
tests\models\test_session.py:1:1: D100 Missing docstring in public module
tests\models\test_session.py:13:5: D103 Missing docstring in public function
   |
11 | # --- Fixtures ---
12 | @pytest.fixture
13 | def valid_session_dict() -> dict[str, Any]:
   |     ^^^^^^^^^^^^^^^^^^ D103
14 |     now = datetime(2023, 1, 1, 12, 0, 0)
15 |     return {
   |

tests\models\test_session.py:31:5: D103 Missing docstring in public function
   |
30 | # --- Creation and Validation ---
31 | def test_valid_session_creation(valid_session_dict: dict[str, Any]) -> None:
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ D103
32 |     s = Session(**valid_session_dict)
33 |     assert s.session_id == valid_session_dict["session_id"]
   |

tests\models\test_session.py:60:5: D103 Missing docstring in public function
   |
58 |     ],
59 | )
60 | def test_missing_required_fields_raises(
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D103
61 |     valid_session_dict: dict[str, Any], missing_field: str
62 | ) -> None:
   |

tests\models\test_session.py:84:5: D103 Missing docstring in public function
   |
82 |     ],
83 | )
84 | def test_invalid_field_values_raise(
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D103
85 |     valid_session_dict: dict[str, Any], field: str, value: Union[str, int]
86 | ) -> None:
   |

tests\models\test_session.py:104:5: D103 Missing docstring in public function
    |
102 |     ],
103 | )
104 | def test_index_business_rules(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^ D103
105 |     valid_session_dict: dict[str, Any], start: int, end: int, expect_error: bool
106 | ) -> None:
    |

tests\models\test_session.py:119:5: D103 Missing docstring in public function
    |
119 | def test_start_time_after_end_time_raises(valid_session_dict: dict[str, Any]) -> None:
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D103
120 |     data = valid_session_dict.copy()
121 |     data["start_time"] = data["end_time"] + timedelta(seconds=1)  # type: ignore
    |

tests\models\test_session.py:127:5: D103 Missing docstring in public function
    |
126 | # --- Computed Properties ---
127 | def test_computed_properties(valid_session_dict: dict[str, Any]) -> None:
    |     ^^^^^^^^^^^^^^^^^^^^^^^^ D103
128 |     s = Session(**valid_session_dict)
129 |     assert s.expected_chars == 5
    |

tests\models\test_session.py:148:5: D103 Missing docstring in public function
    |
146 |     ],
147 | )
148 | def test_correctness_and_accuracy(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D103
149 |     valid_session_dict: dict[str, Any],
150 |     actual_chars: int,
    |

tests\models\test_session.py:170:5: D103 Missing docstring in public function
    |
168 |     ],
169 | )
170 | def test_wpm_cpm_zero_and_normal(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D103
171 |     valid_session_dict: dict[str, Any],
172 |     start_time: datetime,
    |

tests\models\test_session.py:186:5: D103 Missing docstring in public function
    |
185 | # --- Dict/Row Roundtrip ---
186 | def test_to_dict_and_from_dict(valid_session_dict: dict[str, Any]) -> None:
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ D103
187 |     s = Session(**valid_session_dict)
188 |     d = s.to_dict()
    |

tests\models\test_session.py:200:5: D103 Missing docstring in public function
    |
199 | # --- Extra/Calculated Fields ---
200 | def test_from_dict_ignores_calculated_fields(valid_session_dict: dict[str, Any]) -> None:
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D103
201 |     d = valid_session_dict.copy()
202 |     d["total_time"] = 123
    |

tests\models\test_session.py:215:5: D103 Missing docstring in public function
    |
215 | def test_from_dict_with_extra_fields_raises(valid_session_dict: dict[str, Any]) -> None:
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D103
216 |     d = valid_session_dict.copy()
217 |     d["extra_field"] = 123
    |

tests\models\test_session.py:223:5: D103 Missing docstring in public function
    |
222 | # --- Summary ---
223 | def test_get_summary_truncates_content(valid_session_dict: dict[str, Any]) -> None:
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D103
224 |     s = Session(**valid_session_dict)
225 |     summary = s.get_summary()
    |

tests\models\test_session.py:232:5: D103 Missing docstring in public function
    |
231 | # --- Forbidden extra fields on creation ---
232 | def test_extra_fields_forbidden_on_creation(valid_session_dict: dict[str, Any]) -> None:
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D103
233 |     d = valid_session_dict.copy()
234 |     d["foo"] = "bar"
    |

tests\models\test_session.py:240:5: D103 Missing docstring in public function
    |
239 | # --- ms_per_keystroke edge case ---
240 | def test_ms_per_keystroke_zero_chars(valid_session_dict: dict[str, Any]) -> None:
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D103
241 |     d = valid_session_dict.copy()
242 |     d["start_time"] = d["end_time"]  # total_time = 0, expected_chars > 0
    |

tests\models\test_session.py:248:5: D103 Missing docstring in public function
    |
247 | # --- UUID default factory ---
248 | def test_session_id_default_factory(valid_session_dict: dict[str, Any]) -> None:
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D103
249 |     d = valid_session_dict.copy()
250 |     d.pop("session_id")
    |

tests\models\test_session.py:256:5: D103 Missing docstring in public function
    |
255 | # --- Content required for non-abandoned sessions ---
256 | def test_content_required_if_actual_chars(valid_session_dict: dict[str, Any]) -> None:
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D103
257 |     d = valid_session_dict.copy()
258 |     d["content"] = ""
    |

tests\models\test_session_manager.py:1:1: D100 Missing docstring in public module
tests\models\test_session_manager.py:17:5: D103 Missing docstring in public function
   |
17 | def make_session(snippet_id: str, user_id: str, keyboard_id: str, **overrides: object) -> Session:
   |     ^^^^^^^^^^^^ D103
18 |     now = datetime.datetime(2023, 1, 1, 12, 0, 0)
19 |     data = {
   |

tests\models\test_session_manager.py:37:5: D103 Missing docstring in public function
   |
36 | @pytest.fixture
37 | def category_mgr(db_with_tables: DatabaseManager) -> CategoryManager:
   |     ^^^^^^^^^^^^ D103
38 |     return CategoryManager(db_with_tables)
   |

tests\models\test_session_manager.py:42:5: D103 Missing docstring in public function
   |
41 | @pytest.fixture
42 | def snippet_mgr(db_with_tables: DatabaseManager) -> SnippetManager:
   |     ^^^^^^^^^^^ D103
43 |     return SnippetManager(db_with_tables)
   |

tests\models\test_session_manager.py:47:5: D103 Missing docstring in public function
   |
46 | @pytest.fixture
47 | def session_mgr(db_with_tables: DatabaseManager) -> SessionManager:
   |     ^^^^^^^^^^^ D103
48 |     return SessionManager(db_with_tables)
   |

tests\models\test_session_manager.py:52:5: D103 Missing docstring in public function
   |
51 | @pytest.fixture
52 | def sample_category(category_mgr: CategoryManager) -> Category:
   |     ^^^^^^^^^^^^^^^ D103
53 |     category = Category(category_name="Test Category", description="A category for testing")
54 |     category_mgr.save_category(category)
   |

tests\models\test_session_manager.py:59:5: D103 Missing docstring in public function
   |
58 | @pytest.fixture
59 | def sample_snippet(
   |     ^^^^^^^^^^^^^^ D103
60 |     snippet_mgr: SnippetManager, sample_category: Category, test_user: User
61 | ) -> Snippet:
   |

tests\models\test_session_manager.py:71:5: D103 Missing docstring in public function
   |
71 | def test_save_and_get_session(
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^ D103
72 |     session_mgr: SessionManager,
73 |     sample_snippet: Snippet,
   |

tests\models\test_session_manager.py:87:5: D103 Missing docstring in public function
   |
87 | def test_update_session(
   |     ^^^^^^^^^^^^^^^^^^^ D103
88 |     session_mgr: SessionManager,
89 |     sample_snippet: Snippet,
   |

tests\models\test_session_manager.py:105:5: D103 Missing docstring in public function
    |
105 | def test_list_sessions_for_snippet(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D103
106 |     session_mgr: SessionManager,
107 |     sample_snippet: Snippet,
    |

tests\models\test_session_manager.py:128:5: D103 Missing docstring in public function
    |
128 | def test_delete_session_by_id(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^ D103
129 |     session_mgr: SessionManager,
130 |     sample_snippet: Snippet,
    |

tests\models\test_session_manager.py:145:5: D103 Missing docstring in public function
    |
145 | def test_delete_all(
    |     ^^^^^^^^^^^^^^^ D103
146 |     session_mgr: SessionManager,
147 |     snippet_mgr: SnippetManager,
    |

tests\models\test_session_manager.py:184:5: D103 Missing docstring in public function
    |
184 | def test_save_session_returns_id(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D103
185 |     session_mgr: SessionManager,
186 |     sample_snippet: Snippet,
    |

tests\models\test_session_manager.py:199:5: D103 Missing docstring in public function
    |
199 | def test_get_nonexistent_session(session_mgr: SessionManager) -> None:
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D103
200 |     assert session_mgr.get_session_by_id(str(uuid.uuid4())) is None
    |

tests\models\test_session_manager.py:203:5: D103 Missing docstring in public function
    |
203 | def test_list_sessions_for_snippet_empty(session_mgr: SessionManager) -> None:
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D103
204 |     assert session_mgr.list_sessions_for_snippet(str(uuid.uuid4())) == []
    |

tests\models\test_setting.py:1:1: D205 1 blank line required between summary line and description
  |
1 | / """
2 | | Unit tests for the Setting Pydantic model in models.setting.
3 | | Focuses on validation logic within the Setting model itself.
4 | | """
  | |___^ D205
5 |
6 |   # Standard library imports
  |
  = help: Insert single blank line

tests\models\test_setting.py:1:1: D212 [*] Multi-line docstring summary should start at the first line
  |
1 | / """
2 | | Unit tests for the Setting Pydantic model in models.setting.
3 | | Focuses on validation logic within the Setting model itself.
4 | | """
  | |___^ D212
5 |
6 |   # Standard library imports
  |
  = help: Remove whitespace after opening quotes

tests\models\test_setting.py:48:9: D200 One-line docstring should fit on one line
   |
46 |       )
47 |       def test_setting_type_id_validation(self, setting_type_id: str, expected_error_message_part: str) -> None:
48 | /         """
49 | |         Test objective: Verify Setting model's type_id validation for format, length, and ASCII.
50 | |         """
   | |___________^ D200
51 |           with pytest.raises(ValidationError) as exc_info:
52 |               Setting(
   |
   = help: Reformat to one line

tests\models\test_setting.py:48:9: D212 [*] Multi-line docstring summary should start at the first line
   |
46 |       )
47 |       def test_setting_type_id_validation(self, setting_type_id: str, expected_error_message_part: str) -> None:
48 | /         """
49 | |         Test objective: Verify Setting model's type_id validation for format, length, and ASCII.
50 | |         """
   | |___________^ D212
51 |           with pytest.raises(ValidationError) as exc_info:
52 |               Setting(
   |
   = help: Remove whitespace after opening quotes

tests\models\test_setting_manager.py:1:1: D205 1 blank line required between summary line and description
  |
1 | / """
2 | | Unit tests for models.setting_manager.SettingManager.
3 | | Covers CRUD, validation (including DB uniqueness), history tracking, and error handling.
4 | | """
  | |___^ D205
5 |
6 |   import uuid
  |
  = help: Insert single blank line

tests\models\test_setting_manager.py:1:1: D212 [*] Multi-line docstring summary should start at the first line
  |
1 | / """
2 | | Unit tests for models.setting_manager.SettingManager.
3 | | Covers CRUD, validation (including DB uniqueness), history tracking, and error handling.
4 | | """
  | |___^ D212
5 |
6 |   import uuid
  |
  = help: Remove whitespace after opening quotes

tests\models\test_setting_manager.py:18:5: D200 One-line docstring should fit on one line
   |
16 |   @pytest.fixture(scope="function")
17 |   def setting_mgr(db_with_tables: DatabaseManager) -> SettingManager:
18 | /     """
19 | |     Fixture: Provides a SettingManager with a fresh, initialized database.
20 | |     """
   | |_______^ D200
21 |       return SettingManager(db_with_tables)
   |
   = help: Reformat to one line

tests\models\test_setting_manager.py:18:5: D212 [*] Multi-line docstring summary should start at the first line
   |
16 |   @pytest.fixture(scope="function")
17 |   def setting_mgr(db_with_tables: DatabaseManager) -> SettingManager:
18 | /     """
19 | |     Fixture: Provides a SettingManager with a fresh, initialized database.
20 | |     """
   | |_______^ D212
21 |       return SettingManager(db_with_tables)
   |
   = help: Remove whitespace after opening quotes

tests\models\test_setting_manager.py:28:9: D200 One-line docstring should fit on one line
   |
27 |       def test_create_setting_valid(self, setting_mgr: SettingManager) -> None:
28 | /         """
29 | |         Test objective: Create a setting with valid data and verify persistence.
30 | |         """
   | |___________^ D200
31 |           setting_type_id = "SETTYP"
32 |           related_entity_id = str(uuid.uuid4())
   |
   = help: Reformat to one line

tests\models\test_setting_manager.py:28:9: D212 [*] Multi-line docstring summary should start at the first line
   |
27 |       def test_create_setting_valid(self, setting_mgr: SettingManager) -> None:
28 | /         """
29 | |         Test objective: Create a setting with valid data and verify persistence.
30 | |         """
   | |___________^ D212
31 |           setting_type_id = "SETTYP"
32 |           related_entity_id = str(uuid.uuid4())
   |
   = help: Remove whitespace after opening quotes

tests\models\test_setting_manager.py:64:9: D200 One-line docstring should fit on one line
   |
62 |           self, setting_mgr: SettingManager, setting_type_id: str, err_msg_part: str
63 |       ) -> None:
64 | /         """
65 | |         Test objective: Attempt to create a setting with an invalid type_id format.
66 | |         """
   | |___________^ D200
67 |           with pytest.raises((ValueError, SettingValidationError)) as e:
68 |               setting = Setting(
   |
   = help: Reformat to one line

tests\models\test_setting_manager.py:64:9: D212 [*] Multi-line docstring summary should start at the first line
   |
62 |           self, setting_mgr: SettingManager, setting_type_id: str, err_msg_part: str
63 |       ) -> None:
64 | /         """
65 | |         Test objective: Attempt to create a setting with an invalid type_id format.
66 | |         """
   | |___________^ D212
67 |           with pytest.raises((ValueError, SettingValidationError)) as e:
68 |               setting = Setting(
   |
   = help: Remove whitespace after opening quotes

tests\models\test_setting_manager.py:78:9: D205 1 blank line required between summary line and description
   |
77 |       def test_update_existing_setting_with_new_value(self, setting_mgr: SettingManager) -> None:
78 | /         """
79 | |         Test objective: Verify that saving a setting with an existing type_id and entity_id updates
80 | |         the setting value and creates a new history entry.
81 | |         """
   | |___________^ D205
82 |           setting_type_id = "UPDSET"
83 |           related_entity_id = str(uuid.uuid4())
   |
   = help: Insert single blank line

tests\models\test_setting_manager.py:78:9: D212 [*] Multi-line docstring summary should start at the first line
   |
77 |       def test_update_existing_setting_with_new_value(self, setting_mgr: SettingManager) -> None:
78 | /         """
79 | |         Test objective: Verify that saving a setting with an existing type_id and entity_id updates
80 | |         the setting value and creates a new history entry.
81 | |         """
   | |___________^ D212
82 |           setting_type_id = "UPDSET"
83 |           related_entity_id = str(uuid.uuid4())
   |
   = help: Remove whitespace after opening quotes

tests\models\test_setting_manager.py:127:9: D200 One-line docstring should fit on one line
    |
126 |       def test_get_setting_by_type_and_entity(self, setting_mgr: SettingManager) -> None:
127 | /         """
128 | |         Test objective: Retrieve a setting by its type_id and related_entity_id.
129 | |         """
    | |___________^ D200
130 |           setting_type_id = "GETSET"
131 |           related_entity_id = str(uuid.uuid4())
    |
    = help: Reformat to one line

tests\models\test_setting_manager.py:127:9: D212 [*] Multi-line docstring summary should start at the first line
    |
126 |       def test_get_setting_by_type_and_entity(self, setting_mgr: SettingManager) -> None:
127 | /         """
128 | |         Test objective: Retrieve a setting by its type_id and related_entity_id.
129 | |         """
    | |___________^ D212
130 |           setting_type_id = "GETSET"
131 |           related_entity_id = str(uuid.uuid4())
    |
    = help: Remove whitespace after opening quotes

tests\models\test_setting_manager.py:150:9: D200 One-line docstring should fit on one line
    |
149 |       def test_get_setting_with_default(self, setting_mgr: SettingManager) -> None:
150 | /         """
151 | |         Test objective: Test get_setting with a default value when setting doesn't exist.
152 | |         """
    | |___________^ D200
153 |           setting_type_id = "DEFVAL"
154 |           related_entity_id = str(uuid.uuid4())
    |
    = help: Reformat to one line

tests\models\test_setting_manager.py:150:9: D212 [*] Multi-line docstring summary should start at the first line
    |
149 |       def test_get_setting_with_default(self, setting_mgr: SettingManager) -> None:
150 | /         """
151 | |         Test objective: Test get_setting with a default value when setting doesn't exist.
152 | |         """
    | |___________^ D212
153 |           setting_type_id = "DEFVAL"
154 |           related_entity_id = str(uuid.uuid4())
    |
    = help: Remove whitespace after opening quotes

tests\models\test_setting_manager.py:175:9: D200 One-line docstring should fit on one line
    |
174 |       def test_get_setting_not_found(self, setting_mgr: SettingManager) -> None:
175 | /         """
176 | |         Test objective: Attempt to retrieve a non-existent setting.
177 | |         """
    | |___________^ D200
178 |           with pytest.raises(SettingNotFound):
179 |               setting_mgr.get_setting("NOTEXS", str(uuid.uuid4()))
    |
    = help: Reformat to one line

tests\models\test_setting_manager.py:175:9: D212 [*] Multi-line docstring summary should start at the first line
    |
174 |       def test_get_setting_not_found(self, setting_mgr: SettingManager) -> None:
175 | /         """
176 | |         Test objective: Attempt to retrieve a non-existent setting.
177 | |         """
    | |___________^ D212
178 |           with pytest.raises(SettingNotFound):
179 |               setting_mgr.get_setting("NOTEXS", str(uuid.uuid4()))
    |
    = help: Remove whitespace after opening quotes

tests\models\test_setting_manager.py:182:9: D200 One-line docstring should fit on one line
    |
181 |       def test_list_settings_empty(self, setting_mgr: SettingManager) -> None:
182 | /         """
183 | |         Test objective: List settings for an entity when none exist.
184 | |         """
    | |___________^ D200
185 |           settings = setting_mgr.list_settings(str(uuid.uuid4()))
186 |           assert len(settings) == 0
    |
    = help: Reformat to one line

tests\models\test_setting_manager.py:182:9: D212 [*] Multi-line docstring summary should start at the first line
    |
181 |       def test_list_settings_empty(self, setting_mgr: SettingManager) -> None:
182 | /         """
183 | |         Test objective: List settings for an entity when none exist.
184 | |         """
    | |___________^ D212
185 |           settings = setting_mgr.list_settings(str(uuid.uuid4()))
186 |           assert len(settings) == 0
    |
    = help: Remove whitespace after opening quotes

tests\models\test_setting_manager.py:189:9: D200 One-line docstring should fit on one line
    |
188 |       def test_list_settings_populated(self, setting_mgr: SettingManager) -> None:
189 | /         """
190 | |         Test objective: List settings for an entity with multiple settings.
191 | |         """
    | |___________^ D200
192 |           related_entity_id = str(uuid.uuid4())
    |
    = help: Reformat to one line

tests\models\test_setting_manager.py:189:9: D212 [*] Multi-line docstring summary should start at the first line
    |
188 |       def test_list_settings_populated(self, setting_mgr: SettingManager) -> None:
189 | /         """
190 | |         Test objective: List settings for an entity with multiple settings.
191 | |         """
    | |___________^ D212
192 |           related_entity_id = str(uuid.uuid4())
    |
    = help: Remove whitespace after opening quotes

tests\models\test_setting_manager.py:214:9: D200 One-line docstring should fit on one line
    |
213 |       def test_update_setting_value(self, setting_mgr: SettingManager) -> None:
214 | /         """
215 | |         Test objective: Update a setting's value using save_setting.
216 | |         """
    | |___________^ D200
217 |           setting_type_id = "UPDATE"
218 |           related_entity_id = str(uuid.uuid4())
    |
    = help: Reformat to one line

tests\models\test_setting_manager.py:214:9: D212 [*] Multi-line docstring summary should start at the first line
    |
213 |       def test_update_setting_value(self, setting_mgr: SettingManager) -> None:
214 | /         """
215 | |         Test objective: Update a setting's value using save_setting.
216 | |         """
    | |___________^ D212
217 |           setting_type_id = "UPDATE"
218 |           related_entity_id = str(uuid.uuid4())
    |
    = help: Remove whitespace after opening quotes

tests\models\test_setting_manager.py:240:9: D200 One-line docstring should fit on one line
    |
239 |       def test_history_tracking_on_create(self, setting_mgr: SettingManager) -> None:
240 | /         """
241 | |         Test objective: Verify history record is created when a setting is created.
242 | |         """
    | |___________^ D200
243 |           setting_type_id = "HISCRE"
244 |           related_entity_id = str(uuid.uuid4())
    |
    = help: Reformat to one line

tests\models\test_setting_manager.py:240:9: D212 [*] Multi-line docstring summary should start at the first line
    |
239 |       def test_history_tracking_on_create(self, setting_mgr: SettingManager) -> None:
240 | /         """
241 | |         Test objective: Verify history record is created when a setting is created.
242 | |         """
    | |___________^ D212
243 |           setting_type_id = "HISCRE"
244 |           related_entity_id = str(uuid.uuid4())
    |
    = help: Remove whitespace after opening quotes

tests\models\test_setting_manager.py:270:9: D200 One-line docstring should fit on one line
    |
269 |       def test_history_tracking_on_update(self, setting_mgr: SettingManager) -> None:
270 | /         """
271 | |         Test objective: Verify history records are created when a setting is updated.
272 | |         """
    | |___________^ D200
273 |           setting_type_id = "HISUPD"
274 |           related_entity_id = str(uuid.uuid4())
    |
    = help: Reformat to one line

tests\models\test_setting_manager.py:270:9: D212 [*] Multi-line docstring summary should start at the first line
    |
269 |       def test_history_tracking_on_update(self, setting_mgr: SettingManager) -> None:
270 | /         """
271 | |         Test objective: Verify history records are created when a setting is updated.
272 | |         """
    | |___________^ D212
273 |           setting_type_id = "HISUPD"
274 |           related_entity_id = str(uuid.uuid4())
    |
    = help: Remove whitespace after opening quotes

tests\models\test_setting_manager.py:306:9: D200 One-line docstring should fit on one line
    |
305 |       def test_history_tracking_on_delete(self, setting_mgr: SettingManager) -> None:
306 | /         """
307 | |         Test objective: Verify history record is created when a setting is deleted.
308 | |         """
    | |___________^ D200
309 |           setting_type_id = "HISDEL"
310 |           related_entity_id = str(uuid.uuid4())
    |
    = help: Reformat to one line

tests\models\test_setting_manager.py:306:9: D212 [*] Multi-line docstring summary should start at the first line
    |
305 |       def test_history_tracking_on_delete(self, setting_mgr: SettingManager) -> None:
306 | /         """
307 | |         Test objective: Verify history record is created when a setting is deleted.
308 | |         """
    | |___________^ D212
309 |           setting_type_id = "HISDEL"
310 |           related_entity_id = str(uuid.uuid4())
    |
    = help: Remove whitespace after opening quotes

tests\models\test_setting_manager.py:336:9: D200 One-line docstring should fit on one line
    |
335 |       def test_delete_setting(self, setting_mgr: SettingManager) -> None:
336 | /         """
337 | |         Test objective: Delete an existing setting.
338 | |         """
    | |___________^ D200
339 |           setting_type_id = "DELETE"
340 |           related_entity_id = str(uuid.uuid4())
    |
    = help: Reformat to one line

tests\models\test_setting_manager.py:336:9: D212 [*] Multi-line docstring summary should start at the first line
    |
335 |       def test_delete_setting(self, setting_mgr: SettingManager) -> None:
336 | /         """
337 | |         Test objective: Delete an existing setting.
338 | |         """
    | |___________^ D212
339 |           setting_type_id = "DELETE"
340 |           related_entity_id = str(uuid.uuid4())
    |
    = help: Remove whitespace after opening quotes

tests\models\test_setting_manager.py:359:9: D200 One-line docstring should fit on one line
    |
358 |       def test_delete_nonexistent_setting(self, setting_mgr: SettingManager) -> None:
359 | /         """
360 | |         Test objective: Attempt to delete a non-existent setting.
361 | |         """
    | |___________^ D200
362 |           assert setting_mgr.delete_setting("NOEXST", str(uuid.uuid4())) is False
    |
    = help: Reformat to one line

tests\models\test_setting_manager.py:359:9: D212 [*] Multi-line docstring summary should start at the first line
    |
358 |       def test_delete_nonexistent_setting(self, setting_mgr: SettingManager) -> None:
359 | /         """
360 | |         Test objective: Attempt to delete a non-existent setting.
361 | |         """
    | |___________^ D212
362 |           assert setting_mgr.delete_setting("NOEXST", str(uuid.uuid4())) is False
    |
    = help: Remove whitespace after opening quotes

tests\models\test_setting_manager.py:365:9: D200 One-line docstring should fit on one line
    |
364 |       def test_delete_all_settings(self, setting_mgr: SettingManager) -> None:
365 | /         """
366 | |         Test objective: Delete all settings for an entity and verify the action.
367 | |         """
    | |___________^ D200
368 |           related_entity_id = str(uuid.uuid4())
    |
    = help: Reformat to one line

tests\models\test_setting_manager.py:365:9: D212 [*] Multi-line docstring summary should start at the first line
    |
364 |       def test_delete_all_settings(self, setting_mgr: SettingManager) -> None:
365 | /         """
366 | |         Test objective: Delete all settings for an entity and verify the action.
367 | |         """
    | |___________^ D212
368 |           related_entity_id = str(uuid.uuid4())
    |
    = help: Remove whitespace after opening quotes

tests\models\test_setting_manager.py:401:9: D200 One-line docstring should fit on one line
    |
400 |       def test_history_for_bulk_delete(self, setting_mgr: SettingManager) -> None:
401 | /         """
402 | |         Test objective: Verify history tracking for bulk deletion of settings.
403 | |         """
    | |___________^ D200
404 |           related_entity_id = str(uuid.uuid4())
405 |           setting_types = ["BULK01", "BULK02", "BULK03"]
    |
    = help: Reformat to one line

tests\models\test_setting_manager.py:401:9: D212 [*] Multi-line docstring summary should start at the first line
    |
400 |       def test_history_for_bulk_delete(self, setting_mgr: SettingManager) -> None:
401 | /         """
402 | |         Test objective: Verify history tracking for bulk deletion of settings.
403 | |         """
    | |___________^ D212
404 |           related_entity_id = str(uuid.uuid4())
405 |           setting_types = ["BULK01", "BULK02", "BULK03"]
    |
    = help: Remove whitespace after opening quotes

tests\models\test_simple.py:1:1: D200 One-line docstring should fit on one line
  |
1 | / """
2 | | Simple test file to verify pytest discovery.
3 | | """
  | |___^ D200
4 |
5 |   def test_simple():
  |
  = help: Reformat to one line

tests\models\test_simple.py:1:1: D212 [*] Multi-line docstring summary should start at the first line
  |
1 | / """
2 | | Simple test file to verify pytest discovery.
3 | | """
  | |___^ D212
4 |
5 |   def test_simple():
  |
  = help: Remove whitespace after opening quotes

tests\models\test_simple.py:5:5: ANN201 Missing return type annotation for public function `test_simple`
  |
3 | """
4 |
5 | def test_simple():
  |     ^^^^^^^^^^^ ANN201
6 |     """A simple test that should always pass."""
7 |     assert 1 + 1 == 2
  |
  = help: Add return type annotation: `None`

tests\models\test_snippet.py:1:1: D205 1 blank line required between summary line and description
  |
1 | / """
2 | | Combined unit tests for SnippetModel and SnippetManager.
3 | | Covers all CRUD, validation, edge cases, and error handling.
4 | | """
  | |___^ D205
5 |
6 |   import uuid
  |
  = help: Insert single blank line

tests\models\test_snippet.py:1:1: D212 [*] Multi-line docstring summary should start at the first line
  |
1 | / """
2 | | Combined unit tests for SnippetModel and SnippetManager.
3 | | Covers all CRUD, validation, edge cases, and error handling.
4 | | """
  | |___^ D212
5 |
6 |   import uuid
  |
  = help: Remove whitespace after opening quotes

tests\models\test_snippet.py:127:5: D103 Missing docstring in public function
    |
125 |     ],
126 | )
127 | def test_snippet_creation_validation(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D103
128 |     snippet_category_fixture: str,
129 |     snippet_manager: SnippetManager,
    |

tests\models\test_snippet.py:157:5: D103 Missing docstring in public function
    |
155 |     ],
156 | )
157 | def test_snippet_name_uniqueness(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D103
158 |     snippet_category_fixture: str,
159 |     snippet_manager: SnippetManager,
    |

tests\models\test_snippet.py:175:5: D103 Missing docstring in public function
    |
175 | def test_snippet_creation_valid(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ D103
176 |     snippet_manager: SnippetManager, valid_snippet_data: Dict[str, Union[str, str]]
177 | ) -> None:
    |

tests\models\test_snippet.py:193:5: D103 Missing docstring in public function
    |
193 | def test_get_nonexistent_snippet(snippet_manager: SnippetManager) -> None:
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D103
194 |     non_existent_snippet_id = str(uuid.uuid4())
195 |     assert snippet_manager.get_snippet_by_id(non_existent_snippet_id) is None
    |

tests\models\test_snippet.py:198:5: D103 Missing docstring in public function
    |
198 | def test_list_snippets_empty(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^ D103
199 |     snippet_category_fixture: str, snippet_manager: SnippetManager
200 | ) -> None:
    |

tests\models\test_snippet.py:218:5: D103 Missing docstring in public function
    |
218 | def test_list_snippets_populated(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D103
219 |     snippet_category_fixture: str, snippet_manager: SnippetManager
220 | ) -> None:
    |

tests\models\test_snippet.py:241:5: D103 Missing docstring in public function
    |
241 | def test_snippet_edit(
    |     ^^^^^^^^^^^^^^^^^ D103
242 |     snippet_manager: SnippetManager, valid_snippet_data: Dict[str, Union[str, str]]
243 | ) -> None:
    |

tests\models\test_snippet.py:260:5: D103 Missing docstring in public function
    |
260 | def test_snippet_update(snippet_category_fixture: str, snippet_manager: SnippetManager) -> None:
    |     ^^^^^^^^^^^^^^^^^^^ D103
261 |     from models.snippet import Snippet
    |

tests\models\test_snippet.py:274:5: D103 Missing docstring in public function
    |
274 | def test_snippet_update_name_only(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D103
275 |     snippet_category_fixture: str, snippet_manager: SnippetManager
276 | ) -> None:
    |

tests\models\test_snippet.py:291:5: D103 Missing docstring in public function
    |
291 | def test_snippet_update_content_only(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D103
292 |     snippet_category_fixture: str, snippet_manager: SnippetManager
293 | ) -> None:
    |

tests\models\test_snippet.py:308:5: D103 Missing docstring in public function
    |
308 | def test_snippet_delete(snippet_category_fixture: str, snippet_manager: SnippetManager) -> None:
    |     ^^^^^^^^^^^^^^^^^^^ D103
309 |     from models.snippet import Snippet
    |

tests\models\test_snippet.py:328:5: D103 Missing docstring in public function
    |
328 | def test_edit_snippet_change_category(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D103
329 |     snippet_manager: SnippetManager,
330 |     category_manager: CategoryManager,
    |

tests\models\test_snippet.py:351:5: D103 Missing docstring in public function
    |
351 | def test_edit_snippet_invalid_category(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D103
352 |     snippet_manager: SnippetManager, snippet_category_fixture: str
353 | ) -> None:
    |

tests\models\test_snippet.py:366:5: D103 Missing docstring in public function
    |
366 | def test_snippet_sql_injection(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ D103
367 |     snippet_category_fixture: str, snippet_manager: SnippetManager
368 | ) -> None:
    |

tests\models\test_snippet.py:375:5: D103 Missing docstring in public function
    |
375 | def test_snippet_sql_injection_in_content(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D103
376 |     snippet_category_fixture: str, snippet_manager: SnippetManager
377 | ) -> None:
    |

tests\models\test_snippet.py:384:5: D103 Missing docstring in public function
    |
384 | def test_snippet_long_content(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^ D103
385 |     snippet_category_fixture: str, snippet_manager: SnippetManager
386 | ) -> None:
    |

tests\models\test_snippet.py:398:5: D103 Missing docstring in public function
    |
398 | def test_snippet_content_splitting_boundaries(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D103
399 |     snippet_category_fixture: str, snippet_manager: SnippetManager
400 | ) -> None:
    |

tests\models\test_snippet.py:421:5: D103 Missing docstring in public function
    |
421 | def test_update_nonexistent_snippet(snippet_manager: SnippetManager) -> None:
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D103
422 |     non_existent_snippet_id = str(uuid.uuid4())
423 |     with pytest.raises(ForeignKeyError):
    |

tests\models\test_snippet.py:432:5: D103 Missing docstring in public function
    |
432 | def test_snippet_part_number_sequence(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D103
433 |     snippet_category_fixture: str, snippet_manager: SnippetManager, random_id: str
434 | ) -> None:
    |

tests\models\test_snippet.py:483:5: D205 1 blank line required between summary line and description
    |
482 |   def test_python_code_validation() -> None:
483 | /     """
484 | |     Test that Python code with quotes, equals signs, and other SQL-like patterns
485 | |     passes validation when used as snippet content.
486 | |     """
    | |_______^ D205
487 |       python_code = """import numpy as np
488 |   # Create an array
    |
    = help: Insert single blank line

tests\models\test_snippet.py:483:5: D212 [*] Multi-line docstring summary should start at the first line
    |
482 |   def test_python_code_validation() -> None:
483 | /     """
484 | |     Test that Python code with quotes, equals signs, and other SQL-like patterns
485 | |     passes validation when used as snippet content.
486 | |     """
    | |_______^ D212
487 |       python_code = """import numpy as np
488 |   # Create an array
    |
    = help: Remove whitespace after opening quotes

tests\models\test_snippet.py:523:5: D200 One-line docstring should fit on one line
    |
521 |       db_manager: DatabaseManager, snippet_category_fixture: str, random_id: str
522 |   ) -> None:
523 | /     """
524 | |     Test that snippet operations handle errors and success cases appropriately.
525 | |     """
    | |_______^ D200
526 |       # Create snippet manager
527 |       snippet_manager = SnippetManager(db_manager)
    |
    = help: Reformat to one line

tests\models\test_snippet.py:523:5: D212 [*] Multi-line docstring summary should start at the first line
    |
521 |       db_manager: DatabaseManager, snippet_category_fixture: str, random_id: str
522 |   ) -> None:
523 | /     """
524 | |     Test that snippet operations handle errors and success cases appropriately.
525 | |     """
    | |_______^ D212
526 |       # Create snippet manager
527 |       snippet_manager = SnippetManager(db_manager)
    |
    = help: Remove whitespace after opening quotes

tests\models\test_snippet.py:593:5: F811 Redefinition of unused `test_update_nonexistent_snippet` from line 421
    |
593 | def test_update_nonexistent_snippet(snippet_manager: SnippetManager) -> None:
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ F811
594 |     """Test updating a snippet that does not exist."""
595 |     non_existent_snippet_id = str(uuid.uuid4())
    |
    = help: Remove definition: `test_update_nonexistent_snippet`

tests\models\test_snippet.py:810:5: D103 Missing docstring in public function
    |
810 | def test_snippet_sql_injection_content_update(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D103
811 |     snippet_category_fixture: str, snippet_manager: SnippetManager
812 | ) -> None:
    |

tests\models\test_snippet.py:824:5: D103 Missing docstring in public function
    |
824 | def test_snippet_sql_injection_name_update(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D103
825 |     snippet_category_fixture: str, snippet_manager: SnippetManager
826 | ) -> None:
    |

tests\models\test_snippet.py:854:5: D103 Missing docstring in public function
    |
854 | def test_snippet_manager_handles_db_errors_gracefully_on_create(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D103
855 |     snippet_manager: SnippetManager, snippet_category_fixture: str, monkeypatch: MonkeyPatch
856 | ) -> None:
    |

tests\models\test_snippet.py:871:5: D103 Missing docstring in public function
    |
871 | def test_snippet_manager_handles_db_errors_gracefully_on_get(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D103
872 |     snippet_manager: SnippetManager, monkeypatch: MonkeyPatch
873 | ) -> None:
    |

tests\models\test_snippet.py:883:5: D103 Missing docstring in public function
    |
883 | def test_snippet_manager_handles_db_errors_gracefully_on_update(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D103
884 |     snippet_manager: SnippetManager, snippet_category_fixture: str, monkeypatch: MonkeyPatch
885 | ) -> None:
    |

tests\models\test_snippet.py:910:5: D103 Missing docstring in public function
    |
910 | def test_snippet_manager_handles_db_errors_gracefully_on_delete(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D103
911 |     snippet_manager: SnippetManager, snippet_category_fixture: str, monkeypatch: MonkeyPatch
912 | ) -> None:
    |

tests\models\test_snippet.py:948:5: D103 Missing docstring in public function
    |
948 | def test_snippet_manager_handles_db_errors_gracefully_on_list(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D103
949 |     snippet_manager: SnippetManager, snippet_category_fixture: str, monkeypatch: MonkeyPatch
950 | ) -> None:
    |

tests\models\test_snippet.py:960:5: D103 Missing docstring in public function
    |
960 | def test_snippet_manager_handles_db_errors_gracefully_on_search(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D103
961 |     snippet_manager: SnippetManager, monkeypatch: MonkeyPatch
962 | ) -> None:
    |

tests\models\test_snippet_manager.py:1:1: D205 1 blank line required between summary line and description
  |
1 | / """
2 | | Unit tests for the SnippetManager class.
3 | | Covers CRUD operations, validation, edge cases, and error handling for snippets.
4 | | """
  | |___^ D205
5 |
6 |   import datetime
  |
  = help: Insert single blank line

tests\models\test_snippet_manager.py:1:1: D212 [*] Multi-line docstring summary should start at the first line
  |
1 | / """
2 | | Unit tests for the SnippetManager class.
3 | | Covers CRUD operations, validation, edge cases, and error handling for snippets.
4 | | """
  | |___^ D212
5 |
6 |   import datetime
  |
  = help: Remove whitespace after opening quotes

tests\models\test_snippet_manager.py:56:9: D102 Missing docstring in public method
   |
54 |     """Tests for SnippetManager.save_snippet() method (creation and update)."""
55 |
56 |     def test_create_snippet_happy_path(
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
57 |         self, snippet_mgr: SnippetManager, sample_category: Category
58 |     ) -> None:
   |

tests\models\test_snippet_manager.py:174:9: D205 1 blank line required between summary line and description
    |
172 |           self, snippet_mgr: SnippetManager
173 |       ) -> None:
174 | /         """
175 | |         Test objective: Verify ForeignKeyError for non-existent category ID
176 | |         (foreign key constraint).
177 | |         """
    | |___________^ D205
178 |           non_existent_category_id = str(uuid.uuid4())  # Assuming this ID does not exist
179 |           with pytest.raises(ForeignKeyError):
    |
    = help: Insert single blank line

tests\models\test_snippet_manager.py:174:9: D212 [*] Multi-line docstring summary should start at the first line
    |
172 |           self, snippet_mgr: SnippetManager
173 |       ) -> None:
174 | /         """
175 | |         Test objective: Verify ForeignKeyError for non-existent category ID
176 | |         (foreign key constraint).
177 | |         """
    | |___________^ D212
178 |           non_existent_category_id = str(uuid.uuid4())  # Assuming this ID does not exist
179 |           with pytest.raises(ForeignKeyError):
    |
    = help: Remove whitespace after opening quotes

tests\models\test_snippet_manager.py:226:9: D205 1 blank line required between summary line and description
    |
224 |           self, snippet_mgr: SnippetManager, sample_category: Category
225 |       ) -> None:
226 | /         """
227 | |         Test objective: Ensure SnippetManager's internal check for empty content parts is not
228 | |         triggered if Pydantic validation (content min_length=1) is effective.
229 | |         """
    | |___________^ D205
230 |           try:
231 |               # Use minimal valid content
    |
    = help: Insert single blank line

tests\models\test_snippet_manager.py:226:9: D212 [*] Multi-line docstring summary should start at the first line
    |
224 |           self, snippet_mgr: SnippetManager, sample_category: Category
225 |       ) -> None:
226 | /         """
227 | |         Test objective: Ensure SnippetManager's internal check for empty content parts is not
228 | |         triggered if Pydantic validation (content min_length=1) is effective.
229 | |         """
    | |___________^ D212
230 |           try:
231 |               # Use minimal valid content
    |
    = help: Remove whitespace after opening quotes

tests\models\test_snippet_manager.py:254:9: D102 Missing docstring in public method
    |
252 |     """Tests for SnippetManager.get_starting_index() method."""
253 |
254 |     def test_get_starting_index_no_sessions(
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
255 |         self, snippet_mgr: SnippetManager, sample_category: Category
256 |     ) -> None:
    |

tests\models\test_snippet_manager.py:269:9: D102 Missing docstring in public method
    |
267 |         assert idx == 0
268 |
269 |     def test_get_starting_index_with_sessions(
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
270 |         self, snippet_mgr: SnippetManager, sample_category: Category
271 |     ) -> None:
    |

tests\models\test_snippet_manager.py:309:9: D102 Missing docstring in public method
    |
307 |         assert idx == 3  # Next should be 'd'
308 |
309 |     def test_get_starting_index_wraps_to_zero(
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
310 |         self, snippet_mgr: SnippetManager, sample_category: Category
311 |     ) -> None:
    |

tests\models\test_snippet_manager.py:349:9: D102 Missing docstring in public method
    |
347 |         assert idx == 0
348 |
349 |     def test_get_starting_index_greater_than_length(
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
350 |         self, snippet_mgr: SnippetManager, sample_category: Category
351 |     ) -> None:
    |

tests\models\test_snippet_manager.py:389:9: D102 Missing docstring in public method
    |
387 |         assert idx == 0
388 |
389 |     def test_get_starting_index_different_user_keyboard(
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
390 |         self, snippet_mgr: SnippetManager, sample_category: Category
391 |     ) -> None:
    |

tests\models\test_user_manager_fixes.py:1:1: D205 1 blank line required between summary line and description
  |
1 | / """
2 | | Tests for UserManager database access pattern fixes.
3 | | Specifically tests the fixes for psycopg2.ProgrammingError: no results to fetch.
4 | | """
  | |___^ D205
5 |
6 |   import pytest
  |
  = help: Insert single blank line

tests\models\test_user_manager_fixes.py:1:1: D212 [*] Multi-line docstring summary should start at the first line
  |
1 | / """
2 | | Tests for UserManager database access pattern fixes.
3 | | Specifically tests the fixes for psycopg2.ProgrammingError: no results to fetch.
4 | | """
  | |___^ D212
5 |
6 |   import pytest
  |
  = help: Remove whitespace after opening quotes

tests\models\test_user_manager_fixes.py:6:1: I001 [*] Import block is un-sorted or un-formatted
   |
 4 |   """
 5 |
 6 | / import pytest
 7 | | from unittest.mock import Mock, MagicMock
 8 | | from typing import Dict, Any, List
 9 | | import uuid
10 | |
11 | | from models.user_manager import UserManager, UserNotFound, UserValidationError
12 | | from models.user import User
   | |____________________________^ I001
   |
   = help: Organize imports

tests\models\test_user_manager_fixes.py:7:33: F401 [*] `unittest.mock.MagicMock` imported but unused
  |
6 | import pytest
7 | from unittest.mock import Mock, MagicMock
  |                                 ^^^^^^^^^ F401
8 | from typing import Dict, Any, List
9 | import uuid
  |
  = help: Remove unused import: `unittest.mock.MagicMock`

tests\models\test_user_manager_fixes.py:12:25: F401 [*] `models.user.User` imported but unused
   |
11 | from models.user_manager import UserManager, UserNotFound, UserValidationError
12 | from models.user import User
   |                         ^^^^ F401
   |
   = help: Remove unused import: `models.user.User`

text_randomizer.py:2:1: D212 [*] Multi-line docstring summary should start at the first line
  |
1 |   #!/usr/bin/env python3
2 | / """
3 | | Text Randomizer Program
4 | |
5 | | Takes a long string of text, extracts unique words (split by space),
6 | | and outputs them in random order with each word appearing at most twice.
7 | | """
  | |___^ D212
8 |
9 |   import random
  |
  = help: Remove whitespace after opening quotes

text_randomizer.py:2:1: D415 First line should end with a period, question mark, or exclamation point
  |
1 |   #!/usr/bin/env python3
2 | / """
3 | | Text Randomizer Program
4 | |
5 | | Takes a long string of text, extracts unique words (split by space),
6 | | and outputs them in random order with each word appearing at most twice.
7 | | """
  | |___^ D415
8 |
9 |   import random
  |
  = help: Add closing punctuation

text_randomizer.py:14:5: D212 [*] Multi-line docstring summary should start at the first line
   |
13 |   def randomize_text_words(input_text: str) -> str:
14 | /     """
15 | |     Process input text to create a randomized output with unique words appearing at most twice.
16 | |
17 | |     Args:
18 | |         input_text: The input string to process
19 | |
20 | |     Returns:
21 | |         A space-delimited string with words in random order, each appearing at most twice
22 | |     """
   | |_______^ D212
23 |       # Split text into words by spaces and get unique words
24 |       words = input_text.split()
   |
   = help: Remove whitespace after opening quotes

web_ui\__init_LLM_ngrams__.py:1:1: D100 Missing docstring in public module
web_ui\__init_LLM_ngrams__.py:9:5: ANN201 Missing return type annotation for public function `ngram_words_page`
   |
 8 | @web_ui.route("/ngram-words", methods=["GET"])
 9 | def ngram_words_page():
   |     ^^^^^^^^^^^^^^^^ ANN201
10 |     return render_template("ngram_words.html")
   |
   = help: Add return type annotation

web_ui\__init_LLM_ngrams__.py:9:5: D103 Missing docstring in public function
   |
 8 | @web_ui.route("/ngram-words", methods=["GET"])
 9 | def ngram_words_page():
   |     ^^^^^^^^^^^^^^^^ D103
10 |     return render_template("ngram_words.html")
   |

web_ui\__init_LLM_ngrams__.py:14:5: ANN201 Missing return type annotation for public function `api_ngram_words`
   |
13 | @web_ui.route("/api/ngram-words", methods=["POST"])
14 | def api_ngram_words():
   |     ^^^^^^^^^^^^^^^ ANN201
15 |     data = request.get_json()
16 |     snippets = data.get("snippets", [])
   |
   = help: Add return type annotation

web_ui\__init_LLM_ngrams__.py:14:5: D103 Missing docstring in public function
   |
13 | @web_ui.route("/api/ngram-words", methods=["POST"])
14 | def api_ngram_words():
   |     ^^^^^^^^^^^^^^^ D103
15 |     data = request.get_json()
16 |     snippets = data.get("snippets", [])
   |

web_ui\__init_LLM_ngrams__.py:27:13: F821 Undefined name `os`
   |
25 |     try:
26 |         with open(
27 |             os.path.join(os.path.dirname(__file__), "../Keys/OpenAPI_Key.txt"), "r"
   |             ^^ F821
28 |         ) as f:
29 |             openai.api_key = f.read().strip()
   |

web_ui\__init_LLM_ngrams__.py:27:26: F821 Undefined name `os`
   |
25 |     try:
26 |         with open(
27 |             os.path.join(os.path.dirname(__file__), "../Keys/OpenAPI_Key.txt"), "r"
   |                          ^^ F821
28 |         ) as f:
29 |             openai.api_key = f.read().strip()
   |

web_ui\__init_LLM_ngrams__.py:38:121: E501 Line too long (340 > 120)
   |
36 | ΓÇª
37 | ΓÇª
38 | ΓÇªngrams {ngrams}. Can you please assemble this list in random order into a space delimited string, with a maximum length of {max_length} characters. I'm OK if you repeat certain words, and also if you include the actual ngram.
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
39 | ΓÇª
   |

web_ui\__init_LLM_ngrams__.py:51:5: F841 Local variable `generated_text` is assigned to but never used
   |
49 |     )
50 |
51 |     generated_text = response.choices[0].text.strip()
   |     ^^^^^^^^^^^^^^ F841
52 |
53 |     # --- Replace this with your OpenAI API key and call if available ---
   |
   = help: Remove assignment to unused variable `generated_text`

web_ui\__init__.py:1:1: D104 Missing docstring in public package
Found 1895 errors.
[*] 520 fixable with the `--fix` option (364 hidden fixes can be enabled with the `--unsafe-fixes` option).
============================= test session starts =============================
platform win32 -- Python 3.13.2, pytest-8.4.1, pluggy-1.6.0 -- D:\SeanDevLocal\AITypingTrainer\.venv\Scripts\python.exe
cachedir: .pytest_cache
PySide6 6.9.1 -- Qt runtime 6.9.1 -- Qt compiled 6.9.1
rootdir: D:\SeanDevLocal\AITypingTrainer
configfile: pytest.ini
plugins: anyio-4.10.0, cov-6.2.1, mock-3.14.1, qt-4.5.0
collecting ... collected 509 items

tests/models/test_category.py::TestCategoryModel::test_category_creation_valid PASSED [  0%]
tests/models/test_category.py::TestCategoryModel::test_category_name_validation[-Category name cannot be blank.] PASSED [  0%]
tests/models/test_category.py::TestCategoryModel::test_category_name_validation[   -Category name cannot be blank.] PASSED [  0%]
tests/models/test_category.py::TestCategoryModel::test_category_name_validation[AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA-Category name must be at most 64 characters.] PASSED [  0%]
tests/models/test_category.py::TestCategoryModel::test_category_name_validation[NonASCII\xd1ame-Category name must be ASCII-only.] PASSED [  0%]
tests/models/test_category.py::TestCategoryModel::test_category_exceptions_instantiable PASSED [  1%]
tests/models/test_category.py::TestCategoryModel::test_category_init_autogenerates_id PASSED [  1%]
tests/models/test_category.py::TestCategoryModel::test_category_from_dict_valid_and_extra_fields PASSED [  1%]
tests/models/test_category.py::TestCategoryModel::test_category_to_dict PASSED [  1%]
tests/models/test_category.py::TestCategoryModel::test_category_field_type_and_value_errors[category_id-123-Input should be a valid string] PASSED [  1%]
tests/models/test_category.py::TestCategoryModel::test_category_field_type_and_value_errors[category_id-not-a-uuid-category_id must be a valid UUID string] PASSED [  2%]
tests/models/test_category.py::TestCategoryModel::test_category_field_type_and_value_errors[category_name-None-Input should be a valid string] PASSED [  2%]
tests/models/test_category.py::TestCategoryModel::test_category_field_type_and_value_errors[category_name--Category name cannot be blank] PASSED [  2%]
tests/models/test_category.py::TestCategoryModel::test_category_field_type_and_value_errors[category_name- -Category name cannot be blank] PASSED [  2%]
tests/models/test_category.py::TestCategoryModel::test_category_field_type_and_value_errors[category_name-AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA-Category name must be at most 64 characters] PASSED [  2%]
tests/models/test_category.py::TestCategoryModel::test_category_field_type_and_value_errors[category_name-NonASCII\xd1ame-Category name must be ASCII-only] PASSED [  3%]
tests/models/test_category.py::TestCategoryModel::test_category_db_rows_fail_validation PASSED [  3%]
tests/models/test_category_manager.py::TestCategoryManager::test_create_category_valid PASSED [  3%]
tests/models/test_category_manager.py::TestCategoryManager::test_create_category_invalid_format[-blank] PASSED [  3%]
tests/models/test_category_manager.py::TestCategoryManager::test_create_category_invalid_format[  -blank] PASSED [  3%]
tests/models/test_category_manager.py::TestCategoryManager::test_create_category_invalid_format[AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA-at most 64 characters] PASSED [  4%]
tests/models/test_category_manager.py::TestCategoryManager::test_create_category_invalid_format[Caf\xe9 NonASCII-ASCII-only] PASSED [  4%]
tests/models/test_category_manager.py::TestCategoryManager::test_create_category_duplicate_name PASSED [  4%]
tests/models/test_category_manager.py::TestCategoryManager::test_get_category_by_id PASSED [  4%]
tests/models/test_category_manager.py::TestCategoryManager::test_get_category_by_id_not_found PASSED [  4%]
tests/models/test_category_manager.py::TestCategoryManager::test_get_category_by_id_invalid_uuid PASSED [  5%]
tests/models/test_category_manager.py::TestCategoryManager::test_get_category_by_name PASSED [  5%]
tests/models/test_category_manager.py::TestCategoryManager::test_get_category_by_name_not_found PASSED [  5%]
tests/models/test_category_manager.py::TestCategoryManager::test_get_category_by_name_case_sensitive PASSED [  5%]
tests/models/test_category_manager.py::TestCategoryManager::test_list_all_categories_empty PASSED [  5%]
tests/models/test_category_manager.py::TestCategoryManager::test_list_all_categories_populated PASSED [  6%]
tests/models/test_category_manager.py::TestCategoryManager::test_update_category_valid_name PASSED [  6%]
tests/models/test_category_manager.py::TestCategoryManager::test_update_category_invalid_format[-blank] PASSED [  6%]
tests/models/test_category_manager.py::TestCategoryManager::test_update_category_invalid_format[AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA-at most 64 characters] PASSED [  6%]
tests/models/test_category_manager.py::TestCategoryManager::test_update_category_invalid_format[Caf\xe9 Again-ASCII-only] PASSED [  6%]
tests/models/test_category_manager.py::TestCategoryManager::test_update_category_to_duplicate_name PASSED [  7%]
tests/models/test_category_manager.py::TestCategoryManager::test_update_category_to_case_variant_duplicate PASSED [  7%]
tests/models/test_category_manager.py::TestCategoryManager::test_update_category_to_same_name PASSED [  7%]
tests/models/test_category_manager.py::TestCategoryManager::test_delete_category_by_id PASSED [  7%]
tests/models/test_category_manager.py::TestCategoryManager::test_delete_category_by_id_invalid_uuid PASSED [  7%]
tests/models/test_category_manager.py::TestCategoryManager::test_delete_nonexistent_category PASSED [  8%]
tests/models/test_category_manager.py::TestCategoryManager::test_delete_all_categories PASSED [  8%]
tests/models/test_category_manager.py::TestCategoryManager::test_category_validation_blank_and_duplicate PASSED [  8%]
tests/models/test_category_manager.py::TestCategoryManager::test_save_category_non_string_name PASSED [  8%]
tests/models/test_category_manager.py::TestCategoryManager::test_delete_category_alias PASSED [  8%]
tests/models/test_category_manager.py::TestCategoryManager::test_save_category_unexpected_db_error PASSED [  9%]
tests/models/test_dynamic_content_manager.py::TestDynamicContentManagerInitialization::test_init_with_valid_params PASSED [  9%]
tests/models/test_dynamic_content_manager.py::TestDynamicContentManagerInitialization::test_init_with_defaults PASSED [  9%]
tests/models/test_dynamic_content_manager.py::TestDynamicContentManagerInitialization::test_invalid_practice_length_too_small PASSED [  9%]
tests/models/test_dynamic_content_manager.py::TestDynamicContentManagerInitialization::test_invalid_practice_length_too_large PASSED [  9%]
tests/models/test_dynamic_content_manager.py::TestDynamicContentManagerInitialization::test_invalid_practice_length_type PASSED [ 10%]
tests/models/test_dynamic_content_manager.py::TestDynamicContentManagerInitialization::test_mode_setter_with_string PASSED [ 10%]
tests/models/test_dynamic_content_manager.py::TestDynamicContentManagerInitialization::test_mode_setter_with_invalid_string PASSED [ 10%]
tests/models/test_dynamic_content_manager.py::TestDynamicContentManagerInitialization::test_mode_setter_with_enum PASSED [ 10%]
tests/models/test_dynamic_content_manager.py::TestDynamicContentManagerValidation::test_validate_missing_ngrams PASSED [ 10%]
tests/models/test_dynamic_content_manager.py::TestDynamicContentManagerValidation::test_validate_missing_in_scope_keys PASSED [ 11%]
tests/models/test_dynamic_content_manager.py::TestDynamicContentManagerValidation::test_validate_missing_llm_service_for_words_mode PASSED [ 11%]
tests/models/test_dynamic_content_manager.py::TestDynamicContentManagerValidation::test_validate_missing_llm_service_for_mixed_mode PASSED [ 11%]
tests/models/test_dynamic_content_manager.py::TestNGramOnlyMode::test_generate_ngram_content FAILED [ 11%]
tests/models/test_dynamic_content_manager.py::TestNGramOnlyMode::test_ngram_content_custom_delimiter PASSED [ 11%]
tests/models/test_dynamic_content_manager.py::TestNGramOnlyMode::test_ngram_content_respects_length_limit PASSED [ 11%]
tests/models/test_dynamic_content_manager.py::TestNGramOnlyMode::test_ngram_content_filters_out_of_scope_chars FAILED [ 12%]
tests/models/test_dynamic_content_manager.py::TestWordsOnlyMode::test_generate_words_content PASSED [ 12%]
tests/models/test_dynamic_content_manager.py::TestWordsOnlyMode::test_words_content_filters_out_of_scope_chars PASSED [ 12%]
tests/models/test_dynamic_content_manager.py::TestWordsOnlyMode::test_words_content_custom_delimiter PASSED [ 12%]
tests/models/test_dynamic_content_manager.py::TestMixedMode::test_generate_mixed_content PASSED [ 12%]
tests/models/test_dynamic_content_manager.py::TestMixedMode::test_mixed_content_has_variety FAILED [ 13%]
tests/models/test_keyboard.py::test_keyboard_valid PASSED                [ 13%]
tests/models/test_keyboard.py::test_keyboard_empty_name PASSED           [ 13%]
tests/models/test_keyboard.py::test_keyboard_name_strip PASSED           [ 13%]
tests/models/test_keyboard.py::test_keyboard_default_target_ms PASSED    [ 13%]
tests/models/test_keyboard.py::test_keyboard_custom_target_ms PASSED     [ 14%]
tests/models/test_keyboard.py::test_keyboard_target_ms_too_low PASSED    [ 14%]
tests/models/test_keyboard.py::test_keyboard_target_ms_too_high PASSED   [ 14%]
tests/models/test_keyboard.py::test_keyboard_target_ms_none PASSED       [ 14%]
tests/models/test_keyboard_manager.py::test_create_keyboard PASSED       [ 14%]
tests/models/test_keyboard_manager.py::test_get_keyboard PASSED          [ 15%]
tests/models/test_keyboard_manager.py::test_update_keyboard_name PASSED  [ 15%]
tests/models/test_keyboard_manager.py::test_update_keyboard_target_speed PASSED [ 15%]
tests/models/test_keyboard_manager.py::test_delete_keyboard PASSED       [ 15%]
tests/models/test_keystroke.py::TestKeystrokeCreation::test_keystroke_creation_with_valid_data PASSED [ 15%]
tests/models/test_keystroke.py::TestKeystrokeCreation::test_keystroke_creation_with_defaults PASSED [ 16%]
tests/models/test_keystroke.py::TestKeystrokeCreation::test_keystroke_id_auto_generation PASSED [ 16%]
tests/models/test_keystroke.py::TestKeystrokeCreation::test_keystroke_time_auto_generation PASSED [ 16%]
tests/models/test_keystroke.py::TestKeystrokeCreation::test_keystroke_with_none_session_id PASSED [ 16%]
tests/models/test_keystroke.py::TestKeystrokeCreation::test_keystroke_with_error_true PASSED [ 16%]
tests/models/test_keystroke.py::TestKeystrokeCreation::test_keystroke_with_empty_strings PASSED [ 17%]
tests/models/test_keystroke.py::TestKeystrokeCreation::test_keystroke_with_valid_text_index PASSED [ 17%]
tests/models/test_keystroke.py::TestKeystrokeCreation::test_keystroke_with_negative_text_index_raises_error PASSED [ 17%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_with_valid_data PASSED [ 17%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_with_minimal_data PASSED [ 17%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_datetime_iso_string PASSED [ 18%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_datetime_iso_string_with_z PASSED [ 18%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_invalid_datetime_string PASSED [ 18%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_non_datetime_object PASSED [ 18%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_is_error_string_values[true-True] PASSED [ 18%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_is_error_string_values[True-True] PASSED [ 19%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_is_error_string_values[1-True] PASSED [ 19%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_is_error_string_values[t-True] PASSED [ 19%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_is_error_string_values[y-True] PASSED [ 19%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_is_error_string_values[yes-True] PASSED [ 19%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_is_error_string_values[false-False] PASSED [ 20%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_is_error_string_values[False-False] PASSED [ 20%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_is_error_string_values[0-False] PASSED [ 20%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_is_error_string_values[f-False] PASSED [ 20%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_is_error_string_values[n-False] PASSED [ 20%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_is_error_string_values[no-False] PASSED [ 21%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_is_error_string_values[-False] PASSED [ 21%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_is_error_string_values[other-False] PASSED [ 21%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_is_error_integer_values[0-False] PASSED [ 21%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_is_error_integer_values[1-True] PASSED [ 21%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_is_error_integer_values[-1-True] PASSED [ 22%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_is_error_integer_values[42-True] PASSED [ 22%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_is_error_none_value PASSED [ 22%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_session_id_conversion PASSED [ 22%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_session_id_invalid_conversion PASSED [ 22%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_keystroke_id_conversion PASSED [ 22%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_keystroke_id_invalid_conversion PASSED [ 23%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_empty_dict PASSED [ 23%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_text_index_valid_conversion[0-0_0] PASSED [ 23%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_text_index_valid_conversion[5-5_0] PASSED [ 23%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_text_index_valid_conversion[42-42_0] PASSED [ 23%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_text_index_valid_conversion[999999-999999_0] PASSED [ 24%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_text_index_valid_conversion[0-0_1] PASSED [ 24%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_text_index_valid_conversion[5-5_1] PASSED [ 24%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_text_index_valid_conversion[42-42_1] PASSED [ 24%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_text_index_valid_conversion[999999-999999_1] PASSED [ 24%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_text_index_invalid_conversion[invalid] PASSED [ 25%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_text_index_invalid_conversion[not-a-number] PASSED [ 25%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_text_index_invalid_conversion[text_index_value2] PASSED [ 25%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_text_index_invalid_conversion[text_index_value3] PASSED [ 25%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_text_index_invalid_conversion[None] PASSED [ 25%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_text_index_invalid_conversion[-1_0] PASSED [ 26%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_text_index_invalid_conversion[-100_0] PASSED [ 26%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_text_index_invalid_conversion[-1_1] PASSED [ 26%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_text_index_invalid_conversion[-100_1] PASSED [ 26%]
tests/models/test_keystroke.py::TestKeystrokeToDict::test_to_dict_complete_data PASSED [ 26%]
tests/models/test_keystroke.py::TestKeystrokeToDict::test_to_dict_datetime_serialization PASSED [ 27%]
tests/models/test_keystroke.py::TestKeystrokeToDict::test_to_dict_with_none_values PASSED [ 27%]
tests/models/test_keystroke.py::TestKeystrokeToDict::test_to_dict_roundtrip PASSED [ 27%]
tests/models/test_keystroke.py::TestKeystrokeClassMethods::test_get_for_session_success PASSED [ 27%]
tests/models/test_keystroke.py::TestKeystrokeClassMethods::test_get_for_session_empty_result PASSED [ 27%]
tests/models/test_keystroke.py::TestKeystrokeClassMethods::test_get_for_session_none_result PASSED [ 28%]
tests/models/test_keystroke.py::TestKeystrokeClassMethods::test_get_errors_for_session_success PASSED [ 28%]
tests/models/test_keystroke.py::TestKeystrokeClassMethods::test_get_errors_for_session_empty_result PASSED [ 28%]
tests/models/test_keystroke.py::TestKeystrokeClassMethods::test_delete_all_keystrokes_success PASSED [ 28%]
tests/models/test_keystroke.py::TestKeystrokeClassMethods::test_delete_all_keystrokes_exception PASSED [ 28%]
tests/models/test_keystroke.py::TestKeystrokeEdgeCases::test_keystroke_with_unicode_characters PASSED [ 29%]
tests/models/test_keystroke.py::TestKeystrokeEdgeCases::test_keystroke_with_special_characters PASSED [ 29%]
tests/models/test_keystroke.py::TestKeystrokeEdgeCases::test_keystroke_with_very_long_strings PASSED [ 29%]
tests/models/test_keystroke.py::TestKeystrokeEdgeCases::test_keystroke_with_negative_time_since_previous PASSED [ 29%]
tests/models/test_keystroke.py::TestKeystrokeEdgeCases::test_keystroke_with_zero_time_since_previous PASSED [ 29%]
tests/models/test_keystroke.py::TestKeystrokeEdgeCases::test_keystroke_with_very_large_time_since_previous PASSED [ 30%]
tests/models/test_keystroke.py::TestKeystrokeEdgeCases::test_from_dict_with_extra_fields PASSED [ 30%]
tests/models/test_keystroke.py::TestKeystrokeIntegration::test_full_workflow_create_save_retrieve PASSED [ 30%]
tests/models/test_keystroke.py::TestKeystrokeIntegration::test_model_consistency_with_specification PASSED [ 30%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerInitialization::test_init_default_database_manager PASSED [ 30%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerInitialization::test_init_custom_database_manager PASSED [ 31%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerInitialization::test_init_none_database_manager PASSED [ 31%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerAddKeystroke::test_add_single_keystroke PASSED [ 31%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerAddKeystroke::test_add_multiple_keystrokes PASSED [ 31%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerAddKeystroke::test_add_keystroke_with_error PASSED [ 31%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerGetKeystrokesForSession::test_get_keystrokes_for_session_success PASSED [ 32%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerGetKeystrokesForSession::test_get_keystrokes_for_session_empty PASSED [ 32%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerGetKeystrokesForSession::test_get_keystrokes_replaces_existing_list PASSED [ 32%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerGetKeystrokesForSession::test_get_keystrokes_with_uuid_session_id PASSED [ 32%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerSaveKeystrokes::test_save_keystrokes_success FAILED [ 32%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerSaveKeystrokes::test_save_keystrokes_empty_list PASSED [ 33%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerSaveKeystrokes::test_save_keystrokes_database_error FAILED [ 33%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerSaveKeystrokes::test_save_keystrokes_with_special_characters FAILED [ 33%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerSaveKeystrokes::test_save_keystrokes_boolean_conversion FAILED [ 33%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerDeleteKeystrokes::test_delete_keystrokes_by_session_success PASSED [ 33%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerDeleteKeystrokes::test_delete_keystrokes_by_session_database_error PASSED [ 33%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerDeleteKeystrokes::test_delete_keystrokes_by_session_uuid PASSED [ 34%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerDeleteKeystrokes::test_delete_all_keystrokes_success PASSED [ 34%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerDeleteKeystrokes::test_delete_all_keystrokes_database_error PASSED [ 34%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerDeleteKeystrokes::test_delete_keystrokes_empty_session_id PASSED [ 34%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerCountKeystrokes::test_count_keystrokes_dict_result PASSED [ 34%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerCountKeystrokes::test_count_keystrokes_tuple_result PASSED [ 35%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerCountKeystrokes::test_count_keystrokes_zero_result PASSED [ 35%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerCountKeystrokes::test_count_keystrokes_none_result PASSED [ 35%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerCountKeystrokes::test_count_keystrokes_none_count_value PASSED [ 35%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerCountKeystrokes::test_count_keystrokes_database_error PASSED [ 35%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerCountKeystrokes::test_count_keystrokes_result_conversion_error PASSED [ 36%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerCountKeystrokes::test_count_keystrokes_uuid_session_id PASSED [ 36%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerIntegration::test_full_keystroke_workflow FAILED [ 36%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerIntegration::test_concurrent_session_handling PASSED [ 36%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerEdgeCases::test_extreme_session_id_values PASSED [ 36%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerEdgeCases::test_extreme_keystroke_values PASSED [ 37%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerEdgeCases::test_unicode_and_special_characters FAILED [ 37%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerEdgeCases::test_memory_management_large_list PASSED [ 37%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerErrorHandling::test_database_connection_failure FAILED [ 37%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerErrorHandling::test_invalid_keystroke_data PASSED [ 37%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerErrorHandling::test_partial_save_failure FAILED [ 38%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerErrorHandling::test_network_timeout_simulation FAILED [ 38%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerCompatibility::test_different_datetime_formats PASSED [ 38%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerCompatibility::test_boolean_variations PASSED [ 38%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerCompatibility::test_numeric_edge_cases PASSED [ 38%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerCompatibility::test_string_encoding_variants PASSED [ 39%]
tests/models/test_llm_ngram_service.py::test_missing_api_key FAILED      [ 39%]
tests/models/test_llm_ngram_service.py::test_invalid_ngrams PASSED       [ 39%]
tests/models/test_llm_ngram_service.py::test_llm_success PASSED          [ 39%]
tests/models/test_llm_ngram_service.py::test_llm_trims_to_max_length PASSED [ 39%]
tests/models/test_next_session_position.py::test_get_next_position_no_previous_session PASSED [ 40%]
tests/models/test_next_session_position.py::test_get_next_position_continue_from_previous PASSED [ 40%]
tests/models/test_next_session_position.py::test_get_next_position_wrap_around PASSED [ 40%]
tests/models/test_next_session_position.py::test_get_next_position_beyond_length PASSED [ 40%]
tests/models/test_next_session_position.py::test_get_next_position_multiple_sessions PASSED [ 40%]
tests/models/test_ngram.py::TestKeystroke::test_keystroke_basic PASSED   [ 41%]
tests/models/test_ngram.py::TestKeystroke::test_keystroke_nfc_single_char FAILED [ 41%]
tests/models/test_ngram.py::TestNGramTextRules::test_has_sequence_separators PASSED [ 41%]
tests/models/test_ngram.py::TestNGramTextRules::test_is_valid_ngram_text PASSED [ 41%]
tests/models/test_ngram.py::TestSpeedNGram::test_speed_ngram_computes_ms_per_keystroke PASSED [ 41%]
tests/models/test_ngram.py::TestSpeedNGram::test_speed_ngram_rejects_separators PASSED [ 42%]
tests/models/test_ngram.py::TestSpeedNGram::test_speed_ngram_invalid_size PASSED [ 42%]
tests/models/test_ngram.py::TestSpeedNGram::test_speed_ngram_at_max_size PASSED [ 42%]
tests/models/test_ngram.py::TestSpeedNGram::test_speed_ngram_rejects_over_max PASSED [ 42%]
tests/models/test_ngram.py::TestErrorNGram::test_error_ngram_pattern_last_char_only PASSED [ 42%]
tests/models/test_ngram.py::TestErrorNGram::test_error_ngram_pattern_invalid_first_char PASSED [ 43%]
tests/models/test_ngram.py::TestErrorNGram::test_error_ngram_rejects_separators PASSED [ 43%]
tests/models/test_ngram.py::TestErrorNGram::test_error_ngram_at_max_size PASSED [ 43%]
tests/models/test_ngram.py::TestErrorNGram::test_error_ngram_rejects_over_max PASSED [ 43%]
tests/models/test_ngram_analytics_service.py::TestDecayingAverageCalculator::test_calculate_decaying_average_basic PASSED [ 43%]
tests/models/test_ngram_analytics_service.py::TestDecayingAverageCalculator::test_calculate_decaying_average_single_value PASSED [ 44%]
tests/models/test_ngram_analytics_service.py::TestDecayingAverageCalculator::test_calculate_decaying_average_empty_values PASSED [ 44%]
tests/models/test_ngram_analytics_service.py::TestDecayingAverageCalculator::test_calculate_decaying_average_max_samples PASSED [ 44%]
tests/models/test_ngram_analytics_service.py::TestNGramAnalyticsService::test_init_with_valid_dependencies PASSED [ 44%]
tests/models/test_ngram_analytics_service.py::TestNGramAnalyticsService::test_init_with_none_dependencies PASSED [ 44%]
tests/models/test_ngram_analytics_service.py::TestNGramAnalyticsService::test_refresh_speed_summaries_basic ERROR [ 44%]
tests/models/test_ngram_analytics_service.py::TestNGramAnalyticsService::test_get_speed_heatmap_data_basic SKIPPED [ 45%]
tests/models/test_ngram_analytics_service.py::TestNGramAnalyticsService::test_get_performance_trends_basic SKIPPED [ 45%]
tests/models/test_ngram_analytics_service.py::TestNGramAnalyticsService::test_slowest_n_moved_from_ngram_manager SKIPPED [ 45%]
tests/models/test_ngram_analytics_service.py::TestNGramAnalyticsService::test_error_n_moved_from_ngram_manager SKIPPED [ 45%]
tests/models/test_ngram_analytics_service.py::TestNGramAnalyticsService::test_dual_insert_creates_records_in_both_tables FAILED [ 45%]
tests/models/test_ngram_analytics_service.py::TestNGramAnalyticsService::test_history_table_accumulates_all_records FAILED [ 46%]
tests/models/test_ngram_analytics_service.py::TestNGramAnalyticsService::test_get_ngram_history_retrieval FAILED [ 46%]
tests/models/test_ngram_analytics_service.py::TestNGramAnalyticsService::test_history_table_schema_compatibility FAILED [ 46%]
tests/models/test_ngram_analytics_service.py::TestNGramPerformanceData::test_valid_performance_data PASSED [ 46%]
tests/models/test_ngram_analytics_service.py::TestNGramPerformanceData::test_invalid_performance_data PASSED [ 46%]
tests/models/test_ngram_analytics_service.py::TestNGramHeatmapData::test_valid_heatmap_data PASSED [ 47%]
tests/models/test_ngram_analytics_service_session_methods.py::TestSummarizeSessionNgrams::test_summarize_with_ngram_speed_only[1-1] ERROR [ 47%]
tests/models/test_ngram_analytics_service_session_methods.py::TestSummarizeSessionNgrams::test_summarize_with_ngram_speed_only[3-3] ERROR [ 47%]
tests/models/test_ngram_analytics_service_session_methods.py::TestSummarizeSessionNgrams::test_summarize_with_ngram_errors_only[1-1] ERROR [ 47%]
tests/models/test_ngram_analytics_service_session_methods.py::TestSummarizeSessionNgrams::test_summarize_with_ngram_errors_only[2-2] ERROR [ 47%]
tests/models/test_ngram_analytics_service_session_methods.py::TestSummarizeSessionNgrams::test_summarize_with_speed_and_errors ERROR [ 48%]
tests/models/test_ngram_analytics_service_session_methods.py::TestSummarizeSessionNgrams::test_summarize_with_keystrokes[1-1] ERROR [ 48%]
tests/models/test_ngram_analytics_service_session_methods.py::TestSummarizeSessionNgrams::test_summarize_with_keystrokes[3-3] ERROR [ 48%]
tests/models/test_ngram_analytics_service_session_methods.py::TestSummarizeSessionNgrams::test_no_sessions_missing ERROR [ 48%]
tests/models/test_ngram_analytics_service_session_methods.py::TestSummarizeSessionNgrams::test_sessions_missing_no_data ERROR [ 48%]
tests/models/test_ngram_analytics_service_session_methods.py::TestAddSpeedSummaryForSession::test_single_session_processing ERROR [ 49%]
tests/models/test_ngram_analytics_service_session_methods.py::TestAddSpeedSummaryForSession::test_nonexistent_session PASSED [ 49%]
tests/models/test_ngram_analytics_service_session_methods.py::TestAddSpeedSummaryForSession::test_multiple_ngrams_processing ERROR [ 49%]
tests/models/test_ngram_analytics_service_session_methods.py::TestCatchupSpeedSummary::test_empty_database_catchup PASSED [ 49%]
tests/models/test_ngram_analytics_service_session_methods.py::TestCatchupSpeedSummary::test_single_session_catchup ERROR [ 49%]
tests/models/test_ngram_analytics_service_session_methods.py::TestCatchupSpeedSummary::test_multiple_sessions_catchup ERROR [ 50%]
tests/models/test_ngram_analytics_service_session_methods.py::TestCatchupSpeedSummary::test_catchup_with_session_errors ERROR [ 50%]
tests/models/test_ngram_analytics_service_session_methods.py::TestIntegrationScenarios::test_full_workflow_integration ERROR [ 50%]
tests/models/test_ngram_manager.py::TestAnalyzeBasic::test_clean_windows_and_gross_up PASSED [ 50%]
tests/models/test_ngram_manager.py::TestAnalyzeBasic::test_ignored_zero_duration PASSED [ 50%]
tests/models/test_ngram_manager.py::TestAnalyzeBasic::test_separators_split_runs PASSED [ 51%]
tests/models/test_ngram_manager.py::TestErrorClassification::test_error_last_only PASSED [ 51%]
tests/models/test_ngram_manager.py::TestErrorClassification::test_error_not_last_is_ignored PASSED [ 51%]
tests/models/test_ngram_orchestrator_process_end_of_session.py::test_process_end_of_session_success_path FAILED [ 51%]
tests/models/test_ngram_orchestrator_process_end_of_session.py::test_process_end_of_session_session_save_failure FAILED [ 51%]
tests/models/test_ngram_orchestrator_process_end_of_session.py::test_process_end_of_session_keystrokes_save_failure FAILED [ 52%]
tests/models/test_ngram_orchestrator_process_end_of_session.py::test_process_end_of_session_summarization_failure FAILED [ 52%]
tests/models/test_session.py::test_valid_session_creation PASSED         [ 52%]
tests/models/test_session.py::test_missing_required_fields_raises[snippet_id] PASSED [ 52%]
tests/models/test_session.py::test_missing_required_fields_raises[user_id] PASSED [ 52%]
tests/models/test_session.py::test_missing_required_fields_raises[keyboard_id] PASSED [ 53%]
tests/models/test_session.py::test_missing_required_fields_raises[snippet_index_start] PASSED [ 53%]
tests/models/test_session.py::test_missing_required_fields_raises[snippet_index_end] PASSED [ 53%]
tests/models/test_session.py::test_missing_required_fields_raises[content] PASSED [ 53%]
tests/models/test_session.py::test_missing_required_fields_raises[start_time] PASSED [ 53%]
tests/models/test_session.py::test_missing_required_fields_raises[end_time] PASSED [ 54%]
tests/models/test_session.py::test_missing_required_fields_raises[actual_chars] PASSED [ 54%]
tests/models/test_session.py::test_missing_required_fields_raises[errors] PASSED [ 54%]
tests/models/test_session.py::test_invalid_field_values_raise[session_id-not-a-uuid] PASSED [ 54%]
tests/models/test_session.py::test_invalid_field_values_raise[snippet_id-not-a-uuid] PASSED [ 54%]
tests/models/test_session.py::test_invalid_field_values_raise[user_id-not-a-uuid] PASSED [ 55%]
tests/models/test_session.py::test_invalid_field_values_raise[keyboard_id-not-a-uuid] PASSED [ 55%]
tests/models/test_session.py::test_invalid_field_values_raise[snippet_index_start--1] PASSED [ 55%]
tests/models/test_session.py::test_invalid_field_values_raise[snippet_index_end-0] PASSED [ 55%]
tests/models/test_session.py::test_invalid_field_values_raise[start_time-not-a-date] PASSED [ 55%]
tests/models/test_session.py::test_invalid_field_values_raise[end_time-12345] PASSED [ 55%]
tests/models/test_session.py::test_invalid_field_values_raise[actual_chars-not-an-int] PASSED [ 56%]
tests/models/test_session.py::test_invalid_field_values_raise[errors-not-an-int] PASSED [ 56%]
tests/models/test_session.py::test_index_business_rules[0-0-True] PASSED [ 56%]
tests/models/test_session.py::test_index_business_rules[5-5-True] PASSED [ 56%]
tests/models/test_session.py::test_index_business_rules[10-5-True] PASSED [ 56%]
tests/models/test_session.py::test_index_business_rules[-1-5-True] PASSED [ 57%]
tests/models/test_session.py::test_index_business_rules[0-1-False] PASSED [ 57%]
tests/models/test_session.py::test_index_business_rules[2-5-False] PASSED [ 57%]
tests/models/test_session.py::test_start_time_after_end_time_raises PASSED [ 57%]
tests/models/test_session.py::test_computed_properties PASSED            [ 57%]
tests/models/test_session.py::test_correctness_and_accuracy[5-0-1.0-1.0] PASSED [ 58%]
tests/models/test_session.py::test_correctness_and_accuracy[5-5-0.0-0.0] PASSED [ 58%]
tests/models/test_session.py::test_correctness_and_accuracy[0-0-0.0-0.0] PASSED [ 58%]
tests/models/test_session.py::test_wpm_cpm_zero_and_normal[start_time0-end_time0-0.0-0.0] PASSED [ 58%]
tests/models/test_session.py::test_wpm_cpm_zero_and_normal[start_time1-end_time1-1.0-5.0] PASSED [ 58%]
tests/models/test_session.py::test_to_dict_and_from_dict PASSED          [ 59%]
tests/models/test_session.py::test_from_dict_ignores_calculated_fields PASSED [ 59%]
tests/models/test_session.py::test_from_dict_with_extra_fields_raises PASSED [ 59%]
tests/models/test_session.py::test_get_summary_truncates_content PASSED  [ 59%]
tests/models/test_session.py::test_extra_fields_forbidden_on_creation PASSED [ 59%]
tests/models/test_session.py::test_ms_per_keystroke_zero_chars PASSED    [ 60%]
tests/models/test_session.py::test_session_id_default_factory PASSED     [ 60%]
tests/models/test_session.py::test_content_required_if_actual_chars PASSED [ 60%]
tests/models/test_session_manager.py::test_save_and_get_session PASSED   [ 60%]
tests/models/test_session_manager.py::test_update_session PASSED         [ 60%]
tests/models/test_session_manager.py::test_list_sessions_for_snippet PASSED [ 61%]
tests/models/test_session_manager.py::test_delete_session_by_id PASSED   [ 61%]
tests/models/test_session_manager.py::test_delete_all PASSED             [ 61%]
tests/models/test_session_manager.py::test_save_session_returns_id PASSED [ 61%]
tests/models/test_session_manager.py::test_get_nonexistent_session PASSED [ 61%]
tests/models/test_session_manager.py::test_list_sessions_for_snippet_empty PASSED [ 62%]
tests/models/test_setting.py::TestSettingModel::test_setting_creation_valid PASSED [ 62%]
tests/models/test_setting.py::TestSettingModel::test_setting_type_id_validation[-setting_type_id must be exactly 6 characters] PASSED [ 62%]
tests/models/test_setting.py::TestSettingModel::test_setting_type_id_validation[ABC-setting_type_id must be exactly 6 characters] PASSED [ 62%]
tests/models/test_setting.py::TestSettingModel::test_setting_type_id_validation[ABCDEFG-setting_type_id must be exactly 6 characters] PASSED [ 62%]
tests/models/test_setting.py::TestSettingModel::test_setting_type_id_validation[ABCD\u20ac\u03a9-setting_type_id must be ASCII-only] PASSED [ 63%]
tests/models/test_setting.py::TestSettingModel::test_setting_exceptions_instantiable PASSED [ 63%]
tests/models/test_setting.py::TestSettingModel::test_setting_init_autogenerates_id PASSED [ 63%]
tests/models/test_setting.py::TestSettingModel::test_setting_from_dict_valid_and_extra_fields PASSED [ 63%]
tests/models/test_setting.py::TestSettingModel::test_setting_to_dict PASSED [ 63%]
tests/models/test_setting.py::TestSettingModel::test_setting_field_type_and_value_errors[setting_id-123-Input should be a valid string] PASSED [ 64%]
tests/models/test_setting.py::TestSettingModel::test_setting_field_type_and_value_errors[setting_id-not-a-uuid-setting_id must be a valid UUID string] PASSED [ 64%]
tests/models/test_setting.py::TestSettingModel::test_setting_field_type_and_value_errors[setting_type_id-None-Input should be a valid string] PASSED [ 64%]
tests/models/test_setting.py::TestSettingModel::test_setting_field_type_and_value_errors[setting_type_id--setting_type_id must be exactly 6 characters] PASSED [ 64%]
tests/models/test_setting.py::TestSettingModel::test_setting_field_type_and_value_errors[setting_type_id-ABC-setting_type_id must be exactly 6 characters] PASSED [ 64%]
tests/models/test_setting.py::TestSettingModel::test_setting_field_type_and_value_errors[related_entity_id-None-Input should be a valid string] PASSED [ 65%]
tests/models/test_setting.py::TestSettingModel::test_setting_field_type_and_value_errors[related_entity_id-not-a-uuid-related_entity_id must be a valid UUID string] PASSED [ 65%]
tests/models/test_setting.py::TestSettingModel::test_setting_field_type_and_value_errors[updated_at-None-Input should be a valid string] PASSED [ 65%]
tests/models/test_setting.py::TestSettingModel::test_setting_field_type_and_value_errors[updated_at-not-iso-format-updated_at must be a valid ISO datetime string] PASSED [ 65%]
tests/models/test_setting_manager.py::TestSettingManager::test_create_setting_valid PASSED [ 65%]
tests/models/test_setting_manager.py::TestSettingManager::test_create_setting_invalid_format[-must be exactly 6 characters] PASSED [ 66%]
tests/models/test_setting_manager.py::TestSettingManager::test_create_setting_invalid_format[ABC-must be exactly 6 characters] PASSED [ 66%]
tests/models/test_setting_manager.py::TestSettingManager::test_create_setting_invalid_format[ABCDEFG-must be exactly 6 characters] PASSED [ 66%]
tests/models/test_setting_manager.py::TestSettingManager::test_create_setting_invalid_format[ABCD\u20ac\u03a9-must be ASCII-only] PASSED [ 66%]
tests/models/test_setting_manager.py::TestSettingManager::test_update_existing_setting_with_new_value PASSED [ 66%]
tests/models/test_setting_manager.py::TestSettingManager::test_get_setting_by_type_and_entity PASSED [ 66%]
tests/models/test_setting_manager.py::TestSettingManager::test_get_setting_with_default PASSED [ 67%]
tests/models/test_setting_manager.py::TestSettingManager::test_get_setting_not_found PASSED [ 67%]
tests/models/test_setting_manager.py::TestSettingManager::test_list_settings_empty PASSED [ 67%]
tests/models/test_setting_manager.py::TestSettingManager::test_list_settings_populated PASSED [ 67%]
tests/models/test_setting_manager.py::TestSettingManager::test_update_setting_value PASSED [ 67%]
tests/models/test_setting_manager.py::TestSettingManager::test_history_tracking_on_create PASSED [ 68%]
tests/models/test_setting_manager.py::TestSettingManager::test_history_tracking_on_update PASSED [ 68%]
tests/models/test_setting_manager.py::TestSettingManager::test_history_tracking_on_delete PASSED [ 68%]
tests/models/test_setting_manager.py::TestSettingManager::test_delete_setting PASSED [ 68%]
tests/models/test_setting_manager.py::TestSettingManager::test_delete_nonexistent_setting PASSED [ 68%]
tests/models/test_setting_manager.py::TestSettingManager::test_delete_all_settings PASSED [ 69%]
tests/models/test_setting_manager.py::TestSettingManager::test_history_for_bulk_delete PASSED [ 69%]
tests/models/test_simple.py::test_simple PASSED                          [ 69%]
tests/models/test_snippet.py::test_snippet_model_validation_valid PASSED [ 69%]
tests/models/test_snippet.py::test_snippet_model_validation_invalid_name_empty PASSED [ 69%]
tests/models/test_snippet.py::test_snippet_model_validation_invalid_name_non_ascii PASSED [ 70%]
tests/models/test_snippet.py::test_snippet_ascii_name ERROR              [ 70%]
tests/models/test_snippet.py::test_snippet_model_validation_invalid_name_too_long PASSED [ 70%]
tests/models/test_snippet.py::test_snippet_name_length ERROR             [ 70%]
tests/models/test_snippet.py::test_snippet_model_validation_invalid_content_empty PASSED [ 70%]
tests/models/test_snippet.py::test_snippet_model_validation_invalid_category_id PASSED [ 71%]
tests/models/test_snippet.py::test_snippet_creation_validation[Alpha-Some content-True] ERROR [ 71%]
tests/models/test_snippet.py::test_snippet_creation_validation[-Some content-False] ERROR [ 71%]
tests/models/test_snippet.py::test_snippet_creation_validation[AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA-Content-False] ERROR [ 71%]
tests/models/test_snippet.py::test_snippet_creation_validation[NonAscii\xe9-Content-False] ERROR [ 71%]
tests/models/test_snippet.py::test_snippet_creation_validation[Alpha--False] ERROR [ 72%]
tests/models/test_snippet.py::test_snippet_name_uniqueness[Unique1-Unique2-True] ERROR [ 72%]
tests/models/test_snippet.py::test_snippet_name_uniqueness[DupName-DupName-False] ERROR [ 72%]
tests/models/test_snippet.py::test_snippet_creation_valid ERROR          [ 72%]
tests/models/test_snippet.py::test_get_nonexistent_snippet ERROR         [ 72%]
tests/models/test_snippet.py::test_list_snippets_empty ERROR             [ 73%]
tests/models/test_snippet.py::test_list_snippets_populated ERROR         [ 73%]
tests/models/test_snippet.py::test_snippet_edit ERROR                    [ 73%]
tests/models/test_snippet.py::test_snippet_update ERROR                  [ 73%]
tests/models/test_snippet.py::test_snippet_update_name_only ERROR        [ 73%]
tests/models/test_snippet.py::test_snippet_update_content_only ERROR     [ 74%]
tests/models/test_snippet.py::test_snippet_delete ERROR                  [ 74%]
tests/models/test_snippet.py::test_delete_nonexistent_snippet ERROR      [ 74%]
tests/models/test_snippet.py::test_edit_snippet_change_category ERROR    [ 74%]
tests/models/test_snippet.py::test_edit_snippet_invalid_category ERROR   [ 74%]
tests/models/test_snippet.py::test_snippet_sql_injection ERROR           [ 75%]
tests/models/test_snippet.py::test_snippet_sql_injection_in_content ERROR [ 75%]
tests/models/test_snippet.py::test_snippet_long_content ERROR            [ 75%]
tests/models/test_snippet.py::test_snippet_content_splitting_boundaries ERROR [ 75%]
tests/models/test_snippet.py::test_update_nonexistent_snippet ERROR      [ 75%]
tests/models/test_snippet.py::test_snippet_part_number_sequence ERROR    [ 76%]
tests/models/test_snippet.py::test_python_code_validation PASSED         [ 76%]
tests/models/test_snippet.py::test_snippet_operation_handling ERROR      [ 76%]
tests/models/test_snippet.py::test_delete_snippet ERROR                  [ 76%]
tests/models/test_snippet.py::test_create_snippet_with_nonexistent_category ERROR [ 76%]
tests/models/test_snippet.py::test_update_snippet_partial ERROR          [ 77%]
tests/models/test_snippet.py::test_update_snippet_no_changes ERROR       [ 77%]
tests/models/test_snippet.py::test_get_snippet_by_name ERROR             [ 77%]
tests/models/test_snippet.py::test_get_snippet_by_name_nonexistent ERROR [ 77%]
tests/models/test_snippet.py::test_get_snippet_by_name_multiple_categories ERROR [ 77%]
tests/models/test_snippet.py::test_search_snippets ERROR                 [ 77%]
tests/models/test_snippet.py::test_search_snippets_no_results ERROR      [ 78%]
tests/models/test_snippet.py::test_snippet_sql_injection_name_create ERROR [ 78%]
tests/models/test_snippet.py::test_snippet_sql_injection_content_create ERROR [ 78%]
tests/models/test_snippet.py::test_snippet_sql_injection_name_create_with_specific_error ERROR [ 78%]
tests/models/test_snippet.py::test_snippet_sql_injection_content_update ERROR [ 78%]
tests/models/test_snippet.py::test_snippet_sql_injection_name_update ERROR [ 79%]
tests/models/test_snippet.py::test_snippet_deletion_idempotency ERROR    [ 79%]
tests/models/test_snippet.py::test_snippet_manager_handles_db_errors_gracefully_on_create ERROR [ 79%]
tests/models/test_snippet.py::test_snippet_manager_handles_db_errors_gracefully_on_get ERROR [ 79%]
tests/models/test_snippet.py::test_snippet_manager_handles_db_errors_gracefully_on_update ERROR [ 79%]
tests/models/test_snippet.py::test_snippet_manager_handles_db_errors_gracefully_on_delete ERROR [ 80%]
tests/models/test_snippet.py::test_snippet_manager_handles_db_errors_gracefully_on_list ERROR [ 80%]
tests/models/test_snippet.py::test_snippet_manager_handles_db_errors_gracefully_on_search ERROR [ 80%]
tests/models/test_snippet.py::test_create_snippet_pydantic_validation_errors ERROR [ 80%]
tests/models/test_snippet_manager.py::TestCreateSnippet::test_create_snippet_happy_path PASSED [ 80%]
tests/models/test_snippet_manager.py::TestCreateSnippet::test_create_snippet_content_splitting PASSED [ 81%]
tests/models/test_snippet_manager.py::TestCreateSnippet::test_create_snippet_duplicate_name_in_category PASSED [ 81%]
tests/models/test_snippet_manager.py::TestCreateSnippet::test_create_snippet_duplicate_name_different_category PASSED [ 81%]
tests/models/test_snippet_manager.py::TestCreateSnippet::test_create_snippet_invalid_category_id_foreign_key PASSED [ 81%]
tests/models/test_snippet_manager.py::TestCreateSnippet::test_create_snippet_pydantic_validation_errors[-Valid Content-ValueError] PASSED [ 81%]
tests/models/test_snippet_manager.py::TestCreateSnippet::test_create_snippet_pydantic_validation_errors[ -Valid Content-ValueError] PASSED [ 82%]
tests/models/test_snippet_manager.py::TestCreateSnippet::test_create_snippet_pydantic_validation_errors[NNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN-Valid Content-ValueError] PASSED [ 82%]
tests/models/test_snippet_manager.py::TestCreateSnippet::test_create_snippet_pydantic_validation_errors[Invalid\xd1ame-Valid Content-ValueError] PASSED [ 82%]
tests/models/test_snippet_manager.py::TestCreateSnippet::test_create_snippet_pydantic_validation_errors[ValidName--ValueError] PASSED [ 82%]
tests/models/test_snippet_manager.py::TestCreateSnippet::test_create_snippet_pydantic_validation_errors[ValidName- -ValueError] PASSED [ 82%]
tests/models/test_snippet_manager.py::TestCreateSnippet::test_create_snippet_pydantic_validation_errors[ValidName-Invalid\xc7ontent-ValueError] PASSED [ 83%]
tests/models/test_snippet_manager.py::TestCreateSnippet::test_create_snippet_pydantic_validation_errors[DROP TABLE Users;-Content-ValueError] PASSED [ 83%]
tests/models/test_snippet_manager.py::TestCreateSnippet::test_create_snippet_pydantic_validation_errors[ValidName-SELECT * FROM Users; -- comment-ValueError] PASSED [ 83%]
tests/models/test_snippet_manager.py::TestCreateSnippet::test_create_snippet_internal_empty_content_check_unreachable_with_valid_pydantic_input PASSED [ 83%]
tests/models/test_snippet_manager.py::TestGetStartingIndex::test_get_starting_index_no_sessions PASSED [ 83%]
tests/models/test_snippet_manager.py::TestGetStartingIndex::test_get_starting_index_with_sessions PASSED [ 84%]
tests/models/test_snippet_manager.py::TestGetStartingIndex::test_get_starting_index_wraps_to_zero PASSED [ 84%]
tests/models/test_snippet_manager.py::TestGetStartingIndex::test_get_starting_index_greater_than_length PASSED [ 84%]
tests/models/test_snippet_manager.py::TestGetStartingIndex::test_get_starting_index_different_user_keyboard PASSED [ 84%]
tests/models/test_user.py::TestUserModel::test_create_user_with_minimal_fields PASSED [ 84%]
tests/models/test_user.py::TestUserModel::test_create_user_with_existing_id PASSED [ 85%]
tests/models/test_user.py::TestUserModel::test_valid_email_formats[test@example.com] PASSED [ 85%]
tests/models/test_user.py::TestUserModel::test_valid_email_formats[test.user@example.com] PASSED [ 85%]
tests/models/test_user.py::TestUserModel::test_valid_email_formats[test+user@example.com] PASSED [ 85%]
tests/models/test_user.py::TestUserModel::test_valid_email_formats[test.user+tag@example.co.uk] PASSED [ 85%]
tests/models/test_user.py::TestUserModel::test_valid_email_formats[test@subdomain.example.com] PASSED [ 86%]
tests/models/test_user.py::TestUserModel::test_valid_email_formats[test@123.123.123.123] PASSED [ 86%]
tests/models/test_user.py::TestUserModel::test_valid_email_formats[test@[123.123.123.123]] PASSED [ 86%]
tests/models/test_user.py::TestUserModel::test_invalid_email_formats[plainaddress] PASSED [ 86%]
tests/models/test_user.py::TestUserModel::test_invalid_email_formats[@missingusername.com] PASSED [ 86%]
tests/models/test_user.py::TestUserModel::test_invalid_email_formats[username@.com] PASSED [ 87%]
tests/models/test_user.py::TestUserModel::test_invalid_email_formats[.username@example.com] PASSED [ 87%]
tests/models/test_user.py::TestUserModel::test_invalid_email_formats[username@example..com] PASSED [ 87%]
tests/models/test_user.py::TestUserModel::test_invalid_email_formats[username@example.com.] PASSED [ 87%]
tests/models/test_user.py::TestUserModel::test_invalid_email_formats[username@.example.com] PASSED [ 87%]
tests/models/test_user.py::TestUserModel::test_invalid_email_formats[username@-example.com] PASSED [ 88%]
tests/models/test_user.py::TestUserModel::test_invalid_email_formats[username@example-.com] PASSED [ 88%]
tests/models/test_user.py::TestUserModel::test_invalid_email_formats[username@example.com-] PASSED [ 88%]
tests/models/test_user.py::TestUserModel::test_invalid_email_formats[username@example.c] PASSED [ 88%]
tests/models/test_user.py::TestUserModel::test_invalid_email_formats[username@example.com.1a] PASSED [ 88%]
tests/models/test_user.py::TestUserModel::test_invalid_email_formats[username@example.com.a] PASSED [ 88%]
tests/models/test_user.py::TestUserModel::test_invalid_email_formats[username@example.com.1] PASSED [ 89%]
tests/models/test_user.py::TestUserModel::test_invalid_email_formats[username@example.com.a1-] PASSED [ 89%]
tests/models/test_user.py::TestUserModel::test_invalid_email_formats[username@example.com.-a] PASSED [ 89%]
tests/models/test_user.py::TestUserModel::test_valid_name_formats[John] PASSED [ 89%]
tests/models/test_user.py::TestUserModel::test_valid_name_formats[Mary-Jane] PASSED [ 89%]
tests/models/test_user.py::TestUserModel::test_valid_name_formats[O'Reilly] PASSED [ 90%]
tests/models/test_user.py::TestUserModel::test_valid_name_formats[De La Cruz] PASSED [ 90%]
tests/models/test_user.py::TestUserModel::test_valid_name_formats[X] PASSED [ 90%]
tests/models/test_user.py::TestUserModel::test_valid_name_formats[AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA] PASSED [ 90%]
tests/models/test_user.py::TestUserModel::test_invalid_name_formats[] PASSED [ 90%]
tests/models/test_user.py::TestUserModel::test_invalid_name_formats[ ] PASSED [ 91%]
tests/models/test_user.py::TestUserModel::test_invalid_name_formats[\t] PASSED [ 91%]
tests/models/test_user.py::TestUserModel::test_invalid_name_formats[\n] PASSED [ 91%]
tests/models/test_user.py::TestUserModel::test_invalid_name_formats[AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA] PASSED [ 91%]
tests/models/test_user.py::TestUserModel::test_invalid_name_formats[John@Doe] PASSED [ 91%]
tests/models/test_user.py::TestUserModel::test_invalid_name_formats[John\nDoe] PASSED [ 92%]
tests/models/test_user.py::TestUserModel::test_invalid_name_formats[John\tDoe] PASSED [ 92%]
tests/models/test_user.py::TestUserModel::test_invalid_name_formats[John\rDoe] PASSED [ 92%]
tests/models/test_user.py::TestUserModel::test_invalid_name_formats[John\x0cDoe] PASSED [ 92%]
tests/models/test_user.py::TestUserModel::test_invalid_name_formats[John\x0bDoe] PASSED [ 92%]
tests/models/test_user.py::TestUserModel::test_whitespace_stripping PASSED [ 93%]
tests/models/test_user.py::TestUserModel::test_case_insensitive_email PASSED [ 93%]
tests/models/test_user.py::TestUserModel::test_to_dict PASSED            [ 93%]
tests/models/test_user.py::TestUserModel::test_from_dict PASSED          [ 93%]
tests/models/test_user.py::TestUserModel::test_from_dict_with_extra_fields PASSED [ 93%]
tests/models/test_user.py::TestUserModel::test_validate_user_id_empty PASSED [ 94%]
tests/models/test_user.py::TestUserModel::test_validate_user_id_invalid PASSED [ 94%]
tests/models/test_user.py::TestUserModel::test_ip_address_domain_variants PASSED [ 94%]
tests/models/test_user.py::TestUserModel::test_special_domain_validation PASSED [ 94%]
tests/models/test_user.py::TestUserModel::test_domain_edge_cases PASSED  [ 94%]
tests/models/test_user_manager.py::TestUserManager::test_create_and_retrieve_user PASSED [ 95%]
tests/models/test_user_manager.py::TestUserManager::test_update_user PASSED [ 95%]
tests/models/test_user_manager.py::TestUserManager::test_delete_user PASSED [ 95%]
tests/models/test_user_manager.py::TestUserManager::test_list_all_users PASSED [ 95%]
tests/models/test_user_manager.py::TestUserManager::test_email_uniqueness PASSED [ 95%]
tests/models/test_user_manager.py::TestUserManager::test_update_user_with_same_email PASSED [ 96%]
tests/models/test_user_manager.py::TestUserManager::test_nonexistent_user_retrieval PASSED [ 96%]
tests/models/test_user_manager.py::TestUserManager::test_case_insensitive_email_retrieval PASSED [ 96%]
tests/models/test_user_manager.py::TestUserManager::test_empty_database_operations PASSED [ 96%]
tests/models/test_user_manager_fixes.py::TestUserManagerDatabaseAccessFixes::test_list_all_users_with_results PASSED [ 96%]
tests/models/test_user_manager_fixes.py::TestUserManagerDatabaseAccessFixes::test_list_all_users_empty_database PASSED [ 97%]
tests/models/test_user_manager_fixes.py::TestUserManagerDatabaseAccessFixes::test_get_user_by_id_found PASSED [ 97%]
tests/models/test_user_manager_fixes.py::TestUserManagerDatabaseAccessFixes::test_get_user_by_id_not_found PASSED [ 97%]
tests/models/test_user_manager_fixes.py::TestUserManagerDatabaseAccessFixes::test_get_user_by_email_found PASSED [ 97%]
tests/models/test_user_manager_fixes.py::TestUserManagerDatabaseAccessFixes::test_get_user_by_email_not_found PASSED [ 97%]
tests/models/test_user_manager_fixes.py::TestUserManagerDatabaseAccessFixes::test_user_exists_true PASSED [ 98%]
tests/models/test_user_manager_fixes.py::TestUserManagerDatabaseAccessFixes::test_user_exists_false PASSED [ 98%]
tests/models/test_user_manager_fixes.py::TestUserManagerDatabaseAccessFixes::test_delete_user_by_id_exists PASSED [ 98%]
tests/models/test_user_manager_fixes.py::TestUserManagerDatabaseAccessFixes::test_delete_user_by_id_not_exists PASSED [ 98%]
tests/models/test_user_manager_fixes.py::TestUserManagerDatabaseAccessFixes::test_delete_all_users_with_users_dict_result PASSED [ 98%]
tests/models/test_user_manager_fixes.py::TestUserManagerDatabaseAccessFixes::test_delete_all_users_with_users_non_dict_result PASSED [ 99%]
tests/models/test_user_manager_fixes.py::TestUserManagerDatabaseAccessFixes::test_delete_all_users_no_users_dict_result PASSED [ 99%]
tests/models/test_user_manager_fixes.py::TestUserManagerDatabaseAccessFixes::test_delete_all_users_no_users_empty_result PASSED [ 99%]
tests/models/test_user_manager_fixes.py::TestUserManagerDatabaseAccessFixes::test_validate_email_uniqueness_unique PASSED [ 99%]
tests/models/test_user_manager_fixes.py::TestUserManagerDatabaseAccessFixes::test_validate_email_uniqueness_duplicate PASSED [ 99%]
tests/models/test_user_manager_fixes.py::TestUserManagerDatabaseAccessFixes::test_validate_email_uniqueness_update_same_user PASSED [100%]

=================================== ERRORS ====================================
_ ERROR at setup of TestNGramAnalyticsService.test_refresh_speed_summaries_basic _

self = <db.database_manager.DatabaseManager object at 0x00000215B0073230>
query = 'INSERT INTO snippets (snippet_id, category_id, title, content, difficulty_level) VALUES (?, ?, ?, ?, ?)'
params = ('snippet_1', 'cat_1', 'Snippet', 'content', 1)

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table snippets has no column named title

db\database_manager.py:509: OperationalError

The above exception was the direct cause of the following exception:

item = <Function test_refresh_speed_summaries_basic>

    @pytest.hookimpl(wrapper=True, tryfirst=True)
    def pytest_runtest_setup(item):
        """
        Hook called after before test setup starts, to start capturing exceptions
        as early as possible.
        """
        capture_enabled = _is_exception_capture_enabled(item)
        if capture_enabled:
            item.qt_exception_capture_manager = _QtExceptionCaptureManager()
            item.qt_exception_capture_manager.start()
>       result = yield
                 ^^^^^

.venv\Lib\site-packages\pytestqt\plugin.py:178: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:321: in ngram_speed_test_data
    db_with_tables.execute(
db\database_manager.py:524: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x00000215B0073230>
e = OperationalError('table snippets has no column named title')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table snippets has no column named title

db\database_manager.py:434: DatabaseError
---------------------------- Captured stdout setup ----------------------------
Exception during query: table snippets has no column named title. Rolling back transaction.
---------------------------- Captured stderr setup ----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 509, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table snippets has no column named title
_ ERROR at setup of TestSummarizeSessionNgrams.test_summarize_with_ngram_speed_only[1-1] _

self = <db.database_manager.DatabaseManager object at 0x00000215B002A0B0>
query = '\n            INSERT INTO categories (category_id, category_name, description)\n            VALUES (?, ?, ?)\n            '
params = ('2fb1f34c-9dab-488e-bcb1-7411a984c6ee', 'Test Category', 'Test category for testing')

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table categories has no column named description

db\database_manager.py:509: OperationalError

The above exception was the direct cause of the following exception:

db_with_tables = <db.database_manager.DatabaseManager object at 0x00000215B002A0B0>
test_user = User(user_id='8723e353-54ca-4321-8f97-16f25729f8c3', first_name='Test', surname='User', email_address='test.user.70747b0b-8967-46ac-9447-e0c931d2efac@example.com')
test_keyboard = Keyboard(keyboard_id='f0475efe-26d1-4871-929e-75d2149dd1f4', user_id='8723e353-54ca-4321-8f97-16f25729f8c3', keyboard_name='Test Keyboard', target_ms_per_keystroke=600)

    @pytest.fixture
    def test_data_setup(db_with_tables: DatabaseManager, test_user: User, test_keyboard: Keyboard) -> Dict[str, Any]:
        """Set up comprehensive test data for session analytics tests."""
        db = db_with_tables
    
        # Create category and snippet
>       category_id = TestSessionMethodsFixtures.create_category(db)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_ngram_analytics_service_session_methods.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:239: in create_category
    db.execute(
db\database_manager.py:524: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x00000215B002A0B0>
e = OperationalError('table categories has no column named description')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table categories has no column named description

db\database_manager.py:434: DatabaseError
---------------------------- Captured stdout setup ----------------------------
Exception during query: table categories has no column named description. Rolling back transaction.
---------------------------- Captured stderr setup ----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 509, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table categories has no column named description
_ ERROR at setup of TestSummarizeSessionNgrams.test_summarize_with_ngram_speed_only[3-3] _

self = <db.database_manager.DatabaseManager object at 0x00000215B06BAAC0>
query = '\n            INSERT INTO categories (category_id, category_name, description)\n            VALUES (?, ?, ?)\n            '
params = ('d2fc2fbc-775e-4440-8001-75ff55d70a1d', 'Test Category', 'Test category for testing')

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table categories has no column named description

db\database_manager.py:509: OperationalError

The above exception was the direct cause of the following exception:

db_with_tables = <db.database_manager.DatabaseManager object at 0x00000215B06BAAC0>
test_user = User(user_id='f8517ff0-8d84-4253-bbb2-5a5d2eb933a6', first_name='Test', surname='User', email_address='test.user.f3802827-4788-4dea-b496-9069f1e60322@example.com')
test_keyboard = Keyboard(keyboard_id='da6aa4fd-b18d-4a53-8fac-24f44f84f823', user_id='f8517ff0-8d84-4253-bbb2-5a5d2eb933a6', keyboard_name='Test Keyboard', target_ms_per_keystroke=600)

    @pytest.fixture
    def test_data_setup(db_with_tables: DatabaseManager, test_user: User, test_keyboard: Keyboard) -> Dict[str, Any]:
        """Set up comprehensive test data for session analytics tests."""
        db = db_with_tables
    
        # Create category and snippet
>       category_id = TestSessionMethodsFixtures.create_category(db)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_ngram_analytics_service_session_methods.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:239: in create_category
    db.execute(
db\database_manager.py:524: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x00000215B06BAAC0>
e = OperationalError('table categories has no column named description')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table categories has no column named description

db\database_manager.py:434: DatabaseError
---------------------------- Captured stdout setup ----------------------------
Exception during query: table categories has no column named description. Rolling back transaction.
---------------------------- Captured stderr setup ----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 509, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table categories has no column named description
_ ERROR at setup of TestSummarizeSessionNgrams.test_summarize_with_ngram_errors_only[1-1] _

self = <db.database_manager.DatabaseManager object at 0x00000215B068E0B0>
query = '\n            INSERT INTO categories (category_id, category_name, description)\n            VALUES (?, ?, ?)\n            '
params = ('0a00ab1a-abb1-482f-a9ce-6a65f9a53276', 'Test Category', 'Test category for testing')

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table categories has no column named description

db\database_manager.py:509: OperationalError

The above exception was the direct cause of the following exception:

db_with_tables = <db.database_manager.DatabaseManager object at 0x00000215B068E0B0>
test_user = User(user_id='25de59f5-409c-4162-90c5-2011600d64d2', first_name='Test', surname='User', email_address='test.user.db089fb5-825f-4413-ad6c-415c945f055f@example.com')
test_keyboard = Keyboard(keyboard_id='ead55e4f-9f12-4405-8dbf-e032eaf7a00a', user_id='25de59f5-409c-4162-90c5-2011600d64d2', keyboard_name='Test Keyboard', target_ms_per_keystroke=600)

    @pytest.fixture
    def test_data_setup(db_with_tables: DatabaseManager, test_user: User, test_keyboard: Keyboard) -> Dict[str, Any]:
        """Set up comprehensive test data for session analytics tests."""
        db = db_with_tables
    
        # Create category and snippet
>       category_id = TestSessionMethodsFixtures.create_category(db)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_ngram_analytics_service_session_methods.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:239: in create_category
    db.execute(
db\database_manager.py:524: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x00000215B068E0B0>
e = OperationalError('table categories has no column named description')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table categories has no column named description

db\database_manager.py:434: DatabaseError
---------------------------- Captured stdout setup ----------------------------
Exception during query: table categories has no column named description. Rolling back transaction.
---------------------------- Captured stderr setup ----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 509, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table categories has no column named description
_ ERROR at setup of TestSummarizeSessionNgrams.test_summarize_with_ngram_errors_only[2-2] _

self = <db.database_manager.DatabaseManager object at 0x00000215B0734830>
query = '\n            INSERT INTO categories (category_id, category_name, description)\n            VALUES (?, ?, ?)\n            '
params = ('880767c6-3f47-4620-bff9-99db39e818d6', 'Test Category', 'Test category for testing')

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table categories has no column named description

db\database_manager.py:509: OperationalError

The above exception was the direct cause of the following exception:

db_with_tables = <db.database_manager.DatabaseManager object at 0x00000215B0734830>
test_user = User(user_id='6f45dce6-0db2-4670-b10d-5f72953dbe12', first_name='Test', surname='User', email_address='test.user.32d18315-7dbe-4626-b0c7-47780a2fb7cf@example.com')
test_keyboard = Keyboard(keyboard_id='30c63026-9571-4795-ab42-e8d50f71ea72', user_id='6f45dce6-0db2-4670-b10d-5f72953dbe12', keyboard_name='Test Keyboard', target_ms_per_keystroke=600)

    @pytest.fixture
    def test_data_setup(db_with_tables: DatabaseManager, test_user: User, test_keyboard: Keyboard) -> Dict[str, Any]:
        """Set up comprehensive test data for session analytics tests."""
        db = db_with_tables
    
        # Create category and snippet
>       category_id = TestSessionMethodsFixtures.create_category(db)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_ngram_analytics_service_session_methods.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:239: in create_category
    db.execute(
db\database_manager.py:524: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x00000215B0734830>
e = OperationalError('table categories has no column named description')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table categories has no column named description

db\database_manager.py:434: DatabaseError
---------------------------- Captured stdout setup ----------------------------
Exception during query: table categories has no column named description. Rolling back transaction.
---------------------------- Captured stderr setup ----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 509, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table categories has no column named description
_ ERROR at setup of TestSummarizeSessionNgrams.test_summarize_with_speed_and_errors _

self = <db.database_manager.DatabaseManager object at 0x00000215B07347C0>
query = '\n            INSERT INTO categories (category_id, category_name, description)\n            VALUES (?, ?, ?)\n            '
params = ('4a66c240-7966-4448-9e13-60a864f58d67', 'Test Category', 'Test category for testing')

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table categories has no column named description

db\database_manager.py:509: OperationalError

The above exception was the direct cause of the following exception:

db_with_tables = <db.database_manager.DatabaseManager object at 0x00000215B07347C0>
test_user = User(user_id='0dec31fb-45bf-48b6-adb8-fbd8bd0e8181', first_name='Test', surname='User', email_address='test.user.1f687b53-5947-4b6b-aaf5-a6084664f434@example.com')
test_keyboard = Keyboard(keyboard_id='360fc7e3-6f3b-4aa4-92b6-07fc60a9821f', user_id='0dec31fb-45bf-48b6-adb8-fbd8bd0e8181', keyboard_name='Test Keyboard', target_ms_per_keystroke=600)

    @pytest.fixture
    def test_data_setup(db_with_tables: DatabaseManager, test_user: User, test_keyboard: Keyboard) -> Dict[str, Any]:
        """Set up comprehensive test data for session analytics tests."""
        db = db_with_tables
    
        # Create category and snippet
>       category_id = TestSessionMethodsFixtures.create_category(db)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_ngram_analytics_service_session_methods.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:239: in create_category
    db.execute(
db\database_manager.py:524: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x00000215B07347C0>
e = OperationalError('table categories has no column named description')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table categories has no column named description

db\database_manager.py:434: DatabaseError
---------------------------- Captured stdout setup ----------------------------
Exception during query: table categories has no column named description. Rolling back transaction.
---------------------------- Captured stderr setup ----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 509, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table categories has no column named description
_ ERROR at setup of TestSummarizeSessionNgrams.test_summarize_with_keystrokes[1-1] _

self = <db.database_manager.DatabaseManager object at 0x00000215B0734280>
query = '\n            INSERT INTO categories (category_id, category_name, description)\n            VALUES (?, ?, ?)\n            '
params = ('e1d7b4fb-577e-4bf8-8d51-c43cf95ec24d', 'Test Category', 'Test category for testing')

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table categories has no column named description

db\database_manager.py:509: OperationalError

The above exception was the direct cause of the following exception:

db_with_tables = <db.database_manager.DatabaseManager object at 0x00000215B0734280>
test_user = User(user_id='7103dc5c-a8ff-4ced-a24e-c5fbead05326', first_name='Test', surname='User', email_address='test.user.ed271833-1b71-4784-a4c8-cb33d7e7ccdb@example.com')
test_keyboard = Keyboard(keyboard_id='57603464-fcaa-4466-bf44-79163af00e5e', user_id='7103dc5c-a8ff-4ced-a24e-c5fbead05326', keyboard_name='Test Keyboard', target_ms_per_keystroke=600)

    @pytest.fixture
    def test_data_setup(db_with_tables: DatabaseManager, test_user: User, test_keyboard: Keyboard) -> Dict[str, Any]:
        """Set up comprehensive test data for session analytics tests."""
        db = db_with_tables
    
        # Create category and snippet
>       category_id = TestSessionMethodsFixtures.create_category(db)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_ngram_analytics_service_session_methods.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:239: in create_category
    db.execute(
db\database_manager.py:524: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x00000215B0734280>
e = OperationalError('table categories has no column named description')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table categories has no column named description

db\database_manager.py:434: DatabaseError
---------------------------- Captured stdout setup ----------------------------
Exception during query: table categories has no column named description. Rolling back transaction.
---------------------------- Captured stderr setup ----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 509, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table categories has no column named description
_ ERROR at setup of TestSummarizeSessionNgrams.test_summarize_with_keystrokes[3-3] _

self = <db.database_manager.DatabaseManager object at 0x00000215B0735C50>
query = '\n            INSERT INTO categories (category_id, category_name, description)\n            VALUES (?, ?, ?)\n            '
params = ('d60519fb-3eed-41a4-8232-38604e780e21', 'Test Category', 'Test category for testing')

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table categories has no column named description

db\database_manager.py:509: OperationalError

The above exception was the direct cause of the following exception:

db_with_tables = <db.database_manager.DatabaseManager object at 0x00000215B0735C50>
test_user = User(user_id='29ddc842-94de-462f-8eeb-fa047ba710e9', first_name='Test', surname='User', email_address='test.user.c2a58e71-ab8e-4ab1-8239-9a5afe4d9461@example.com')
test_keyboard = Keyboard(keyboard_id='70b7a34d-0744-412e-9e7a-e6f0f39a667a', user_id='29ddc842-94de-462f-8eeb-fa047ba710e9', keyboard_name='Test Keyboard', target_ms_per_keystroke=600)

    @pytest.fixture
    def test_data_setup(db_with_tables: DatabaseManager, test_user: User, test_keyboard: Keyboard) -> Dict[str, Any]:
        """Set up comprehensive test data for session analytics tests."""
        db = db_with_tables
    
        # Create category and snippet
>       category_id = TestSessionMethodsFixtures.create_category(db)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_ngram_analytics_service_session_methods.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:239: in create_category
    db.execute(
db\database_manager.py:524: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x00000215B0735C50>
e = OperationalError('table categories has no column named description')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table categories has no column named description

db\database_manager.py:434: DatabaseError
---------------------------- Captured stdout setup ----------------------------
Exception during query: table categories has no column named description. Rolling back transaction.
---------------------------- Captured stderr setup ----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 509, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table categories has no column named description
____ ERROR at setup of TestSummarizeSessionNgrams.test_no_sessions_missing ____

self = <db.database_manager.DatabaseManager object at 0x00000215B0737930>
query = '\n            INSERT INTO categories (category_id, category_name, description)\n            VALUES (?, ?, ?)\n            '
params = ('b14f6b1a-65cf-42cd-b70d-e2552a8d5d06', 'Test Category', 'Test category for testing')

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table categories has no column named description

db\database_manager.py:509: OperationalError

The above exception was the direct cause of the following exception:

db_with_tables = <db.database_manager.DatabaseManager object at 0x00000215B0737930>
test_user = User(user_id='53be71f0-6cd7-44cc-a9be-48d2de1145bf', first_name='Test', surname='User', email_address='test.user.b2315a28-e5b7-4aae-adb0-71a7a6ffe2bc@example.com')
test_keyboard = Keyboard(keyboard_id='d914bdd3-82c9-4cde-8ba3-3498a7f34a31', user_id='53be71f0-6cd7-44cc-a9be-48d2de1145bf', keyboard_name='Test Keyboard', target_ms_per_keystroke=600)

    @pytest.fixture
    def test_data_setup(db_with_tables: DatabaseManager, test_user: User, test_keyboard: Keyboard) -> Dict[str, Any]:
        """Set up comprehensive test data for session analytics tests."""
        db = db_with_tables
    
        # Create category and snippet
>       category_id = TestSessionMethodsFixtures.create_category(db)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_ngram_analytics_service_session_methods.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:239: in create_category
    db.execute(
db\database_manager.py:524: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x00000215B0737930>
e = OperationalError('table categories has no column named description')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table categories has no column named description

db\database_manager.py:434: DatabaseError
---------------------------- Captured stdout setup ----------------------------
Exception during query: table categories has no column named description. Rolling back transaction.
---------------------------- Captured stderr setup ----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 509, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table categories has no column named description
_ ERROR at setup of TestSummarizeSessionNgrams.test_sessions_missing_no_data __

self = <db.database_manager.DatabaseManager object at 0x00000215B0734750>
query = '\n            INSERT INTO categories (category_id, category_name, description)\n            VALUES (?, ?, ?)\n            '
params = ('c85d3d0f-88b2-4dc8-ab60-298732e2edc6', 'Test Category', 'Test category for testing')

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table categories has no column named description

db\database_manager.py:509: OperationalError

The above exception was the direct cause of the following exception:

db_with_tables = <db.database_manager.DatabaseManager object at 0x00000215B0734750>
test_user = User(user_id='8f3f4859-f8ad-417c-957d-eefe7dc1b85e', first_name='Test', surname='User', email_address='test.user.a1a0dc7c-bf32-4cbe-a602-cf0022288796@example.com')
test_keyboard = Keyboard(keyboard_id='9ce27134-5012-4f68-96f4-5b4bc1f21e17', user_id='8f3f4859-f8ad-417c-957d-eefe7dc1b85e', keyboard_name='Test Keyboard', target_ms_per_keystroke=600)

    @pytest.fixture
    def test_data_setup(db_with_tables: DatabaseManager, test_user: User, test_keyboard: Keyboard) -> Dict[str, Any]:
        """Set up comprehensive test data for session analytics tests."""
        db = db_with_tables
    
        # Create category and snippet
>       category_id = TestSessionMethodsFixtures.create_category(db)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_ngram_analytics_service_session_methods.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:239: in create_category
    db.execute(
db\database_manager.py:524: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x00000215B0734750>
e = OperationalError('table categories has no column named description')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table categories has no column named description

db\database_manager.py:434: DatabaseError
---------------------------- Captured stdout setup ----------------------------
Exception during query: table categories has no column named description. Rolling back transaction.
---------------------------- Captured stderr setup ----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 509, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table categories has no column named description
_ ERROR at setup of TestAddSpeedSummaryForSession.test_single_session_processing _

self = <db.database_manager.DatabaseManager object at 0x00000215B0734360>
query = '\n            INSERT INTO categories (category_id, category_name, description)\n            VALUES (?, ?, ?)\n            '
params = ('80f1f134-4df9-4bfc-8fe0-307c47994f26', 'Test Category', 'Test category for testing')

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table categories has no column named description

db\database_manager.py:509: OperationalError

The above exception was the direct cause of the following exception:

db_with_tables = <db.database_manager.DatabaseManager object at 0x00000215B0734360>
test_user = User(user_id='776a1c11-0a80-4d0d-ad54-bfb84352614c', first_name='Test', surname='User', email_address='test.user.0d5d5779-b8ac-4fad-9833-37ff7b6f6283@example.com')
test_keyboard = Keyboard(keyboard_id='40de1ddb-c446-49f3-8978-5ada9969fb5f', user_id='776a1c11-0a80-4d0d-ad54-bfb84352614c', keyboard_name='Test Keyboard', target_ms_per_keystroke=600)

    @pytest.fixture
    def test_data_setup(db_with_tables: DatabaseManager, test_user: User, test_keyboard: Keyboard) -> Dict[str, Any]:
        """Set up comprehensive test data for session analytics tests."""
        db = db_with_tables
    
        # Create category and snippet
>       category_id = TestSessionMethodsFixtures.create_category(db)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_ngram_analytics_service_session_methods.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:239: in create_category
    db.execute(
db\database_manager.py:524: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x00000215B0734360>
e = OperationalError('table categories has no column named description')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table categories has no column named description

db\database_manager.py:434: DatabaseError
---------------------------- Captured stdout setup ----------------------------
Exception during query: table categories has no column named description. Rolling back transaction.
---------------------------- Captured stderr setup ----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 509, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table categories has no column named description
_ ERROR at setup of TestAddSpeedSummaryForSession.test_multiple_ngrams_processing _

self = <db.database_manager.DatabaseManager object at 0x00000215B0759A90>
query = '\n            INSERT INTO categories (category_id, category_name, description)\n            VALUES (?, ?, ?)\n            '
params = ('03fc924d-25a7-45e9-8469-b697102c90b3', 'Test Category', 'Test category for testing')

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table categories has no column named description

db\database_manager.py:509: OperationalError

The above exception was the direct cause of the following exception:

db_with_tables = <db.database_manager.DatabaseManager object at 0x00000215B0759A90>
test_user = User(user_id='9aa4cfba-92e6-4286-92a5-d004ad822e92', first_name='Test', surname='User', email_address='test.user.0cc3c4a4-6ace-4076-a8ee-3131be1ab0f5@example.com')
test_keyboard = Keyboard(keyboard_id='f2e3728c-a7fa-449c-b438-b923418c3ff4', user_id='9aa4cfba-92e6-4286-92a5-d004ad822e92', keyboard_name='Test Keyboard', target_ms_per_keystroke=600)

    @pytest.fixture
    def test_data_setup(db_with_tables: DatabaseManager, test_user: User, test_keyboard: Keyboard) -> Dict[str, Any]:
        """Set up comprehensive test data for session analytics tests."""
        db = db_with_tables
    
        # Create category and snippet
>       category_id = TestSessionMethodsFixtures.create_category(db)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_ngram_analytics_service_session_methods.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:239: in create_category
    db.execute(
db\database_manager.py:524: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x00000215B0759A90>
e = OperationalError('table categories has no column named description')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table categories has no column named description

db\database_manager.py:434: DatabaseError
---------------------------- Captured stdout setup ----------------------------
Exception during query: table categories has no column named description. Rolling back transaction.
---------------------------- Captured stderr setup ----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 509, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table categories has no column named description
____ ERROR at setup of TestCatchupSpeedSummary.test_single_session_catchup ____

self = <db.database_manager.DatabaseManager object at 0x00000215B075BB60>
query = '\n            INSERT INTO categories (category_id, category_name, description)\n            VALUES (?, ?, ?)\n            '
params = ('83b44f57-7c87-4958-ac8e-6ae5fad081fd', 'Test Category', 'Test category for testing')

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table categories has no column named description

db\database_manager.py:509: OperationalError

The above exception was the direct cause of the following exception:

db_with_tables = <db.database_manager.DatabaseManager object at 0x00000215B075BB60>
test_user = User(user_id='041ea6de-6c22-4cdf-afbb-4e60991f2f5f', first_name='Test', surname='User', email_address='test.user.2995a187-4a89-435e-829f-008f35292040@example.com')
test_keyboard = Keyboard(keyboard_id='9756a60c-5060-4230-aa06-9e040f14c679', user_id='041ea6de-6c22-4cdf-afbb-4e60991f2f5f', keyboard_name='Test Keyboard', target_ms_per_keystroke=600)

    @pytest.fixture
    def test_data_setup(db_with_tables: DatabaseManager, test_user: User, test_keyboard: Keyboard) -> Dict[str, Any]:
        """Set up comprehensive test data for session analytics tests."""
        db = db_with_tables
    
        # Create category and snippet
>       category_id = TestSessionMethodsFixtures.create_category(db)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_ngram_analytics_service_session_methods.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:239: in create_category
    db.execute(
db\database_manager.py:524: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x00000215B075BB60>
e = OperationalError('table categories has no column named description')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table categories has no column named description

db\database_manager.py:434: DatabaseError
---------------------------- Captured stdout setup ----------------------------
Exception during query: table categories has no column named description. Rolling back transaction.
---------------------------- Captured stderr setup ----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 509, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table categories has no column named description
__ ERROR at setup of TestCatchupSpeedSummary.test_multiple_sessions_catchup ___

self = <db.database_manager.DatabaseManager object at 0x00000215B07589F0>
query = '\n            INSERT INTO categories (category_id, category_name, description)\n            VALUES (?, ?, ?)\n            '
params = ('290c1ecc-4768-4615-9c9a-67654cb75fed', 'Test Category', 'Test category for testing')

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table categories has no column named description

db\database_manager.py:509: OperationalError

The above exception was the direct cause of the following exception:

db_with_tables = <db.database_manager.DatabaseManager object at 0x00000215B07589F0>
test_user = User(user_id='8460f4f9-51ab-44a5-a776-69479569c003', first_name='Test', surname='User', email_address='test.user.f63636aa-cf8a-4215-9f14-072c81470bab@example.com')
test_keyboard = Keyboard(keyboard_id='73df1459-9c4a-43e5-8680-925b9fd8057b', user_id='8460f4f9-51ab-44a5-a776-69479569c003', keyboard_name='Test Keyboard', target_ms_per_keystroke=600)

    @pytest.fixture
    def test_data_setup(db_with_tables: DatabaseManager, test_user: User, test_keyboard: Keyboard) -> Dict[str, Any]:
        """Set up comprehensive test data for session analytics tests."""
        db = db_with_tables
    
        # Create category and snippet
>       category_id = TestSessionMethodsFixtures.create_category(db)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_ngram_analytics_service_session_methods.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:239: in create_category
    db.execute(
db\database_manager.py:524: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x00000215B07589F0>
e = OperationalError('table categories has no column named description')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table categories has no column named description

db\database_manager.py:434: DatabaseError
---------------------------- Captured stdout setup ----------------------------
Exception during query: table categories has no column named description. Rolling back transaction.
---------------------------- Captured stderr setup ----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 509, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table categories has no column named description
_ ERROR at setup of TestCatchupSpeedSummary.test_catchup_with_session_errors __

self = <db.database_manager.DatabaseManager object at 0x00000215B075BEE0>
query = '\n            INSERT INTO categories (category_id, category_name, description)\n            VALUES (?, ?, ?)\n            '
params = ('12149ced-c9f5-44f7-b25e-00bbc044400c', 'Test Category', 'Test category for testing')

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table categories has no column named description

db\database_manager.py:509: OperationalError

The above exception was the direct cause of the following exception:

db_with_tables = <db.database_manager.DatabaseManager object at 0x00000215B075BEE0>
test_user = User(user_id='3d76d5ea-2464-46dd-80e8-e071026f6baf', first_name='Test', surname='User', email_address='test.user.f43f6a2f-3716-450c-a038-86cf0c0ba2b1@example.com')
test_keyboard = Keyboard(keyboard_id='ae331da3-1c8e-44e7-b870-a5a355a4029f', user_id='3d76d5ea-2464-46dd-80e8-e071026f6baf', keyboard_name='Test Keyboard', target_ms_per_keystroke=600)

    @pytest.fixture
    def test_data_setup(db_with_tables: DatabaseManager, test_user: User, test_keyboard: Keyboard) -> Dict[str, Any]:
        """Set up comprehensive test data for session analytics tests."""
        db = db_with_tables
    
        # Create category and snippet
>       category_id = TestSessionMethodsFixtures.create_category(db)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_ngram_analytics_service_session_methods.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:239: in create_category
    db.execute(
db\database_manager.py:524: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x00000215B075BEE0>
e = OperationalError('table categories has no column named description')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table categories has no column named description

db\database_manager.py:434: DatabaseError
---------------------------- Captured stdout setup ----------------------------
Exception during query: table categories has no column named description. Rolling back transaction.
---------------------------- Captured stderr setup ----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 509, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table categories has no column named description
__ ERROR at setup of TestIntegrationScenarios.test_full_workflow_integration __

self = <db.database_manager.DatabaseManager object at 0x00000215B0098600>
query = '\n            INSERT INTO categories (category_id, category_name, description)\n            VALUES (?, ?, ?)\n            '
params = ('c0c87d7a-8579-43d9-9022-f22f69227aa0', 'Test Category', 'Test category for testing')

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table categories has no column named description

db\database_manager.py:509: OperationalError

The above exception was the direct cause of the following exception:

db_with_tables = <db.database_manager.DatabaseManager object at 0x00000215B0098600>
test_user = User(user_id='b9fb71cf-1a70-4404-b19f-5ff940c775e1', first_name='Test', surname='User', email_address='test.user.b7e8b56c-e925-494a-85fd-1126af87b008@example.com')
test_keyboard = Keyboard(keyboard_id='4df30869-8d3a-40d6-bd78-d75e3b894218', user_id='b9fb71cf-1a70-4404-b19f-5ff940c775e1', keyboard_name='Test Keyboard', target_ms_per_keystroke=600)

    @pytest.fixture
    def test_data_setup(db_with_tables: DatabaseManager, test_user: User, test_keyboard: Keyboard) -> Dict[str, Any]:
        """Set up comprehensive test data for session analytics tests."""
        db = db_with_tables
    
        # Create category and snippet
>       category_id = TestSessionMethodsFixtures.create_category(db)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_ngram_analytics_service_session_methods.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:239: in create_category
    db.execute(
db\database_manager.py:524: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x00000215B0098600>
e = OperationalError('table categories has no column named description')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table categories has no column named description

db\database_manager.py:434: DatabaseError
---------------------------- Captured stdout setup ----------------------------
Exception during query: table categories has no column named description. Rolling back transaction.
---------------------------- Captured stderr setup ----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 509, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table categories has no column named description
__________________ ERROR at setup of test_snippet_ascii_name __________________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 64
  def test_snippet_ascii_name(valid_snippet_data: Dict[str, str]) -> None:
E       fixture 'valid_snippet_data' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:64
_________________ ERROR at setup of test_snippet_name_length __________________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 86
  def test_snippet_name_length(valid_snippet_data: Dict[str, Union[str, str]]) -> None:
E       fixture 'valid_snippet_data' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:86
_ ERROR at setup of test_snippet_creation_validation[Alpha-Some content-True] _
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 117
  @pytest.mark.parametrize(
      "name,content,expect_success",
      [
          ("Alpha", "Some content", True),
          ("", "Some content", False),  # Validation for name
          ("A" * 129, "Content", False),  # Validation for name length
          ("NonAsciiΘ", "Content", False),  # Validation for name ASCII
          ("Alpha", "", False),  # Validation for content
      ],
  )
  def test_snippet_creation_validation(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:117
___ ERROR at setup of test_snippet_creation_validation[-Some content-False] ___
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 117
  @pytest.mark.parametrize(
      "name,content,expect_success",
      [
          ("Alpha", "Some content", True),
          ("", "Some content", False),  # Validation for name
          ("A" * 129, "Content", False),  # Validation for name length
          ("NonAsciiΘ", "Content", False),  # Validation for name ASCII
          ("Alpha", "", False),  # Validation for content
      ],
  )
  def test_snippet_creation_validation(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:117
_ ERROR at setup of test_snippet_creation_validation[AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA-Content-False] _
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 117
  @pytest.mark.parametrize(
      "name,content,expect_success",
      [
          ("Alpha", "Some content", True),
          ("", "Some content", False),  # Validation for name
          ("A" * 129, "Content", False),  # Validation for name length
          ("NonAsciiΘ", "Content", False),  # Validation for name ASCII
          ("Alpha", "", False),  # Validation for content
      ],
  )
  def test_snippet_creation_validation(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:117
_ ERROR at setup of test_snippet_creation_validation[NonAscii\xe9-Content-False] _
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 117
  @pytest.mark.parametrize(
      "name,content,expect_success",
      [
          ("Alpha", "Some content", True),
          ("", "Some content", False),  # Validation for name
          ("A" * 129, "Content", False),  # Validation for name length
          ("NonAsciiΘ", "Content", False),  # Validation for name ASCII
          ("Alpha", "", False),  # Validation for content
      ],
  )
  def test_snippet_creation_validation(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:117
______ ERROR at setup of test_snippet_creation_validation[Alpha--False] _______
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 117
  @pytest.mark.parametrize(
      "name,content,expect_success",
      [
          ("Alpha", "Some content", True),
          ("", "Some content", False),  # Validation for name
          ("A" * 129, "Content", False),  # Validation for name length
          ("NonAsciiΘ", "Content", False),  # Validation for name ASCII
          ("Alpha", "", False),  # Validation for content
      ],
  )
  def test_snippet_creation_validation(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:117
____ ERROR at setup of test_snippet_name_uniqueness[Unique1-Unique2-True] _____
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 150
  @pytest.mark.parametrize(
      "name1,name2,should_succeed",
      [
          ("Unique1", "Unique2", True),
          ("DupName", "DupName", False),
      ],
  )
  def test_snippet_name_uniqueness(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:150
____ ERROR at setup of test_snippet_name_uniqueness[DupName-DupName-False] ____
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 150
  @pytest.mark.parametrize(
      "name1,name2,should_succeed",
      [
          ("Unique1", "Unique2", True),
          ("DupName", "DupName", False),
      ],
  )
  def test_snippet_name_uniqueness(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:150
________________ ERROR at setup of test_snippet_creation_valid ________________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 175
  def test_snippet_creation_valid(
E       fixture 'snippet_manager' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:175
_______________ ERROR at setup of test_get_nonexistent_snippet ________________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 193
  def test_get_nonexistent_snippet(snippet_manager: SnippetManager) -> None:
E       fixture 'snippet_manager' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:193
_________________ ERROR at setup of test_list_snippets_empty __________________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 198
  def test_list_snippets_empty(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:198
_______________ ERROR at setup of test_list_snippets_populated ________________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 218
  def test_list_snippets_populated(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:218
_____________________ ERROR at setup of test_snippet_edit _____________________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 241
  def test_snippet_edit(
E       fixture 'snippet_manager' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:241
____________________ ERROR at setup of test_snippet_update ____________________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 260
  def test_snippet_update(snippet_category_fixture: str, snippet_manager: SnippetManager) -> None:
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:260
_______________ ERROR at setup of test_snippet_update_name_only _______________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 274
  def test_snippet_update_name_only(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:274
_____________ ERROR at setup of test_snippet_update_content_only ______________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 291
  def test_snippet_update_content_only(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:291
____________________ ERROR at setup of test_snippet_delete ____________________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 308
  def test_snippet_delete(snippet_category_fixture: str, snippet_manager: SnippetManager) -> None:
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:308
______________ ERROR at setup of test_delete_nonexistent_snippet ______________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 317
  def test_delete_nonexistent_snippet(snippet_manager: SnippetManager) -> None:
E       fixture 'snippet_manager' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:317
_____________ ERROR at setup of test_edit_snippet_change_category _____________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 328
  def test_edit_snippet_change_category(
E       fixture 'snippet_manager' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:328
____________ ERROR at setup of test_edit_snippet_invalid_category _____________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 351
  def test_edit_snippet_invalid_category(
E       fixture 'snippet_manager' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:351
________________ ERROR at setup of test_snippet_sql_injection _________________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 366
  def test_snippet_sql_injection(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:366
___________ ERROR at setup of test_snippet_sql_injection_in_content ___________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 375
  def test_snippet_sql_injection_in_content(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:375
_________________ ERROR at setup of test_snippet_long_content _________________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 384
  def test_snippet_long_content(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:384
_________ ERROR at setup of test_snippet_content_splitting_boundaries _________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 398
  def test_snippet_content_splitting_boundaries(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:398
______________ ERROR at setup of test_update_nonexistent_snippet ______________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 593
  def test_update_nonexistent_snippet(snippet_manager: SnippetManager) -> None:
E       fixture 'snippet_manager' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:593
_____________ ERROR at setup of test_snippet_part_number_sequence _____________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 432
  def test_snippet_part_number_sequence(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:432
______________ ERROR at setup of test_snippet_operation_handling ______________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 520
  def test_snippet_operation_handling(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:520
____________________ ERROR at setup of test_delete_snippet ____________________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 563
  def test_delete_snippet(snippet_category_fixture: str, snippet_manager: SnippetManager) -> None:
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:563
_______ ERROR at setup of test_create_snippet_with_nonexistent_category _______
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 580
  def test_create_snippet_with_nonexistent_category(snippet_manager: SnippetManager) -> None:
E       fixture 'snippet_manager' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:580
________________ ERROR at setup of test_update_snippet_partial ________________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 602
  def test_update_snippet_partial(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:602
______________ ERROR at setup of test_update_snippet_no_changes _______________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 637
  def test_update_snippet_no_changes(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:637
_________________ ERROR at setup of test_get_snippet_by_name __________________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 665
  def test_get_snippet_by_name(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:665
___________ ERROR at setup of test_get_snippet_by_name_nonexistent ____________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 685
  def test_get_snippet_by_name_nonexistent(
E       fixture 'snippet_manager' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:685
_______ ERROR at setup of test_get_snippet_by_name_multiple_categories ________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 692
  def test_get_snippet_by_name_multiple_categories(
E       fixture 'category_manager' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:692
___________________ ERROR at setup of test_search_snippets ____________________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 727
  def test_search_snippets(snippet_category_fixture: str, snippet_manager: SnippetManager) -> None:
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:727
______________ ERROR at setup of test_search_snippets_no_results ______________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 760
  def test_search_snippets_no_results(snippet_manager: SnippetManager) -> None:
E       fixture 'snippet_manager' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:760
__________ ERROR at setup of test_snippet_sql_injection_name_create ___________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 768
  def test_snippet_sql_injection_name_create(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:768
_________ ERROR at setup of test_snippet_sql_injection_content_create _________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 782
  def test_snippet_sql_injection_content_create(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:782
_ ERROR at setup of test_snippet_sql_injection_name_create_with_specific_error _
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 796
  def test_snippet_sql_injection_name_create_with_specific_error(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:796
_________ ERROR at setup of test_snippet_sql_injection_content_update _________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 810
  def test_snippet_sql_injection_content_update(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:810
__________ ERROR at setup of test_snippet_sql_injection_name_update ___________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 824
  def test_snippet_sql_injection_name_update(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:824
_____________ ERROR at setup of test_snippet_deletion_idempotency _____________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 838
  def test_snippet_deletion_idempotency(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:838
_ ERROR at setup of test_snippet_manager_handles_db_errors_gracefully_on_create _
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 854
  def test_snippet_manager_handles_db_errors_gracefully_on_create(
E       fixture 'snippet_manager' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:854
_ ERROR at setup of test_snippet_manager_handles_db_errors_gracefully_on_get __
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 871
  def test_snippet_manager_handles_db_errors_gracefully_on_get(
E       fixture 'snippet_manager' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:871
_ ERROR at setup of test_snippet_manager_handles_db_errors_gracefully_on_update _
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 883
  def test_snippet_manager_handles_db_errors_gracefully_on_update(
E       fixture 'snippet_manager' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:883
_ ERROR at setup of test_snippet_manager_handles_db_errors_gracefully_on_delete _
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 910
  def test_snippet_manager_handles_db_errors_gracefully_on_delete(
E       fixture 'snippet_manager' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:910
_ ERROR at setup of test_snippet_manager_handles_db_errors_gracefully_on_list _
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 948
  def test_snippet_manager_handles_db_errors_gracefully_on_list(
E       fixture 'snippet_manager' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:948
_ ERROR at setup of test_snippet_manager_handles_db_errors_gracefully_on_search _
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 960
  def test_snippet_manager_handles_db_errors_gracefully_on_search(
E       fixture 'snippet_manager' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:960
______ ERROR at setup of test_create_snippet_pydantic_validation_errors _______
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 972
  def test_create_snippet_pydantic_validation_errors(
E       fixture 'snippet_manager' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:972
================================== FAILURES ===================================
________________ TestNGramOnlyMode.test_generate_ngram_content ________________

self = <AITypingTrainer.tests.models.test_dynamic_content_manager.TestNGramOnlyMode object at 0x00000215AFF247D0>
basic_manager = <models.dynamic_content_manager.DynamicContentManager object at 0x00000215B0403BD0>

    def test_generate_ngram_content(self, basic_manager: DynamicContentManager) -> None:
        """Test generating content with NGramOnly mode."""
        basic_manager.mode = ContentMode.NGRAM_ONLY
        content = basic_manager.generate_content()
    
        # Verify content format and constraints
        assert content, "Content should not be empty"
        assert len(content) <= basic_manager.practice_length, "Content should not exceed practice length"
    
        # Verify content only contains ngrams from focus list
        parts = content.split()
        for part in parts:
>           assert part in basic_manager.ngram_focus_list, f"Part '{part}' should be in ngram focus list"
E           AssertionError: Part 'e' should be in ngram focus list
E           assert 'e' in ['es', 'st', 'te']
E            +  where ['es', 'st', 'te'] = <models.dynamic_content_manager.DynamicContentManager object at 0x00000215B0403BD0>.ngram_focus_list

tests\models\test_dynamic_content_manager.py:170: AssertionError
_______ TestNGramOnlyMode.test_ngram_content_filters_out_of_scope_chars _______

self = <AITypingTrainer.tests.models.test_dynamic_content_manager.TestNGramOnlyMode object at 0x00000215AFA71F30>

    def test_ngram_content_filters_out_of_scope_chars(self) -> None:
        """Test that NGramOnly content filters out ngrams with out-of-scope characters."""
        manager = DynamicContentManager(
            in_scope_keys=["a", "b"],
            ngram_focus_list=["ab", "cd", "xy"],  # Only "ab" should be used
            mode=ContentMode.NGRAM_ONLY
        )
    
        content = manager.generate_content()
    
        # Content should only include "ab"
>       assert content == "ab" or content == "", "Content should only include ngrams with in-scope keys"
E       AssertionError: Content should only include ngrams with in-scope keys
E       assert ('ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab a' == 'ab'
E         
E         - ab
E         + ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab a or 'ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab a' == ''
E         
E         + ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab a)

tests\models\test_dynamic_content_manager.py:202: AssertionError
________________ TestMixedMode.test_mixed_content_has_variety _________________

self = <AITypingTrainer.tests.models.test_dynamic_content_manager.TestMixedMode object at 0x00000215AFF24E10>
basic_manager = <models.dynamic_content_manager.DynamicContentManager object at 0x00000215B0493250>

    def test_mixed_content_has_variety(self, basic_manager: DynamicContentManager) -> None:
        """Test that Mixed content includes both ngrams and words."""
        # This test is a bit tricky since the mixed content is randomized
        # We'll make multiple attempts and check statistics
    
        basic_manager.mode = ContentMode.MIXED
        basic_manager.ngram_focus_list = ["ab", "cd"]
    
        # Replace the mock LLM service with one that returns very distinct words
        with patch.object(basic_manager.llm_service, "get_words_with_ngrams",  # type: ignore
                         return_value="abcdef cdabef longerword"):
    
            # Make multiple generation attempts
            seen_ngrams = set()
            seen_longer = False
    
            for _ in range(10):  # Try multiple times due to randomization
                content = basic_manager.generate_content()
                parts = content.split()
    
                for part in parts:
                    if part in basic_manager.ngram_focus_list:
                        seen_ngrams.add(part)
                    elif len(part) > 3:  # Assume longer parts are "words" not ngrams
                        seen_longer = True
    
            # We should see both ngrams and longer words
>           assert seen_ngrams, "Mixed content should include some ngrams"
E           AssertionError: Mixed content should include some ngrams
E           assert set()

tests\models\test_dynamic_content_manager.py:306: AssertionError
---------------------------- Captured stdout call -----------------------------
Generating Text: Raw words: abcdef cdabef longerword
Skipping word: abcdef - bad characters
Skipping word: cdabef - bad characters
Skipping word: longerword - bad characters
Generating Text: Raw words: abcdef cdabef longerword
Skipping word: abcdef - bad characters
Skipping word: cdabef - bad characters
Skipping word: longerword - bad characters
Generating Text: Raw words: abcdef cdabef longerword
Skipping word: abcdef - bad characters
Skipping word: cdabef - bad characters
Skipping word: longerword - bad characters
Generating Text: Raw words: abcdef cdabef longerword
Skipping word: abcdef - bad characters
Skipping word: cdabef - bad characters
Skipping word: longerword - bad characters
Generating Text: Raw words: abcdef cdabef longerword
Skipping word: abcdef - bad characters
Skipping word: cdabef - bad characters
Skipping word: longerword - bad characters
Generating Text: Raw words: abcdef cdabef longerword
Skipping word: abcdef - bad characters
Skipping word: cdabef - bad characters
Skipping word: longerword - bad characters
Generating Text: Raw words: abcdef cdabef longerword
Skipping word: abcdef - bad characters
Skipping word: cdabef - bad characters
Skipping word: longerword - bad characters
Generating Text: Raw words: abcdef cdabef longerword
Skipping word: abcdef - bad characters
Skipping word: cdabef - bad characters
Skipping word: longerword - bad characters
Generating Text: Raw words: abcdef cdabef longerword
Skipping word: abcdef - bad characters
Skipping word: cdabef - bad characters
Skipping word: longerword - bad characters
Generating Text: Raw words: abcdef cdabef longerword
Skipping word: abcdef - bad characters
Skipping word: cdabef - bad characters
Skipping word: longerword - bad characters
_______ TestKeystrokeManagerSaveKeystrokes.test_save_keystrokes_success _______

self = <AITypingTrainer.tests.models.test_keystroke_manager.TestKeystrokeManagerSaveKeystrokes object at 0x00000215AFF26850>
manager_with_mock_db = <models.keystroke_manager.KeystrokeManager object at 0x00000215B03F1220>
sample_keystrokes = [Keystroke(session_id='save-test-session', keystroke_id='d2a188e2-5978-4349-a9c4-d6ffe62a6d80', keystroke_time=datetim...=datetime.timezone.utc), keystroke_char='c', expected_char='c', is_error=False, time_since_previous=120, text_index=0)]

    def test_save_keystrokes_success(
        self, manager_with_mock_db: KeystrokeManager, sample_keystrokes: List[Keystroke]
    ) -> None:
        """Test successful saving of keystrokes."""
        manager_with_mock_db.keystroke_list = sample_keystrokes
    
        result = manager_with_mock_db.save_keystrokes()
    
        assert result is True
>       assert manager_with_mock_db.db_manager.execute.call_count == 3
E       AssertionError: assert 0 == 3
E        +  where 0 = <Mock name='mock.execute' id='2292171060096'>.call_count
E        +    where <Mock name='mock.execute' id='2292171060096'> = <Mock spec='DatabaseManager' id='2292171062784'>.execute
E        +      where <Mock spec='DatabaseManager' id='2292171062784'> = <models.keystroke_manager.KeystrokeManager object at 0x00000215B03F1220>.db_manager

tests\models\test_keystroke_manager.py:234: AssertionError
___ TestKeystrokeManagerSaveKeystrokes.test_save_keystrokes_database_error ____

self = <AITypingTrainer.tests.models.test_keystroke_manager.TestKeystrokeManagerSaveKeystrokes object at 0x00000215AFA736F0>
manager_with_mock_db = <models.keystroke_manager.KeystrokeManager object at 0x00000215B0403A10>
sample_keystrokes = [Keystroke(session_id='save-test-session', keystroke_id='a9c81d03-1e41-44a0-964a-662dc6227b86', keystroke_time=datetim...=datetime.timezone.utc), keystroke_char='c', expected_char='c', is_error=False, time_since_previous=120, text_index=0)]

    def test_save_keystrokes_database_error(
        self, manager_with_mock_db: KeystrokeManager, sample_keystrokes: List[Keystroke]
    ) -> None:
        """Test handling of database errors during save."""
        manager_with_mock_db.keystroke_list = sample_keystrokes
        manager_with_mock_db.db_manager.execute.side_effect = Exception(
            "Database connection failed"
        )
    
        with patch("sys.stderr"), patch("traceback.print_exc"):
            result = manager_with_mock_db.save_keystrokes()
    
>       assert result is False
E       assert True is False

tests\models\test_keystroke_manager.py:277: AssertionError
_ TestKeystrokeManagerSaveKeystrokes.test_save_keystrokes_with_special_characters _

self = <AITypingTrainer.tests.models.test_keystroke_manager.TestKeystrokeManagerSaveKeystrokes object at 0x00000215AFA73820>
manager_with_mock_db = <models.keystroke_manager.KeystrokeManager object at 0x00000215B0442CF0>

    def test_save_keystrokes_with_special_characters(
        self, manager_with_mock_db: KeystrokeManager
    ) -> None:
        """Test saving keystrokes with special characters."""
        import uuid
    
        special_chars = ["'", '"', "\\\\", "\\n", "\\t", "\u20ac", "\U0001f60a"]
        keystrokes = []
        for _i, char in enumerate(special_chars):
            keystroke = Keystroke(
                session_id="special-char-session",
                keystroke_id=str(uuid.uuid4()),
                keystroke_time=datetime.now(timezone.utc),
                keystroke_char=char,
                expected_char=char,
                is_error=False,
                time_since_previous=100,
            )
            keystrokes.append(keystroke)
        manager_with_mock_db.keystroke_list = keystrokes
        result = manager_with_mock_db.save_keystrokes()
        assert result is True
>       assert manager_with_mock_db.db_manager.execute.call_count == len(special_chars)
E       assert 0 == 7
E        +  where 0 = <Mock name='mock.execute' id='2292175901024'>.call_count
E        +    where <Mock name='mock.execute' id='2292175901024'> = <Mock spec='DatabaseManager' id='2292171060768'>.execute
E        +      where <Mock spec='DatabaseManager' id='2292171060768'> = <models.keystroke_manager.KeystrokeManager object at 0x00000215B0442CF0>.db_manager
E        +  and   7 = len(["'", '"', '\\', '\n', '\t', '\u20ac', '\U0001f60a'])

tests\models\test_keystroke_manager.py:301: AssertionError
_ TestKeystrokeManagerSaveKeystrokes.test_save_keystrokes_boolean_conversion __

self = <AITypingTrainer.tests.models.test_keystroke_manager.TestKeystrokeManagerSaveKeystrokes object at 0x00000215AFFBD010>
manager_with_mock_db = <models.keystroke_manager.KeystrokeManager object at 0x00000215B0567860>

    def test_save_keystrokes_boolean_conversion(
        self, manager_with_mock_db: KeystrokeManager
    ) -> None:
        """Test that boolean is_error is properly converted to int."""
        import uuid
    
        keystroke = Keystroke(
            session_id="bool-test",
            keystroke_id=str(uuid.uuid4()),
            keystroke_time=datetime.now(timezone.utc),
            keystroke_char="a",
            expected_char="b",
            is_error=True,
            time_since_previous=50,
        )
        manager_with_mock_db.keystroke_list = [keystroke]
        result = manager_with_mock_db.save_keystrokes()
        assert result is True
        call_args = manager_with_mock_db.db_manager.execute.call_args
>       params = call_args[0][1]
                 ^^^^^^^^^^^^
E       TypeError: 'NoneType' object is not subscriptable

tests\models\test_keystroke_manager.py:322: TypeError
________ TestKeystrokeManagerIntegration.test_full_keystroke_workflow _________

self = <AITypingTrainer.tests.models.test_keystroke_manager.TestKeystrokeManagerIntegration object at 0x00000215AFF26FD0>
integration_manager = <models.keystroke_manager.KeystrokeManager object at 0x00000215B05A36B0>

    def test_full_keystroke_workflow(self, integration_manager: KeystrokeManager) -> None:
        """Test complete workflow: add, save, count, retrieve, delete."""
        import uuid
    
        session_id = str(uuid.uuid4())
        # Insert a matching session into the database
        db = integration_manager.db_manager
        db.init_tables()
        # Ensure session_keystrokes table is correct for UUID keystroke_id
        db.execute("DROP TABLE IF EXISTS session_keystrokes")
        db.execute(
            """
            CREATE TABLE session_keystrokes (
                keystroke_id TEXT PRIMARY KEY,
                session_id TEXT NOT NULL,
                keystroke_time TEXT NOT NULL,
                keystroke_char TEXT NOT NULL,
                expected_char TEXT NOT NULL,
                is_error INTEGER NOT NULL,
                time_since_previous INTEGER,
                FOREIGN KEY (session_id) REFERENCES practice_sessions(session_id) ON DELETE CASCADE
            )
            """
        )
        category_id = str(uuid.uuid4())
        # Insert a matching category into the database
        db.execute(
            """
            INSERT INTO categories (category_id, category_name) VALUES (?, ?)
            """,
            (category_id, "integration-category"),
        )
        snippet_id = str(uuid.uuid4())
        # Insert a matching snippet into the database
        db.execute(
            """
            INSERT INTO snippets (snippet_id, category_id, snippet_name) VALUES (?, ?, ?)
            """,
            (snippet_id, category_id, "integration-snippet"),
        )
        user_id = str(uuid.uuid4())
        keyboard_id = str(uuid.uuid4())
        db.execute(
            "INSERT INTO users (user_id, first_name, surname, email_address) VALUES (?, ?, ?, ?)",
            (user_id, "Test", "User", f"testuser_{user_id[:8]}@example.com"),
        )
        db.execute(
            "INSERT INTO keyboards (keyboard_id, user_id, keyboard_name) VALUES (?, ?, ?)",
            (keyboard_id, user_id, "Test Keyboard"),
        )
        db.execute(
            "INSERT INTO practice_sessions (session_id, snippet_id, user_id, keyboard_id, snippet_index_start, snippet_index_end, content, start_time, end_time, actual_chars, errors, ms_per_keystroke) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)",
            (
                session_id,
                snippet_id,
                user_id,
                keyboard_id,
                0,
                10,
                "abcde",
                "2025-06-10T12:00:00",
                "2025-06-10T12:01:00",
                5,
                0,
                100.0,
            ),
        )
        # Create test keystrokes
        keystrokes = []
        for i in range(5):
            keystroke = Keystroke(
                session_id=session_id,
                keystroke_id=str(uuid.uuid4()),
                keystroke_time=datetime.now(timezone.utc),
                keystroke_char=chr(97 + i),
                expected_char=chr(97 + i),
                is_error=i == 2,  # Make one an error
                time_since_previous=100 + i * 10,  # Always integer
            )
            keystrokes.append(keystroke)
            integration_manager.add_keystroke(keystroke)
        # Verify keystrokes are in memory
        assert len(integration_manager.keystroke_list) == 5
        # Save to database
        save_result = integration_manager.save_keystrokes()
>       assert save_result is True
E       assert False is True

tests\models\test_keystroke_manager.py:636: AssertionError
---------------------------- Captured stdout call -----------------------------
 Exception during execute_many: table session_keystrokes has no column named text_index. Rolling back transaction.
---------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 605, in execute_many
    return self._bulk_executemany(cursor, query, params_list)
           ~~~~~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 633, in _bulk_executemany
    cursor.executemany(query, params_list)
    ~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^
sqlite3.OperationalError: table session_keystrokes has no column named text_index
Error saving keystrokes: Database operation failed: table session_keystrokes has no column named text_index
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 605, in execute_many
    return self._bulk_executemany(cursor, query, params_list)
           ~~~~~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 633, in _bulk_executemany
    cursor.executemany(query, params_list)
    ~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^
sqlite3.OperationalError: table session_keystrokes has no column named text_index

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\models\keystroke_manager.py", line 63, in save_keystrokes
    self.db_manager.execute_many(query, params)  # type: ignore[attr-defined]
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 614, in execute_many
    self._translate_and_raise(e)
    ~~~~~~~~~~~~~~~~~~~~~~~~~^^^
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 434, in _translate_and_raise
    raise DatabaseError(f"Database operation failed: {e}") from e
db.exceptions.DatabaseError: Database operation failed: table session_keystrokes has no column named text_index
______ TestKeystrokeManagerEdgeCases.test_unicode_and_special_characters ______

self = <AITypingTrainer.tests.models.test_keystroke_manager.TestKeystrokeManagerEdgeCases object at 0x00000215AFA73E10>
manager = <models.keystroke_manager.KeystrokeManager object at 0x00000215B057E2D0>

    def test_unicode_and_special_characters(self, manager: KeystrokeManager) -> None:
        """Test handling of Unicode and special characters in keystrokes."""
        import uuid
    
        special_chars = [
            "\U0001f642",
            "\u6d4b\u8bd5",
            "cafΘ",
            "\u03a9",
            "\n",
            "\t",
            "\\",
            "'",
            '"',
            "\0",
        ]
        for _i, char in enumerate(special_chars):
            keystroke = Keystroke(
                session_id="unicode-test",
                keystroke_id=str(uuid.uuid4()),
                keystroke_time=datetime.now(timezone.utc),
                keystroke_char=char,
                expected_char=char,
                is_error=False,
                time_since_previous=100,  # Always integer
            )
            manager.add_keystroke(keystroke)
        assert len(manager.keystroke_list) == len(special_chars)
        result = manager.save_keystrokes()
        assert result is True
>       assert manager.db_manager.execute.call_count == len(special_chars)
E       assert 0 == 10
E        +  where 0 = <Mock name='mock.execute' id='2292175909088'>.call_count
E        +    where <Mock name='mock.execute' id='2292175909088'> = <Mock spec='DatabaseManager' id='2292175910432'>.execute
E        +      where <Mock spec='DatabaseManager' id='2292175910432'> = <models.keystroke_manager.KeystrokeManager object at 0x00000215B057E2D0>.db_manager
E        +  and   10 = len(['\U0001f642', '\u6d4b\u8bd5', 'caf\xe9', '\u03a9', '\n', '\t', '\\', "'", '"', '\x00'])

tests\models\test_keystroke_manager.py:829: AssertionError
_____ TestKeystrokeManagerErrorHandling.test_database_connection_failure ______

self = <AITypingTrainer.tests.models.test_keystroke_manager.TestKeystrokeManagerErrorHandling object at 0x00000215AFF274D0>
manager = <models.keystroke_manager.KeystrokeManager object at 0x00000215B054C9B0>

    def test_database_connection_failure(self, manager: KeystrokeManager) -> None:
        """Test handling of database connection failures."""
        import uuid
    
        manager.db_manager.execute.side_effect = Exception("Connection lost")
        keystroke = Keystroke(
            session_id="error-test",
            keystroke_id=str(uuid.uuid4()),
            keystroke_time=datetime.now(timezone.utc),
            keystroke_char="a",
            expected_char="a",
            is_error=False,
            time_since_previous=100,
        )
        manager.add_keystroke(keystroke)
        result = manager.save_keystrokes()
>       assert result is False
E       assert True is False

tests\models\test_keystroke_manager.py:878: AssertionError
_________ TestKeystrokeManagerErrorHandling.test_partial_save_failure _________

self = <AITypingTrainer.tests.models.test_keystroke_manager.TestKeystrokeManagerErrorHandling object at 0x00000215B0010180>
manager = <models.keystroke_manager.KeystrokeManager object at 0x00000215B05A1430>

    def test_partial_save_failure(self, manager: KeystrokeManager) -> None:
        """Test handling when some keystrokes save successfully and others fail."""
        import uuid
    
        keystrokes = []
        for i in range(3):
            keystroke = Keystroke(
                session_id="partial-test",
                keystroke_id=str(uuid.uuid4()),
                keystroke_time=datetime.now(timezone.utc),
                keystroke_char=chr(97 + i),
                expected_char=chr(97 + i),
                is_error=False,
                time_since_previous=100,
            )
            keystrokes.append(keystroke)
        manager.keystroke_list = keystrokes
        manager.db_manager.execute.side_effect = [None, Exception("Save failed"), None]
        result = manager.save_keystrokes()
>       assert result is False
E       assert True is False

tests\models\test_keystroke_manager.py:919: AssertionError
______ TestKeystrokeManagerErrorHandling.test_network_timeout_simulation ______

self = <AITypingTrainer.tests.models.test_keystroke_manager.TestKeystrokeManagerErrorHandling object at 0x00000215B00102B0>
manager = <models.keystroke_manager.KeystrokeManager object at 0x00000215B059C1D0>

    def test_network_timeout_simulation(self, manager: KeystrokeManager) -> None:
        """Test handling of network timeout-like errors."""
        import time
        import uuid
    
        def slow_execute(*args: object, **kwargs: object) -> object:
            time.sleep(0.1)  # Simulate slow operation
            raise TimeoutError("Database timeout")
    
        manager.db_manager.execute.side_effect = slow_execute
        keystroke = Keystroke(
            session_id="timeout-test",
            keystroke_id=str(uuid.uuid4()),
            keystroke_time=datetime.now(timezone.utc),
            keystroke_char="a",
            expected_char="a",
            is_error=False,
            time_since_previous=100,
        )
        manager.add_keystroke(keystroke)
        result = manager.save_keystrokes()
>       assert result is False
E       assert True is False

tests\models\test_keystroke_manager.py:942: AssertionError
____________________________ test_missing_api_key _____________________________

    def test_missing_api_key():
>       with pytest.raises(LLMMissingAPIKeyError):
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       Failed: DID NOT RAISE <class 'models.llm_ngram_service.LLMMissingAPIKeyError'>

tests\models\test_llm_ngram_service.py:8: Failed
________________ TestKeystroke.test_keystroke_nfc_single_char _________________

self = <AITypingTrainer.tests.models.test_ngram.TestKeystroke object at 0x00000215AFF27D90>

    def test_keystroke_nfc_single_char(self):
        # composed e + \u0301
        k = Keystroke(keystroke_time=ts(0), text_index=0, expected_char="e\u0301", keystroke_char="Θ", is_error=False)
>       assert k.expected_char == "Θ"
E       AssertionError: assert 'e\u0301' == '\xe9'
E         
E         - Θ
E         + e\u0301

tests\models\test_ngram.py:32: AssertionError
__ TestNGramAnalyticsService.test_dual_insert_creates_records_in_both_tables __

self = <AITypingTrainer.tests.models.test_ngram_analytics_service.TestNGramAnalyticsService object at 0x00000215AFFC9650>
temp_db = 'C:\\Users\\seanb\\AppData\\Local\\Temp\\tmpghu_4j57.db'
mock_sessions = [{'keyboard_id': 'keyboard_1', 'session_id': 'session_1', 'start_time': '2024-01-01 10:01:00', 'target_ms_per_keystrok...: 'keyboard_1', 'session_id': 'session_2', 'start_time': '2024-01-01 10:02:00', 'target_ms_per_keystroke': 170.0, ...}]
mock_ngram_data = [{'ms_per_keystroke': 100.0, 'ngram_size': 2, 'ngram_speed_id': 'ng_0', 'ngram_text': 'th', ...}, {'ms_per_keystroke':...ram_text': 'th', ...}, {'ms_per_keystroke': 107.5, 'ngram_size': 3, 'ngram_speed_id': 'ng_3', 'ngram_text': 'he', ...}]

    def test_dual_insert_creates_records_in_both_tables(
        self,
        temp_db: DatabaseManager,
        mock_sessions: List[MockSessionData],
        mock_ngram_data: List[MockNGramSpeedData],
    ) -> None:
        """
        Test objective: Verify dual-insert creates records in both current and history tables.
    
        Tests that when refresh_speed_summaries is called, records are created
        in both ngram_speed_summary_curr and ngram_speed_summary_hist tables.
        """
        ngram_manager = NGramManager(temp_db)
        service = NGramAnalyticsService(temp_db, ngram_manager)
    
        # Set up test data
        user_id = "user_1"
        keyboard_id = "keyboard_1"
    
        # Insert test session and keyboard data
        for session in mock_sessions:
>           temp_db.execute(
            ^^^^^^^^^^^^^^^
                """INSERT INTO practice_sessions
                (session_id, user_id, keyboard_id, snippet_id, snippet_index_start, snippet_index_end,
                 content, start_time, end_time, actual_chars, errors, ms_per_keystroke)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)""",
                (
                    session["session_id"],
                    session["user_id"],
                    session["keyboard_id"],
                    "test_snippet_1",
                    0,
                    10,
                    "test content",
                    session["start_time"],
                    session["start_time"],
                    "test",
                    0,
                    session["target_ms_per_keystroke"],
                ),
            )
E           AttributeError: 'str' object has no attribute 'execute'

tests\models\test_ngram_analytics_service.py:370: AttributeError
____ TestNGramAnalyticsService.test_history_table_accumulates_all_records _____

self = <AITypingTrainer.tests.models.test_ngram_analytics_service.TestNGramAnalyticsService object at 0x00000215AFFC9C50>
temp_db = 'C:\\Users\\seanb\\AppData\\Local\\Temp\\tmpm8vmagkx.db'
mock_sessions = [{'keyboard_id': 'keyboard_1', 'session_id': 'session_1', 'start_time': '2024-01-01 10:01:00', 'target_ms_per_keystrok...: 'keyboard_1', 'session_id': 'session_2', 'start_time': '2024-01-01 10:02:00', 'target_ms_per_keystroke': 170.0, ...}]
mock_ngram_data = [{'ms_per_keystroke': 100.0, 'ngram_size': 2, 'ngram_speed_id': 'ng_0', 'ngram_text': 'th', ...}, {'ms_per_keystroke':...ram_text': 'th', ...}, {'ms_per_keystroke': 107.5, 'ngram_size': 3, 'ngram_speed_id': 'ng_3', 'ngram_text': 'he', ...}]

    def test_history_table_accumulates_all_records(
        self,
        temp_db: DatabaseManager,
        mock_sessions: List[MockSessionData],
        mock_ngram_data: List[MockNGramSpeedData],
    ) -> None:
        """
        Test objective: Verify history table contains all records over multiple refreshes.
    
        Tests that the history table accumulates all records from multiple
        refresh operations while current table only contains latest values.
        """
        ngram_manager = NGramManager(temp_db)
        service = NGramAnalyticsService(temp_db, ngram_manager)
    
        user_id = "user_1"
        keyboard_id = "keyboard_1"
    
        # Set up initial test data
        for session in mock_sessions:
>           temp_db.execute(
            ^^^^^^^^^^^^^^^
                """INSERT INTO practice_sessions
                (session_id, user_id, keyboard_id, snippet_id, snippet_index_start, snippet_index_end,
                 content, start_time, end_time, actual_chars, errors, ms_per_keystroke)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)""",
                (
                    session["session_id"],
                    session["user_id"],
                    session["keyboard_id"],
                    "test_snippet_1",
                    0,
                    10,
                    "test content",
                    session["start_time"],
                    session["start_time"],
                    "test",
                    0,
                    session["target_ms_per_keystroke"],
                ),
            )
E           AttributeError: 'str' object has no attribute 'execute'

tests\models\test_ngram_analytics_service.py:442: AttributeError
_________ TestNGramAnalyticsService.test_get_ngram_history_retrieval __________

self = <AITypingTrainer.tests.models.test_ngram_analytics_service.TestNGramAnalyticsService object at 0x00000215AFDAEA80>
temp_db = 'C:\\Users\\seanb\\AppData\\Local\\Temp\\tmpczlrmbn_.db'
mock_sessions = [{'keyboard_id': 'keyboard_1', 'session_id': 'session_1', 'start_time': '2024-01-01 10:01:00', 'target_ms_per_keystrok...: 'keyboard_1', 'session_id': 'session_2', 'start_time': '2024-01-01 10:02:00', 'target_ms_per_keystroke': 170.0, ...}]
mock_ngram_data = [{'ms_per_keystroke': 100.0, 'ngram_size': 2, 'ngram_speed_id': 'ng_0', 'ngram_text': 'th', ...}, {'ms_per_keystroke':...ram_text': 'th', ...}, {'ms_per_keystroke': 107.5, 'ngram_size': 3, 'ngram_speed_id': 'ng_3', 'ngram_text': 'he', ...}]

    def test_get_ngram_history_retrieval(
        self,
        temp_db: DatabaseManager,
        mock_sessions: List[MockSessionData],
        mock_ngram_data: List[MockNGramSpeedData],
    ) -> None:
        """
        Test objective: Verify history retrieval functionality.
    
        Tests that historical data can be retrieved properly with correct
        timestamps and performance metrics.
        """
        ngram_manager = NGramManager(temp_db)
        service = NGramAnalyticsService(temp_db, ngram_manager)
    
        user_id = "user_1"
        keyboard_id = "keyboard_1"
    
        # Set up test data and refresh
        for session in mock_sessions:
>           temp_db.execute(
            ^^^^^^^^^^^^^^^
                """INSERT INTO practice_sessions
                (session_id, user_id, keyboard_id, snippet_id, snippet_index_start, snippet_index_end,
                 content, start_time, end_time, actual_chars, errors, ms_per_keystroke)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)""",
                (
                    session["session_id"],
                    session["user_id"],
                    session["keyboard_id"],
                    "test_snippet_1",
                    0,
                    10,
                    "test content",
                    session["start_time"],
                    session["start_time"],
                    "test",
                    0,
                    session["target_ms_per_keystroke"],
                ),
            )
E           AttributeError: 'str' object has no attribute 'execute'

tests\models\test_ngram_analytics_service.py:552: AttributeError
______ TestNGramAnalyticsService.test_history_table_schema_compatibility ______

self = <AITypingTrainer.tests.models.test_ngram_analytics_service.TestNGramAnalyticsService object at 0x00000215AFDAE8A0>
temp_db = 'C:\\Users\\seanb\\AppData\\Local\\Temp\\tmp99cvh0c6.db'

    def test_history_table_schema_compatibility(
        self, temp_db: DatabaseManager
    ) -> None:
        """
        Test objective: Verify history table schema matches current table.
    
        Tests that the history table has the same essential columns as
        the current table plus additional history-specific fields.
        """
        ngram_manager = NGramManager(temp_db)
        service = NGramAnalyticsService(temp_db, ngram_manager)
    
        # Verify table schemas are compatible
>       current_schema = temp_db.fetchall("PRAGMA table_info(ngram_speed_summary_curr)")
                         ^^^^^^^^^^^^^^^^
E       AttributeError: 'str' object has no attribute 'fetchall'

tests\models\test_ngram_analytics_service.py:617: AttributeError
__________________ test_process_end_of_session_success_path ___________________

self = <db.database_manager.DatabaseManager object at 0x00000215B0099CC0>
query = '\n            INSERT INTO categories (category_id, category_name, description)\n            VALUES (?, ?, ?)\n            '
params = ('387cb8fc-7f37-4373-802a-6fc372ba07aa', 'Test Category', 'Test category for testing')

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table categories has no column named description

db\database_manager.py:509: OperationalError

The above exception was the direct cause of the following exception:

db_with_tables = <db.database_manager.DatabaseManager object at 0x00000215B0099CC0>
test_user = User(user_id='0c7a563e-ab18-4df4-8411-ab47117df375', first_name='Test', surname='User', email_address='test.user.c6269f74-2dd6-4c6a-8ecd-21bcdf0df5eb@example.com')
test_keyboard = Keyboard(keyboard_id='991a7023-2743-4db3-8103-e7e5185bc968', user_id='0c7a563e-ab18-4df4-8411-ab47117df375', keyboard_name='Test Keyboard', target_ms_per_keystroke=600)

    def test_process_end_of_session_success_path(db_with_tables, test_user, test_keyboard):
        # Arrange: create snippet (for FK completeness) and a new Session not yet in DB
        from tests.models.conftest import TestSessionMethodsFixtures
    
>       category_id = TestSessionMethodsFixtures.create_category(db_with_tables)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_ngram_orchestrator_process_end_of_session.py:40: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:239: in create_category
    db.execute(
db\database_manager.py:524: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x00000215B0099CC0>
e = OperationalError('table categories has no column named description')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table categories has no column named description

db\database_manager.py:434: DatabaseError
---------------------------- Captured stdout call -----------------------------
Exception during query: table categories has no column named description. Rolling back transaction.
---------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 509, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table categories has no column named description
______________ test_process_end_of_session_session_save_failure _______________

self = <db.database_manager.DatabaseManager object at 0x00000215B0758590>
query = '\n            INSERT INTO categories (category_id, category_name, description)\n            VALUES (?, ?, ?)\n            '
params = ('ce36582e-a8d0-40f9-9a7e-3c05641aceec', 'Test Category', 'Test category for testing')

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table categories has no column named description

db\database_manager.py:509: OperationalError

The above exception was the direct cause of the following exception:

db_with_tables = <db.database_manager.DatabaseManager object at 0x00000215B0758590>
test_user = User(user_id='f72bac8a-5a96-4f4c-be63-1a8c7bcb9fec', first_name='Test', surname='User', email_address='test.user.0976bb4a-3166-4fa4-8d27-f17bda761f3c@example.com')

    def test_process_end_of_session_session_save_failure(db_with_tables, test_user):
        """Fails at step 1: session save should raise due to FK violation (invalid keyboard_id)."""
        from tests.models.conftest import TestSessionMethodsFixtures
    
        # Valid snippet/category, but invalid keyboard_id to trigger FK failure on insert
>       category_id = TestSessionMethodsFixtures.create_category(db_with_tables)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_ngram_orchestrator_process_end_of_session.py:129: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:239: in create_category
    db.execute(
db\database_manager.py:524: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x00000215B0758590>
e = OperationalError('table categories has no column named description')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table categories has no column named description

db\database_manager.py:434: DatabaseError
---------------------------- Captured stdout call -----------------------------
Exception during query: table categories has no column named description. Rolling back transaction.
---------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 509, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table categories has no column named description
_____________ test_process_end_of_session_keystrokes_save_failure _____________

self = <db.database_manager.DatabaseManager object at 0x00000215B0708C20>
query = '\n            INSERT INTO categories (category_id, category_name, description)\n            VALUES (?, ?, ?)\n            '
params = ('eb6df46a-f453-45b3-b0fa-26a7a26c8802', 'Test Category', 'Test category for testing')

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table categories has no column named description

db\database_manager.py:509: OperationalError

The above exception was the direct cause of the following exception:

db_with_tables = <db.database_manager.DatabaseManager object at 0x00000215B0708C20>
test_user = User(user_id='a3ec5e61-284c-4f16-bb83-19ff280a29c1', first_name='Test', surname='User', email_address='test.user.a3c2f427-ed90-45fe-98fa-c1aea5794eff@example.com')
test_keyboard = Keyboard(keyboard_id='352d8735-218e-4732-b45e-b1fba22259d4', user_id='a3ec5e61-284c-4f16-bb83-19ff280a29c1', keyboard_name='Test Keyboard', target_ms_per_keystroke=600)

    def test_process_end_of_session_keystrokes_save_failure(db_with_tables, test_user, test_keyboard):
        """Fails at step 2: keystrokes save should return False due to invalid keystroke session_id."""
        from tests.models.conftest import TestSessionMethodsFixtures
    
>       category_id = TestSessionMethodsFixtures.create_category(db_with_tables)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_ngram_orchestrator_process_end_of_session.py:170: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:239: in create_category
    db.execute(
db\database_manager.py:524: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x00000215B0708C20>
e = OperationalError('table categories has no column named description')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table categories has no column named description

db\database_manager.py:434: DatabaseError
---------------------------- Captured stdout call -----------------------------
Exception during query: table categories has no column named description. Rolling back transaction.
---------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 509, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table categories has no column named description
______________ test_process_end_of_session_summarization_failure ______________

self = <db.database_manager.DatabaseManager object at 0x00000215B07096A0>
query = '\n            INSERT INTO categories (category_id, category_name, description)\n            VALUES (?, ?, ?)\n            '
params = ('0f2e68e3-7521-49b9-9b2f-be917e639b7d', 'Test Category', 'Test category for testing')

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table categories has no column named description

db\database_manager.py:509: OperationalError

The above exception was the direct cause of the following exception:

db_with_tables = <db.database_manager.DatabaseManager object at 0x00000215B07096A0>
test_user = User(user_id='634f4052-b7fe-4122-82bf-7d264763c35d', first_name='Test', surname='User', email_address='test.user.e9cff88e-f840-4817-a2cc-617ef865c80d@example.com')
test_keyboard = Keyboard(keyboard_id='14537075-af0b-4276-80cb-7a11579c0981', user_id='634f4052-b7fe-4122-82bf-7d264763c35d', keyboard_name='Test Keyboard', target_ms_per_keystroke=600)

    def test_process_end_of_session_summarization_failure(db_with_tables, test_user, test_keyboard):
        """Fails at step 4: drop summary table to force summarization SQL to fail after n-grams."""
        from tests.models.conftest import TestSessionMethodsFixtures
    
>       category_id = TestSessionMethodsFixtures.create_category(db_with_tables)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_ngram_orchestrator_process_end_of_session.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:239: in create_category
    db.execute(
db\database_manager.py:524: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x00000215B07096A0>
e = OperationalError('table categories has no column named description')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table categories has no column named description

db\database_manager.py:434: DatabaseError
---------------------------- Captured stdout call -----------------------------
Exception during query: table categories has no column named description. Rolling back transaction.
---------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 509, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table categories has no column named description
============================== warnings summary ===============================
tests/models/test_session.py::test_to_dict_and_from_dict
  D:\SeanDevLocal\AITypingTrainer\models\session.py:108: PydanticDeprecatedSince20: The `dict` method is deprecated; use `model_dump` instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.11/migration/
    return self.dict()

tests/models/test_user.py::TestUserModel::test_to_dict
  D:\SeanDevLocal\AITypingTrainer\models\user.py:202: PydanticDeprecatedSince20: The `dict` method is deprecated; use `model_dump` instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.11/migration/
    return self.dict()

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=========================== short test summary info ===========================
FAILED tests/models/test_dynamic_content_manager.py::TestNGramOnlyMode::test_generate_ngram_content - AssertionError: Part 'e' should be in ngram focus list
assert 'e' in ['es', 'st', 'te']
 +  where ['es', 'st', 'te'] = <models.dynamic_content_manager.DynamicContentManager object at 0x00000215B0403BD0>.ngram_focus_list
FAILED tests/models/test_dynamic_content_manager.py::TestNGramOnlyMode::test_ngram_content_filters_out_of_scope_chars - AssertionError: Content should only include ngrams with in-scope keys
assert ('ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab a' == 'ab'
  
  - ab
  + ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab a or 'ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab a' == ''
  
  + ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab a)
FAILED tests/models/test_dynamic_content_manager.py::TestMixedMode::test_mixed_content_has_variety - AssertionError: Mixed content should include some ngrams
assert set()
FAILED tests/models/test_keystroke_manager.py::TestKeystrokeManagerSaveKeystrokes::test_save_keystrokes_success - AssertionError: assert 0 == 3
 +  where 0 = <Mock name='mock.execute' id='2292171060096'>.call_count
 +    where <Mock name='mock.execute' id='2292171060096'> = <Mock spec='DatabaseManager' id='2292171062784'>.execute
 +      where <Mock spec='DatabaseManager' id='2292171062784'> = <models.keystroke_manager.KeystrokeManager object at 0x00000215B03F1220>.db_manager
FAILED tests/models/test_keystroke_manager.py::TestKeystrokeManagerSaveKeystrokes::test_save_keystrokes_database_error - assert True is False
FAILED tests/models/test_keystroke_manager.py::TestKeystrokeManagerSaveKeystrokes::test_save_keystrokes_with_special_characters - assert 0 == 7
 +  where 0 = <Mock name='mock.execute' id='2292175901024'>.call_count
 +    where <Mock name='mock.execute' id='2292175901024'> = <Mock spec='DatabaseManager' id='2292171060768'>.execute
 +      where <Mock spec='DatabaseManager' id='2292171060768'> = <models.keystroke_manager.KeystrokeManager object at 0x00000215B0442CF0>.db_manager
 +  and   7 = len(["'", '"', '\\', '\n', '\t', '\u20ac', '\U0001f60a'])
FAILED tests/models/test_keystroke_manager.py::TestKeystrokeManagerSaveKeystrokes::test_save_keystrokes_boolean_conversion - TypeError: 'NoneType' object is not subscriptable
FAILED tests/models/test_keystroke_manager.py::TestKeystrokeManagerIntegration::test_full_keystroke_workflow - assert False is True
FAILED tests/models/test_keystroke_manager.py::TestKeystrokeManagerEdgeCases::test_unicode_and_special_characters - assert 0 == 10
 +  where 0 = <Mock name='mock.execute' id='2292175909088'>.call_count
 +    where <Mock name='mock.execute' id='2292175909088'> = <Mock spec='DatabaseManager' id='2292175910432'>.execute
 +      where <Mock spec='DatabaseManager' id='2292175910432'> = <models.keystroke_manager.KeystrokeManager object at 0x00000215B057E2D0>.db_manager
 +  and   10 = len(['\U0001f642', '\u6d4b\u8bd5', 'caf\xe9', '\u03a9', '\n', '\t', '\\', "'", '"', '\x00'])
FAILED tests/models/test_keystroke_manager.py::TestKeystrokeManagerErrorHandling::test_database_connection_failure - assert True is False
FAILED tests/models/test_keystroke_manager.py::TestKeystrokeManagerErrorHandling::test_partial_save_failure - assert True is False
FAILED tests/models/test_keystroke_manager.py::TestKeystrokeManagerErrorHandling::test_network_timeout_simulation - assert True is False
FAILED tests/models/test_llm_ngram_service.py::test_missing_api_key - Failed: DID NOT RAISE <class 'models.llm_ngram_service.LLMMissingAPIKeyError'>
FAILED tests/models/test_ngram.py::TestKeystroke::test_keystroke_nfc_single_char - AssertionError: assert 'e\\u0301' == '\\xe9'\n  \n  - \xe9\n  + e\u0301
FAILED tests/models/test_ngram_analytics_service.py::TestNGramAnalyticsService::test_dual_insert_creates_records_in_both_tables - AttributeError: 'str' object has no attribute 'execute'
FAILED tests/models/test_ngram_analytics_service.py::TestNGramAnalyticsService::test_history_table_accumulates_all_records - AttributeError: 'str' object has no attribute 'execute'
FAILED tests/models/test_ngram_analytics_service.py::TestNGramAnalyticsService::test_get_ngram_history_retrieval - AttributeError: 'str' object has no attribute 'execute'
FAILED tests/models/test_ngram_analytics_service.py::TestNGramAnalyticsService::test_history_table_schema_compatibility - AttributeError: 'str' object has no attribute 'fetchall'
FAILED tests/models/test_ngram_orchestrator_process_end_of_session.py::test_process_end_of_session_success_path - db.exceptions.DatabaseError: Database operation failed: table categories has no column named description
FAILED tests/models/test_ngram_orchestrator_process_end_of_session.py::test_process_end_of_session_session_save_failure - db.exceptions.DatabaseError: Database operation failed: table categories has no column named description
FAILED tests/models/test_ngram_orchestrator_process_end_of_session.py::test_process_end_of_session_keystrokes_save_failure - db.exceptions.DatabaseError: Database operation failed: table categories has no column named description
FAILED tests/models/test_ngram_orchestrator_process_end_of_session.py::test_process_end_of_session_summarization_failure - db.exceptions.DatabaseError: Database operation failed: table categories has no column named description
ERROR tests/models/test_ngram_analytics_service.py::TestNGramAnalyticsService::test_refresh_speed_summaries_basic - db.exceptions.DatabaseError: Database operation failed: table snippets has no column named title
ERROR tests/models/test_ngram_analytics_service_session_methods.py::TestSummarizeSessionNgrams::test_summarize_with_ngram_speed_only[1-1] - db.exceptions.DatabaseError: Database operation failed: table categories has no column named description
ERROR tests/models/test_ngram_analytics_service_session_methods.py::TestSummarizeSessionNgrams::test_summarize_with_ngram_speed_only[3-3] - db.exceptions.DatabaseError: Database operation failed: table categories has no column named description
ERROR tests/models/test_ngram_analytics_service_session_methods.py::TestSummarizeSessionNgrams::test_summarize_with_ngram_errors_only[1-1] - db.exceptions.DatabaseError: Database operation failed: table categories has no column named description
ERROR tests/models/test_ngram_analytics_service_session_methods.py::TestSummarizeSessionNgrams::test_summarize_with_ngram_errors_only[2-2] - db.exceptions.DatabaseError: Database operation failed: table categories has no column named description
ERROR tests/models/test_ngram_analytics_service_session_methods.py::TestSummarizeSessionNgrams::test_summarize_with_speed_and_errors - db.exceptions.DatabaseError: Database operation failed: table categories has no column named description
ERROR tests/models/test_ngram_analytics_service_session_methods.py::TestSummarizeSessionNgrams::test_summarize_with_keystrokes[1-1] - db.exceptions.DatabaseError: Database operation failed: table categories has no column named description
ERROR tests/models/test_ngram_analytics_service_session_methods.py::TestSummarizeSessionNgrams::test_summarize_with_keystrokes[3-3] - db.exceptions.DatabaseError: Database operation failed: table categories has no column named description
ERROR tests/models/test_ngram_analytics_service_session_methods.py::TestSummarizeSessionNgrams::test_no_sessions_missing - db.exceptions.DatabaseError: Database operation failed: table categories has no column named description
ERROR tests/models/test_ngram_analytics_service_session_methods.py::TestSummarizeSessionNgrams::test_sessions_missing_no_data - db.exceptions.DatabaseError: Database operation failed: table categories has no column named description
ERROR tests/models/test_ngram_analytics_service_session_methods.py::TestAddSpeedSummaryForSession::test_single_session_processing - db.exceptions.DatabaseError: Database operation failed: table categories has no column named description
ERROR tests/models/test_ngram_analytics_service_session_methods.py::TestAddSpeedSummaryForSession::test_multiple_ngrams_processing - db.exceptions.DatabaseError: Database operation failed: table categories has no column named description
ERROR tests/models/test_ngram_analytics_service_session_methods.py::TestCatchupSpeedSummary::test_single_session_catchup - db.exceptions.DatabaseError: Database operation failed: table categories has no column named description
ERROR tests/models/test_ngram_analytics_service_session_methods.py::TestCatchupSpeedSummary::test_multiple_sessions_catchup - db.exceptions.DatabaseError: Database operation failed: table categories has no column named description
ERROR tests/models/test_ngram_analytics_service_session_methods.py::TestCatchupSpeedSummary::test_catchup_with_session_errors - db.exceptions.DatabaseError: Database operation failed: table categories has no column named description
ERROR tests/models/test_ngram_analytics_service_session_methods.py::TestIntegrationScenarios::test_full_workflow_integration - db.exceptions.DatabaseError: Database operation failed: table categories has no column named description
ERROR tests/models/test_snippet.py::test_snippet_ascii_name
ERROR tests/models/test_snippet.py::test_snippet_name_length
ERROR tests/models/test_snippet.py::test_snippet_creation_validation[Alpha-Some content-True]
ERROR tests/models/test_snippet.py::test_snippet_creation_validation[-Some content-False]
ERROR tests/models/test_snippet.py::test_snippet_creation_validation[AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA-Content-False]
ERROR tests/models/test_snippet.py::test_snippet_creation_validation[NonAscii\xe9-Content-False]
ERROR tests/models/test_snippet.py::test_snippet_creation_validation[Alpha--False]
ERROR tests/models/test_snippet.py::test_snippet_name_uniqueness[Unique1-Unique2-True]
ERROR tests/models/test_snippet.py::test_snippet_name_uniqueness[DupName-DupName-False]
ERROR tests/models/test_snippet.py::test_snippet_creation_valid
ERROR tests/models/test_snippet.py::test_get_nonexistent_snippet
ERROR tests/models/test_snippet.py::test_list_snippets_empty
ERROR tests/models/test_snippet.py::test_list_snippets_populated
ERROR tests/models/test_snippet.py::test_snippet_edit
ERROR tests/models/test_snippet.py::test_snippet_update
ERROR tests/models/test_snippet.py::test_snippet_update_name_only
ERROR tests/models/test_snippet.py::test_snippet_update_content_only
ERROR tests/models/test_snippet.py::test_snippet_delete
ERROR tests/models/test_snippet.py::test_delete_nonexistent_snippet
ERROR tests/models/test_snippet.py::test_edit_snippet_change_category
ERROR tests/models/test_snippet.py::test_edit_snippet_invalid_category
ERROR tests/models/test_snippet.py::test_snippet_sql_injection
ERROR tests/models/test_snippet.py::test_snippet_sql_injection_in_content
ERROR tests/models/test_snippet.py::test_snippet_long_content
ERROR tests/models/test_snippet.py::test_snippet_content_splitting_boundaries
ERROR tests/models/test_snippet.py::test_update_nonexistent_snippet
ERROR tests/models/test_snippet.py::test_snippet_part_number_sequence
ERROR tests/models/test_snippet.py::test_snippet_operation_handling
ERROR tests/models/test_snippet.py::test_delete_snippet
ERROR tests/models/test_snippet.py::test_create_snippet_with_nonexistent_category
ERROR tests/models/test_snippet.py::test_update_snippet_partial
ERROR tests/models/test_snippet.py::test_update_snippet_no_changes
ERROR tests/models/test_snippet.py::test_get_snippet_by_name
ERROR tests/models/test_snippet.py::test_get_snippet_by_name_nonexistent
ERROR tests/models/test_snippet.py::test_get_snippet_by_name_multiple_categories
ERROR tests/models/test_snippet.py::test_search_snippets
ERROR tests/models/test_snippet.py::test_search_snippets_no_results
ERROR tests/models/test_snippet.py::test_snippet_sql_injection_name_create
ERROR tests/models/test_snippet.py::test_snippet_sql_injection_content_create
ERROR tests/models/test_snippet.py::test_snippet_sql_injection_name_create_with_specific_error
ERROR tests/models/test_snippet.py::test_snippet_sql_injection_content_update
ERROR tests/models/test_snippet.py::test_snippet_sql_injection_name_update
ERROR tests/models/test_snippet.py::test_snippet_deletion_idempotency
ERROR tests/models/test_snippet.py::test_snippet_manager_handles_db_errors_gracefully_on_create
ERROR tests/models/test_snippet.py::test_snippet_manager_handles_db_errors_gracefully_on_get
ERROR tests/models/test_snippet.py::test_snippet_manager_handles_db_errors_gracefully_on_update
ERROR tests/models/test_snippet.py::test_snippet_manager_handles_db_errors_gracefully_on_delete
ERROR tests/models/test_snippet.py::test_snippet_manager_handles_db_errors_gracefully_on_list
ERROR tests/models/test_snippet.py::test_snippet_manager_handles_db_errors_gracefully_on_search
ERROR tests/models/test_snippet.py::test_create_snippet_pydantic_validation_errors
====== 22 failed, 417 passed, 4 skipped, 2 warnings, 66 errors in 33.75s ======
============================= test session starts =============================
platform win32 -- Python 3.13.2, pytest-8.4.1, pluggy-1.6.0
PySide6 6.9.1 -- Qt runtime 6.9.1 -- Qt compiled 6.9.1
rootdir: D:\SeanDevLocal\AITypingTrainer
configfile: pytest.ini
plugins: anyio-4.10.0, cov-6.2.1, mock-3.14.1, qt-4.5.0
collected 509 items

tests\models\test_category.py .................                          [  3%]
tests\models\test_category_manager.py .............................      [  9%]
tests\models\test_dynamic_content_manager.py ............F..F....F       [ 13%]
tests\models\test_keyboard.py ........                                   [ 14%]
tests\models\test_keyboard_manager.py .....                              [ 15%]
tests\models\test_keystroke.py ......................................... [ 23%]
...................................                                      [ 30%]
tests\models\test_keystroke_manager.py ..........F.FFF..............F... [ 37%]
F.F.FF....                                                               [ 39%]
tests\models\test_llm_ngram_service.py F...                              [ 39%]
tests\models\test_next_session_position.py .....                         [ 40%]
tests\models\test_ngram.py .F............                                [ 43%]
tests\models\test_ngram_analytics_service.py ......EssssFFFF...          [ 47%]
tests\models\test_ngram_analytics_service_session_methods.py EEEEEEEEEE. [ 49%]
E.EEEE                                                                   [ 50%]
tests\models\test_ngram_manager.py .....                                 [ 51%]
tests\models\test_ngram_orchestrator_process_end_of_session.py FFFF      [ 52%]
tests\models\test_session.py ..........................................  [ 60%]
tests\models\test_session_manager.py ........                            [ 62%]
tests\models\test_setting.py ..................                          [ 65%]
tests\models\test_setting_manager.py ...................                 [ 69%]
tests\models\test_simple.py .                                            [ 69%]
tests\models\test_snippet.py ...E.E..EEEEEEEEEEEEEEEEEEEEEEEEE.EEEEEEEEE [ 77%]
EEEEEEEEEEEEEE                                                           [ 80%]
tests\models\test_snippet_manager.py ....................                [ 84%]
tests\models\test_user.py .............................................. [ 93%]
......                                                                   [ 94%]
tests\models\test_user_manager.py .........                              [ 96%]
tests\models\test_user_manager_fixes.py .................                [100%]

=================================== ERRORS ====================================
_ ERROR at setup of TestNGramAnalyticsService.test_refresh_speed_summaries_basic _

self = <db.database_manager.DatabaseManager object at 0x000001EF17828E50>
query = 'INSERT INTO snippets (snippet_id, category_id, title, content, difficulty_level) VALUES (?, ?, ?, ?, ?)'
params = ('snippet_1', 'cat_1', 'Snippet', 'content', 1)

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table snippets has no column named title

db\database_manager.py:509: OperationalError

The above exception was the direct cause of the following exception:

item = <Function test_refresh_speed_summaries_basic>

    @pytest.hookimpl(wrapper=True, tryfirst=True)
    def pytest_runtest_setup(item):
        """
        Hook called after before test setup starts, to start capturing exceptions
        as early as possible.
        """
        capture_enabled = _is_exception_capture_enabled(item)
        if capture_enabled:
            item.qt_exception_capture_manager = _QtExceptionCaptureManager()
            item.qt_exception_capture_manager.start()
>       result = yield
                 ^^^^^

.venv\Lib\site-packages\pytestqt\plugin.py:178: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:321: in ngram_speed_test_data
    db_with_tables.execute(
db\database_manager.py:524: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x000001EF17828E50>
e = OperationalError('table snippets has no column named title')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table snippets has no column named title

db\database_manager.py:434: DatabaseError
---------------------------- Captured stdout setup ----------------------------
Exception during query: table snippets has no column named title. Rolling back transaction.
---------------------------- Captured stderr setup ----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 509, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table snippets has no column named title
_ ERROR at setup of TestSummarizeSessionNgrams.test_summarize_with_ngram_speed_only[1-1] _

self = <db.database_manager.DatabaseManager object at 0x000001EF18E71320>
query = '\n            INSERT INTO categories (category_id, category_name, description)\n            VALUES (?, ?, ?)\n            '
params = ('de21adaf-34e8-410c-a846-a2f16e61e3ad', 'Test Category', 'Test category for testing')

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table categories has no column named description

db\database_manager.py:509: OperationalError

The above exception was the direct cause of the following exception:

db_with_tables = <db.database_manager.DatabaseManager object at 0x000001EF18E71320>
test_user = User(user_id='8c09620d-8b0f-441d-bf1d-d2fd9b781610', first_name='Test', surname='User', email_address='test.user.bfa24469-b994-44d7-9d8d-61eaebb6082d@example.com')
test_keyboard = Keyboard(keyboard_id='1a282c21-ae8f-493f-a1b5-b527c22cd8ef', user_id='8c09620d-8b0f-441d-bf1d-d2fd9b781610', keyboard_name='Test Keyboard', target_ms_per_keystroke=600)

    @pytest.fixture
    def test_data_setup(db_with_tables: DatabaseManager, test_user: User, test_keyboard: Keyboard) -> Dict[str, Any]:
        """Set up comprehensive test data for session analytics tests."""
        db = db_with_tables
    
        # Create category and snippet
>       category_id = TestSessionMethodsFixtures.create_category(db)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_ngram_analytics_service_session_methods.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:239: in create_category
    db.execute(
db\database_manager.py:524: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x000001EF18E71320>
e = OperationalError('table categories has no column named description')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table categories has no column named description

db\database_manager.py:434: DatabaseError
---------------------------- Captured stdout setup ----------------------------
Exception during query: table categories has no column named description. Rolling back transaction.
---------------------------- Captured stderr setup ----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 509, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table categories has no column named description
_ ERROR at setup of TestSummarizeSessionNgrams.test_summarize_with_ngram_speed_only[3-3] _

self = <db.database_manager.DatabaseManager object at 0x000001EF17828E50>
query = '\n            INSERT INTO categories (category_id, category_name, description)\n            VALUES (?, ?, ?)\n            '
params = ('cd34bb1a-94e5-4e1f-8af7-91ddeea9aaaa', 'Test Category', 'Test category for testing')

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table categories has no column named description

db\database_manager.py:509: OperationalError

The above exception was the direct cause of the following exception:

db_with_tables = <db.database_manager.DatabaseManager object at 0x000001EF17828E50>
test_user = User(user_id='fce19b47-d9fc-41d4-a150-2fff88783e1e', first_name='Test', surname='User', email_address='test.user.32c8497c-ce26-4d15-942f-6bea1006374f@example.com')
test_keyboard = Keyboard(keyboard_id='d06b935d-19eb-4711-8b1e-a340bf681c42', user_id='fce19b47-d9fc-41d4-a150-2fff88783e1e', keyboard_name='Test Keyboard', target_ms_per_keystroke=600)

    @pytest.fixture
    def test_data_setup(db_with_tables: DatabaseManager, test_user: User, test_keyboard: Keyboard) -> Dict[str, Any]:
        """Set up comprehensive test data for session analytics tests."""
        db = db_with_tables
    
        # Create category and snippet
>       category_id = TestSessionMethodsFixtures.create_category(db)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_ngram_analytics_service_session_methods.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:239: in create_category
    db.execute(
db\database_manager.py:524: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x000001EF17828E50>
e = OperationalError('table categories has no column named description')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table categories has no column named description

db\database_manager.py:434: DatabaseError
---------------------------- Captured stdout setup ----------------------------
Exception during query: table categories has no column named description. Rolling back transaction.
---------------------------- Captured stderr setup ----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 509, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table categories has no column named description
_ ERROR at setup of TestSummarizeSessionNgrams.test_summarize_with_ngram_errors_only[1-1] _

self = <db.database_manager.DatabaseManager object at 0x000001EF18FDF230>
query = '\n            INSERT INTO categories (category_id, category_name, description)\n            VALUES (?, ?, ?)\n            '
params = ('5def4b0e-1783-4e91-a16f-28583f5d7dac', 'Test Category', 'Test category for testing')

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table categories has no column named description

db\database_manager.py:509: OperationalError

The above exception was the direct cause of the following exception:

db_with_tables = <db.database_manager.DatabaseManager object at 0x000001EF18FDF230>
test_user = User(user_id='f321e467-50f4-4fb7-a888-fb337131ab34', first_name='Test', surname='User', email_address='test.user.6b1050e5-af29-4675-9526-be272176df3d@example.com')
test_keyboard = Keyboard(keyboard_id='bee7bd35-8e1a-41fb-8a0a-70f9592585b5', user_id='f321e467-50f4-4fb7-a888-fb337131ab34', keyboard_name='Test Keyboard', target_ms_per_keystroke=600)

    @pytest.fixture
    def test_data_setup(db_with_tables: DatabaseManager, test_user: User, test_keyboard: Keyboard) -> Dict[str, Any]:
        """Set up comprehensive test data for session analytics tests."""
        db = db_with_tables
    
        # Create category and snippet
>       category_id = TestSessionMethodsFixtures.create_category(db)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_ngram_analytics_service_session_methods.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:239: in create_category
    db.execute(
db\database_manager.py:524: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x000001EF18FDF230>
e = OperationalError('table categories has no column named description')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table categories has no column named description

db\database_manager.py:434: DatabaseError
---------------------------- Captured stdout setup ----------------------------
Exception during query: table categories has no column named description. Rolling back transaction.
---------------------------- Captured stderr setup ----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 509, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table categories has no column named description
_ ERROR at setup of TestSummarizeSessionNgrams.test_summarize_with_ngram_errors_only[2-2] _

self = <db.database_manager.DatabaseManager object at 0x000001EF18FDE660>
query = '\n            INSERT INTO categories (category_id, category_name, description)\n            VALUES (?, ?, ?)\n            '
params = ('2dc70db4-7a22-4c4d-ae6e-048f31d37fc1', 'Test Category', 'Test category for testing')

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table categories has no column named description

db\database_manager.py:509: OperationalError

The above exception was the direct cause of the following exception:

db_with_tables = <db.database_manager.DatabaseManager object at 0x000001EF18FDE660>
test_user = User(user_id='abd4c3c0-36fb-4856-abcc-7ac51ea90f6e', first_name='Test', surname='User', email_address='test.user.9ab6eca3-30e3-4d14-8548-a2b82f2fad16@example.com')
test_keyboard = Keyboard(keyboard_id='45e01a83-96fc-4194-b160-64af1b4f23c2', user_id='abd4c3c0-36fb-4856-abcc-7ac51ea90f6e', keyboard_name='Test Keyboard', target_ms_per_keystroke=600)

    @pytest.fixture
    def test_data_setup(db_with_tables: DatabaseManager, test_user: User, test_keyboard: Keyboard) -> Dict[str, Any]:
        """Set up comprehensive test data for session analytics tests."""
        db = db_with_tables
    
        # Create category and snippet
>       category_id = TestSessionMethodsFixtures.create_category(db)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_ngram_analytics_service_session_methods.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:239: in create_category
    db.execute(
db\database_manager.py:524: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x000001EF18FDE660>
e = OperationalError('table categories has no column named description')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table categories has no column named description

db\database_manager.py:434: DatabaseError
---------------------------- Captured stdout setup ----------------------------
Exception during query: table categories has no column named description. Rolling back transaction.
---------------------------- Captured stderr setup ----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 509, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table categories has no column named description
_ ERROR at setup of TestSummarizeSessionNgrams.test_summarize_with_speed_and_errors _

self = <db.database_manager.DatabaseManager object at 0x000001EF18FDFB60>
query = '\n            INSERT INTO categories (category_id, category_name, description)\n            VALUES (?, ?, ?)\n            '
params = ('6ade18e1-b8bb-43f0-bf73-3071b8e780d1', 'Test Category', 'Test category for testing')

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table categories has no column named description

db\database_manager.py:509: OperationalError

The above exception was the direct cause of the following exception:

db_with_tables = <db.database_manager.DatabaseManager object at 0x000001EF18FDFB60>
test_user = User(user_id='18c8966e-de4e-401f-bc69-2e8610b4de78', first_name='Test', surname='User', email_address='test.user.d222df31-5fbe-4a59-99d8-0efce086bf1a@example.com')
test_keyboard = Keyboard(keyboard_id='b150845e-949e-4f69-96dd-20dc1f8801ca', user_id='18c8966e-de4e-401f-bc69-2e8610b4de78', keyboard_name='Test Keyboard', target_ms_per_keystroke=600)

    @pytest.fixture
    def test_data_setup(db_with_tables: DatabaseManager, test_user: User, test_keyboard: Keyboard) -> Dict[str, Any]:
        """Set up comprehensive test data for session analytics tests."""
        db = db_with_tables
    
        # Create category and snippet
>       category_id = TestSessionMethodsFixtures.create_category(db)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_ngram_analytics_service_session_methods.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:239: in create_category
    db.execute(
db\database_manager.py:524: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x000001EF18FDFB60>
e = OperationalError('table categories has no column named description')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table categories has no column named description

db\database_manager.py:434: DatabaseError
---------------------------- Captured stdout setup ----------------------------
Exception during query: table categories has no column named description. Rolling back transaction.
---------------------------- Captured stderr setup ----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 509, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table categories has no column named description
_ ERROR at setup of TestSummarizeSessionNgrams.test_summarize_with_keystrokes[1-1] _

self = <db.database_manager.DatabaseManager object at 0x000001EF18F78AD0>
query = '\n            INSERT INTO categories (category_id, category_name, description)\n            VALUES (?, ?, ?)\n            '
params = ('5f5d2c15-81c4-40c4-9ae5-d4cd7dc650d9', 'Test Category', 'Test category for testing')

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table categories has no column named description

db\database_manager.py:509: OperationalError

The above exception was the direct cause of the following exception:

db_with_tables = <db.database_manager.DatabaseManager object at 0x000001EF18F78AD0>
test_user = User(user_id='40d92870-9026-4509-8536-0620f14fe6ab', first_name='Test', surname='User', email_address='test.user.0dd76d19-dc05-49d8-b4a9-dd97c79242d4@example.com')
test_keyboard = Keyboard(keyboard_id='13f92f00-a0d5-4f51-88a3-9ddec96dcc76', user_id='40d92870-9026-4509-8536-0620f14fe6ab', keyboard_name='Test Keyboard', target_ms_per_keystroke=600)

    @pytest.fixture
    def test_data_setup(db_with_tables: DatabaseManager, test_user: User, test_keyboard: Keyboard) -> Dict[str, Any]:
        """Set up comprehensive test data for session analytics tests."""
        db = db_with_tables
    
        # Create category and snippet
>       category_id = TestSessionMethodsFixtures.create_category(db)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_ngram_analytics_service_session_methods.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:239: in create_category
    db.execute(
db\database_manager.py:524: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x000001EF18F78AD0>
e = OperationalError('table categories has no column named description')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table categories has no column named description

db\database_manager.py:434: DatabaseError
---------------------------- Captured stdout setup ----------------------------
Exception during query: table categories has no column named description. Rolling back transaction.
---------------------------- Captured stderr setup ----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 509, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table categories has no column named description
_ ERROR at setup of TestSummarizeSessionNgrams.test_summarize_with_keystrokes[3-3] _

self = <db.database_manager.DatabaseManager object at 0x000001EF18F7AC10>
query = '\n            INSERT INTO categories (category_id, category_name, description)\n            VALUES (?, ?, ?)\n            '
params = ('089833e5-b9f0-46d9-bc18-2784b53ab0b9', 'Test Category', 'Test category for testing')

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table categories has no column named description

db\database_manager.py:509: OperationalError

The above exception was the direct cause of the following exception:

db_with_tables = <db.database_manager.DatabaseManager object at 0x000001EF18F7AC10>
test_user = User(user_id='973e914c-59e5-403e-9ca9-25228ad327b2', first_name='Test', surname='User', email_address='test.user.d5b48d81-aadd-4e4f-9458-edb1b0e30107@example.com')
test_keyboard = Keyboard(keyboard_id='7a7a3f81-8034-4afd-9c20-fff04e98c649', user_id='973e914c-59e5-403e-9ca9-25228ad327b2', keyboard_name='Test Keyboard', target_ms_per_keystroke=600)

    @pytest.fixture
    def test_data_setup(db_with_tables: DatabaseManager, test_user: User, test_keyboard: Keyboard) -> Dict[str, Any]:
        """Set up comprehensive test data for session analytics tests."""
        db = db_with_tables
    
        # Create category and snippet
>       category_id = TestSessionMethodsFixtures.create_category(db)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_ngram_analytics_service_session_methods.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:239: in create_category
    db.execute(
db\database_manager.py:524: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x000001EF18F7AC10>
e = OperationalError('table categories has no column named description')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table categories has no column named description

db\database_manager.py:434: DatabaseError
---------------------------- Captured stdout setup ----------------------------
Exception during query: table categories has no column named description. Rolling back transaction.
---------------------------- Captured stderr setup ----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 509, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table categories has no column named description
____ ERROR at setup of TestSummarizeSessionNgrams.test_no_sessions_missing ____

self = <db.database_manager.DatabaseManager object at 0x000001EF18FDFF50>
query = '\n            INSERT INTO categories (category_id, category_name, description)\n            VALUES (?, ?, ?)\n            '
params = ('f521cf53-3c01-4a7f-8027-7eaf655b0b37', 'Test Category', 'Test category for testing')

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table categories has no column named description

db\database_manager.py:509: OperationalError

The above exception was the direct cause of the following exception:

db_with_tables = <db.database_manager.DatabaseManager object at 0x000001EF18FDFF50>
test_user = User(user_id='1eabfce2-8012-4fa4-a02b-621a51e95902', first_name='Test', surname='User', email_address='test.user.37091cdd-e4b5-4f71-92a1-8057f923944f@example.com')
test_keyboard = Keyboard(keyboard_id='57e1c41a-733f-4972-a54d-0319a1cb6fee', user_id='1eabfce2-8012-4fa4-a02b-621a51e95902', keyboard_name='Test Keyboard', target_ms_per_keystroke=600)

    @pytest.fixture
    def test_data_setup(db_with_tables: DatabaseManager, test_user: User, test_keyboard: Keyboard) -> Dict[str, Any]:
        """Set up comprehensive test data for session analytics tests."""
        db = db_with_tables
    
        # Create category and snippet
>       category_id = TestSessionMethodsFixtures.create_category(db)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_ngram_analytics_service_session_methods.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:239: in create_category
    db.execute(
db\database_manager.py:524: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x000001EF18FDFF50>
e = OperationalError('table categories has no column named description')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table categories has no column named description

db\database_manager.py:434: DatabaseError
---------------------------- Captured stdout setup ----------------------------
Exception during query: table categories has no column named description. Rolling back transaction.
---------------------------- Captured stderr setup ----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 509, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table categories has no column named description
_ ERROR at setup of TestSummarizeSessionNgrams.test_sessions_missing_no_data __

self = <db.database_manager.DatabaseManager object at 0x000001EF18F78D70>
query = '\n            INSERT INTO categories (category_id, category_name, description)\n            VALUES (?, ?, ?)\n            '
params = ('7a5d4ca9-2878-42bf-8471-f7dd3fc59fc4', 'Test Category', 'Test category for testing')

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table categories has no column named description

db\database_manager.py:509: OperationalError

The above exception was the direct cause of the following exception:

db_with_tables = <db.database_manager.DatabaseManager object at 0x000001EF18F78D70>
test_user = User(user_id='916bde05-7a66-40be-bbdd-5b375ba40ad9', first_name='Test', surname='User', email_address='test.user.49acba3c-33d2-4d35-9af0-e0b8d5009f2b@example.com')
test_keyboard = Keyboard(keyboard_id='ed9eceda-728c-422b-ad4d-a6e4a6fb7a15', user_id='916bde05-7a66-40be-bbdd-5b375ba40ad9', keyboard_name='Test Keyboard', target_ms_per_keystroke=600)

    @pytest.fixture
    def test_data_setup(db_with_tables: DatabaseManager, test_user: User, test_keyboard: Keyboard) -> Dict[str, Any]:
        """Set up comprehensive test data for session analytics tests."""
        db = db_with_tables
    
        # Create category and snippet
>       category_id = TestSessionMethodsFixtures.create_category(db)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_ngram_analytics_service_session_methods.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:239: in create_category
    db.execute(
db\database_manager.py:524: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x000001EF18F78D70>
e = OperationalError('table categories has no column named description')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table categories has no column named description

db\database_manager.py:434: DatabaseError
---------------------------- Captured stdout setup ----------------------------
Exception during query: table categories has no column named description. Rolling back transaction.
---------------------------- Captured stderr setup ----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 509, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table categories has no column named description
_ ERROR at setup of TestAddSpeedSummaryForSession.test_single_session_processing _

self = <db.database_manager.DatabaseManager object at 0x000001EF18F7BC40>
query = '\n            INSERT INTO categories (category_id, category_name, description)\n            VALUES (?, ?, ?)\n            '
params = ('8c1f42ee-728e-4386-8d9c-3ee0fe9c6466', 'Test Category', 'Test category for testing')

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table categories has no column named description

db\database_manager.py:509: OperationalError

The above exception was the direct cause of the following exception:

db_with_tables = <db.database_manager.DatabaseManager object at 0x000001EF18F7BC40>
test_user = User(user_id='71f2a9b5-d538-47eb-8e31-48d504e21d35', first_name='Test', surname='User', email_address='test.user.1376123e-2852-4961-9604-db5d1d286aff@example.com')
test_keyboard = Keyboard(keyboard_id='d9d9720d-0f1e-478c-b3fd-aa7ee40a3832', user_id='71f2a9b5-d538-47eb-8e31-48d504e21d35', keyboard_name='Test Keyboard', target_ms_per_keystroke=600)

    @pytest.fixture
    def test_data_setup(db_with_tables: DatabaseManager, test_user: User, test_keyboard: Keyboard) -> Dict[str, Any]:
        """Set up comprehensive test data for session analytics tests."""
        db = db_with_tables
    
        # Create category and snippet
>       category_id = TestSessionMethodsFixtures.create_category(db)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_ngram_analytics_service_session_methods.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:239: in create_category
    db.execute(
db\database_manager.py:524: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x000001EF18F7BC40>
e = OperationalError('table categories has no column named description')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table categories has no column named description

db\database_manager.py:434: DatabaseError
---------------------------- Captured stdout setup ----------------------------
Exception during query: table categories has no column named description. Rolling back transaction.
---------------------------- Captured stderr setup ----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 509, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table categories has no column named description
_ ERROR at setup of TestAddSpeedSummaryForSession.test_multiple_ngrams_processing _

self = <db.database_manager.DatabaseManager object at 0x000001EF18F7B4D0>
query = '\n            INSERT INTO categories (category_id, category_name, description)\n            VALUES (?, ?, ?)\n            '
params = ('69675e58-258f-4aba-9e05-f21f6a3b2966', 'Test Category', 'Test category for testing')

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table categories has no column named description

db\database_manager.py:509: OperationalError

The above exception was the direct cause of the following exception:

db_with_tables = <db.database_manager.DatabaseManager object at 0x000001EF18F7B4D0>
test_user = User(user_id='eb7b5f67-f7c0-40c4-b491-f46faffca71c', first_name='Test', surname='User', email_address='test.user.8b5636c6-dca6-4ea7-93c4-7330e7ff4980@example.com')
test_keyboard = Keyboard(keyboard_id='c07158a4-f141-4698-b2ec-86da0454b0de', user_id='eb7b5f67-f7c0-40c4-b491-f46faffca71c', keyboard_name='Test Keyboard', target_ms_per_keystroke=600)

    @pytest.fixture
    def test_data_setup(db_with_tables: DatabaseManager, test_user: User, test_keyboard: Keyboard) -> Dict[str, Any]:
        """Set up comprehensive test data for session analytics tests."""
        db = db_with_tables
    
        # Create category and snippet
>       category_id = TestSessionMethodsFixtures.create_category(db)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_ngram_analytics_service_session_methods.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:239: in create_category
    db.execute(
db\database_manager.py:524: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x000001EF18F7B4D0>
e = OperationalError('table categories has no column named description')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table categories has no column named description

db\database_manager.py:434: DatabaseError
---------------------------- Captured stdout setup ----------------------------
Exception during query: table categories has no column named description. Rolling back transaction.
---------------------------- Captured stderr setup ----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 509, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table categories has no column named description
____ ERROR at setup of TestCatchupSpeedSummary.test_single_session_catchup ____

self = <db.database_manager.DatabaseManager object at 0x000001EF18F79D30>
query = '\n            INSERT INTO categories (category_id, category_name, description)\n            VALUES (?, ?, ?)\n            '
params = ('d4254902-6b85-42de-85fc-4b529d66995c', 'Test Category', 'Test category for testing')

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table categories has no column named description

db\database_manager.py:509: OperationalError

The above exception was the direct cause of the following exception:

db_with_tables = <db.database_manager.DatabaseManager object at 0x000001EF18F79D30>
test_user = User(user_id='b89cf487-0305-4c10-b0e8-3c7693e5646c', first_name='Test', surname='User', email_address='test.user.ec66d32c-4736-4a31-af00-75a59e5efbab@example.com')
test_keyboard = Keyboard(keyboard_id='bbc1e8a4-5edf-4370-867a-7b32521c09ce', user_id='b89cf487-0305-4c10-b0e8-3c7693e5646c', keyboard_name='Test Keyboard', target_ms_per_keystroke=600)

    @pytest.fixture
    def test_data_setup(db_with_tables: DatabaseManager, test_user: User, test_keyboard: Keyboard) -> Dict[str, Any]:
        """Set up comprehensive test data for session analytics tests."""
        db = db_with_tables
    
        # Create category and snippet
>       category_id = TestSessionMethodsFixtures.create_category(db)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_ngram_analytics_service_session_methods.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:239: in create_category
    db.execute(
db\database_manager.py:524: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x000001EF18F79D30>
e = OperationalError('table categories has no column named description')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table categories has no column named description

db\database_manager.py:434: DatabaseError
---------------------------- Captured stdout setup ----------------------------
Exception during query: table categories has no column named description. Rolling back transaction.
---------------------------- Captured stderr setup ----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 509, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table categories has no column named description
__ ERROR at setup of TestCatchupSpeedSummary.test_multiple_sessions_catchup ___

self = <db.database_manager.DatabaseManager object at 0x000001EF18F44050>
query = '\n            INSERT INTO categories (category_id, category_name, description)\n            VALUES (?, ?, ?)\n            '
params = ('228ff07a-64e4-4be4-b9ba-6f5856e8e5b4', 'Test Category', 'Test category for testing')

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table categories has no column named description

db\database_manager.py:509: OperationalError

The above exception was the direct cause of the following exception:

db_with_tables = <db.database_manager.DatabaseManager object at 0x000001EF18F44050>
test_user = User(user_id='2b68f6ac-8f84-4a16-9409-85dcbc36548b', first_name='Test', surname='User', email_address='test.user.8b7284d8-a926-4509-b49b-feb07352b887@example.com')
test_keyboard = Keyboard(keyboard_id='6a88ed9f-7a68-4d53-bad0-b523d641a486', user_id='2b68f6ac-8f84-4a16-9409-85dcbc36548b', keyboard_name='Test Keyboard', target_ms_per_keystroke=600)

    @pytest.fixture
    def test_data_setup(db_with_tables: DatabaseManager, test_user: User, test_keyboard: Keyboard) -> Dict[str, Any]:
        """Set up comprehensive test data for session analytics tests."""
        db = db_with_tables
    
        # Create category and snippet
>       category_id = TestSessionMethodsFixtures.create_category(db)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_ngram_analytics_service_session_methods.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:239: in create_category
    db.execute(
db\database_manager.py:524: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x000001EF18F44050>
e = OperationalError('table categories has no column named description')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table categories has no column named description

db\database_manager.py:434: DatabaseError
---------------------------- Captured stdout setup ----------------------------
Exception during query: table categories has no column named description. Rolling back transaction.
---------------------------- Captured stderr setup ----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 509, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table categories has no column named description
_ ERROR at setup of TestCatchupSpeedSummary.test_catchup_with_session_errors __

self = <db.database_manager.DatabaseManager object at 0x000001EF18F7BC40>
query = '\n            INSERT INTO categories (category_id, category_name, description)\n            VALUES (?, ?, ?)\n            '
params = ('ec1ed00a-77d6-47a3-b3f4-53afdf118423', 'Test Category', 'Test category for testing')

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table categories has no column named description

db\database_manager.py:509: OperationalError

The above exception was the direct cause of the following exception:

db_with_tables = <db.database_manager.DatabaseManager object at 0x000001EF18F7BC40>
test_user = User(user_id='2a662af2-0652-4234-8dad-9e70a16c106e', first_name='Test', surname='User', email_address='test.user.aa73b9c8-52a0-487c-af35-18dc11b3104e@example.com')
test_keyboard = Keyboard(keyboard_id='527e66b0-342d-4473-8363-7698da0318f5', user_id='2a662af2-0652-4234-8dad-9e70a16c106e', keyboard_name='Test Keyboard', target_ms_per_keystroke=600)

    @pytest.fixture
    def test_data_setup(db_with_tables: DatabaseManager, test_user: User, test_keyboard: Keyboard) -> Dict[str, Any]:
        """Set up comprehensive test data for session analytics tests."""
        db = db_with_tables
    
        # Create category and snippet
>       category_id = TestSessionMethodsFixtures.create_category(db)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_ngram_analytics_service_session_methods.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:239: in create_category
    db.execute(
db\database_manager.py:524: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x000001EF18F7BC40>
e = OperationalError('table categories has no column named description')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table categories has no column named description

db\database_manager.py:434: DatabaseError
---------------------------- Captured stdout setup ----------------------------
Exception during query: table categories has no column named description. Rolling back transaction.
---------------------------- Captured stderr setup ----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 509, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table categories has no column named description
__ ERROR at setup of TestIntegrationScenarios.test_full_workflow_integration __

self = <db.database_manager.DatabaseManager object at 0x000001EF18F79710>
query = '\n            INSERT INTO categories (category_id, category_name, description)\n            VALUES (?, ?, ?)\n            '
params = ('bebde13d-f630-4919-b0bd-09589bdd1ddc', 'Test Category', 'Test category for testing')

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table categories has no column named description

db\database_manager.py:509: OperationalError

The above exception was the direct cause of the following exception:

db_with_tables = <db.database_manager.DatabaseManager object at 0x000001EF18F79710>
test_user = User(user_id='22fc27e3-09a6-4e2a-87ca-5cdc94a2e314', first_name='Test', surname='User', email_address='test.user.a5886cce-2008-4d1a-ad8e-e4e387243284@example.com')
test_keyboard = Keyboard(keyboard_id='2ec04519-3729-40b3-8fb0-554aae1d35df', user_id='22fc27e3-09a6-4e2a-87ca-5cdc94a2e314', keyboard_name='Test Keyboard', target_ms_per_keystroke=600)

    @pytest.fixture
    def test_data_setup(db_with_tables: DatabaseManager, test_user: User, test_keyboard: Keyboard) -> Dict[str, Any]:
        """Set up comprehensive test data for session analytics tests."""
        db = db_with_tables
    
        # Create category and snippet
>       category_id = TestSessionMethodsFixtures.create_category(db)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_ngram_analytics_service_session_methods.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:239: in create_category
    db.execute(
db\database_manager.py:524: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x000001EF18F79710>
e = OperationalError('table categories has no column named description')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table categories has no column named description

db\database_manager.py:434: DatabaseError
---------------------------- Captured stdout setup ----------------------------
Exception during query: table categories has no column named description. Rolling back transaction.
---------------------------- Captured stderr setup ----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 509, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table categories has no column named description
__________________ ERROR at setup of test_snippet_ascii_name __________________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 64
  def test_snippet_ascii_name(valid_snippet_data: Dict[str, str]) -> None:
E       fixture 'valid_snippet_data' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:64
_________________ ERROR at setup of test_snippet_name_length __________________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 86
  def test_snippet_name_length(valid_snippet_data: Dict[str, Union[str, str]]) -> None:
E       fixture 'valid_snippet_data' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:86
_ ERROR at setup of test_snippet_creation_validation[Alpha-Some content-True] _
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 117
  @pytest.mark.parametrize(
      "name,content,expect_success",
      [
          ("Alpha", "Some content", True),
          ("", "Some content", False),  # Validation for name
          ("A" * 129, "Content", False),  # Validation for name length
          ("NonAsciiΘ", "Content", False),  # Validation for name ASCII
          ("Alpha", "", False),  # Validation for content
      ],
  )
  def test_snippet_creation_validation(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:117
___ ERROR at setup of test_snippet_creation_validation[-Some content-False] ___
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 117
  @pytest.mark.parametrize(
      "name,content,expect_success",
      [
          ("Alpha", "Some content", True),
          ("", "Some content", False),  # Validation for name
          ("A" * 129, "Content", False),  # Validation for name length
          ("NonAsciiΘ", "Content", False),  # Validation for name ASCII
          ("Alpha", "", False),  # Validation for content
      ],
  )
  def test_snippet_creation_validation(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:117
_ ERROR at setup of test_snippet_creation_validation[AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA-Content-False] _
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 117
  @pytest.mark.parametrize(
      "name,content,expect_success",
      [
          ("Alpha", "Some content", True),
          ("", "Some content", False),  # Validation for name
          ("A" * 129, "Content", False),  # Validation for name length
          ("NonAsciiΘ", "Content", False),  # Validation for name ASCII
          ("Alpha", "", False),  # Validation for content
      ],
  )
  def test_snippet_creation_validation(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:117
_ ERROR at setup of test_snippet_creation_validation[NonAscii\xe9-Content-False] _
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 117
  @pytest.mark.parametrize(
      "name,content,expect_success",
      [
          ("Alpha", "Some content", True),
          ("", "Some content", False),  # Validation for name
          ("A" * 129, "Content", False),  # Validation for name length
          ("NonAsciiΘ", "Content", False),  # Validation for name ASCII
          ("Alpha", "", False),  # Validation for content
      ],
  )
  def test_snippet_creation_validation(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:117
______ ERROR at setup of test_snippet_creation_validation[Alpha--False] _______
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 117
  @pytest.mark.parametrize(
      "name,content,expect_success",
      [
          ("Alpha", "Some content", True),
          ("", "Some content", False),  # Validation for name
          ("A" * 129, "Content", False),  # Validation for name length
          ("NonAsciiΘ", "Content", False),  # Validation for name ASCII
          ("Alpha", "", False),  # Validation for content
      ],
  )
  def test_snippet_creation_validation(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:117
____ ERROR at setup of test_snippet_name_uniqueness[Unique1-Unique2-True] _____
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 150
  @pytest.mark.parametrize(
      "name1,name2,should_succeed",
      [
          ("Unique1", "Unique2", True),
          ("DupName", "DupName", False),
      ],
  )
  def test_snippet_name_uniqueness(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:150
____ ERROR at setup of test_snippet_name_uniqueness[DupName-DupName-False] ____
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 150
  @pytest.mark.parametrize(
      "name1,name2,should_succeed",
      [
          ("Unique1", "Unique2", True),
          ("DupName", "DupName", False),
      ],
  )
  def test_snippet_name_uniqueness(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:150
________________ ERROR at setup of test_snippet_creation_valid ________________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 175
  def test_snippet_creation_valid(
E       fixture 'snippet_manager' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:175
_______________ ERROR at setup of test_get_nonexistent_snippet ________________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 193
  def test_get_nonexistent_snippet(snippet_manager: SnippetManager) -> None:
E       fixture 'snippet_manager' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:193
_________________ ERROR at setup of test_list_snippets_empty __________________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 198
  def test_list_snippets_empty(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:198
_______________ ERROR at setup of test_list_snippets_populated ________________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 218
  def test_list_snippets_populated(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:218
_____________________ ERROR at setup of test_snippet_edit _____________________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 241
  def test_snippet_edit(
E       fixture 'snippet_manager' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:241
____________________ ERROR at setup of test_snippet_update ____________________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 260
  def test_snippet_update(snippet_category_fixture: str, snippet_manager: SnippetManager) -> None:
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:260
_______________ ERROR at setup of test_snippet_update_name_only _______________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 274
  def test_snippet_update_name_only(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:274
_____________ ERROR at setup of test_snippet_update_content_only ______________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 291
  def test_snippet_update_content_only(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:291
____________________ ERROR at setup of test_snippet_delete ____________________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 308
  def test_snippet_delete(snippet_category_fixture: str, snippet_manager: SnippetManager) -> None:
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:308
______________ ERROR at setup of test_delete_nonexistent_snippet ______________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 317
  def test_delete_nonexistent_snippet(snippet_manager: SnippetManager) -> None:
E       fixture 'snippet_manager' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:317
_____________ ERROR at setup of test_edit_snippet_change_category _____________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 328
  def test_edit_snippet_change_category(
E       fixture 'snippet_manager' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:328
____________ ERROR at setup of test_edit_snippet_invalid_category _____________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 351
  def test_edit_snippet_invalid_category(
E       fixture 'snippet_manager' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:351
________________ ERROR at setup of test_snippet_sql_injection _________________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 366
  def test_snippet_sql_injection(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:366
___________ ERROR at setup of test_snippet_sql_injection_in_content ___________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 375
  def test_snippet_sql_injection_in_content(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:375
_________________ ERROR at setup of test_snippet_long_content _________________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 384
  def test_snippet_long_content(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:384
_________ ERROR at setup of test_snippet_content_splitting_boundaries _________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 398
  def test_snippet_content_splitting_boundaries(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:398
______________ ERROR at setup of test_update_nonexistent_snippet ______________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 593
  def test_update_nonexistent_snippet(snippet_manager: SnippetManager) -> None:
E       fixture 'snippet_manager' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:593
_____________ ERROR at setup of test_snippet_part_number_sequence _____________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 432
  def test_snippet_part_number_sequence(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:432
______________ ERROR at setup of test_snippet_operation_handling ______________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 520
  def test_snippet_operation_handling(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:520
____________________ ERROR at setup of test_delete_snippet ____________________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 563
  def test_delete_snippet(snippet_category_fixture: str, snippet_manager: SnippetManager) -> None:
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:563
_______ ERROR at setup of test_create_snippet_with_nonexistent_category _______
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 580
  def test_create_snippet_with_nonexistent_category(snippet_manager: SnippetManager) -> None:
E       fixture 'snippet_manager' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:580
________________ ERROR at setup of test_update_snippet_partial ________________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 602
  def test_update_snippet_partial(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:602
______________ ERROR at setup of test_update_snippet_no_changes _______________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 637
  def test_update_snippet_no_changes(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:637
_________________ ERROR at setup of test_get_snippet_by_name __________________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 665
  def test_get_snippet_by_name(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:665
___________ ERROR at setup of test_get_snippet_by_name_nonexistent ____________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 685
  def test_get_snippet_by_name_nonexistent(
E       fixture 'snippet_manager' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:685
_______ ERROR at setup of test_get_snippet_by_name_multiple_categories ________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 692
  def test_get_snippet_by_name_multiple_categories(
E       fixture 'category_manager' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:692
___________________ ERROR at setup of test_search_snippets ____________________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 727
  def test_search_snippets(snippet_category_fixture: str, snippet_manager: SnippetManager) -> None:
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:727
______________ ERROR at setup of test_search_snippets_no_results ______________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 760
  def test_search_snippets_no_results(snippet_manager: SnippetManager) -> None:
E       fixture 'snippet_manager' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:760
__________ ERROR at setup of test_snippet_sql_injection_name_create ___________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 768
  def test_snippet_sql_injection_name_create(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:768
_________ ERROR at setup of test_snippet_sql_injection_content_create _________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 782
  def test_snippet_sql_injection_content_create(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:782
_ ERROR at setup of test_snippet_sql_injection_name_create_with_specific_error _
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 796
  def test_snippet_sql_injection_name_create_with_specific_error(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:796
_________ ERROR at setup of test_snippet_sql_injection_content_update _________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 810
  def test_snippet_sql_injection_content_update(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:810
__________ ERROR at setup of test_snippet_sql_injection_name_update ___________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 824
  def test_snippet_sql_injection_name_update(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:824
_____________ ERROR at setup of test_snippet_deletion_idempotency _____________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 838
  def test_snippet_deletion_idempotency(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:838
_ ERROR at setup of test_snippet_manager_handles_db_errors_gracefully_on_create _
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 854
  def test_snippet_manager_handles_db_errors_gracefully_on_create(
E       fixture 'snippet_manager' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:854
_ ERROR at setup of test_snippet_manager_handles_db_errors_gracefully_on_get __
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 871
  def test_snippet_manager_handles_db_errors_gracefully_on_get(
E       fixture 'snippet_manager' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:871
_ ERROR at setup of test_snippet_manager_handles_db_errors_gracefully_on_update _
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 883
  def test_snippet_manager_handles_db_errors_gracefully_on_update(
E       fixture 'snippet_manager' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:883
_ ERROR at setup of test_snippet_manager_handles_db_errors_gracefully_on_delete _
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 910
  def test_snippet_manager_handles_db_errors_gracefully_on_delete(
E       fixture 'snippet_manager' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:910
_ ERROR at setup of test_snippet_manager_handles_db_errors_gracefully_on_list _
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 948
  def test_snippet_manager_handles_db_errors_gracefully_on_list(
E       fixture 'snippet_manager' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:948
_ ERROR at setup of test_snippet_manager_handles_db_errors_gracefully_on_search _
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 960
  def test_snippet_manager_handles_db_errors_gracefully_on_search(
E       fixture 'snippet_manager' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:960
______ ERROR at setup of test_create_snippet_pydantic_validation_errors _______
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 972
  def test_create_snippet_pydantic_validation_errors(
E       fixture 'snippet_manager' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:972
================================== FAILURES ===================================
________________ TestNGramOnlyMode.test_generate_ngram_content ________________

self = <AITypingTrainer.tests.models.test_dynamic_content_manager.TestNGramOnlyMode object at 0x000001EF1727EAD0>
basic_manager = <models.dynamic_content_manager.DynamicContentManager object at 0x000001EF17D082F0>

    def test_generate_ngram_content(self, basic_manager: DynamicContentManager) -> None:
        """Test generating content with NGramOnly mode."""
        basic_manager.mode = ContentMode.NGRAM_ONLY
        content = basic_manager.generate_content()
    
        # Verify content format and constraints
        assert content, "Content should not be empty"
        assert len(content) <= basic_manager.practice_length, "Content should not exceed practice length"
    
        # Verify content only contains ngrams from focus list
        parts = content.split()
        for part in parts:
>           assert part in basic_manager.ngram_focus_list, f"Part '{part}' should be in ngram focus list"
E           AssertionError: Part 'e' should be in ngram focus list
E           assert 'e' in ['es', 'st', 'te']
E            +  where ['es', 'st', 'te'] = <models.dynamic_content_manager.DynamicContentManager object at 0x000001EF17D082F0>.ngram_focus_list

tests\models\test_dynamic_content_manager.py:170: AssertionError
_______ TestNGramOnlyMode.test_ngram_content_filters_out_of_scope_chars _______

self = <AITypingTrainer.tests.models.test_dynamic_content_manager.TestNGramOnlyMode object at 0x000001EF1718E8B0>

    def test_ngram_content_filters_out_of_scope_chars(self) -> None:
        """Test that NGramOnly content filters out ngrams with out-of-scope characters."""
        manager = DynamicContentManager(
            in_scope_keys=["a", "b"],
            ngram_focus_list=["ab", "cd", "xy"],  # Only "ab" should be used
            mode=ContentMode.NGRAM_ONLY
        )
    
        content = manager.generate_content()
    
        # Content should only include "ab"
>       assert content == "ab" or content == "", "Content should only include ngrams with in-scope keys"
E       AssertionError: Content should only include ngrams with in-scope keys
E       assert ('ab ab ab ab ...ab ab ab ab a' == 'ab'
E         
E         - ab
E         + ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab a or 'ab ab ab ab ...ab ab ab ab a' == ''
E         
E         + ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab a)

tests\models\test_dynamic_content_manager.py:202: AssertionError
________________ TestMixedMode.test_mixed_content_has_variety _________________

self = <AITypingTrainer.tests.models.test_dynamic_content_manager.TestMixedMode object at 0x000001EF1727F110>
basic_manager = <models.dynamic_content_manager.DynamicContentManager object at 0x000001EF18D1E850>

    def test_mixed_content_has_variety(self, basic_manager: DynamicContentManager) -> None:
        """Test that Mixed content includes both ngrams and words."""
        # This test is a bit tricky since the mixed content is randomized
        # We'll make multiple attempts and check statistics
    
        basic_manager.mode = ContentMode.MIXED
        basic_manager.ngram_focus_list = ["ab", "cd"]
    
        # Replace the mock LLM service with one that returns very distinct words
        with patch.object(basic_manager.llm_service, "get_words_with_ngrams",  # type: ignore
                         return_value="abcdef cdabef longerword"):
    
            # Make multiple generation attempts
            seen_ngrams = set()
            seen_longer = False
    
            for _ in range(10):  # Try multiple times due to randomization
                content = basic_manager.generate_content()
                parts = content.split()
    
                for part in parts:
                    if part in basic_manager.ngram_focus_list:
                        seen_ngrams.add(part)
                    elif len(part) > 3:  # Assume longer parts are "words" not ngrams
                        seen_longer = True
    
            # We should see both ngrams and longer words
>           assert seen_ngrams, "Mixed content should include some ngrams"
E           AssertionError: Mixed content should include some ngrams
E           assert set()

tests\models\test_dynamic_content_manager.py:306: AssertionError
---------------------------- Captured stdout call -----------------------------
Generating Text: Raw words: abcdef cdabef longerword
Skipping word: abcdef - bad characters
Skipping word: cdabef - bad characters
Skipping word: longerword - bad characters
Generating Text: Raw words: abcdef cdabef longerword
Skipping word: abcdef - bad characters
Skipping word: cdabef - bad characters
Skipping word: longerword - bad characters
Generating Text: Raw words: abcdef cdabef longerword
Skipping word: abcdef - bad characters
Skipping word: cdabef - bad characters
Skipping word: longerword - bad characters
Generating Text: Raw words: abcdef cdabef longerword
Skipping word: abcdef - bad characters
Skipping word: cdabef - bad characters
Skipping word: longerword - bad characters
Generating Text: Raw words: abcdef cdabef longerword
Skipping word: abcdef - bad characters
Skipping word: cdabef - bad characters
Skipping word: longerword - bad characters
Generating Text: Raw words: abcdef cdabef longerword
Skipping word: abcdef - bad characters
Skipping word: cdabef - bad characters
Skipping word: longerword - bad characters
Generating Text: Raw words: abcdef cdabef longerword
Skipping word: abcdef - bad characters
Skipping word: cdabef - bad characters
Skipping word: longerword - bad characters
Generating Text: Raw words: abcdef cdabef longerword
Skipping word: abcdef - bad characters
Skipping word: cdabef - bad characters
Skipping word: longerword - bad characters
Generating Text: Raw words: abcdef cdabef longerword
Skipping word: abcdef - bad characters
Skipping word: cdabef - bad characters
Skipping word: longerword - bad characters
Generating Text: Raw words: abcdef cdabef longerword
Skipping word: abcdef - bad characters
Skipping word: cdabef - bad characters
Skipping word: longerword - bad characters
_______ TestKeystrokeManagerSaveKeystrokes.test_save_keystrokes_success _______

self = <AITypingTrainer.tests.models.test_keystroke_manager.TestKeystrokeManagerSaveKeystrokes object at 0x000001EF177E8B90>
manager_with_mock_db = <models.keystroke_manager.KeystrokeManager object at 0x000001EF18D688C0>
sample_keystrokes = [Keystroke(session_id='save-test-session', keystroke_id='26d3f213-0951-4be5-8d50-6241d1238208', keystroke_time=datetim...=datetime.timezone.utc), keystroke_char='c', expected_char='c', is_error=False, time_since_previous=120, text_index=0)]

    def test_save_keystrokes_success(
        self, manager_with_mock_db: KeystrokeManager, sample_keystrokes: List[Keystroke]
    ) -> None:
        """Test successful saving of keystrokes."""
        manager_with_mock_db.keystroke_list = sample_keystrokes
    
        result = manager_with_mock_db.save_keystrokes()
    
        assert result is True
>       assert manager_with_mock_db.db_manager.execute.call_count == 3
E       AssertionError: assert 0 == 3
E        +  where 0 = <Mock name='mock.execute' id='2126407381552'>.call_count
E        +    where <Mock name='mock.execute' id='2126407381552'> = <Mock spec='DatabaseManager' id='2126407383568'>.execute
E        +      where <Mock spec='DatabaseManager' id='2126407383568'> = <models.keystroke_manager.KeystrokeManager object at 0x000001EF18D688C0>.db_manager

tests\models\test_keystroke_manager.py:234: AssertionError
___ TestKeystrokeManagerSaveKeystrokes.test_save_keystrokes_database_error ____

self = <AITypingTrainer.tests.models.test_keystroke_manager.TestKeystrokeManagerSaveKeystrokes object at 0x000001EF1782C2B0>
manager_with_mock_db = <models.keystroke_manager.KeystrokeManager object at 0x000001EF17D0B690>
sample_keystrokes = [Keystroke(session_id='save-test-session', keystroke_id='3692ece3-7283-4d5d-9b87-e77b05affe8e', keystroke_time=datetim...=datetime.timezone.utc), keystroke_char='c', expected_char='c', is_error=False, time_since_previous=120, text_index=0)]

    def test_save_keystrokes_database_error(
        self, manager_with_mock_db: KeystrokeManager, sample_keystrokes: List[Keystroke]
    ) -> None:
        """Test handling of database errors during save."""
        manager_with_mock_db.keystroke_list = sample_keystrokes
        manager_with_mock_db.db_manager.execute.side_effect = Exception(
            "Database connection failed"
        )
    
        with patch("sys.stderr"), patch("traceback.print_exc"):
            result = manager_with_mock_db.save_keystrokes()
    
>       assert result is False
E       assert True is False

tests\models\test_keystroke_manager.py:277: AssertionError
_ TestKeystrokeManagerSaveKeystrokes.test_save_keystrokes_with_special_characters _

self = <AITypingTrainer.tests.models.test_keystroke_manager.TestKeystrokeManagerSaveKeystrokes object at 0x000001EF1782C3E0>
manager_with_mock_db = <models.keystroke_manager.KeystrokeManager object at 0x000001EF18E94E50>

    def test_save_keystrokes_with_special_characters(
        self, manager_with_mock_db: KeystrokeManager
    ) -> None:
        """Test saving keystrokes with special characters."""
        import uuid
    
        special_chars = ["'", '"', "\\\\", "\\n", "\\t", "\u20ac", "\U0001f60a"]
        keystrokes = []
        for _i, char in enumerate(special_chars):
            keystroke = Keystroke(
                session_id="special-char-session",
                keystroke_id=str(uuid.uuid4()),
                keystroke_time=datetime.now(timezone.utc),
                keystroke_char=char,
                expected_char=char,
                is_error=False,
                time_since_previous=100,
            )
            keystrokes.append(keystroke)
        manager_with_mock_db.keystroke_list = keystrokes
        result = manager_with_mock_db.save_keystrokes()
        assert result is True
>       assert manager_with_mock_db.db_manager.execute.call_count == len(special_chars)
E       assert 0 == 7
E        +  where 0 = <Mock name='mock.execute' id='2126426101744'>.call_count
E        +    where <Mock name='mock.execute' id='2126426101744'> = <Mock spec='DatabaseManager' id='2126407381216'>.execute
E        +      where <Mock spec='DatabaseManager' id='2126407381216'> = <models.keystroke_manager.KeystrokeManager object at 0x000001EF18E94E50>.db_manager
E        +  and   7 = len(["'", '"', '\\', '\n', '\t', 'Ç', ...])

tests\models\test_keystroke_manager.py:301: AssertionError
_ TestKeystrokeManagerSaveKeystrokes.test_save_keystrokes_boolean_conversion __

self = <AITypingTrainer.tests.models.test_keystroke_manager.TestKeystrokeManagerSaveKeystrokes object at 0x000001EF17825910>
manager_with_mock_db = <models.keystroke_manager.KeystrokeManager object at 0x000001EF18E0E270>

    def test_save_keystrokes_boolean_conversion(
        self, manager_with_mock_db: KeystrokeManager
    ) -> None:
        """Test that boolean is_error is properly converted to int."""
        import uuid
    
        keystroke = Keystroke(
            session_id="bool-test",
            keystroke_id=str(uuid.uuid4()),
            keystroke_time=datetime.now(timezone.utc),
            keystroke_char="a",
            expected_char="b",
            is_error=True,
            time_since_previous=50,
        )
        manager_with_mock_db.keystroke_list = [keystroke]
        result = manager_with_mock_db.save_keystrokes()
        assert result is True
        call_args = manager_with_mock_db.db_manager.execute.call_args
>       params = call_args[0][1]
                 ^^^^^^^^^^^^
E       TypeError: 'NoneType' object is not subscriptable

tests\models\test_keystroke_manager.py:322: TypeError
________ TestKeystrokeManagerIntegration.test_full_keystroke_workflow _________

self = <AITypingTrainer.tests.models.test_keystroke_manager.TestKeystrokeManagerIntegration object at 0x000001EF177E9310>
integration_manager = <models.keystroke_manager.KeystrokeManager object at 0x000001EF18E47FB0>

    def test_full_keystroke_workflow(self, integration_manager: KeystrokeManager) -> None:
        """Test complete workflow: add, save, count, retrieve, delete."""
        import uuid
    
        session_id = str(uuid.uuid4())
        # Insert a matching session into the database
        db = integration_manager.db_manager
        db.init_tables()
        # Ensure session_keystrokes table is correct for UUID keystroke_id
        db.execute("DROP TABLE IF EXISTS session_keystrokes")
        db.execute(
            """
            CREATE TABLE session_keystrokes (
                keystroke_id TEXT PRIMARY KEY,
                session_id TEXT NOT NULL,
                keystroke_time TEXT NOT NULL,
                keystroke_char TEXT NOT NULL,
                expected_char TEXT NOT NULL,
                is_error INTEGER NOT NULL,
                time_since_previous INTEGER,
                FOREIGN KEY (session_id) REFERENCES practice_sessions(session_id) ON DELETE CASCADE
            )
            """
        )
        category_id = str(uuid.uuid4())
        # Insert a matching category into the database
        db.execute(
            """
            INSERT INTO categories (category_id, category_name) VALUES (?, ?)
            """,
            (category_id, "integration-category"),
        )
        snippet_id = str(uuid.uuid4())
        # Insert a matching snippet into the database
        db.execute(
            """
            INSERT INTO snippets (snippet_id, category_id, snippet_name) VALUES (?, ?, ?)
            """,
            (snippet_id, category_id, "integration-snippet"),
        )
        user_id = str(uuid.uuid4())
        keyboard_id = str(uuid.uuid4())
        db.execute(
            "INSERT INTO users (user_id, first_name, surname, email_address) VALUES (?, ?, ?, ?)",
            (user_id, "Test", "User", f"testuser_{user_id[:8]}@example.com"),
        )
        db.execute(
            "INSERT INTO keyboards (keyboard_id, user_id, keyboard_name) VALUES (?, ?, ?)",
            (keyboard_id, user_id, "Test Keyboard"),
        )
        db.execute(
            "INSERT INTO practice_sessions (session_id, snippet_id, user_id, keyboard_id, snippet_index_start, snippet_index_end, content, start_time, end_time, actual_chars, errors, ms_per_keystroke) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)",
            (
                session_id,
                snippet_id,
                user_id,
                keyboard_id,
                0,
                10,
                "abcde",
                "2025-06-10T12:00:00",
                "2025-06-10T12:01:00",
                5,
                0,
                100.0,
            ),
        )
        # Create test keystrokes
        keystrokes = []
        for i in range(5):
            keystroke = Keystroke(
                session_id=session_id,
                keystroke_id=str(uuid.uuid4()),
                keystroke_time=datetime.now(timezone.utc),
                keystroke_char=chr(97 + i),
                expected_char=chr(97 + i),
                is_error=i == 2,  # Make one an error
                time_since_previous=100 + i * 10,  # Always integer
            )
            keystrokes.append(keystroke)
            integration_manager.add_keystroke(keystroke)
        # Verify keystrokes are in memory
        assert len(integration_manager.keystroke_list) == 5
        # Save to database
        save_result = integration_manager.save_keystrokes()
>       assert save_result is True
E       assert False is True

tests\models\test_keystroke_manager.py:636: AssertionError
---------------------------- Captured stdout call -----------------------------
 Exception during execute_many: table session_keystrokes has no column named text_index. Rolling back transaction.
---------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 605, in execute_many
    return self._bulk_executemany(cursor, query, params_list)
           ~~~~~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 633, in _bulk_executemany
    cursor.executemany(query, params_list)
    ~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^
sqlite3.OperationalError: table session_keystrokes has no column named text_index
Error saving keystrokes: Database operation failed: table session_keystrokes has no column named text_index
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 605, in execute_many
    return self._bulk_executemany(cursor, query, params_list)
           ~~~~~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 633, in _bulk_executemany
    cursor.executemany(query, params_list)
    ~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^
sqlite3.OperationalError: table session_keystrokes has no column named text_index

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\models\keystroke_manager.py", line 63, in save_keystrokes
    self.db_manager.execute_many(query, params)  # type: ignore[attr-defined]
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 614, in execute_many
    self._translate_and_raise(e)
    ~~~~~~~~~~~~~~~~~~~~~~~~~^^^
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 434, in _translate_and_raise
    raise DatabaseError(f"Database operation failed: {e}") from e
db.exceptions.DatabaseError: Database operation failed: table session_keystrokes has no column named text_index
______ TestKeystrokeManagerEdgeCases.test_unicode_and_special_characters ______

self = <AITypingTrainer.tests.models.test_keystroke_manager.TestKeystrokeManagerEdgeCases object at 0x000001EF1782C9D0>
manager = <models.keystroke_manager.KeystrokeManager object at 0x000001EF18E81850>

    def test_unicode_and_special_characters(self, manager: KeystrokeManager) -> None:
        """Test handling of Unicode and special characters in keystrokes."""
        import uuid
    
        special_chars = [
            "\U0001f642",
            "\u6d4b\u8bd5",
            "cafΘ",
            "\u03a9",
            "\n",
            "\t",
            "\\",
            "'",
            '"',
            "\0",
        ]
        for _i, char in enumerate(special_chars):
            keystroke = Keystroke(
                session_id="unicode-test",
                keystroke_id=str(uuid.uuid4()),
                keystroke_time=datetime.now(timezone.utc),
                keystroke_char=char,
                expected_char=char,
                is_error=False,
                time_since_previous=100,  # Always integer
            )
            manager.add_keystroke(keystroke)
        assert len(manager.keystroke_list) == len(special_chars)
        result = manager.save_keystrokes()
        assert result is True
>       assert manager.db_manager.execute.call_count == len(special_chars)
E       AssertionError: assert 0 == 10
E        +  where 0 = <Mock name='mock.execute' id='2126426107120'>.call_count
E        +    where <Mock name='mock.execute' id='2126426107120'> = <Mock spec='DatabaseManager' id='2126426108464'>.execute
E        +      where <Mock spec='DatabaseManager' id='2126426108464'> = <models.keystroke_manager.KeystrokeManager object at 0x000001EF18E81850>.db_manager
E        +  and   10 = len(['\U0001f642', '\u6d4b\u8bd5', 'caf\xe9', '\u03a9', '\\n', '\\t', ...])

tests\models\test_keystroke_manager.py:829: AssertionError
_____ TestKeystrokeManagerErrorHandling.test_database_connection_failure ______

self = <AITypingTrainer.tests.models.test_keystroke_manager.TestKeystrokeManagerErrorHandling object at 0x000001EF177E9810>
manager = <models.keystroke_manager.KeystrokeManager object at 0x000001EF18E11550>

    def test_database_connection_failure(self, manager: KeystrokeManager) -> None:
        """Test handling of database connection failures."""
        import uuid
    
        manager.db_manager.execute.side_effect = Exception("Connection lost")
        keystroke = Keystroke(
            session_id="error-test",
            keystroke_id=str(uuid.uuid4()),
            keystroke_time=datetime.now(timezone.utc),
            keystroke_char="a",
            expected_char="a",
            is_error=False,
            time_since_previous=100,
        )
        manager.add_keystroke(keystroke)
        result = manager.save_keystrokes()
>       assert result is False
E       assert True is False

tests\models\test_keystroke_manager.py:878: AssertionError
_________ TestKeystrokeManagerErrorHandling.test_partial_save_failure _________

self = <AITypingTrainer.tests.models.test_keystroke_manager.TestKeystrokeManagerErrorHandling object at 0x000001EF1782CC30>
manager = <models.keystroke_manager.KeystrokeManager object at 0x000001EF18E812B0>

    def test_partial_save_failure(self, manager: KeystrokeManager) -> None:
        """Test handling when some keystrokes save successfully and others fail."""
        import uuid
    
        keystrokes = []
        for i in range(3):
            keystroke = Keystroke(
                session_id="partial-test",
                keystroke_id=str(uuid.uuid4()),
                keystroke_time=datetime.now(timezone.utc),
                keystroke_char=chr(97 + i),
                expected_char=chr(97 + i),
                is_error=False,
                time_since_previous=100,
            )
            keystrokes.append(keystroke)
        manager.keystroke_list = keystrokes
        manager.db_manager.execute.side_effect = [None, Exception("Save failed"), None]
        result = manager.save_keystrokes()
>       assert result is False
E       assert True is False

tests\models\test_keystroke_manager.py:919: AssertionError
______ TestKeystrokeManagerErrorHandling.test_network_timeout_simulation ______

self = <AITypingTrainer.tests.models.test_keystroke_manager.TestKeystrokeManagerErrorHandling object at 0x000001EF1782CD60>
manager = <models.keystroke_manager.KeystrokeManager object at 0x000001EF18DED7F0>

    def test_network_timeout_simulation(self, manager: KeystrokeManager) -> None:
        """Test handling of network timeout-like errors."""
        import time
        import uuid
    
        def slow_execute(*args: object, **kwargs: object) -> object:
            time.sleep(0.1)  # Simulate slow operation
            raise TimeoutError("Database timeout")
    
        manager.db_manager.execute.side_effect = slow_execute
        keystroke = Keystroke(
            session_id="timeout-test",
            keystroke_id=str(uuid.uuid4()),
            keystroke_time=datetime.now(timezone.utc),
            keystroke_char="a",
            expected_char="a",
            is_error=False,
            time_since_previous=100,
        )
        manager.add_keystroke(keystroke)
        result = manager.save_keystrokes()
>       assert result is False
E       assert True is False

tests\models\test_keystroke_manager.py:942: AssertionError
____________________________ test_missing_api_key _____________________________

    def test_missing_api_key():
>       with pytest.raises(LLMMissingAPIKeyError):
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       Failed: DID NOT RAISE <class 'models.llm_ngram_service.LLMMissingAPIKeyError'>

tests\models\test_llm_ngram_service.py:8: Failed
________________ TestKeystroke.test_keystroke_nfc_single_char _________________

self = <AITypingTrainer.tests.models.test_ngram.TestKeystroke object at 0x000001EF177EA0D0>

    def test_keystroke_nfc_single_char(self):
        # composed e + \u0301
        k = Keystroke(keystroke_time=ts(0), text_index=0, expected_char="e\u0301", keystroke_char="Θ", is_error=False)
>       assert k.expected_char == "Θ"
E       AssertionError: assert 'e\u0301' == '\xe9'
E         
E         - Θ
E         + e\u0301

tests\models\test_ngram.py:32: AssertionError
__ TestNGramAnalyticsService.test_dual_insert_creates_records_in_both_tables __

self = <AITypingTrainer.tests.models.test_ngram_analytics_service.TestNGramAnalyticsService object at 0x000001EF177F5850>
temp_db = 'C:\\Users\\seanb\\AppData\\Local\\Temp\\tmprpfen75n.db'
mock_sessions = [{'keyboard_id': 'keyboard_1', 'session_id': 'session_1', 'start_time': '2024-01-01 10:01:00', 'target_ms_per_keystrok...: 'keyboard_1', 'session_id': 'session_2', 'start_time': '2024-01-01 10:02:00', 'target_ms_per_keystroke': 170.0, ...}]
mock_ngram_data = [{'ms_per_keystroke': 100.0, 'ngram_size': 2, 'ngram_speed_id': 'ng_0', 'ngram_text': 'th', ...}, {'ms_per_keystroke':...ram_text': 'th', ...}, {'ms_per_keystroke': 107.5, 'ngram_size': 3, 'ngram_speed_id': 'ng_3', 'ngram_text': 'he', ...}]

    def test_dual_insert_creates_records_in_both_tables(
        self,
        temp_db: DatabaseManager,
        mock_sessions: List[MockSessionData],
        mock_ngram_data: List[MockNGramSpeedData],
    ) -> None:
        """
        Test objective: Verify dual-insert creates records in both current and history tables.
    
        Tests that when refresh_speed_summaries is called, records are created
        in both ngram_speed_summary_curr and ngram_speed_summary_hist tables.
        """
        ngram_manager = NGramManager(temp_db)
        service = NGramAnalyticsService(temp_db, ngram_manager)
    
        # Set up test data
        user_id = "user_1"
        keyboard_id = "keyboard_1"
    
        # Insert test session and keyboard data
        for session in mock_sessions:
>           temp_db.execute(
            ^^^^^^^^^^^^^^^
                """INSERT INTO practice_sessions
                (session_id, user_id, keyboard_id, snippet_id, snippet_index_start, snippet_index_end,
                 content, start_time, end_time, actual_chars, errors, ms_per_keystroke)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)""",
                (
                    session["session_id"],
                    session["user_id"],
                    session["keyboard_id"],
                    "test_snippet_1",
                    0,
                    10,
                    "test content",
                    session["start_time"],
                    session["start_time"],
                    "test",
                    0,
                    session["target_ms_per_keystroke"],
                ),
            )
E           AttributeError: 'str' object has no attribute 'execute'

tests\models\test_ngram_analytics_service.py:370: AttributeError
____ TestNGramAnalyticsService.test_history_table_accumulates_all_records _____

self = <AITypingTrainer.tests.models.test_ngram_analytics_service.TestNGramAnalyticsService object at 0x000001EF177F5A50>
temp_db = 'C:\\Users\\seanb\\AppData\\Local\\Temp\\tmpmidb3pk6.db'
mock_sessions = [{'keyboard_id': 'keyboard_1', 'session_id': 'session_1', 'start_time': '2024-01-01 10:01:00', 'target_ms_per_keystrok...: 'keyboard_1', 'session_id': 'session_2', 'start_time': '2024-01-01 10:02:00', 'target_ms_per_keystroke': 170.0, ...}]
mock_ngram_data = [{'ms_per_keystroke': 100.0, 'ngram_size': 2, 'ngram_speed_id': 'ng_0', 'ngram_text': 'th', ...}, {'ms_per_keystroke':...ram_text': 'th', ...}, {'ms_per_keystroke': 107.5, 'ngram_size': 3, 'ngram_speed_id': 'ng_3', 'ngram_text': 'he', ...}]

    def test_history_table_accumulates_all_records(
        self,
        temp_db: DatabaseManager,
        mock_sessions: List[MockSessionData],
        mock_ngram_data: List[MockNGramSpeedData],
    ) -> None:
        """
        Test objective: Verify history table contains all records over multiple refreshes.
    
        Tests that the history table accumulates all records from multiple
        refresh operations while current table only contains latest values.
        """
        ngram_manager = NGramManager(temp_db)
        service = NGramAnalyticsService(temp_db, ngram_manager)
    
        user_id = "user_1"
        keyboard_id = "keyboard_1"
    
        # Set up initial test data
        for session in mock_sessions:
>           temp_db.execute(
            ^^^^^^^^^^^^^^^
                """INSERT INTO practice_sessions
                (session_id, user_id, keyboard_id, snippet_id, snippet_index_start, snippet_index_end,
                 content, start_time, end_time, actual_chars, errors, ms_per_keystroke)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)""",
                (
                    session["session_id"],
                    session["user_id"],
                    session["keyboard_id"],
                    "test_snippet_1",
                    0,
                    10,
                    "test content",
                    session["start_time"],
                    session["start_time"],
                    "test",
                    0,
                    session["target_ms_per_keystroke"],
                ),
            )
E           AttributeError: 'str' object has no attribute 'execute'

tests\models\test_ngram_analytics_service.py:442: AttributeError
_________ TestNGramAnalyticsService.test_get_ngram_history_retrieval __________

self = <AITypingTrainer.tests.models.test_ngram_analytics_service.TestNGramAnalyticsService object at 0x000001EF175A3980>
temp_db = 'C:\\Users\\seanb\\AppData\\Local\\Temp\\tmp7z56qff5.db'
mock_sessions = [{'keyboard_id': 'keyboard_1', 'session_id': 'session_1', 'start_time': '2024-01-01 10:01:00', 'target_ms_per_keystrok...: 'keyboard_1', 'session_id': 'session_2', 'start_time': '2024-01-01 10:02:00', 'target_ms_per_keystroke': 170.0, ...}]
mock_ngram_data = [{'ms_per_keystroke': 100.0, 'ngram_size': 2, 'ngram_speed_id': 'ng_0', 'ngram_text': 'th', ...}, {'ms_per_keystroke':...ram_text': 'th', ...}, {'ms_per_keystroke': 107.5, 'ngram_size': 3, 'ngram_speed_id': 'ng_3', 'ngram_text': 'he', ...}]

    def test_get_ngram_history_retrieval(
        self,
        temp_db: DatabaseManager,
        mock_sessions: List[MockSessionData],
        mock_ngram_data: List[MockNGramSpeedData],
    ) -> None:
        """
        Test objective: Verify history retrieval functionality.
    
        Tests that historical data can be retrieved properly with correct
        timestamps and performance metrics.
        """
        ngram_manager = NGramManager(temp_db)
        service = NGramAnalyticsService(temp_db, ngram_manager)
    
        user_id = "user_1"
        keyboard_id = "keyboard_1"
    
        # Set up test data and refresh
        for session in mock_sessions:
>           temp_db.execute(
            ^^^^^^^^^^^^^^^
                """INSERT INTO practice_sessions
                (session_id, user_id, keyboard_id, snippet_id, snippet_index_start, snippet_index_end,
                 content, start_time, end_time, actual_chars, errors, ms_per_keystroke)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)""",
                (
                    session["session_id"],
                    session["user_id"],
                    session["keyboard_id"],
                    "test_snippet_1",
                    0,
                    10,
                    "test content",
                    session["start_time"],
                    session["start_time"],
                    "test",
                    0,
                    session["target_ms_per_keystroke"],
                ),
            )
E           AttributeError: 'str' object has no attribute 'execute'

tests\models\test_ngram_analytics_service.py:552: AttributeError
______ TestNGramAnalyticsService.test_history_table_schema_compatibility ______

self = <AITypingTrainer.tests.models.test_ngram_analytics_service.TestNGramAnalyticsService object at 0x000001EF175A3B60>
temp_db = 'C:\\Users\\seanb\\AppData\\Local\\Temp\\tmp42fnbcxj.db'

    def test_history_table_schema_compatibility(
        self, temp_db: DatabaseManager
    ) -> None:
        """
        Test objective: Verify history table schema matches current table.
    
        Tests that the history table has the same essential columns as
        the current table plus additional history-specific fields.
        """
        ngram_manager = NGramManager(temp_db)
        service = NGramAnalyticsService(temp_db, ngram_manager)
    
        # Verify table schemas are compatible
>       current_schema = temp_db.fetchall("PRAGMA table_info(ngram_speed_summary_curr)")
                         ^^^^^^^^^^^^^^^^
E       AttributeError: 'str' object has no attribute 'fetchall'

tests\models\test_ngram_analytics_service.py:617: AttributeError
__________________ test_process_end_of_session_success_path ___________________

self = <db.database_manager.DatabaseManager object at 0x000001EF18F78FA0>
query = '\n            INSERT INTO categories (category_id, category_name, description)\n            VALUES (?, ?, ?)\n            '
params = ('46d6089f-0a7c-4186-b152-5e016deb7668', 'Test Category', 'Test category for testing')

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table categories has no column named description

db\database_manager.py:509: OperationalError

The above exception was the direct cause of the following exception:

db_with_tables = <db.database_manager.DatabaseManager object at 0x000001EF18F78FA0>
test_user = User(user_id='0c6501ab-91b1-4f67-b18e-411c2da318cd', first_name='Test', surname='User', email_address='test.user.6e509963-e550-42b7-a9c2-ebadfbbd9d6e@example.com')
test_keyboard = Keyboard(keyboard_id='e4c2f0bc-1475-4de3-9338-f15f5756ad08', user_id='0c6501ab-91b1-4f67-b18e-411c2da318cd', keyboard_name='Test Keyboard', target_ms_per_keystroke=600)

    def test_process_end_of_session_success_path(db_with_tables, test_user, test_keyboard):
        # Arrange: create snippet (for FK completeness) and a new Session not yet in DB
        from tests.models.conftest import TestSessionMethodsFixtures
    
>       category_id = TestSessionMethodsFixtures.create_category(db_with_tables)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_ngram_orchestrator_process_end_of_session.py:40: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:239: in create_category
    db.execute(
db\database_manager.py:524: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x000001EF18F78FA0>
e = OperationalError('table categories has no column named description')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table categories has no column named description

db\database_manager.py:434: DatabaseError
---------------------------- Captured stdout call -----------------------------
Exception during query: table categories has no column named description. Rolling back transaction.
---------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 509, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table categories has no column named description
______________ test_process_end_of_session_session_save_failure _______________

self = <db.database_manager.DatabaseManager object at 0x000001EF18F47AF0>
query = '\n            INSERT INTO categories (category_id, category_name, description)\n            VALUES (?, ?, ?)\n            '
params = ('9c174bbe-428e-4b81-8439-1d16440493ce', 'Test Category', 'Test category for testing')

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table categories has no column named description

db\database_manager.py:509: OperationalError

The above exception was the direct cause of the following exception:

db_with_tables = <db.database_manager.DatabaseManager object at 0x000001EF18F47AF0>
test_user = User(user_id='506d33ca-4108-46fb-9e7c-6be4dd22041f', first_name='Test', surname='User', email_address='test.user.b1ad9a90-420c-4ad4-9237-9f3e7789a187@example.com')

    def test_process_end_of_session_session_save_failure(db_with_tables, test_user):
        """Fails at step 1: session save should raise due to FK violation (invalid keyboard_id)."""
        from tests.models.conftest import TestSessionMethodsFixtures
    
        # Valid snippet/category, but invalid keyboard_id to trigger FK failure on insert
>       category_id = TestSessionMethodsFixtures.create_category(db_with_tables)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_ngram_orchestrator_process_end_of_session.py:129: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:239: in create_category
    db.execute(
db\database_manager.py:524: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x000001EF18F47AF0>
e = OperationalError('table categories has no column named description')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table categories has no column named description

db\database_manager.py:434: DatabaseError
---------------------------- Captured stdout call -----------------------------
Exception during query: table categories has no column named description. Rolling back transaction.
---------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 509, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table categories has no column named description
_____________ test_process_end_of_session_keystrokes_save_failure _____________

self = <db.database_manager.DatabaseManager object at 0x000001EF18F47850>
query = '\n            INSERT INTO categories (category_id, category_name, description)\n            VALUES (?, ?, ?)\n            '
params = ('443fa620-7bd7-40da-99cf-933455ca7865', 'Test Category', 'Test category for testing')

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table categories has no column named description

db\database_manager.py:509: OperationalError

The above exception was the direct cause of the following exception:

db_with_tables = <db.database_manager.DatabaseManager object at 0x000001EF18F47850>
test_user = User(user_id='24ad9cca-d102-4d84-8c58-0c5779c1b748', first_name='Test', surname='User', email_address='test.user.8c293ce2-eb58-4ae1-8ab2-767a58379f87@example.com')
test_keyboard = Keyboard(keyboard_id='c68309f2-3ce3-47c2-a78c-4ff6b123037e', user_id='24ad9cca-d102-4d84-8c58-0c5779c1b748', keyboard_name='Test Keyboard', target_ms_per_keystroke=600)

    def test_process_end_of_session_keystrokes_save_failure(db_with_tables, test_user, test_keyboard):
        """Fails at step 2: keystrokes save should return False due to invalid keystroke session_id."""
        from tests.models.conftest import TestSessionMethodsFixtures
    
>       category_id = TestSessionMethodsFixtures.create_category(db_with_tables)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_ngram_orchestrator_process_end_of_session.py:170: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:239: in create_category
    db.execute(
db\database_manager.py:524: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x000001EF18F47850>
e = OperationalError('table categories has no column named description')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table categories has no column named description

db\database_manager.py:434: DatabaseError
---------------------------- Captured stdout call -----------------------------
Exception during query: table categories has no column named description. Rolling back transaction.
---------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 509, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table categories has no column named description
______________ test_process_end_of_session_summarization_failure ______________

self = <db.database_manager.DatabaseManager object at 0x000001EF18F474D0>
query = '\n            INSERT INTO categories (category_id, category_name, description)\n            VALUES (?, ?, ?)\n            '
params = ('c13bc7db-4348-4dd3-a2a9-0594a4c2a5cb', 'Test Category', 'Test category for testing')

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table categories has no column named description

db\database_manager.py:509: OperationalError

The above exception was the direct cause of the following exception:

db_with_tables = <db.database_manager.DatabaseManager object at 0x000001EF18F474D0>
test_user = User(user_id='395fff5b-f0f7-42ed-bec5-efe9d8a78b0e', first_name='Test', surname='User', email_address='test.user.667bcf03-bf08-4d04-b11b-76428b651374@example.com')
test_keyboard = Keyboard(keyboard_id='7186a88e-1ab4-4647-8d0d-9385f4604ead', user_id='395fff5b-f0f7-42ed-bec5-efe9d8a78b0e', keyboard_name='Test Keyboard', target_ms_per_keystroke=600)

    def test_process_end_of_session_summarization_failure(db_with_tables, test_user, test_keyboard):
        """Fails at step 4: drop summary table to force summarization SQL to fail after n-grams."""
        from tests.models.conftest import TestSessionMethodsFixtures
    
>       category_id = TestSessionMethodsFixtures.create_category(db_with_tables)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_ngram_orchestrator_process_end_of_session.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:239: in create_category
    db.execute(
db\database_manager.py:524: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x000001EF18F474D0>
e = OperationalError('table categories has no column named description')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table categories has no column named description

db\database_manager.py:434: DatabaseError
---------------------------- Captured stdout call -----------------------------
Exception during query: table categories has no column named description. Rolling back transaction.
---------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 509, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table categories has no column named description
============================== warnings summary ===============================
tests/models/test_category_manager.py::TestCategoryManager::test_list_all_categories_populated
  C:\Python\Python313\Lib\inspect.py:445: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000001EF17C2F1F0>
    def isasyncgenfunction(obj):
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_category_manager.py::TestCategoryManager::test_list_all_categories_populated
  C:\Python\Python313\Lib\inspect.py:445: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000001EF17C609A0>
    def isasyncgenfunction(obj):
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_category_manager.py::TestCategoryManager::test_list_all_categories_populated
  C:\Python\Python313\Lib\inspect.py:445: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000001EF17C60F40>
    def isasyncgenfunction(obj):
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_category_manager.py::TestCategoryManager::test_list_all_categories_populated
  C:\Python\Python313\Lib\inspect.py:445: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000001EF17C61030>
    def isasyncgenfunction(obj):
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_category_manager.py::TestCategoryManager::test_list_all_categories_populated
  C:\Python\Python313\Lib\inspect.py:445: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000001EF17C61300>
    def isasyncgenfunction(obj):
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_category_manager.py::TestCategoryManager::test_list_all_categories_populated
  C:\Python\Python313\Lib\inspect.py:445: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000001EF17C61120>
    def isasyncgenfunction(obj):
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_category_manager.py::TestCategoryManager::test_list_all_categories_populated
  C:\Python\Python313\Lib\inspect.py:445: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000001EF17C60D60>
    def isasyncgenfunction(obj):
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_category_manager.py::TestCategoryManager::test_list_all_categories_populated
  C:\Python\Python313\Lib\inspect.py:445: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000001EF17C60B80>
    def isasyncgenfunction(obj):
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_category_manager.py::TestCategoryManager::test_list_all_categories_populated
  C:\Python\Python313\Lib\inspect.py:445: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000001EF17C61210>
    def isasyncgenfunction(obj):
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_category_manager.py::TestCategoryManager::test_save_category_unexpected_db_error
  D:\SeanDevLocal\AITypingTrainer\.venv\Lib\site-packages\_pytest\raises.py:437: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000001EF17C2DA80>
    def _parse_exc(
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_category_manager.py::TestCategoryManager::test_save_category_unexpected_db_error
  D:\SeanDevLocal\AITypingTrainer\.venv\Lib\site-packages\_pytest\raises.py:437: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000001EF17C60220>
    def _parse_exc(
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_category_manager.py::TestCategoryManager::test_save_category_unexpected_db_error
  D:\SeanDevLocal\AITypingTrainer\.venv\Lib\site-packages\_pytest\raises.py:437: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000001EF17C624D0>
    def _parse_exc(
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_category_manager.py::TestCategoryManager::test_save_category_unexpected_db_error
  D:\SeanDevLocal\AITypingTrainer\.venv\Lib\site-packages\_pytest\raises.py:437: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000001EF17C62A70>
    def _parse_exc(
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_category_manager.py::TestCategoryManager::test_save_category_unexpected_db_error
  D:\SeanDevLocal\AITypingTrainer\.venv\Lib\site-packages\_pytest\raises.py:437: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000001EF17C62B60>
    def _parse_exc(
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_category_manager.py::TestCategoryManager::test_save_category_unexpected_db_error
  D:\SeanDevLocal\AITypingTrainer\.venv\Lib\site-packages\_pytest\raises.py:437: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000001EF17C62C50>
    def _parse_exc(
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_category_manager.py::TestCategoryManager::test_save_category_unexpected_db_error
  D:\SeanDevLocal\AITypingTrainer\.venv\Lib\site-packages\_pytest\raises.py:437: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000001EF17C62D40>
    def _parse_exc(
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_category_manager.py::TestCategoryManager::test_save_category_unexpected_db_error
  D:\SeanDevLocal\AITypingTrainer\.venv\Lib\site-packages\_pytest\raises.py:437: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000001EF17C62E30>
    def _parse_exc(
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_category_manager.py::TestCategoryManager::test_save_category_unexpected_db_error
  D:\SeanDevLocal\AITypingTrainer\.venv\Lib\site-packages\_pytest\raises.py:437: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000001EF17C62F20>
    def _parse_exc(
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_category_manager.py::TestCategoryManager::test_save_category_unexpected_db_error
  D:\SeanDevLocal\AITypingTrainer\.venv\Lib\site-packages\_pytest\raises.py:437: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000001EF17C63010>
    def _parse_exc(
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_category_manager.py::TestCategoryManager::test_save_category_unexpected_db_error
  D:\SeanDevLocal\AITypingTrainer\.venv\Lib\site-packages\_pytest\raises.py:437: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000001EF17C63100>
    def _parse_exc(
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_category_manager.py::TestCategoryManager::test_save_category_unexpected_db_error
  D:\SeanDevLocal\AITypingTrainer\.venv\Lib\site-packages\_pytest\raises.py:437: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000001EF17C631F0>
    def _parse_exc(
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_keystroke.py::TestKeystrokeClassMethods::test_get_for_session_empty_result
  C:\Python\Python313\Lib\unittest\mock.py:502: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000001EF18D69030>
    _safe_super(NonCallableMock, self).__init__(
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_keystroke.py::TestKeystrokeClassMethods::test_get_for_session_empty_result
  C:\Python\Python313\Lib\unittest\mock.py:502: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000001EF18D69300>
    _safe_super(NonCallableMock, self).__init__(
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_keystroke.py::TestKeystrokeClassMethods::test_get_for_session_empty_result
  C:\Python\Python313\Lib\unittest\mock.py:502: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000001EF18D693F0>
    _safe_super(NonCallableMock, self).__init__(
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_keystroke.py::TestKeystrokeClassMethods::test_get_for_session_empty_result
  C:\Python\Python313\Lib\unittest\mock.py:502: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000001EF18D694E0>
    _safe_super(NonCallableMock, self).__init__(
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_keystroke.py::TestKeystrokeClassMethods::test_get_for_session_empty_result
  C:\Python\Python313\Lib\unittest\mock.py:502: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000001EF18D695D0>
    _safe_super(NonCallableMock, self).__init__(
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_keystroke_manager.py::TestKeystrokeManagerGetKeystrokesForSession::test_get_keystrokes_with_uuid_session_id
  C:\Python\Python313\Lib\unittest\mock.py:2245: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000001EF18D698A0>
    def __init__(self, name, parent):
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_keystroke_manager.py::TestKeystrokeManagerGetKeystrokesForSession::test_get_keystrokes_with_uuid_session_id
  C:\Python\Python313\Lib\unittest\mock.py:2245: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000001EF18D69990>
    def __init__(self, name, parent):
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_keystroke_manager.py::TestKeystrokeManagerEdgeCases::test_memory_management_large_list
  C:\Python\Python313\Lib\uuid.py:174: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000001EF18EA8040>
    if [hex, bytes, bytes_le, fields, int].count(None) != 4:
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_ngram_orchestrator_process_end_of_session.py::test_process_end_of_session_summarization_failure
  D:\SeanDevLocal\AITypingTrainer\.venv\Lib\site-packages\pydantic\main.py:1204: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000001EF18EAB1F0>
    def __repr_args__(self) -> _repr.ReprArgs:
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_ngram_orchestrator_process_end_of_session.py::test_process_end_of_session_summarization_failure
  D:\SeanDevLocal\AITypingTrainer\.venv\Lib\site-packages\pydantic\main.py:1204: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000001EF18EAB100>
    def __repr_args__(self) -> _repr.ReprArgs:
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_ngram_orchestrator_process_end_of_session.py::test_process_end_of_session_summarization_failure
  D:\SeanDevLocal\AITypingTrainer\.venv\Lib\site-packages\pydantic\main.py:1204: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000001EF18D6B2E0>
    def __repr_args__(self) -> _repr.ReprArgs:
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_ngram_orchestrator_process_end_of_session.py::test_process_end_of_session_summarization_failure
  D:\SeanDevLocal\AITypingTrainer\.venv\Lib\site-packages\pydantic\main.py:1204: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000001EF18D6AB60>
    def __repr_args__(self) -> _repr.ReprArgs:
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_ngram_orchestrator_process_end_of_session.py::test_process_end_of_session_summarization_failure
  D:\SeanDevLocal\AITypingTrainer\.venv\Lib\site-packages\pydantic\main.py:1204: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000001EF18F1F880>
    def __repr_args__(self) -> _repr.ReprArgs:
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_ngram_orchestrator_process_end_of_session.py::test_process_end_of_session_summarization_failure
  D:\SeanDevLocal\AITypingTrainer\.venv\Lib\site-packages\pydantic\main.py:1204: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000001EF18F1EB60>
    def __repr_args__(self) -> _repr.ReprArgs:
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_ngram_orchestrator_process_end_of_session.py::test_process_end_of_session_summarization_failure
  D:\SeanDevLocal\AITypingTrainer\.venv\Lib\site-packages\pydantic\main.py:1204: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000001EF18F1CD60>
    def __repr_args__(self) -> _repr.ReprArgs:
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_session.py::test_to_dict_and_from_dict
  D:\SeanDevLocal\AITypingTrainer\models\session.py:108: PydanticDeprecatedSince20: The `dict` method is deprecated; use `model_dump` instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.11/migration/
    return self.dict()

tests/models/test_setting.py::TestSettingModel::test_setting_to_dict
  C:\Python\Python313\Lib\uuid.py:174: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000001EF18EAB3D0>
    if [hex, bytes, bytes_le, fields, int].count(None) != 4:
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_setting.py::TestSettingModel::test_setting_to_dict
  C:\Python\Python313\Lib\uuid.py:174: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000001EF18EABB50>
    if [hex, bytes, bytes_le, fields, int].count(None) != 4:
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_setting.py::TestSettingModel::test_setting_to_dict
  C:\Python\Python313\Lib\uuid.py:174: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000001EF18EABC40>
    if [hex, bytes, bytes_le, fields, int].count(None) != 4:
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_setting.py::TestSettingModel::test_setting_to_dict
  C:\Python\Python313\Lib\uuid.py:174: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000001EF18EABE20>
    if [hex, bytes, bytes_le, fields, int].count(None) != 4:
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_setting.py::TestSettingModel::test_setting_to_dict
  C:\Python\Python313\Lib\uuid.py:174: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000001EF18EABA60>
    if [hex, bytes, bytes_le, fields, int].count(None) != 4:
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_setting.py::TestSettingModel::test_setting_to_dict
  C:\Python\Python313\Lib\uuid.py:174: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000001EF18EAA5C0>
    if [hex, bytes, bytes_le, fields, int].count(None) != 4:
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_setting.py::TestSettingModel::test_setting_to_dict
  C:\Python\Python313\Lib\uuid.py:174: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000001EF18EAB5B0>
    if [hex, bytes, bytes_le, fields, int].count(None) != 4:
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_setting.py::TestSettingModel::test_setting_to_dict
  C:\Python\Python313\Lib\uuid.py:174: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000001EF123C27A0>
    if [hex, bytes, bytes_le, fields, int].count(None) != 4:
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_setting_manager.py::TestSettingManager::test_list_settings_populated
  D:\SeanDevLocal\AITypingTrainer\db\database_manager.py:374: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000001EF1997EA70>
    cursor.execute(query)
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_setting_manager.py::TestSettingManager::test_list_settings_populated
  D:\SeanDevLocal\AITypingTrainer\db\database_manager.py:374: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000001EF19968310>
    cursor.execute(query)
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_setting_manager.py::TestSettingManager::test_list_settings_populated
  D:\SeanDevLocal\AITypingTrainer\db\database_manager.py:374: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000001EF199684F0>
    cursor.execute(query)
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_setting_manager.py::TestSettingManager::test_list_settings_populated
  D:\SeanDevLocal\AITypingTrainer\db\database_manager.py:374: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000001EF199685E0>
    cursor.execute(query)
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_setting_manager.py::TestSettingManager::test_list_settings_populated
  D:\SeanDevLocal\AITypingTrainer\db\database_manager.py:374: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000001EF199686D0>
    cursor.execute(query)
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_setting_manager.py::TestSettingManager::test_list_settings_populated
  D:\SeanDevLocal\AITypingTrainer\db\database_manager.py:374: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000001EF199688B0>
    cursor.execute(query)
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_snippet.py::test_list_snippets_empty
  <frozen abc>:117: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000001EF1997DA80>
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_snippet.py::test_list_snippets_empty
  <frozen abc>:117: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000001EF1997D990>
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_snippet.py::test_list_snippets_empty
  <frozen abc>:117: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000001EF1997D030>
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_snippet.py::test_list_snippets_empty
  <frozen abc>:117: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000001EF1997C9A0>
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_snippet.py::test_list_snippets_empty
  <frozen abc>:117: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000001EF1997D120>
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_snippet.py::test_list_snippets_empty
  <frozen abc>:117: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000001EF1997CA90>
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_snippet.py::test_list_snippets_empty
  <frozen abc>:117: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000001EF1997C400>
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_snippet.py::test_list_snippets_empty
  <frozen abc>:117: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000001EF1997C130>
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_snippet.py::test_update_snippet_no_changes
  D:\SeanDevLocal\AITypingTrainer\.venv\Lib\site-packages\_pytest\reports.py:346: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000001EF199A9E40>
    keywords = {x: 1 for x in item.keywords}
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_snippet_manager.py::TestCreateSnippet::test_create_snippet_duplicate_name_in_category
  C:\Python\Python313\Lib\functools.py:53: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000001EF199AB4C0>
    value = getattr(wrapped, attr)
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_snippet_manager.py::TestCreateSnippet::test_create_snippet_duplicate_name_in_category
  C:\Python\Python313\Lib\functools.py:53: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000001EF199A8040>
    value = getattr(wrapped, attr)
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_user.py::TestUserModel::test_invalid_email_formats[username@example.com-]
  D:\SeanDevLocal\AITypingTrainer\.venv\Lib\site-packages\_pytest\raises.py:348: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000001EF1997FB50>
    if not isinstance(
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_user.py::TestUserModel::test_invalid_email_formats[username@example.com-]
  D:\SeanDevLocal\AITypingTrainer\.venv\Lib\site-packages\_pytest\raises.py:348: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000001EF1997D3F0>
    if not isinstance(
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_user.py::TestUserModel::test_invalid_email_formats[username@example.com-]
  D:\SeanDevLocal\AITypingTrainer\.venv\Lib\site-packages\_pytest\raises.py:348: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000001EF1997F970>
    if not isinstance(
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_user.py::TestUserModel::test_invalid_email_formats[username@example.com-]
  D:\SeanDevLocal\AITypingTrainer\.venv\Lib\site-packages\_pytest\raises.py:348: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000001EF1997FE20>
    if not isinstance(
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_user.py::TestUserModel::test_invalid_email_formats[username@example.com-]
  D:\SeanDevLocal\AITypingTrainer\.venv\Lib\site-packages\_pytest\raises.py:348: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000001EF1997D210>
    if not isinstance(
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_user.py::TestUserModel::test_invalid_email_formats[username@example.com-]
  D:\SeanDevLocal\AITypingTrainer\.venv\Lib\site-packages\_pytest\raises.py:348: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000001EF1997F880>
    if not isinstance(
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_user.py::TestUserModel::test_invalid_email_formats[username@example.com-]
  D:\SeanDevLocal\AITypingTrainer\.venv\Lib\site-packages\_pytest\raises.py:348: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000001EF1996BC40>
    if not isinstance(
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_user.py::TestUserModel::test_invalid_email_formats[username@example.com-]
  D:\SeanDevLocal\AITypingTrainer\.venv\Lib\site-packages\_pytest\raises.py:348: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000001EF1996A890>
    if not isinstance(
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_user.py::TestUserModel::test_invalid_email_formats[username@example.com-]
  D:\SeanDevLocal\AITypingTrainer\.venv\Lib\site-packages\_pytest\raises.py:348: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000001EF1996B2E0>
    if not isinstance(
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_user.py::TestUserModel::test_invalid_email_formats[username@example.com-]
  D:\SeanDevLocal\AITypingTrainer\.venv\Lib\site-packages\_pytest\raises.py:348: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000001EF1996BD30>
    if not isinstance(
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_user.py::TestUserModel::test_invalid_email_formats[username@example.com-]
  D:\SeanDevLocal\AITypingTrainer\.venv\Lib\site-packages\_pytest\raises.py:348: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000001EF1996B3D0>
    if not isinstance(
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_user.py::TestUserModel::test_invalid_email_formats[username@example.com-]
  D:\SeanDevLocal\AITypingTrainer\.venv\Lib\site-packages\_pytest\raises.py:348: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000001EF1996B1F0>
    if not isinstance(
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_user.py::TestUserModel::test_invalid_email_formats[username@example.com-]
  D:\SeanDevLocal\AITypingTrainer\.venv\Lib\site-packages\_pytest\raises.py:348: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000001EF1996AD40>
    if not isinstance(
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_user.py::TestUserModel::test_invalid_email_formats[username@example.com-]
  D:\SeanDevLocal\AITypingTrainer\.venv\Lib\site-packages\_pytest\raises.py:348: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000001EF1996A2F0>
    if not isinstance(
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_user.py::TestUserModel::test_invalid_email_formats[username@example.com-]
  D:\SeanDevLocal\AITypingTrainer\.venv\Lib\site-packages\_pytest\raises.py:348: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000001EF1996A980>
    if not isinstance(
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_user.py::TestUserModel::test_invalid_email_formats[username@example.com-]
  D:\SeanDevLocal\AITypingTrainer\.venv\Lib\site-packages\_pytest\raises.py:348: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000001EF1996BB50>
    if not isinstance(
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_user.py::TestUserModel::test_invalid_email_formats[username@example.com-]
  D:\SeanDevLocal\AITypingTrainer\.venv\Lib\site-packages\_pytest\raises.py:348: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000001EF1996BA60>
    if not isinstance(
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_user.py::TestUserModel::test_to_dict
  D:\SeanDevLocal\AITypingTrainer\models\user.py:202: PydanticDeprecatedSince20: The `dict` method is deprecated; use `model_dump` instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.11/migration/
    return self.dict()

tests/models/test_user_manager_fixes.py::TestUserManagerDatabaseAccessFixes::test_get_user_by_id_not_found
  C:\Python\Python313\Lib\re\_parser.py:239: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000001EF199698A0>
    def __next(self):
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_user_manager_fixes.py::TestUserManagerDatabaseAccessFixes::test_get_user_by_id_not_found
  C:\Python\Python313\Lib\re\_parser.py:239: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000001EF1996AA70>
    def __next(self):
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_user_manager_fixes.py::TestUserManagerDatabaseAccessFixes::test_get_user_by_id_not_found
  C:\Python\Python313\Lib\re\_parser.py:239: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000001EF1996A5C0>
    def __next(self):
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_user_manager_fixes.py::TestUserManagerDatabaseAccessFixes::test_get_user_by_id_not_found
  C:\Python\Python313\Lib\re\_parser.py:239: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000001EF19969B70>
    def __next(self):
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_user_manager_fixes.py::TestUserManagerDatabaseAccessFixes::test_get_user_by_id_not_found
  C:\Python\Python313\Lib\re\_parser.py:239: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000001EF199696C0>
    def __next(self):
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_user_manager_fixes.py::TestUserManagerDatabaseAccessFixes::test_get_user_by_id_not_found
  C:\Python\Python313\Lib\re\_parser.py:239: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000001EF19969120>
    def __next(self):
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_user_manager_fixes.py::TestUserManagerDatabaseAccessFixes::test_get_user_by_id_not_found
  C:\Python\Python313\Lib\re\_parser.py:239: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000001EF19968130>
    def __next(self):
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_user_manager_fixes.py::TestUserManagerDatabaseAccessFixes::test_get_user_by_id_not_found
  C:\Python\Python313\Lib\re\_parser.py:239: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000001EF19968400>
    def __next(self):
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_user_manager_fixes.py::TestUserManagerDatabaseAccessFixes::test_get_user_by_id_not_found
  C:\Python\Python313\Lib\re\_parser.py:239: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000001EF19969990>
    def __next(self):
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=============================== tests coverage ================================
_______________ coverage: platform win32, python 3.13.2-final-0 _______________

Name                                Stmts   Miss  Cover   Missing
-----------------------------------------------------------------
models\__init__.py                      1      0   100%
models\category.py                     45      1    98%   67
models\category_manager.py             70      8    89%   219-229
models\dynamic_content_manager.py     129      7    95%   84, 100, 123, 148, 172, 189, 242
models\dynamic_content_service.py     144    144     0%   7-308
models\keyboard.py                     66     16    76%   38, 40, 47, 49, 67, 70-71, 78, 81-82, 86, 90-94
models\keyboard_manager.py             57      7    88%   60-69, 89, 133, 144-146
models\keystroke.py                    89      5    94%   40, 72-73, 83-84
models\keystroke_manager.py            62      4    94%   65-66, 142-143
models\library.py                      72     72     0%   7-161
models\llm_ngram_service.py           146     86    41%   9-11, 43, 54-59, 100-101, 105-118, 122-140, 144-184, 188-219, 235-236
models\ngram.py                        83      0   100%
models\ngram_analytics_service.py     391    279    29%   69, 75, 216-292, 310-319, 335-394, 419-498, 502-529, 548-655, 686-753, 782-845, 860-1013, 1043-1247, 1283-1346, 1359-1376, 1385-1398
models\ngram_manager.py               126     41    67%   68, 76, 84, 96-97, 173, 193, 244-275, 286-304, 308, 337-344
models\session.py                      88      2    98%   74, 86
models\session_manager.py             110     44    60%   62-75, 108-121, 139-150, 220-231, 254-258, 263-282, 289-335
models\setting.py                      74      3    96%   87, 107, 119
models\setting_manager.py              68     10    85%   43-50, 179-182, 294
models\snippet.py                      87     20    77%   84-94, 129, 153, 157, 161-171
models\snippet_manager.py             179    117    35%   46, 48, 78-82, 90, 118, 135-138, 142-151, 168-198, 215-250, 267-303, 309-321, 342-380, 392
models\user.py                        101     11    89%   64, 70, 82, 87, 95, 101, 104, 124-125, 143, 156
models\user_manager.py                 68      0   100%
-----------------------------------------------------------------
TOTAL                                2256    877    61%
=========================== short test summary info ===========================
FAILED tests/models/test_dynamic_content_manager.py::TestNGramOnlyMode::test_generate_ngram_content
FAILED tests/models/test_dynamic_content_manager.py::TestNGramOnlyMode::test_ngram_content_filters_out_of_scope_chars
FAILED tests/models/test_dynamic_content_manager.py::TestMixedMode::test_mixed_content_has_variety
FAILED tests/models/test_keystroke_manager.py::TestKeystrokeManagerSaveKeystrokes::test_save_keystrokes_success
FAILED tests/models/test_keystroke_manager.py::TestKeystrokeManagerSaveKeystrokes::test_save_keystrokes_database_error
FAILED tests/models/test_keystroke_manager.py::TestKeystrokeManagerSaveKeystrokes::test_save_keystrokes_with_special_characters
FAILED tests/models/test_keystroke_manager.py::TestKeystrokeManagerSaveKeystrokes::test_save_keystrokes_boolean_conversion
FAILED tests/models/test_keystroke_manager.py::TestKeystrokeManagerIntegration::test_full_keystroke_workflow
FAILED tests/models/test_keystroke_manager.py::TestKeystrokeManagerEdgeCases::test_unicode_and_special_characters
FAILED tests/models/test_keystroke_manager.py::TestKeystrokeManagerErrorHandling::test_database_connection_failure
FAILED tests/models/test_keystroke_manager.py::TestKeystrokeManagerErrorHandling::test_partial_save_failure
FAILED tests/models/test_keystroke_manager.py::TestKeystrokeManagerErrorHandling::test_network_timeout_simulation
FAILED tests/models/test_llm_ngram_service.py::test_missing_api_key - Failed:...
FAILED tests/models/test_ngram.py::TestKeystroke::test_keystroke_nfc_single_char
FAILED tests/models/test_ngram_analytics_service.py::TestNGramAnalyticsService::test_dual_insert_creates_records_in_both_tables
FAILED tests/models/test_ngram_analytics_service.py::TestNGramAnalyticsService::test_history_table_accumulates_all_records
FAILED tests/models/test_ngram_analytics_service.py::TestNGramAnalyticsService::test_get_ngram_history_retrieval
FAILED tests/models/test_ngram_analytics_service.py::TestNGramAnalyticsService::test_history_table_schema_compatibility
FAILED tests/models/test_ngram_orchestrator_process_end_of_session.py::test_process_end_of_session_success_path
FAILED tests/models/test_ngram_orchestrator_process_end_of_session.py::test_process_end_of_session_session_save_failure
FAILED tests/models/test_ngram_orchestrator_process_end_of_session.py::test_process_end_of_session_keystrokes_save_failure
FAILED tests/models/test_ngram_orchestrator_process_end_of_session.py::test_process_end_of_session_summarization_failure
ERROR tests/models/test_ngram_analytics_service.py::TestNGramAnalyticsService::test_refresh_speed_summaries_basic
ERROR tests/models/test_ngram_analytics_service_session_methods.py::TestSummarizeSessionNgrams::test_summarize_with_ngram_speed_only[1-1]
ERROR tests/models/test_ngram_analytics_service_session_methods.py::TestSummarizeSessionNgrams::test_summarize_with_ngram_speed_only[3-3]
ERROR tests/models/test_ngram_analytics_service_session_methods.py::TestSummarizeSessionNgrams::test_summarize_with_ngram_errors_only[1-1]
ERROR tests/models/test_ngram_analytics_service_session_methods.py::TestSummarizeSessionNgrams::test_summarize_with_ngram_errors_only[2-2]
ERROR tests/models/test_ngram_analytics_service_session_methods.py::TestSummarizeSessionNgrams::test_summarize_with_speed_and_errors
ERROR tests/models/test_ngram_analytics_service_session_methods.py::TestSummarizeSessionNgrams::test_summarize_with_keystrokes[1-1]
ERROR tests/models/test_ngram_analytics_service_session_methods.py::TestSummarizeSessionNgrams::test_summarize_with_keystrokes[3-3]
ERROR tests/models/test_ngram_analytics_service_session_methods.py::TestSummarizeSessionNgrams::test_no_sessions_missing
ERROR tests/models/test_ngram_analytics_service_session_methods.py::TestSummarizeSessionNgrams::test_sessions_missing_no_data
ERROR tests/models/test_ngram_analytics_service_session_methods.py::TestAddSpeedSummaryForSession::test_single_session_processing
ERROR tests/models/test_ngram_analytics_service_session_methods.py::TestAddSpeedSummaryForSession::test_multiple_ngrams_processing
ERROR tests/models/test_ngram_analytics_service_session_methods.py::TestCatchupSpeedSummary::test_single_session_catchup
ERROR tests/models/test_ngram_analytics_service_session_methods.py::TestCatchupSpeedSummary::test_multiple_sessions_catchup
ERROR tests/models/test_ngram_analytics_service_session_methods.py::TestCatchupSpeedSummary::test_catchup_with_session_errors
ERROR tests/models/test_ngram_analytics_service_session_methods.py::TestIntegrationScenarios::test_full_workflow_integration
ERROR tests/models/test_snippet.py::test_snippet_ascii_name
ERROR tests/models/test_snippet.py::test_snippet_name_length
ERROR tests/models/test_snippet.py::test_snippet_creation_validation[Alpha-Some content-True]
ERROR tests/models/test_snippet.py::test_snippet_creation_validation[-Some content-False]
ERROR tests/models/test_snippet.py::test_snippet_creation_validation[AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA-Content-False]
ERROR tests/models/test_snippet.py::test_snippet_creation_validation[NonAscii\xe9-Content-False]
ERROR tests/models/test_snippet.py::test_snippet_creation_validation[Alpha--False]
ERROR tests/models/test_snippet.py::test_snippet_name_uniqueness[Unique1-Unique2-True]
ERROR tests/models/test_snippet.py::test_snippet_name_uniqueness[DupName-DupName-False]
ERROR tests/models/test_snippet.py::test_snippet_creation_valid
ERROR tests/models/test_snippet.py::test_get_nonexistent_snippet
ERROR tests/models/test_snippet.py::test_list_snippets_empty
ERROR tests/models/test_snippet.py::test_list_snippets_populated
ERROR tests/models/test_snippet.py::test_snippet_edit
ERROR tests/models/test_snippet.py::test_snippet_update
ERROR tests/models/test_snippet.py::test_snippet_update_name_only
ERROR tests/models/test_snippet.py::test_snippet_update_content_only
ERROR tests/models/test_snippet.py::test_snippet_delete
ERROR tests/models/test_snippet.py::test_delete_nonexistent_snippet
ERROR tests/models/test_snippet.py::test_edit_snippet_change_category
ERROR tests/models/test_snippet.py::test_edit_snippet_invalid_category
ERROR tests/models/test_snippet.py::test_snippet_sql_injection
ERROR tests/models/test_snippet.py::test_snippet_sql_injection_in_content
ERROR tests/models/test_snippet.py::test_snippet_long_content
ERROR tests/models/test_snippet.py::test_snippet_content_splitting_boundaries
ERROR tests/models/test_snippet.py::test_update_nonexistent_snippet
ERROR tests/models/test_snippet.py::test_snippet_part_number_sequence
ERROR tests/models/test_snippet.py::test_snippet_operation_handling
ERROR tests/models/test_snippet.py::test_delete_snippet
ERROR tests/models/test_snippet.py::test_create_snippet_with_nonexistent_category
ERROR tests/models/test_snippet.py::test_update_snippet_partial
ERROR tests/models/test_snippet.py::test_update_snippet_no_changes
ERROR tests/models/test_snippet.py::test_get_snippet_by_name
ERROR tests/models/test_snippet.py::test_get_snippet_by_name_nonexistent
ERROR tests/models/test_snippet.py::test_get_snippet_by_name_multiple_categories
ERROR tests/models/test_snippet.py::test_search_snippets
ERROR tests/models/test_snippet.py::test_search_snippets_no_results
ERROR tests/models/test_snippet.py::test_snippet_sql_injection_name_create
ERROR tests/models/test_snippet.py::test_snippet_sql_injection_content_create
ERROR tests/models/test_snippet.py::test_snippet_sql_injection_name_create_with_specific_error
ERROR tests/models/test_snippet.py::test_snippet_sql_injection_content_update
ERROR tests/models/test_snippet.py::test_snippet_sql_injection_name_update
ERROR tests/models/test_snippet.py::test_snippet_deletion_idempotency
ERROR tests/models/test_snippet.py::test_snippet_manager_handles_db_errors_gracefully_on_create
ERROR tests/models/test_snippet.py::test_snippet_manager_handles_db_errors_gracefully_on_get
ERROR tests/models/test_snippet.py::test_snippet_manager_handles_db_errors_gracefully_on_update
ERROR tests/models/test_snippet.py::test_snippet_manager_handles_db_errors_gracefully_on_delete
ERROR tests/models/test_snippet.py::test_snippet_manager_handles_db_errors_gracefully_on_list
ERROR tests/models/test_snippet.py::test_snippet_manager_handles_db_errors_gracefully_on_search
ERROR tests/models/test_snippet.py::test_create_snippet_pydantic_validation_errors
===== 22 failed, 417 passed, 4 skipped, 89 warnings, 66 errors in 36.83s ======
