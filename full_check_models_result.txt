helpers\debug_util.py:80: error: No overload variant of "print" matches argument types "str", "tuple[object, ...]", "dict[str, object]"  [call-overload]
helpers\debug_util.py:80: note: Possible overload variants:
helpers\debug_util.py:80: note:     def print(*values: object, sep: str | None = ..., end: str | None = ..., file: SupportsWrite[str] | None = ..., flush: Literal[False] = ...) -> None
helpers\debug_util.py:80: note:     def print(*values: object, sep: str | None = ..., end: str | None = ..., file: _SupportsWriteAndFlush[str] | None = ..., flush: bool) -> None
helpers\debug_util.py:79: error: Unused "type: ignore" comment  [unused-ignore]
db\database_manager.py:56: error: Expression has type "Any"  [misc]
db\database_manager.py:64: error: Expression has type "Any"  [misc]
db\database_manager.py:95: error: No overload variant of "print" matches argument types "tuple[object, ...]", "dict[str, object]"  [call-overload]
db\database_manager.py:95: note: Possible overload variants:
db\database_manager.py:95: note:     def print(*values: object, sep: str | None = ..., end: str | None = ..., file: SupportsWrite[str] | None = ..., flush: Literal[False] = ...) -> None
db\database_manager.py:95: note:     def print(*values: object, sep: str | None = ..., end: str | None = ..., file: _SupportsWriteAndFlush[str] | None = ..., flush: bool) -> None
db\database_manager.py:170: error: Expression type contains "Any" (has type "dict[str, Any] | None")  [misc]
db\database_manager.py:171: error: Expression type contains "Any" (has type "dict[str, Any] | None")  [misc]
db\database_manager.py:175: error: Expression type contains "Any" (has type "dict[str, Any] | None")  [misc]
db\database_manager.py:191: error: Expression type contains "Any" (has type "list[dict[str, Any]]")  [misc]
db\database_manager.py:192: error: Expression type contains "Any" (has type "dict[str, Any]")  [misc]
db\database_manager.py:192: error: Expression has type "Any"  [misc]
db\database_manager.py:192: error: Expression type contains "Any" (has type "list[dict[str, Any]]")  [misc]
db\database_manager.py:201: error: Expression type contains "Any" (has type "dict[str, Any]")  [misc]
db\database_manager.py:201: error: Expression has type "Any"  [misc]
db\database_manager.py:201: error: Expression type contains "Any" (has type "list[dict[str, Any]]")  [misc]
db\database_manager.py:262: error: Expression type contains "Any" (has type "type[Row]")  [misc]
db\database_manager.py:280: error: Expression has type "Any"  [misc]
db\database_manager.py:281: error: Expression has type "Any"  [misc]
db\database_manager.py:282: error: Expression has type "Any"  [misc]
db\database_manager.py:285: error: Expression has type "Any"  [misc]
db\database_manager.py:286: error: Expression has type "Any"  [misc]
db\database_manager.py:287: error: Expression has type "Any"  [misc]
db\database_manager.py:288: error: Expression has type "Any"  [misc]
db\database_manager.py:289: error: Expression has type "Any"  [misc]
db\database_manager.py:295: error: Expression has type "Any"  [misc]
db\database_manager.py:296: error: Expression has type "Any"  [misc]
db\database_manager.py:297: error: Expression has type "Any"  [misc]
db\database_manager.py:298: error: Expression has type "Any"  [misc]
db\database_manager.py:299: error: Expression has type "Any"  [misc]
db\database_manager.py:320: error: Expression type contains "Any" (has type "tuple[Any, ...] | None")  [misc]
db\database_manager.py:321: error: Expression type contains "Any" (has type "tuple[Any, ...] | None")  [misc]
db\database_manager.py:323: error: Expression has type "Any"  [misc]
db\database_manager.py:323: error: Expression type contains "Any" (has type "tuple[Any, ...]")  [misc]
db\database_manager.py:342: error: Expression type contains "Any" (has type "Connection | Any")  [misc]
db\database_manager.py:354: error: Expression type contains "Any" (has type "Connection | Any")  [misc]
db\database_manager.py:373: error: Expression type contains "Any" (has type "Connection | Any")  [misc]
db\database_manager.py:375: error: Expression type contains "Any" (has type "Connection | Any")  [misc]
db\database_manager.py:388: error: Expression type contains "Any" (has type "Connection | Any")  [misc]
db\database_manager.py:388: error: Expression type contains "Any" (has type "Cursor | Any")  [misc]
db\database_manager.py:389: error: Expression type contains "Any" (has type "Cursor | Any")  [misc]
db\database_manager.py:390: error: Expression type contains "Any" (has type "Connection | Any")  [misc]
db\database_manager.py:391: error: Expression type contains "Any" (has type "Cursor | Any")  [misc]
db\database_manager.py:465: error: Expression type contains "Any" (has type "Any | None")  [misc]
db\database_manager.py:466: error: Expression type contains "Any" (has type "tuple[Any, Any]")  [misc]
db\database_manager.py:466: error: Expression has type "Any"  [misc]
db\database_manager.py:467: error: Expression has type "Any"  [misc]
db\database_manager.py:469: error: Expression has type "Any"  [misc]
db\database_manager.py:471: error: Expression has type "Any"  [misc]
db\database_manager.py:473: error: Expression has type "Any"  [misc]
db\database_manager.py:474: error: Expression has type "Any"  [misc]
db\database_manager.py:475: error: Expression has type "Any"  [misc]
db\database_manager.py:476: error: Expression has type "Any"  [misc]
db\database_manager.py:478: error: Expression has type "Any"  [misc]
db\database_manager.py:486: error: Expression has type "Any"  [misc]
db\database_manager.py:487: error: Expression has type "Any"  [misc]
db\database_manager.py:488: error: Expression has type "Any"  [misc]
db\database_manager.py:489: error: Expression has type "Any"  [misc]
db\database_manager.py:490: error: Expression has type "Any"  [misc]
db\database_manager.py:491: error: Expression has type "Any"  [misc]
db\database_manager.py:528: error: Expression type contains "Any" (has type "Connection | Any")  [misc]
db\database_manager.py:535: error: Expression type contains "Any" (has type "Connection | Any")  [misc]
db\database_manager.py:625: error: Expression type contains "Any" (has type "Connection | Any")  [misc]
db\database_manager.py:650: error: Expression type contains "Any" (has type "Connection | Any")  [misc]
db\database_manager.py:672: error: Expression type contains "Any" (has type "Any | None")  [misc]
db\database_manager.py:686: error: Expression has type "Any"  [misc]
db\database_manager.py:688: error: Expression type contains "Any" (has type "Connection | Any")  [misc]
db\database_manager.py:718: error: Expression type contains "Any" (has type "str | Any")  [misc]
db\database_manager.py:718: error: Expression type contains "Any" (has type "list[str | Any]")  [misc]
db\database_manager.py:718: error: Expression type contains "Any" (has type "list[str] | Any")  [misc]
db\database_manager.py:723: error: Expression type contains "Any" (has type "list[str] | Any")  [misc]
db\database_manager.py:732: error: Expression type contains "Any" (has type "list[str | Any]")  [misc]
db\database_manager.py:739: error: Expression type contains "Any" (has type "dict[str, Any] | tuple[Any, ...] | None")  [misc]
db\database_manager.py:740: error: Expression type contains "Any" (has type "dict[str, Any] | tuple[Any, ...] | None")  [misc]
db\database_manager.py:747: error: Expression type contains "Any" (has type "list[str | Any]")  [misc]
db\database_manager.py:764: error: Expression type contains "Any" (has type "Connection | Any")  [misc]
db\database_manager.py:783: error: Expression type contains "Any" (has type "tuple[Any, ...]")  [misc]
db\database_manager.py:784: error: Expression type contains "Any" (has type "dict[str, Any] | tuple[Any, ...] | None")  [misc]
db\database_manager.py:787: error: Expression type contains "Any" (has type "dict[str, Any] | tuple[Any, ...] | None")  [misc]
db\database_manager.py:792: error: Expression type contains "Any" (has type "Sequence[Sequence[Any]] | None")  [misc]
db\database_manager.py:793: error: Expression type contains "Any" (has type "tuple[Any, ...]")  [misc]
db\database_manager.py:794: error: Expression type contains "Any" (has type "Sequence[Any]")  [misc]
db\database_manager.py:794: error: Expression type contains "Any" (has type "list[Any]")  [misc]
db\database_manager.py:794: error: Expression has type "Any"  [misc]
db\database_manager.py:794: error: Expression type contains "Any" (has type "Sequence[Sequence[Any]]")  [misc]
db\database_manager.py:795: error: Expression type contains "Any" (has type "dict[str, Any]")  [misc]
db\database_manager.py:795: error: Expression type contains "Any" (has type "list[Any]")  [misc]
db\database_manager.py:795: error: Expression has type "Any"  [misc]
db\database_manager.py:795: error: Expression type contains "Any" (has type "tuple[Any, ...]")  [misc]
db\database_manager.py:798: error: Expression type contains "Any" (has type "dict[str, Any] | dict[Any, Any]")  [misc]
db\database_manager.py:798: error: Expression type contains "Any" (has type "dict[str, Any] | tuple[Any, ...]")  [misc]
db\database_manager.py:819: error: Expression type contains "Any" (has type "tuple[Any, ...]")  [misc]
db\database_manager.py:820: error: Expression type contains "Any" (has type "list[dict[str, Any] | tuple[Any, ...]]")  [misc]
db\database_manager.py:823: error: Expression type contains "Any" (has type "Literal[False] | list[dict[str, Any] | tuple[Any, ...]]")  [misc]
db\database_manager.py:823: error: Expression type contains "Any" (has type "list[dict[str, Any] | tuple[Any, ...]]")  [misc]
db\database_manager.py:824: error: Expression type contains "Any" (has type "Sequence[Sequence[Any]] | None")  [misc]
db\database_manager.py:825: error: Expression type contains "Any" (has type "list[tuple[Any, ...]]")  [misc]
db\database_manager.py:826: error: Expression type contains "Any" (has type "Sequence[Any]")  [misc]
db\database_manager.py:826: error: Expression type contains "Any" (has type "list[Any]")  [misc]
db\database_manager.py:826: error: Expression has type "Any"  [misc]
db\database_manager.py:826: error: Expression type contains "Any" (has type "Sequence[Sequence[Any]]")  [misc]
db\database_manager.py:827: error: Expression type contains "Any" (has type "tuple[Any, ...]")  [misc]
db\database_manager.py:827: error: Expression type contains "Any" (has type "list[dict[str, Any]]")  [misc]
db\database_manager.py:827: error: Expression type contains "Any" (has type "dict[str, Any]")  [misc]
db\database_manager.py:827: error: Expression type contains "Any" (has type "list[Any]")  [misc]
db\database_manager.py:827: error: Expression has type "Any"  [misc]
db\database_manager.py:827: error: Expression type contains "Any" (has type "list[tuple[Any, ...]]")  [misc]
db\database_manager.py:830: error: Expression type contains "Any" (has type "dict[str, Any] | tuple[Any, ...]")  [misc]
db\database_manager.py:830: error: Expression type contains "Any" (has type "list[dict[str, Any]]")  [misc]
db\database_manager.py:830: error: Expression type contains "Any" (has type "dict[str, Any] | dict[Any, Any]")  [misc]
db\database_manager.py:830: error: Expression type contains "Any" (has type "list[dict[str, Any] | tuple[Any, ...]]")  [misc]
db\database_manager.py:848: error: Expression type contains "Any" (has type "tuple[Any, ...]")  [misc]
db\database_manager.py:849: error: Expression type contains "Any" (has type "list[dict[str, Any] | tuple[Any, ...]]")  [misc]
db\database_manager.py:852: error: Expression type contains "Any" (has type "Literal[False] | list[dict[str, Any] | tuple[Any, ...]]")  [misc]
db\database_manager.py:852: error: Expression type contains "Any" (has type "list[dict[str, Any] | tuple[Any, ...]]")  [misc]
db\database_manager.py:853: error: Expression type contains "Any" (has type "Sequence[Sequence[Any]] | None")  [misc]
db\database_manager.py:854: error: Expression type contains "Any" (has type "list[tuple[Any, ...]]")  [misc]
db\database_manager.py:855: error: Expression type contains "Any" (has type "Sequence[Any]")  [misc]
db\database_manager.py:855: error: Expression type contains "Any" (has type "list[Any]")  [misc]
db\database_manager.py:855: error: Expression has type "Any"  [misc]
db\database_manager.py:855: error: Expression type contains "Any" (has type "Sequence[Sequence[Any]]")  [misc]
db\database_manager.py:856: error: Expression type contains "Any" (has type "tuple[Any, ...]")  [misc]
db\database_manager.py:856: error: Expression type contains "Any" (has type "list[dict[str, Any]]")  [misc]
db\database_manager.py:856: error: Expression type contains "Any" (has type "dict[str, Any]")  [misc]
db\database_manager.py:856: error: Expression type contains "Any" (has type "list[Any]")  [misc]
db\database_manager.py:856: error: Expression has type "Any"  [misc]
db\database_manager.py:856: error: Expression type contains "Any" (has type "list[tuple[Any, ...]]")  [misc]
db\database_manager.py:859: error: Expression type contains "Any" (has type "dict[str, Any] | tuple[Any, ...]")  [misc]
db\database_manager.py:859: error: Expression type contains "Any" (has type "list[dict[str, Any]]")  [misc]
db\database_manager.py:859: error: Expression type contains "Any" (has type "dict[str, Any] | dict[Any, Any]")  [misc]
db\database_manager.py:859: error: Expression type contains "Any" (has type "list[dict[str, Any] | tuple[Any, ...]]")  [misc]
db\database_manager.py:55: error: Unused "type: ignore" comment  [unused-ignore]
db\database_manager.py:63: error: Unused "type: ignore" comment  [unused-ignore]
models\user.py:179: error: Expression type contains "Any" (has type "Callable[[type[User], dict[Any, Any]], dict[Any, Any]]")  [misc]
models\user.py:181: error: Missing type parameters for generic type "dict"  [type-arg]
models\user.py:185: error: Expression type contains "Any" (has type "dict[Any, Any]")  [misc]
models\user.py:185: error: Expression has type "Any"  [misc]
models\user.py:186: error: Expression type contains "Any" (has type "dict[Any, Any]")  [misc]
models\user.py:187: error: Expression type contains "Any" (has type "dict[Any, Any]")  [misc]
models\user.py:203: error: Expression type contains "Any" (has type "dict[str, Any]")  [misc]
models\user.py:209: error: Expression type contains "Any" (has type "dict[str, Any]")  [misc]
models\user.py:209: error: Expression type contains "Any" (has type "dict_keys[str, Any]")  [misc]
models\user.py:212: error: Expression type contains "Any" (has type "dict[str, Any]")  [misc]
models\snippet.py:164: error: Expression type contains "Any" (has type "dict[str, Any]")  [misc]
models\snippet.py:169: error: Argument 1 to "Snippet" has incompatible type "**dict[str, object]"; expected "str | None"  [arg-type]
models\snippet.py:169: error: Argument 1 to "Snippet" has incompatible type "**dict[str, object]"; expected "str"  [arg-type]
models\setting.py:96: error: Expression type contains "Any" (has type "Callable[[type[Setting], dict[Any, Any]], dict[Any, Any]]")  [misc]
models\setting.py:98: error: Missing type parameters for generic type "dict"  [type-arg]
models\setting.py:100: error: Expression type contains "Any" (has type "dict[Any, Any]")  [misc]
models\setting.py:100: error: Expression type contains "Any" (has type "Any | None")  [misc]
models\setting.py:101: error: Expression type contains "Any" (has type "dict[Any, Any]")  [misc]
models\setting.py:102: error: Expression type contains "Any" (has type "dict[Any, Any]")  [misc]
models\setting.py:134: error: Expression type contains "Any" (has type "dict[str, Any]")  [misc]
models\setting.py:150: error: Expression type contains "Any" (has type "dict[str, Any]")  [misc]
models\setting.py:150: error: Expression type contains "Any" (has type "dict_keys[str, Any]")  [misc]
models\setting.py:153: error: Expression type contains "Any" (has type "dict[str, Any]")  [misc]
models\session.py:119: error: Expression type contains "Any" (has type "dict[str, Any]")  [misc]
models\session.py:125: error: Expression type contains "Any" (has type "dict[str, Any]")  [misc]
models\session.py:135: error: Expression type contains "Any" (has type "dict[str, Any]")  [misc]
models\session.py:139: error: Expression type contains "Any" (has type "dict[str, Any]")  [misc]
models\keystroke.py:43: error: Expression type contains "Any" (has type "dict[str, Any]")  [misc]
models\keystroke.py:43: error: Expression type contains "Any" (has type "Any | None")  [misc]
models\keystroke.py:44: error: Expression type contains "Any" (has type "Any | None")  [misc]
models\keystroke.py:51: error: Expression type contains "Any" (has type "datetime | Any | None")  [misc]
models\keystroke.py:55: error: Expression type contains "Any" (has type "dict[str, Any]")  [misc]
models\keystroke.py:55: error: Expression type contains "Any" (has type "Any | None")  [misc]
models\keystroke.py:56: error: Expression type contains "Any" (has type "Any | None")  [misc]
models\keystroke.py:58: error: Expression type contains "Any" (has type "Any | None")  [misc]
models\keystroke.py:60: error: Expression type contains "Any" (has type "bool | Any | None")  [misc]
models\keystroke.py:61: error: Expression type contains "Any" (has type "Any | None")  [misc]
models\keystroke.py:64: error: Expression type contains "Any" (has type "dict[str, Any]")  [misc]
models\keystroke.py:64: error: Expression type contains "Any" (has type "Any | None")  [misc]
models\keystroke.py:65: error: Expression type contains "Any" (has type "Any | None")  [misc]
models\keystroke.py:65: error: Expression has type "Any"  [misc]
models\keystroke.py:67: error: Expression has type "Any"  [misc]
models\keystroke.py:73: error: Expression type contains "Any" (has type "dict[str, Any]")  [misc]
models\keystroke.py:73: error: Expression type contains "Any" (has type "Any | None")  [misc]
models\keystroke.py:74: error: Expression type contains "Any" (has type "Any | None")  [misc]
models\keystroke.py:76: error: Expression has type "Any"  [misc]
models\keystroke.py:78: error: Expression has type "Any"  [misc]
models\keystroke.py:83: error: Expression type contains "Any" (has type "dict[str, Any]")  [misc]
models\keystroke.py:83: error: Expression has type "Any"  [misc]
models\keystroke.py:84: error: Expression has type "Any"  [misc]
models\keystroke.py:89: error: Expression has type "Any"  [misc]
models\keystroke.py:100: error: Expression type contains "Any" (has type "dict[str, Any]")  [misc]
models\keystroke.py:100: error: Expression has type "Any"  [misc]
models\keystroke.py:101: error: Expression type contains "Any" (has type "dict[str, Any]")  [misc]
models\keystroke.py:101: error: Expression has type "Any"  [misc]
models\keystroke.py:103: error: Expression type contains "Any" (has type "dict[str, Any]")  [misc]
models\keystroke.py:103: error: Expression type contains "Any" (has type "Any | None")  [misc]
models\keystroke.py:109: error: Expression type contains "Any" (has type "dict[str, Any]")  [misc]
models\keystroke.py:138: error: Expression type contains "Any" (has type "dict[str, Any] | None")  [misc]
models\keystroke.py:139: error: Expression type contains "Any" (has type "dict[str, Any]")  [misc]
models\keystroke.py:139: error: Expression has type "Any"  [misc]
models\keystroke.py:139: error: Expression type contains "Any" (has type "Any | int")  [misc]
models\keystroke.py:139: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\keystroke.py:139: error: Expression type contains "Any" (has type "dict[str, Any] | None")  [misc]
models\keystroke.py:158: error: Expression type contains "Any" (has type "list[dict[str, Any]]")  [misc]
models\keystroke.py:159: error: Expression type contains "Any" (has type "dict[str, Any]")  [misc]
models\keystroke.py:159: error: Expression type contains "Any" (has type "list[dict[str, Any]]")  [misc]
models\keystroke.py:176: error: Expression type contains "Any" (has type "list[dict[str, Any]]")  [misc]
models\keystroke.py:177: error: Expression type contains "Any" (has type "dict[str, Any]")  [misc]
models\keystroke.py:177: error: Expression type contains "Any" (has type "list[dict[str, Any]]")  [misc]
models\keyboard.py:65: error: Expression type contains "Any" (has type "Callable[[type[Keyboard], dict[Any, Any]], dict[Any, Any]]")  [misc]
models\keyboard.py:67: error: Missing type parameters for generic type "dict"  [type-arg]
models\keyboard.py:69: error: Expression type contains "Any" (has type "dict[Any, Any]")  [misc]
models\keyboard.py:69: error: Expression type contains "Any" (has type "Any | None")  [misc]
models\keyboard.py:70: error: Expression type contains "Any" (has type "dict[Any, Any]")  [misc]
models\keyboard.py:71: error: Expression type contains "Any" (has type "dict[Any, Any]")  [misc]
models\keyboard.py:99: error: Expression type contains "Any" (has type "dict[str, Any]")  [misc]
models\keyboard.py:115: error: Expression type contains "Any" (has type "dict[str, Any]")  [misc]
models\keyboard.py:115: error: Expression type contains "Any" (has type "dict_keys[str, Any]")  [misc]
models\keyboard.py:118: error: Expression type contains "Any" (has type "dict[str, Any]")  [misc]
models\category.py:55: error: Expression type contains "Any" (has type "Callable[[type[Category], dict[Any, Any]], dict[Any, Any]]")  [misc]
models\category.py:57: error: Missing type parameters for generic type "dict"  [type-arg]
models\category.py:59: error: Expression type contains "Any" (has type "dict[Any, Any]")  [misc]
models\category.py:59: error: Expression type contains "Any" (has type "Any | None")  [misc]
models\category.py:60: error: Expression type contains "Any" (has type "dict[Any, Any]")  [misc]
models\category.py:61: error: Expression type contains "Any" (has type "dict[Any, Any]")  [misc]
models\category.py:82: error: Expression type contains "Any" (has type "dict[str, Any]")  [misc]
models\category.py:98: error: Expression type contains "Any" (has type "dict[str, Any]")  [misc]
models\category.py:98: error: Expression type contains "Any" (has type "dict_keys[str, Any]")  [misc]
models\category.py:101: error: Expression type contains "Any" (has type "dict[str, Any]")  [misc]
models\user_manager.py:50: error: Expression type contains "Any" (has type "dict[str, Any] | None")  [misc]
models\user_manager.py:50: error: Expression type contains "Any" (has type "tuple[Any, ...]")  [misc]
models\user_manager.py:55: error: Expression type contains "Any" (has type "dict[str, Any] | None")  [misc]
models\user_manager.py:59: error: Expression type contains "Any" (has type "dict[str, Any] | None")  [misc]
models\user_manager.py:62: error: Expression type contains "Any" (has type "dict[str, Any]")  [misc]
models\user_manager.py:62: error: Expression has type "Any"  [misc]
models\user_manager.py:63: error: Expression type contains "Any" (has type "dict[str, Any]")  [misc]
models\user_manager.py:63: error: Expression has type "Any"  [misc]
models\user_manager.py:64: error: Expression type contains "Any" (has type "dict[str, Any]")  [misc]
models\user_manager.py:64: error: Expression has type "Any"  [misc]
models\user_manager.py:65: error: Expression type contains "Any" (has type "dict[str, Any]")  [misc]
models\user_manager.py:65: error: Expression has type "Any"  [misc]
models\user_manager.py:75: error: Expression type contains "Any" (has type "dict[str, Any] | None")  [misc]
models\user_manager.py:76: error: Expression type contains "Any" (has type "dict[str, Any] | None")  [misc]
models\user_manager.py:79: error: Expression type contains "Any" (has type "dict[str, Any]")  [misc]
models\user_manager.py:79: error: Expression has type "Any"  [misc]
models\user_manager.py:80: error: Expression type contains "Any" (has type "dict[str, Any]")  [misc]
models\user_manager.py:80: error: Expression has type "Any"  [misc]
models\user_manager.py:81: error: Expression type contains "Any" (has type "dict[str, Any]")  [misc]
models\user_manager.py:81: error: Expression has type "Any"  [misc]
models\user_manager.py:82: error: Expression type contains "Any" (has type "dict[str, Any]")  [misc]
models\user_manager.py:82: error: Expression has type "Any"  [misc]
models\user_manager.py:91: error: Expression type contains "Any" (has type "list[dict[str, Any]]")  [misc]
models\user_manager.py:92: error: Expression type contains "Any" (has type "dict[str, Any]")  [misc]
models\user_manager.py:94: error: Expression type contains "Any" (has type "dict[str, Any]")  [misc]
models\user_manager.py:94: error: Expression has type "Any"  [misc]
models\user_manager.py:95: error: Expression type contains "Any" (has type "dict[str, Any]")  [misc]
models\user_manager.py:95: error: Expression has type "Any"  [misc]
models\user_manager.py:96: error: Expression type contains "Any" (has type "dict[str, Any]")  [misc]
models\user_manager.py:96: error: Expression has type "Any"  [misc]
models\user_manager.py:97: error: Expression type contains "Any" (has type "dict[str, Any]")  [misc]
models\user_manager.py:97: error: Expression has type "Any"  [misc]
models\user_manager.py:99: error: Expression type contains "Any" (has type "list[dict[str, Any]]")  [misc]
models\user_manager.py:105: error: Argument 1 to "__user_exists" of "UserManager" has incompatible type "str | None"; expected "str"  [arg-type]
models\user_manager.py:112: error: Expression type contains "Any" (has type "dict[str, Any] | None")  [misc]
models\user_manager.py:115: error: Expression type contains "Any" (has type "dict[str, Any] | None")  [misc]
models\user_manager.py:135: error: Expression type contains "Any" (has type "dict[str, Any] | None")  [misc]
models\user_manager.py:152: error: Expression type contains "Any" (has type "dict[str, Any] | None")  [misc]
models\user_manager.py:154: error: Expression type contains "Any" (has type "dict[str, Any] | None")  [misc]
models\user_manager.py:156: error: Expression type contains "Any" (has type "dict[str, Any]")  [misc]
models\user_manager.py:158: error: Expression type contains "Any" (has type "Any | int")  [misc]
models\user_manager.py:158: error: Expression type contains "Any" (has type "SupportsNext[Any]")  [misc]
models\user_manager.py:165: error: Expression type contains "Any" (has type "Any | int")  [misc]
models\user_manager.py:165: error: Expression type contains "Any" (has type "Any | bool")  [misc]
models\snippet_manager.py:70: error: Expression type contains "Any" (has type "dict[str, Any] | tuple[Any, ...] | None")  [misc]
models\snippet_manager.py:73: error: Expression type contains "Any" (has type "dict[str, Any] | tuple[Any, ...] | None")  [misc]
models\snippet_manager.py:115: error: Expression type contains "Any" (has type "dict[str, Any] | tuple[Any, ...] | None")  [misc]
models\snippet_manager.py:116: error: Expression type contains "Any" (has type "dict[str, Any] | tuple[Any, ...] | None")  [misc]
models\snippet_manager.py:120: error: Expression type contains "Any" (has type "dict[str, Any]")  [misc]
models\snippet_manager.py:120: error: Expression type contains "Any" (has type "zip[tuple[str, Any]]")  [misc]
models\snippet_manager.py:120: error: Expression type contains "Any" (has type "dict[str, Any] | tuple[Any, ...]")  [misc]
models\snippet_manager.py:121: error: Expression type contains "Any" (has type "dict[str, Any] | tuple[Any, ...]")  [misc]
models\snippet_manager.py:122: error: Expression type contains "Any" (has type "str | Any")  [misc]
models\snippet_manager.py:122: error: Expression type contains "Any" (has type "dict[str, Any] | tuple[Any, ...]")  [misc]
models\snippet_manager.py:122: error: Expression has type "Any"  [misc]
models\snippet_manager.py:122: error: Invalid index type "str | Any" for "tuple[Any, ...]"; expected type "SupportsIndex"  [index]
models\snippet_manager.py:122: error: Expression type contains "Any" (has type "dict_keys[str, Any] | Any")  [misc]
models\snippet_manager.py:128: error: Expression type contains "Any" (has type "list[dict[str, Any] | tuple[Any, ...]]")  [misc]
models\snippet_manager.py:130: error: Expression type contains "Any" (has type "dict[str, Any] | tuple[Any, ...]")  [misc]
models\snippet_manager.py:130: error: Expression has type "Any"  [misc]
models\snippet_manager.py:130: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\snippet_manager.py:130: error: Expression type contains "Any" (has type "list[dict[str, Any] | tuple[Any, ...]]")  [misc]
models\snippet_manager.py:139: error: Expression type contains "Any" (has type "dict[str, Any]")  [misc]
models\snippet_manager.py:140: error: Expression type contains "Any" (has type "dict[str, Any]")  [misc]
models\snippet_manager.py:172: error: Expression type contains "Any" (has type "dict[str, Any] | tuple[Any, ...] | None")  [misc]
models\snippet_manager.py:173: error: Expression type contains "Any" (has type "dict[str, Any] | tuple[Any, ...] | None")  [misc]
models\snippet_manager.py:176: error: Expression type contains "Any" (has type "tuple[Any, ...]")  [misc]
models\snippet_manager.py:176: error: Expression has type "Any"  [misc]
models\snippet_manager.py:176: error: Expression type contains "Any" (has type "dict[str, Any] | tuple[Any, ...]")  [misc]
models\snippet_manager.py:176: error: Expression type contains "Any" (has type "dict[str, Any]")  [misc]
models\snippet_manager.py:177: error: Expression has type "Any"  [misc]
models\snippet_manager.py:216: error: Expression type contains "Any" (has type "list[dict[str, Any] | tuple[Any, ...]]")  [misc]
models\snippet_manager.py:220: error: Expression type contains "Any" (has type "dict[str, Any] | tuple[Any, ...]")  [misc]
models\snippet_manager.py:220: error: Expression type contains "Any" (has type "list[dict[str, Any] | tuple[Any, ...]]")  [misc]
models\snippet_manager.py:221: error: Expression type contains "Any" (has type "dict[str, Any]")  [misc]
models\snippet_manager.py:221: error: Expression type contains "Any" (has type "zip[tuple[str, Any]]")  [misc]
models\snippet_manager.py:221: error: Expression type contains "Any" (has type "dict[str, Any] | tuple[Any, ...]")  [misc]
models\snippet_manager.py:222: error: Expression type contains "Any" (has type "dict[str, Any] | tuple[Any, ...]")  [misc]
models\snippet_manager.py:223: error: Expression type contains "Any" (has type "str | Any")  [misc]
models\snippet_manager.py:223: error: Expression type contains "Any" (has type "dict[str, Any] | tuple[Any, ...]")  [misc]
models\snippet_manager.py:223: error: Expression has type "Any"  [misc]
models\snippet_manager.py:223: error: Invalid index type "str | Any" for "tuple[Any, ...]"; expected type "SupportsIndex"  [index]
models\snippet_manager.py:223: error: Expression type contains "Any" (has type "dict_keys[str, Any] | Any")  [misc]
models\snippet_manager.py:224: error: Expression type contains "Any" (has type "dict[str, Any]")  [misc]
models\snippet_manager.py:224: error: Expression has type "Any"  [misc]
models\snippet_manager.py:228: error: Expression type contains "Any" (has type "tuple[Any]")  [misc]
models\snippet_manager.py:228: error: Expression has type "Any"  [misc]
models\snippet_manager.py:230: error: Expression type contains "Any" (has type "list[dict[str, Any] | tuple[Any, ...]]")  [misc]
models\snippet_manager.py:231: error: Expression type contains "Any" (has type "dict[str, Any] | tuple[Any, ...]")  [misc]
models\snippet_manager.py:231: error: Expression has type "Any"  [misc]
models\snippet_manager.py:231: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\snippet_manager.py:231: error: Expression type contains "Any" (has type "list[dict[str, Any] | tuple[Any, ...]]")  [misc]
models\snippet_manager.py:233: error: Expression type contains "Any" (has type "dict[str, Any]")  [misc]
models\snippet_manager.py:234: error: Expression type contains "Any" (has type "dict[str, Any]")  [misc]
models\snippet_manager.py:276: error: Expression type contains "Any" (has type "list[Any]")  [misc]
models\snippet_manager.py:280: error: Expression type contains "Any" (has type "list[Any]")  [misc]
models\snippet_manager.py:281: error: Expression type contains "Any" (has type "list[dict[str, Any] | tuple[Any, ...]]")  [misc]
models\snippet_manager.py:283: error: Expression type contains "Any" (has type "dict[str, Any] | tuple[Any, ...]")  [misc]
models\snippet_manager.py:283: error: Expression type contains "Any" (has type "list[Any]")  [misc]
models\snippet_manager.py:283: error: Expression type contains "Any" (has type "tuple[Any, ...]")  [misc]
models\snippet_manager.py:283: error: Expression has type "Any"  [misc]
models\snippet_manager.py:283: error: Expression type contains "Any" (has type "dict[str, Any]")  [misc]
models\snippet_manager.py:283: error: Expression type contains "Any" (has type "list[dict[str, Any] | tuple[Any, ...]]")  [misc]
models\snippet_manager.py:286: error: Expression has type "Any"  [misc]
models\snippet_manager.py:286: error: Expression type contains "Any" (has type "list[Any]")  [misc]
models\snippet_manager.py:287: error: Expression has type "Any"  [misc]
models\snippet_manager.py:347: error: Expression type contains "Any" (has type "dict[str, Any] | tuple[Any, ...] | None")  [misc]
models\snippet_manager.py:349: error: Expression type contains "Any" (has type "dict[str, Any] | tuple[Any, ...] | None")  [misc]
models\snippet_manager.py:352: error: Expression type contains "Any" (has type "dict[str, Any]")  [misc]
models\snippet_manager.py:352: error: Expression type contains "Any" (has type "zip[tuple[str, Any]]")  [misc]
models\snippet_manager.py:352: error: Expression type contains "Any" (has type "dict[str, Any] | tuple[Any, ...]")  [misc]
models\snippet_manager.py:356: error: Expression type contains "Any" (has type "tuple[Any]")  [misc]
models\snippet_manager.py:356: error: Expression type contains "Any" (has type "dict[str, Any]")  [misc]
models\snippet_manager.py:356: error: Expression has type "Any"  [misc]
models\snippet_manager.py:358: error: Expression type contains "Any" (has type "list[dict[str, Any] | tuple[Any, ...]]")  [misc]
models\snippet_manager.py:359: error: Expression type contains "Any" (has type "dict[str, Any] | tuple[Any, ...]")  [misc]
models\snippet_manager.py:359: error: Expression has type "Any"  [misc]
models\snippet_manager.py:359: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\snippet_manager.py:359: error: Expression type contains "Any" (has type "list[dict[str, Any] | tuple[Any, ...]]")  [misc]
models\snippet_manager.py:361: error: Expression type contains "Any" (has type "dict[str, Any]")  [misc]
models\snippet_manager.py:362: error: Expression type contains "Any" (has type "dict[str, Any]")  [misc]
models\snippet_manager.py:368: error: Missing named argument "description" for "Snippet"  [call-arg]
models\snippet_manager.py:409: error: Expression type contains "Any" (has type "dict[str, Any] | tuple[Any, ...] | None")  [misc]
models\snippet_manager.py:410: error: Expression type contains "Any" (has type "dict[str, Any] | tuple[Any, ...]")  [misc]
models\snippet_manager.py:410: error: Expression has type "Any"  [misc]
models\snippet_manager.py:410: error: Expression type contains "Any" (has type "Any | None")  [misc]
models\snippet_manager.py:410: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\snippet_manager.py:410: error: Expression type contains "Any" (has type "dict[str, Any] | tuple[Any, ...] | None")  [misc]
models\snippet_manager.py:410: error: Expression type contains "Any" (has type "dict[str, Any] | tuple[Any, ...] | bool | None")  [misc]
models\snippet_manager.py:411: error: Expression type contains "Any" (has type "Any | None")  [misc]
models\snippet_manager.py:413: error: Expression has type "Any"  [misc]
models\snippet_manager.py:415: error: Returning Any from function declared to return "int"  [no-any-return]
models\snippet_manager.py:415: error: Expression has type "Any"  [misc]
models\setting_manager.py:45: error: Expression type contains "Any" (has type "dict[str, Any] | tuple[Any, ...] | None")  [misc]
models\setting_manager.py:72: error: Expression type contains "Any" (has type "dict[str, Any] | tuple[Any, ...] | None")  [misc]
models\setting_manager.py:81: error: Expression type contains "Any" (has type "dict[str, Any] | tuple[Any, ...] | None")  [misc]
models\setting_manager.py:83: error: Expression type contains "Any" (has type "dict[str, Any] | tuple[Any, ...]")  [misc]
models\setting_manager.py:83: error: Expression has type "Any"  [misc]
models\setting_manager.py:83: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\setting_manager.py:84: error: Expression type contains "Any" (has type "dict[str, Any] | tuple[Any, ...]")  [misc]
models\setting_manager.py:84: error: Expression has type "Any"  [misc]
models\setting_manager.py:84: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\setting_manager.py:85: error: Expression type contains "Any" (has type "dict[str, Any] | tuple[Any, ...]")  [misc]
models\setting_manager.py:85: error: Expression has type "Any"  [misc]
models\setting_manager.py:85: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\setting_manager.py:86: error: Expression type contains "Any" (has type "dict[str, Any] | tuple[Any, ...]")  [misc]
models\setting_manager.py:86: error: Expression has type "Any"  [misc]
models\setting_manager.py:86: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\setting_manager.py:87: error: Expression type contains "Any" (has type "dict[str, Any] | tuple[Any, ...]")  [misc]
models\setting_manager.py:87: error: Expression has type "Any"  [misc]
models\setting_manager.py:87: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\setting_manager.py:115: error: Expression type contains "Any" (has type "list[dict[str, Any] | tuple[Any, ...]]")  [misc]
models\setting_manager.py:124: error: Expression type contains "Any" (has type "dict[str, Any] | tuple[Any, ...]")  [misc]
models\setting_manager.py:126: error: Expression type contains "Any" (has type "dict[str, Any] | tuple[Any, ...]")  [misc]
models\setting_manager.py:126: error: Expression has type "Any"  [misc]
models\setting_manager.py:126: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\setting_manager.py:127: error: Expression type contains "Any" (has type "dict[str, Any] | tuple[Any, ...]")  [misc]
models\setting_manager.py:127: error: Expression has type "Any"  [misc]
models\setting_manager.py:127: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\setting_manager.py:128: error: Expression type contains "Any" (has type "dict[str, Any] | tuple[Any, ...]")  [misc]
models\setting_manager.py:128: error: Expression has type "Any"  [misc]
models\setting_manager.py:128: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\setting_manager.py:129: error: Expression type contains "Any" (has type "dict[str, Any] | tuple[Any, ...]")  [misc]
models\setting_manager.py:129: error: Expression has type "Any"  [misc]
models\setting_manager.py:129: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\setting_manager.py:130: error: Expression type contains "Any" (has type "dict[str, Any] | tuple[Any, ...]")  [misc]
models\setting_manager.py:130: error: Expression has type "Any"  [misc]
models\setting_manager.py:130: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\setting_manager.py:132: error: Expression type contains "Any" (has type "list[dict[str, Any] | tuple[Any, ...]]")  [misc]
models\setting_manager.py:154: error: Expression type contains "Any" (has type "dict[str, Any] | tuple[Any, ...] | None")  [misc]
models\setting_manager.py:159: error: Expression type contains "Any" (has type "dict[str, Any] | tuple[Any, ...] | None")  [misc]
models\setting_manager.py:162: error: Expression type contains "Any" (has type "tuple[Any, ...]")  [misc]
models\setting_manager.py:162: error: Expression has type "Any"  [misc]
models\setting_manager.py:163: error: Expression type contains "Any" (has type "dict[str, Any] | tuple[Any, ...]")  [misc]
models\setting_manager.py:164: error: Expression type contains "Any" (has type "dict[str, Any]")  [misc]
models\setting_manager.py:164: error: Expression has type "Any"  [misc]
models\setting_manager.py:174: error: Expression type contains "Any" (has type "dict[str, Any] | tuple[Any, ...] | None")  [misc]
models\setting_manager.py:177: error: Expression type contains "Any" (has type "dict[str, Any] | tuple[Any, ...] | None")  [misc]
models\ngram.py:125: error: Expression type contains "Any" (has type "dict[str, Any]")  [misc]
models\ngram.py:125: error: Expression type contains "Any" (has type "Any | None")  [misc]
models\ngram.py:125: error: Expression type contains "Any" (has type "ValidationInfo | dict[str, Any]")  [misc]
models\ngram.py:126: error: Expression type contains "Any" (has type "Any | None")  [misc]
models\ngram.py:126: error: Expression type contains "Any" (has type "Any | bool | None")  [misc]
models\ngram.py:126: error: Expression has type "Any"  [misc]
models\ngram.py:127: error: Expression has type "Any"  [misc]
models\ngram.py:128: error: Expression has type "Any"  [misc]
models\llm_ngram_service.py:19: error: Cannot assign to a type  [misc]
models\llm_ngram_service.py:19: note: Error code "misc" not covered by "type: ignore" comment
models\llm_ngram_service.py:21: error: Name "OpenAIAPIError" already defined (possibly by an import)  [no-redef]
models\llm_ngram_service.py:24: error: Name "OpenAIRateLimitError" already defined (possibly by an import)  [no-redef]
models\llm_ngram_service.py:27: error: Name "OpenAIAPITimeoutError" already defined (possibly by an import)  [no-redef]
models\llm_ngram_service.py:200: error: Expression type contains "Any" (has type "list[Any]")  [misc]
models\llm_ngram_service.py:203: error: Expression type contains "Any" (has type "Any | None")  [misc]
models\llm_ngram_service.py:204: error: Expression type contains "Any" (has type "Any | None")  [misc]
models\llm_ngram_service.py:205: error: Expression type contains "Any" (has type "Any | None")  [misc]
models\llm_ngram_service.py:211: error: Expression type contains "Any" (has type "Any | None")  [misc]
models\llm_ngram_service.py:212: error: Expression type contains "Any" (has type "Any | None")  [misc]
models\llm_ngram_service.py:217: error: Expression has type "Any"  [misc]
models\llm_ngram_service.py:217: error: Expression type contains "Any" (has type "Any | list[Never]")  [misc]
models\llm_ngram_service.py:217: error: Expression type contains "Any" (has type "Any | list[Any]")  [misc]
models\llm_ngram_service.py:217: error: Expression type contains "Any" (has type "list[Any]")  [misc]
models\llm_ngram_service.py:218: error: Expression type contains "Any" (has type "Any | None")  [misc]
models\llm_ngram_service.py:218: error: Expression type contains "Any" (has type "Any | bool")  [misc]
models\llm_ngram_service.py:218: error: Expression has type "Any"  [misc]
models\llm_ngram_service.py:219: error: Expression has type "Any"  [misc]
models\llm_ngram_service.py:219: error: Expression type contains "Any" (has type "Any | list[Any]")  [misc]
models\llm_ngram_service.py:219: error: Expression type contains "Any" (has type "list[Any]")  [misc]
models\llm_ngram_service.py:220: error: Expression type contains "Any" (has type "Any | None")  [misc]
models\llm_ngram_service.py:220: error: Expression type contains "Any" (has type "Any | bool")  [misc]
models\llm_ngram_service.py:220: error: Expression has type "Any"  [misc]
models\llm_ngram_service.py:221: error: Expression type contains "Any" (has type "Any | None")  [misc]
models\llm_ngram_service.py:221: error: Expression has type "Any"  [misc]
models\llm_ngram_service.py:222: error: Expression type contains "Any" (has type "Any | None")  [misc]
models\llm_ngram_service.py:232: error: Unused "type: ignore" comment  [unused-ignore]
models\llm_ngram_service.py:264: error: Expression type contains "Any" (has type "dict[str, Any]")  [misc]
models\llm_ngram_service.py:264: error: Expression type contains "Any" (has type "dict[str, Any] | str")  [misc]
models\keystroke_manager.py:58: error: Expression type contains "Any" (has type "Any | bool")  [misc]
models\keystroke_manager.py:60: error: Unused "type: ignore" comment  [unused-ignore]
models\keystroke_manager.py:121: error: Expression type contains "Any" (has type "dict[str, Any] | None")  [misc]
models\keystroke_manager.py:130: error: Expression type contains "Any" (has type "dict[str, Any] | None")  [misc]
models\keystroke_manager.py:131: error: Expression type contains "Any" (has type "dict[str, Any]")  [misc]
models\keystroke_manager.py:132: error: Expression type contains "Any" (has type "dict[str, Any]")  [misc]
models\keystroke_manager.py:132: error: Expression has type "Any"  [misc]
models\keystroke_manager.py:132: error: Expression type contains "Any" (has type "Any | int")  [misc]
models\keystroke_manager.py:135: error: Expression type contains "Any" (has type "dict[str, Any]")  [misc]
models\keystroke_manager.py:136: error: Incompatible return value type (got "str", expected "int")  [return-value]
models\keyboard_manager.py:45: error: Expression type contains "Any" (has type "dict[str, Any] | tuple[Any, ...] | None")  [misc]
models\keyboard_manager.py:52: error: Expression type contains "Any" (has type "dict[str, Any] | tuple[Any, ...] | None")  [misc]
models\keyboard_manager.py:60: error: Expression type contains "Any" (has type "dict[str, Any] | tuple[Any, ...] | None")  [misc]
models\keyboard_manager.py:63: error: Expression type contains "Any" (has type "dict[str, Any] | tuple[Any, ...]")  [misc]
models\keyboard_manager.py:63: error: Expression has type "Any"  [misc]
models\keyboard_manager.py:63: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\keyboard_manager.py:64: error: Expression type contains "Any" (has type "dict[str, Any] | tuple[Any, ...]")  [misc]
models\keyboard_manager.py:64: error: Expression has type "Any"  [misc]
models\keyboard_manager.py:64: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\keyboard_manager.py:65: error: Expression type contains "Any" (has type "dict[str, Any] | tuple[Any, ...]")  [misc]
models\keyboard_manager.py:65: error: Expression has type "Any"  [misc]
models\keyboard_manager.py:65: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\keyboard_manager.py:66: error: Expression type contains "Any" (has type "dict[str, Any] | tuple[Any, ...]")  [misc]
models\keyboard_manager.py:66: error: Expression has type "Any"  [misc]
models\keyboard_manager.py:66: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\keyboard_manager.py:71: error: Expression type contains "Any" (has type "list[dict[str, Any] | tuple[Any, ...]]")  [misc]
models\keyboard_manager.py:80: error: Expression type contains "Any" (has type "dict[str, Any] | tuple[Any, ...]")  [misc]
models\keyboard_manager.py:82: error: Expression type contains "Any" (has type "dict[str, Any] | tuple[Any, ...]")  [misc]
models\keyboard_manager.py:82: error: Expression has type "Any"  [misc]
models\keyboard_manager.py:82: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\keyboard_manager.py:83: error: Expression type contains "Any" (has type "dict[str, Any] | tuple[Any, ...]")  [misc]
models\keyboard_manager.py:83: error: Expression has type "Any"  [misc]
models\keyboard_manager.py:83: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\keyboard_manager.py:84: error: Expression type contains "Any" (has type "dict[str, Any] | tuple[Any, ...]")  [misc]
models\keyboard_manager.py:84: error: Expression has type "Any"  [misc]
models\keyboard_manager.py:84: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\keyboard_manager.py:85: error: Expression type contains "Any" (has type "dict[str, Any] | tuple[Any, ...]")  [misc]
models\keyboard_manager.py:85: error: Expression has type "Any"  [misc]
models\keyboard_manager.py:85: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\keyboard_manager.py:86: error: Expression type contains "Any" (has type "list[dict[str, Any] | tuple[Any, ...]]")  [misc]
models\keyboard_manager.py:103: error: Expression type contains "Any" (has type "dict[str, Any] | tuple[Any, ...] | None")  [misc]
models\keyboard_manager.py:106: error: Expression type contains "Any" (has type "dict[str, Any] | tuple[Any, ...] | None")  [misc]
models\keyboard_manager.py:142: error: Expression type contains "Any" (has type "dict[str, Any] | tuple[Any, ...] | None")  [misc]
models\keyboard_manager.py:159: error: Expression type contains "Any" (has type "dict[str, Any] | tuple[Any, ...] | None")  [misc]
models\keyboard_manager.py:159: error: Value of type "dict[str, Any] | tuple[Any, ...] | None" is not indexable  [index]
models\keyboard_manager.py:159: error: Expression has type "Any"  [misc]
models\keyboard_manager.py:159: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\keyboard_manager.py:161: error: Returning Any from function declared to return "bool"  [no-any-return]
models\keyboard_manager.py:161: error: Expression has type "Any"  [misc]
models\category_manager.py:65: error: Expression type contains "Any" (has type "dict[str, Any] | tuple[Any, ...] | None")  [misc]
models\category_manager.py:81: error: Expression type contains "Any" (has type "dict[str, Any] | tuple[Any, ...] | None")  [misc]
models\category_manager.py:85: error: Expression type contains "Any" (has type "dict[str, Any] | tuple[Any, ...] | None")  [misc]
models\category_manager.py:87: error: Expression type contains "Any" (has type "dict[str, Any] | tuple[Any, ...]")  [misc]
models\category_manager.py:87: error: Expression has type "Any"  [misc]
models\category_manager.py:87: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\category_manager.py:101: error: Expression type contains "Any" (has type "dict[str, Any] | tuple[Any, ...] | None")  [misc]
models\category_manager.py:105: error: Expression type contains "Any" (has type "dict[str, Any] | tuple[Any, ...] | None")  [misc]
models\category_manager.py:107: error: Expression type contains "Any" (has type "dict[str, Any] | tuple[Any, ...]")  [misc]
models\category_manager.py:107: error: Expression has type "Any"  [misc]
models\category_manager.py:107: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\category_manager.py:115: error: Expression type contains "Any" (has type "list[dict[str, Any] | tuple[Any, ...]]")  [misc]
models\category_manager.py:118: error: Expression type contains "Any" (has type "dict[str, Any] | tuple[Any, ...]")  [misc]
models\category_manager.py:120: error: Expression type contains "Any" (has type "dict[str, Any] | tuple[Any, ...]")  [misc]
models\category_manager.py:120: error: Expression has type "Any"  [misc]
models\category_manager.py:120: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\category_manager.py:121: error: Expression type contains "Any" (has type "dict[str, Any] | tuple[Any, ...]")  [misc]
models\category_manager.py:121: error: Expression has type "Any"  [misc]
models\category_manager.py:121: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\category_manager.py:123: error: Expression type contains "Any" (has type "list[dict[str, Any] | tuple[Any, ...]]")  [misc]
models\category_manager.py:148: error: Expression type contains "Any" (has type "dict[str, Any] | tuple[Any, ...] | None")  [misc]
models\category_manager.py:151: error: Expression type contains "Any" (has type "dict[str, Any] | tuple[Any, ...] | None")  [misc]
models\category_manager.py:178: error: Expression type contains "Any" (has type "dict[str, Any] | tuple[Any, ...] | None")  [misc]
models\category_manager.py:201: error: Expression type contains "Any" (has type "dict[str, Any] | tuple[Any, ...] | None")  [misc]
models\category_manager.py:201: error: Value of type "dict[str, Any] | tuple[Any, ...] | None" is not indexable  [index]
models\category_manager.py:201: error: Expression has type "Any"  [misc]
models\category_manager.py:201: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\category_manager.py:203: error: Returning Any from function declared to return "bool"  [no-any-return]
models\category_manager.py:203: error: Expression has type "Any"  [misc]
models\ngram_manager.py:75: error: Name "ks_by_index" already defined on line 71  [no-redef]
models\ngram_manager.py:75: error: Expression type contains "Any" (has type "dict[Any, Any]")  [misc]
models\library.py:165: error: Returning Any from function declared to return "bool"  [no-any-return]
models\library.py:165: error: "SnippetManager" has no attribute "delete_snippet"; maybe "delete_all_snippets"?  [attr-defined]
models\library.py:165: error: Expression has type "Any"  [misc]
models\dynamic_content_service.py:238: error: Need type annotation for "result" (hint: "result: list[<type>] = ...")  [var-annotated]
models\dynamic_content_service.py:243: error: Expression type contains "Any" (has type "list[Any]")  [misc]
models\session_manager.py:41: error: Expression type contains "Any" (has type "dict[str, Any] | tuple[Any, ...] | None")  [misc]
models\session_manager.py:49: error: Expression type contains "Any" (has type "dict[str, Any] | tuple[Any, ...] | None")  [misc]
models\session_manager.py:52: error: Expression type contains "Any" (has type "dict[str, Any] | tuple[Any, ...]")  [misc]
models\session_manager.py:52: error: Expression has type "Any"  [misc]
models\session_manager.py:52: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\session_manager.py:53: error: Expression type contains "Any" (has type "dict[str, Any] | tuple[Any, ...]")  [misc]
models\session_manager.py:53: error: Expression has type "Any"  [misc]
models\session_manager.py:53: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\session_manager.py:54: error: Expression type contains "Any" (has type "dict[str, Any] | tuple[Any, ...]")  [misc]
models\session_manager.py:54: error: Expression has type "Any"  [misc]
models\session_manager.py:54: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\session_manager.py:55: error: Expression type contains "Any" (has type "dict[str, Any] | tuple[Any, ...]")  [misc]
models\session_manager.py:55: error: Expression has type "Any"  [misc]
models\session_manager.py:55: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\session_manager.py:56: error: Expression type contains "Any" (has type "dict[str, Any] | tuple[Any, ...]")  [misc]
models\session_manager.py:56: error: Expression has type "Any"  [misc]
models\session_manager.py:56: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\session_manager.py:57: error: Expression type contains "Any" (has type "dict[str, Any] | tuple[Any, ...]")  [misc]
models\session_manager.py:57: error: Expression has type "Any"  [misc]
models\session_manager.py:57: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\session_manager.py:58: error: Expression type contains "Any" (has type "dict[str, Any] | tuple[Any, ...]")  [misc]
models\session_manager.py:58: error: Expression has type "Any"  [misc]
models\session_manager.py:58: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\session_manager.py:59: error: Expression type contains "Any" (has type "dict[str, Any] | tuple[Any, ...]")  [misc]
models\session_manager.py:59: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\session_manager.py:60: error: Expression type contains "Any" (has type "dict[str, Any] | tuple[Any, ...]")  [misc]
models\session_manager.py:60: error: Expression has type "Any"  [misc]
models\session_manager.py:60: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\session_manager.py:61: error: Expression type contains "Any" (has type "dict[str, Any] | tuple[Any, ...]")  [misc]
models\session_manager.py:61: error: Expression has type "Any"  [misc]
models\session_manager.py:61: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\session_manager.py:62: error: Expression type contains "Any" (has type "dict[str, Any] | tuple[Any, ...]")  [misc]
models\session_manager.py:62: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\session_manager.py:63: error: Expression type contains "Any" (has type "dict[str, Any] | tuple[Any, ...]")  [misc]
models\session_manager.py:63: error: Expression has type "Any"  [misc]
models\session_manager.py:63: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\session_manager.py:64: error: Expression type contains "Any" (has type "dict[str, Any] | tuple[Any, ...]")  [misc]
models\session_manager.py:64: error: Expression has type "Any"  [misc]
models\session_manager.py:64: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\session_manager.py:65: error: Expression type contains "Any" (has type "dict[str, Any] | tuple[Any, ...]")  [misc]
models\session_manager.py:65: error: Expression has type "Any"  [misc]
models\session_manager.py:65: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\session_manager.py:66: error: Expression type contains "Any" (has type "dict[str, Any] | tuple[Any, ...]")  [misc]
models\session_manager.py:66: error: Expression has type "Any"  [misc]
models\session_manager.py:66: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\session_manager.py:86: error: Expression type contains "Any" (has type "list[dict[str, Any] | tuple[Any, ...]]")  [misc]
models\session_manager.py:95: error: Expression type contains "Any" (has type "dict[str, Any] | tuple[Any, ...]")  [misc]
models\session_manager.py:97: error: Expression type contains "Any" (has type "dict[str, Any] | tuple[Any, ...]")  [misc]
models\session_manager.py:97: error: Expression has type "Any"  [misc]
models\session_manager.py:97: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\session_manager.py:98: error: Expression type contains "Any" (has type "dict[str, Any] | tuple[Any, ...]")  [misc]
models\session_manager.py:98: error: Expression has type "Any"  [misc]
models\session_manager.py:98: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\session_manager.py:99: error: Expression type contains "Any" (has type "dict[str, Any] | tuple[Any, ...]")  [misc]
models\session_manager.py:99: error: Expression has type "Any"  [misc]
models\session_manager.py:99: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\session_manager.py:100: error: Expression type contains "Any" (has type "dict[str, Any] | tuple[Any, ...]")  [misc]
models\session_manager.py:100: error: Expression has type "Any"  [misc]
models\session_manager.py:100: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\session_manager.py:101: error: Expression type contains "Any" (has type "dict[str, Any] | tuple[Any, ...]")  [misc]
models\session_manager.py:101: error: Expression has type "Any"  [misc]
models\session_manager.py:101: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\session_manager.py:102: error: Expression type contains "Any" (has type "dict[str, Any] | tuple[Any, ...]")  [misc]
models\session_manager.py:102: error: Expression has type "Any"  [misc]
models\session_manager.py:102: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\session_manager.py:103: error: Expression type contains "Any" (has type "dict[str, Any] | tuple[Any, ...]")  [misc]
models\session_manager.py:103: error: Expression has type "Any"  [misc]
models\session_manager.py:103: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\session_manager.py:104: error: Expression type contains "Any" (has type "dict[str, Any] | tuple[Any, ...]")  [misc]
models\session_manager.py:104: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\session_manager.py:105: error: Expression type contains "Any" (has type "dict[str, Any] | tuple[Any, ...]")  [misc]
models\session_manager.py:105: error: Expression has type "Any"  [misc]
models\session_manager.py:105: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\session_manager.py:106: error: Expression type contains "Any" (has type "dict[str, Any] | tuple[Any, ...]")  [misc]
models\session_manager.py:106: error: Expression has type "Any"  [misc]
models\session_manager.py:106: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\session_manager.py:107: error: Expression type contains "Any" (has type "dict[str, Any] | tuple[Any, ...]")  [misc]
models\session_manager.py:107: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\session_manager.py:108: error: Expression type contains "Any" (has type "dict[str, Any] | tuple[Any, ...]")  [misc]
models\session_manager.py:108: error: Expression has type "Any"  [misc]
models\session_manager.py:108: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\session_manager.py:109: error: Expression type contains "Any" (has type "dict[str, Any] | tuple[Any, ...]")  [misc]
models\session_manager.py:109: error: Expression has type "Any"  [misc]
models\session_manager.py:109: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\session_manager.py:110: error: Expression type contains "Any" (has type "dict[str, Any] | tuple[Any, ...]")  [misc]
models\session_manager.py:110: error: Expression has type "Any"  [misc]
models\session_manager.py:110: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\session_manager.py:111: error: Expression type contains "Any" (has type "dict[str, Any] | tuple[Any, ...]")  [misc]
models\session_manager.py:111: error: Expression has type "Any"  [misc]
models\session_manager.py:111: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\session_manager.py:113: error: Expression type contains "Any" (has type "list[dict[str, Any] | tuple[Any, ...]]")  [misc]
models\session_manager.py:137: error: Expression type contains "Any" (has type "dict[str, Any] | tuple[Any, ...] | None")  [misc]
models\session_manager.py:141: error: Expression type contains "Any" (has type "dict[str, Any] | tuple[Any, ...] | None")  [misc]
models\session_manager.py:224: error: Returning Any from function declared to return "bool"  [no-any-return]
models\session_manager.py:224: error: "CursorProtocol" has no attribute "rowcount"  [attr-defined]
models\session_manager.py:224: error: Expression has type "Any"  [misc]
models\session_manager.py:295: error: Expression type contains "Any" (has type "dict[str, Any] | None")  [misc]
models\session_manager.py:307: error: Expression type contains "Any" (has type "dict[str, Any] | None")  [misc]
models\session_manager.py:311: error: Expression type contains "Any" (has type "dict[str, Any]")  [misc]
models\session_manager.py:311: error: Expression has type "Any"  [misc]
models\session_manager.py:312: error: Expression type contains "Any" (has type "dict[str, Any]")  [misc]
models\session_manager.py:312: error: Expression has type "Any"  [misc]
models\session_manager.py:313: error: Expression type contains "Any" (has type "dict[str, Any]")  [misc]
models\session_manager.py:313: error: Expression has type "Any"  [misc]
models\session_manager.py:314: error: Expression type contains "Any" (has type "dict[str, Any]")  [misc]
models\session_manager.py:314: error: Expression has type "Any"  [misc]
models\session_manager.py:315: error: Expression type contains "Any" (has type "dict[str, Any]")  [misc]
models\session_manager.py:315: error: Expression has type "Any"  [misc]
models\session_manager.py:316: error: Expression type contains "Any" (has type "dict[str, Any]")  [misc]
models\session_manager.py:316: error: Expression has type "Any"  [misc]
models\session_manager.py:317: error: Expression type contains "Any" (has type "dict[str, Any]")  [misc]
models\session_manager.py:317: error: Expression has type "Any"  [misc]
models\session_manager.py:318: error: Expression type contains "Any" (has type "dict[str, Any]")  [misc]
models\session_manager.py:319: error: Expression type contains "Any" (has type "dict[str, Any]")  [misc]
models\session_manager.py:319: error: Expression has type "Any"  [misc]
models\session_manager.py:320: error: Expression type contains "Any" (has type "dict[str, Any]")  [misc]
models\session_manager.py:320: error: Expression has type "Any"  [misc]
models\session_manager.py:321: error: Expression type contains "Any" (has type "dict[str, Any]")  [misc]
models\session_manager.py:322: error: Expression type contains "Any" (has type "dict[str, Any]")  [misc]
models\session_manager.py:322: error: Expression has type "Any"  [misc]
models\session_manager.py:323: error: Expression type contains "Any" (has type "dict[str, Any]")  [misc]
models\session_manager.py:323: error: Expression has type "Any"  [misc]
models\session_manager.py:324: error: Expression type contains "Any" (has type "dict[str, Any]")  [misc]
models\session_manager.py:324: error: Expression has type "Any"  [misc]
models\session_manager.py:325: error: Expression type contains "Any" (has type "dict[str, Any]")  [misc]
models\session_manager.py:325: error: Expression has type "Any"  [misc]
models\ngram_analytics_service.py:420: error: Expression type contains "Any" (has type "list[dict[str, Any]]")  [misc]
models\ngram_analytics_service.py:424: error: Expression type contains "Any" (has type "dict[str, Any]")  [misc]
models\ngram_analytics_service.py:424: error: Expression type contains "Any" (has type "list[dict[str, Any]]")  [misc]
models\ngram_analytics_service.py:506: error: Expression type contains "Any" (has type "list[dict[str, Any]]")  [misc]
models\ngram_analytics_service.py:506: error: Expression type contains "Any" (has type "tuple[Any, ...]")  [misc]
models\ngram_analytics_service.py:509: error: Expression type contains "Any" (has type "dict[str, Any]")  [misc]
models\ngram_analytics_service.py:509: error: Expression type contains "Any" (has type "list[dict[str, Any]]")  [misc]
models\ngram_analytics_service.py:665: error: Expression type contains "Any" (has type "list[dict[str, Any]]")  [misc]
models\ngram_analytics_service.py:670: error: Expression type contains "Any" (has type "dict[str, Any]")  [misc]
models\ngram_analytics_service.py:670: error: Expression type contains "Any" (has type "list[dict[str, Any]]")  [misc]
models\ngram_analytics_service.py:689: error: Expression type contains "Any" (has type "Callable[[Any], Any]")  [misc]
models\ngram_analytics_service.py:689: error: Expression has type "Any"  [misc]
Found 660 errors in 22 files (checked 21 source files)
D100 Missing docstring in public module
--> models\ngram_manager.py:1:1

Found 1 error.
D212 [*] Multi-line docstring summary should start at the first line
  --> AiTypingApp.py:1:1
   |
 1 | / """
 2 | | AI Typing Trainer Application Entry Point.
 3 | |
 4 | | This module serves as the main entry point for the AI Typing Trainer application.
 5 | | It handles:
 6 | | - Displaying a splash screen during startup
 7 | | - Starting and verifying the GraphQL API server
 8 | | - Starting and verifying the web server
 9 | | - Launching both desktop UI and web UI main menus
10 | |
11 | | All operations follow robust error handling with clear user feedback.
12 | | """
   | |___^
13 |
14 |   import os
   |
help: Remove whitespace after opening quotes

D212 [*] Multi-line docstring summary should start at the first line
  --> AiTypingApp.py:59:9
   |
57 |           npm_command: Optional[List[str]] = None,
58 |       ) -> None:
59 | /         """
60 | |         Initialize the server worker.
61 | |
62 | |         Args:
63 | |             server_type: Type of server ("api" or "web")
64 | |             script_path: Path to the Python script to run (for API server)
65 | |             cwd: Current working directory for the process
66 | |             npm_command: Command to run for npm-based servers (for web server)
67 | |         """
   | |___________^
68 |           super().__init__()
69 |           self.server_type = server_type
   |
help: Remove whitespace after opening quotes

D205 1 blank line required between summary line and description
   --> AiTypingApp.py:183:5
    |
182 |   class SplashScreen(QDialog):
183 | /     """
184 | |     Splash screen dialog that displays during application startup.
185 | |     Shows status updates while servers are being initialized.
186 | |     """
    | |_______^
187 |
188 |       def __init__(self) -> None:
    |
help: Insert single blank line

D212 [*] Multi-line docstring summary should start at the first line
   --> AiTypingApp.py:183:5
    |
182 |   class SplashScreen(QDialog):
183 | /     """
184 | |     Splash screen dialog that displays during application startup.
185 | |     Shows status updates while servers are being initialized.
186 | |     """
    | |_______^
187 |
188 |       def __init__(self) -> None:
    |
help: Remove whitespace after opening quotes

D205 1 blank line required between summary line and description
   --> AiTypingApp.py:389:5
    |
388 |   class AiTypingApp:
389 | /     """
390 | |     Main application class for AI Typing Trainer.
391 | |     Handles application startup, server initialization, and UI display.
392 | |     """
    | |_______^
393 |
394 |       def __init__(self) -> None:
    |
help: Insert single blank line

D212 [*] Multi-line docstring summary should start at the first line
   --> AiTypingApp.py:389:5
    |
388 |   class AiTypingApp:
389 | /     """
390 | |     Main application class for AI Typing Trainer.
391 | |     Handles application startup, server initialization, and UI display.
392 | |     """
    | |_______^
393 |
394 |       def __init__(self) -> None:
    |
help: Remove whitespace after opening quotes

D212 [*] Multi-line docstring summary should start at the first line
   --> AiTypingApp.py:408:9
    |
407 |       def start(self) -> int:
408 | /         """
409 | |         Start the application.
410 | |
411 | |         Returns:
412 | |             int: Application exit code
413 | |         """
    | |___________^
414 |           # Show splash screen
415 |           splash = SplashScreen()
    |
help: Remove whitespace after opening quotes

D100 Missing docstring in public module
--> Spikes\hit_aws_aurora.py:1:1

D100 Missing docstring in public module
--> Spikes\simple_hit_aws.py:1:1

D104 Missing docstring in public package
--> __init__.py:1:1

D100 Missing docstring in public module
--> ai_typing.py:1:1

D200 One-line docstring should fit on one line
  --> ai_typing.py:61:9
   |
60 |       def update_status(self, msg: str) -> None:
61 | /         """
62 | |         Update the splash screen status label.
63 | |         """
   | |___________^
64 |           self.label.setText(msg)
65 |           QtWidgets.QApplication.processEvents()
   |
help: Reformat to one line

D212 [*] Multi-line docstring summary should start at the first line
  --> ai_typing.py:61:9
   |
60 |       def update_status(self, msg: str) -> None:
61 | /         """
62 | |         Update the splash screen status label.
63 | |         """
   | |___________^
64 |           self.label.setText(msg)
65 |           QtWidgets.QApplication.processEvents()
   |
help: Remove whitespace after opening quotes

D200 One-line docstring should fit on one line
  --> ai_typing.py:68:9
   |
67 |       def close_splash(self) -> None:
68 | /         """
69 | |         Close the splash screen.
70 | |         """
   | |___________^
71 |           self.close()
   |
help: Reformat to one line

D212 [*] Multi-line docstring summary should start at the first line
  --> ai_typing.py:68:9
   |
67 |       def close_splash(self) -> None:
68 | /         """
69 | |         Close the splash screen.
70 | |         """
   | |___________^
71 |           self.close()
   |
help: Remove whitespace after opening quotes

D200 One-line docstring should fit on one line
  --> ai_typing.py:75:5
   |
74 |   def start_backend() -> subprocess.Popen[bytes]:
75 | /     """
76 | |     Start the backend server using the current Python interpreter.
77 | |     """
   | |_______^
78 |       # Use sys.executable for correct Python interpreter
79 |       return subprocess.Popen(
   |
help: Reformat to one line

D212 [*] Multi-line docstring summary should start at the first line
  --> ai_typing.py:75:5
   |
74 |   def start_backend() -> subprocess.Popen[bytes]:
75 | /     """
76 | |     Start the backend server using the current Python interpreter.
77 | |     """
   | |_______^
78 |       # Use sys.executable for correct Python interpreter
79 |       return subprocess.Popen(
   |
help: Remove whitespace after opening quotes

D200 One-line docstring should fit on one line
   --> ai_typing.py:120:5
    |
119 |   def launch_desktop_ui() -> None:
120 | /     """
121 | |     Launch the desktop UI as a subprocess.
122 | |     """
    | |_______^
123 |       subprocess.Popen(
124 |           [sys.executable, DESKTOP_UI_SCRIPT],
    |
help: Reformat to one line

D212 [*] Multi-line docstring summary should start at the first line
   --> ai_typing.py:120:5
    |
119 |   def launch_desktop_ui() -> None:
120 | /     """
121 | |     Launch the desktop UI as a subprocess.
122 | |     """
    | |_______^
123 |       subprocess.Popen(
124 |           [sys.executable, DESKTOP_UI_SCRIPT],
    |
help: Remove whitespace after opening quotes

D104 Missing docstring in public package
--> api\__init__.py:1:1

D100 Missing docstring in public module
--> api\category_api.py:1:1

F401 [*] `typing.Any` imported but unused
 --> api\category_api.py:1:20
  |
1 | from typing import Any, Dict, List, Tuple, Union
  |                    ^^^
2 |
3 | from flask import Blueprint, Response, jsonify, request
  |
help: Remove unused import

F401 [*] `typing.Dict` imported but unused
 --> api\category_api.py:1:25
  |
1 | from typing import Any, Dict, List, Tuple, Union
  |                         ^^^^
2 |
3 | from flask import Blueprint, Response, jsonify, request
  |
help: Remove unused import

F401 [*] `typing.List` imported but unused
 --> api\category_api.py:1:31
  |
1 | from typing import Any, Dict, List, Tuple, Union
  |                               ^^^^
2 |
3 | from flask import Blueprint, Response, jsonify, request
  |
help: Remove unused import

D101 Missing docstring in public class
  --> api\category_api.py:10:7
   |
10 | class CategoryCreateRequest(BaseModel):
   |       ^^^^^^^^^^^^^^^^^^^^^
11 |     category_name: str
   |

D101 Missing docstring in public class
  --> api\category_api.py:14:7
   |
14 | class CategoryRenameRequest(BaseModel):
   |       ^^^^^^^^^^^^^^^^^^^^^
15 |     category_name: str
   |

D103 Missing docstring in public function
  --> api\category_api.py:18:5
   |
18 | def create_category_api() -> Blueprint:
   |     ^^^^^^^^^^^^^^^^^^^
19 |     category_api = Blueprint("category_api", __name__)
   |

D212 [*] Multi-line docstring summary should start at the first line
 --> api\category_graphql.py:1:1
  |
1 | / """
2 | | GraphQL API for Category operations using Graphene and Flask.
3 | |
4 | | This module provides a GraphQL interface for managing categories in the application,
5 | | with endpoints for querying, creating, updating, and deleting categories.
6 | | """
  | |___^
7 |
8 |   # Standard library imports
  |
help: Remove whitespace after opening quotes

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `_info`
  --> api\category_graphql.py:45:41
   |
43 |     category = Field(CategoryType, category_id=Int(name="categoryId", required=True))
44 |
45 |     def resolve_categories(self, _info: Any) -> TypedList[Category]:
   |                                         ^^^
46 |         """
47 |         Resolve all categories.
   |

D212 [*] Multi-line docstring summary should start at the first line
  --> api\category_graphql.py:46:9
   |
45 |       def resolve_categories(self, _info: Any) -> TypedList[Category]:
46 | /         """
47 | |         Resolve all categories.
48 | |
49 | |         Args:
50 | |             _info: GraphQL resolver info (unused but required by GraphQL)
51 | |
52 | |         Returns:
53 | |             List of category models
54 | |         """
   | |___________^
55 |           return CategoryManager.list_categories()
   |
help: Remove whitespace after opening quotes

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `_info`
  --> api\category_graphql.py:57:39
   |
55 |         return CategoryManager.list_categories()
56 |
57 |     def resolve_category(self, _info: Any, category_id: int) -> Optional[Category]:
   |                                       ^^^
58 |         """
59 |         Resolve a specific category by ID.
   |

D212 [*] Multi-line docstring summary should start at the first line
  --> api\category_graphql.py:58:9
   |
57 |       def resolve_category(self, _info: Any, category_id: int) -> Optional[Category]:
58 | /         """
59 | |         Resolve a specific category by ID.
60 | |
61 | |         Args:
62 | |             _info: GraphQL resolver info (unused but required by GraphQL)
63 | |             category_id: The ID of the category to fetch
64 | |
65 | |         Returns:
66 | |             The category model if found, None otherwise
67 | |         """
   | |___________^
68 |           try:
69 |               return CategoryManager.get_category(category_id)
   |
help: Remove whitespace after opening quotes

D106 Missing docstring in public nested class
  --> api\category_graphql.py:80:11
   |
78 |     """
79 |
80 |     class Arguments:
   |           ^^^^^^^^^
81 |         category_name = String(required=True, name="categoryName")
   |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `_info`
  --> api\category_graphql.py:85:29
   |
83 |     category = Field(lambda: CategoryType)
84 |
85 |     def mutate(self, _info: Any, category_name: str) -> "CreateCategory":
   |                             ^^^
86 |         """
87 |         Create a new category with the provided name.
   |

D212 [*] Multi-line docstring summary should start at the first line
   --> api\category_graphql.py:86:9
    |
 85 |       def mutate(self, _info: Any, category_name: str) -> "CreateCategory":
 86 | /         """
 87 | |         Create a new category with the provided name.
 88 | |
 89 | |         Args:
 90 | |             _info: GraphQL resolver info (unused but required by GraphQL)
 91 | |             category_name: The name for the new category
 92 | |
 93 | |         Returns:
 94 | |             CreateCategory: The mutation result with the created category
 95 | |
 96 | |         Raises:
 97 | |             GraphQLError: If validation fails or an error occurs
 98 | |         """
    | |___________^
 99 |           try:
100 |               cat = CategoryManager.create_category(category_name)
    |
help: Remove whitespace after opening quotes

B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
   --> api\category_graphql.py:105:13
    |
103 |         except (CategoryValidationError, ValueError) as e:
104 |             # Graphene will convert this to a proper GraphQL error
105 |             raise Exception(str(e))
    |             ^^^^^^^^^^^^^^^^^^^^^^^
    |

D106 Missing docstring in public nested class
   --> api\category_graphql.py:114:11
    |
112 |     """
113 |
114 |     class Arguments:
    |           ^^^^^^^^^
115 |         category_id = Int(required=True, name="categoryId")
116 |         category_name = String(required=True, name="categoryName")
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `_info`
   --> api\category_graphql.py:121:22
    |
120 |     def mutate(
121 |         self, _info: Any, category_id: int, category_name: str
    |                      ^^^
122 |     ) -> "UpdateCategory":
123 |         """
    |

D212 [*] Multi-line docstring summary should start at the first line
   --> api\category_graphql.py:123:9
    |
121 |           self, _info: Any, category_id: int, category_name: str
122 |       ) -> "UpdateCategory":
123 | /         """
124 | |         Update an existing category with the provided name.
125 | |
126 | |         Args:
127 | |             _info: GraphQL resolver info (unused but required by GraphQL)
128 | |             category_id: The ID of the category to update
129 | |             category_name: The new name for the category
130 | |
131 | |         Returns:
132 | |             UpdateCategory: The mutation result with the updated category
133 | |
134 | |         Raises:
135 | |             GraphQLError: If validation fails or the category is not found
136 | |         """
    | |___________^
137 |           try:
138 |               cat = CategoryManager.rename_category(category_id, category_name)
    |
help: Remove whitespace after opening quotes

B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
   --> api\category_graphql.py:143:13
    |
141 |         except (CategoryValidationError, CategoryNotFound, ValueError) as e:
142 |             # Graphene will convert this to a proper GraphQL error
143 |             raise Exception(str(e))
    |             ^^^^^^^^^^^^^^^^^^^^^^^
    |

D106 Missing docstring in public nested class
   --> api\category_graphql.py:152:11
    |
150 |     """
151 |
152 |     class Arguments:
    |           ^^^^^^^^^
153 |         category_id = Int(required=True, name="categoryId")
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `_info`
   --> api\category_graphql.py:157:29
    |
155 |     ok = Boolean()
156 |
157 |     def mutate(self, _info: Any, category_id: int) -> "DeleteCategory":
    |                             ^^^
158 |         """
159 |         Delete a category by ID.
    |

D212 [*] Multi-line docstring summary should start at the first line
   --> api\category_graphql.py:158:9
    |
157 |       def mutate(self, _info: Any, category_id: int) -> "DeleteCategory":
158 | /         """
159 | |         Delete a category by ID.
160 | |
161 | |         Args:
162 | |             _info: GraphQL resolver info (unused but required by GraphQL)
163 | |             category_id: The ID of the category to delete
164 | |
165 | |         Returns:
166 | |             DeleteCategory: The mutation result with ok=True if successful
167 | |
168 | |         Raises:
169 | |             GraphQLError: If the category is not found
170 | |         """
    | |___________^
171 |           try:
172 |               CategoryManager.delete_category(category_id)
    |
help: Remove whitespace after opening quotes

B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
   --> api\category_graphql.py:177:13
    |
175 |         except CategoryNotFound as e:
176 |             # Graphene will convert this to a proper GraphQL error
177 |             raise Exception(str(e))
    |             ^^^^^^^^^^^^^^^^^^^^^^^
    |

D212 [*] Multi-line docstring summary should start at the first line
   --> api\category_graphql.py:200:5
    |
198 |   @category_graphql.route("/graphql", methods=["POST"])
199 |   def graphql_api() -> Response:
200 | /     """
201 | |     GraphQL API endpoint for category operations.
202 | |
203 | |     Handles GraphQL queries and mutations and returns formatted JSON responses.
204 | |
205 | |     Returns:
206 | |         Response: JSON response with GraphQL execution result
207 | |     """
    | |_______^
208 |       data = request.get_json() or {}
209 |       query = data.get("query", "")
    |
help: Remove whitespace after opening quotes

D415 First line should end with a period, question mark, or exclamation point
  --> api\dbviewer_api.py:1:1
   |
 1 | / """Database Viewer API Module
 2 | |
 3 | | Provides REST API endpoints for the Database Viewer functionality:
 4 | | - Listing available database tables
 5 | | - Retrieving table data with pagination, sorting, and filtering
 6 | | - Exporting table data to CSV
 7 | |
 8 | | All endpoints are read-only and ensure proper validation and error handling.
 9 | | """
   | |___^
10 |
11 |   from io import StringIO
   |
help: Add closing punctuation

ANN201 Missing return type annotation for public function `list_tables`
  --> api\dbviewer_api.py:34:5
   |
33 | @dbviewer_api.route("/tables", methods=["GET"])
34 | def list_tables():
   |     ^^^^^^^^^^^
35 |     """List all available database tables."""
36 |     try:
   |
help: Add return type annotation

ANN201 Missing return type annotation for public function `get_table_data`
  --> api\dbviewer_api.py:52:5
   |
51 | @dbviewer_api.route("/table", methods=["GET"])
52 | def get_table_data():
   |     ^^^^^^^^^^^^^^
53 |     """Get table data with pagination, sorting, and filtering.
   |
help: Add return type annotation

ANN201 Missing return type annotation for public function `export_table_to_csv`
   --> api\dbviewer_api.py:101:5
    |
100 | @dbviewer_api.route("/export", methods=["GET"])
101 | def export_table_to_csv():
    |     ^^^^^^^^^^^^^^^^^^^
102 |     """Export table data to CSV format.
    |
help: Add return type annotation

D100 Missing docstring in public module
--> api\keystroke_api.py:1:1

E402 Module level import not at top of file
 --> api\keystroke_api.py:8:1
  |
6 | keystroke_api = Blueprint("keystroke_api", __name__)
7 |
8 | from typing import Optional
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |

D101 Missing docstring in public class
  --> api\keystroke_api.py:11:7
   |
11 | class KeystrokeCreateModel(BaseModel):
   |       ^^^^^^^^^^^^^^^^^^^^
12 |     session_id: int
13 |     keystroke_id: Optional[int] = None
   |

ANN201 Missing return type annotation for public function `api_record_keystroke`
  --> api\keystroke_api.py:22:5
   |
21 | @keystroke_api.route("/api/keystrokes", methods=["POST"])
22 | def api_record_keystroke():
   |     ^^^^^^^^^^^^^^^^^^^^
23 |     import sys
   |
help: Add return type annotation

D103 Missing docstring in public function
  --> api\keystroke_api.py:22:5
   |
21 | @keystroke_api.route("/api/keystrokes", methods=["POST"])
22 | def api_record_keystroke():
   |     ^^^^^^^^^^^^^^^^^^^^
23 |     import sys
   |

ANN201 Missing return type annotation for public function `api_list_keystrokes`
  --> api\keystroke_api.py:71:5
   |
70 | @keystroke_api.route("/api/keystrokes", methods=["GET"])
71 | def api_list_keystrokes():
   |     ^^^^^^^^^^^^^^^^^^^
72 |     session_id = request.args.get("session_id")
73 |     if not session_id:
   |
help: Add return type annotation

D103 Missing docstring in public function
  --> api\keystroke_api.py:71:5
   |
70 | @keystroke_api.route("/api/keystrokes", methods=["GET"])
71 | def api_list_keystrokes():
   |     ^^^^^^^^^^^^^^^^^^^
72 |     session_id = request.args.get("session_id")
73 |     if not session_id:
   |

D205 1 blank line required between summary line and description
 --> api\library_graphql.py:1:1
  |
1 | / """
2 | | GraphQL API for the Snippets Library (categories, snippets, snippet parts).
3 | | All logic is routed through LibraryManager in models/library.py.
4 | | """
  | |___^
5 |
6 |   import graphene
  |
help: Insert single blank line

D212 [*] Multi-line docstring summary should start at the first line
 --> api\library_graphql.py:1:1
  |
1 | / """
2 | | GraphQL API for the Snippets Library (categories, snippets, snippet parts).
3 | | All logic is routed through LibraryManager in models/library.py.
4 | | """
  | |___^
5 |
6 |   import graphene
  |
help: Remove whitespace after opening quotes

ANN201 Missing return type annotation for public function `get_library_manager`
  --> api\library_graphql.py:18:5
   |
18 | def get_library_manager():
   |     ^^^^^^^^^^^^^^^^^^^
19 |     # Dependency injection for testability
20 |     db_manager = getattr(g, "db_manager", None)
   |
help: Add return type annotation

D103 Missing docstring in public function
  --> api\library_graphql.py:18:5
   |
18 | def get_library_manager():
   |     ^^^^^^^^^^^^^^^^^^^
19 |     # Dependency injection for testability
20 |     db_manager = getattr(g, "db_manager", None)
   |

D101 Missing docstring in public class
  --> api\library_graphql.py:26:7
   |
26 | class CategoryType(graphene.ObjectType):
   |       ^^^^^^^^^^^^
27 |     category_id = Int()
28 |     category_name = String()
   |

D101 Missing docstring in public class
  --> api\library_graphql.py:31:7
   |
31 | class SnippetType(graphene.ObjectType):
   |       ^^^^^^^^^^^
32 |     snippet_id = Int()
33 |     category_id = Int()
   |

D101 Missing docstring in public class
  --> api\library_graphql.py:38:7
   |
38 | class SnippetPartType(graphene.ObjectType):
   |       ^^^^^^^^^^^^^^^
39 |     part_id = Int()
40 |     snippet_id = Int()
   |

D101 Missing docstring in public class
  --> api\library_graphql.py:46:7
   |
45 | # QUERIES
46 | class Query(ObjectType):
   |       ^^^^^
47 |     categories = List(CategoryType)
48 |     snippets = List(SnippetType, category_id=Int(required=True))
   |

ANN201 Missing return type annotation for public function `resolve_categories`
  --> api\library_graphql.py:52:9
   |
50 |     snippet_parts = List(SnippetPartType, snippet_id=Int(required=True))
51 |
52 |     def resolve_categories(self, info):
   |         ^^^^^^^^^^^^^^^^^^
53 |         mgr = get_library_manager()
54 |         return mgr.list_categories()
   |
help: Add return type annotation

D102 Missing docstring in public method
  --> api\library_graphql.py:52:9
   |
50 |     snippet_parts = List(SnippetPartType, snippet_id=Int(required=True))
51 |
52 |     def resolve_categories(self, info):
   |         ^^^^^^^^^^^^^^^^^^
53 |         mgr = get_library_manager()
54 |         return mgr.list_categories()
   |

ANN001 Missing type annotation for function argument `info`
  --> api\library_graphql.py:52:34
   |
50 |     snippet_parts = List(SnippetPartType, snippet_id=Int(required=True))
51 |
52 |     def resolve_categories(self, info):
   |                                  ^^^^
53 |         mgr = get_library_manager()
54 |         return mgr.list_categories()
   |

ANN201 Missing return type annotation for public function `resolve_snippets`
  --> api\library_graphql.py:56:9
   |
54 |         return mgr.list_categories()
55 |
56 |     def resolve_snippets(self, info, category_id):
   |         ^^^^^^^^^^^^^^^^
57 |         mgr = get_library_manager()
58 |         return mgr.list_snippets(category_id)
   |
help: Add return type annotation

D102 Missing docstring in public method
  --> api\library_graphql.py:56:9
   |
54 |         return mgr.list_categories()
55 |
56 |     def resolve_snippets(self, info, category_id):
   |         ^^^^^^^^^^^^^^^^
57 |         mgr = get_library_manager()
58 |         return mgr.list_snippets(category_id)
   |

ANN001 Missing type annotation for function argument `info`
  --> api\library_graphql.py:56:32
   |
54 |         return mgr.list_categories()
55 |
56 |     def resolve_snippets(self, info, category_id):
   |                                ^^^^
57 |         mgr = get_library_manager()
58 |         return mgr.list_snippets(category_id)
   |

ANN001 Missing type annotation for function argument `category_id`
  --> api\library_graphql.py:56:38
   |
54 |         return mgr.list_categories()
55 |
56 |     def resolve_snippets(self, info, category_id):
   |                                      ^^^^^^^^^^^
57 |         mgr = get_library_manager()
58 |         return mgr.list_snippets(category_id)
   |

ANN201 Missing return type annotation for public function `resolve_snippet`
  --> api\library_graphql.py:60:9
   |
58 |         return mgr.list_snippets(category_id)
59 |
60 |     def resolve_snippet(self, info, snippet_id):
   |         ^^^^^^^^^^^^^^^
61 |         mgr = get_library_manager()
62 |         snippets = mgr.list_snippets(-1)  # Dummy call to get type
   |
help: Add return type annotation

D102 Missing docstring in public method
  --> api\library_graphql.py:60:9
   |
58 |         return mgr.list_snippets(category_id)
59 |
60 |     def resolve_snippet(self, info, snippet_id):
   |         ^^^^^^^^^^^^^^^
61 |         mgr = get_library_manager()
62 |         snippets = mgr.list_snippets(-1)  # Dummy call to get type
   |

ANN001 Missing type annotation for function argument `info`
  --> api\library_graphql.py:60:31
   |
58 |         return mgr.list_snippets(category_id)
59 |
60 |     def resolve_snippet(self, info, snippet_id):
   |                               ^^^^
61 |         mgr = get_library_manager()
62 |         snippets = mgr.list_snippets(-1)  # Dummy call to get type
   |

ANN001 Missing type annotation for function argument `snippet_id`
  --> api\library_graphql.py:60:37
   |
58 |         return mgr.list_snippets(category_id)
59 |
60 |     def resolve_snippet(self, info, snippet_id):
   |                                     ^^^^^^^^^^
61 |         mgr = get_library_manager()
62 |         snippets = mgr.list_snippets(-1)  # Dummy call to get type
   |

ANN201 Missing return type annotation for public function `resolve_snippet_parts`
  --> api\library_graphql.py:68:9
   |
66 |         return None
67 |
68 |     def resolve_snippet_parts(self, info, snippet_id):
   |         ^^^^^^^^^^^^^^^^^^^^^
69 |         mgr = get_library_manager()
70 |         return mgr.list_parts(snippet_id)
   |
help: Add return type annotation

D102 Missing docstring in public method
  --> api\library_graphql.py:68:9
   |
66 |         return None
67 |
68 |     def resolve_snippet_parts(self, info, snippet_id):
   |         ^^^^^^^^^^^^^^^^^^^^^
69 |         mgr = get_library_manager()
70 |         return mgr.list_parts(snippet_id)
   |

ANN001 Missing type annotation for function argument `info`
  --> api\library_graphql.py:68:37
   |
66 |         return None
67 |
68 |     def resolve_snippet_parts(self, info, snippet_id):
   |                                     ^^^^
69 |         mgr = get_library_manager()
70 |         return mgr.list_parts(snippet_id)
   |

ANN001 Missing type annotation for function argument `snippet_id`
  --> api\library_graphql.py:68:43
   |
66 |         return None
67 |
68 |     def resolve_snippet_parts(self, info, snippet_id):
   |                                           ^^^^^^^^^^
69 |         mgr = get_library_manager()
70 |         return mgr.list_parts(snippet_id)
   |

D101 Missing docstring in public class
  --> api\library_graphql.py:74:7
   |
73 | # MUTATIONS
74 | class CreateCategory(Mutation):
   |       ^^^^^^^^^^^^^^
75 |     class Arguments:
76 |         category_name = String(required=True)
   |

D106 Missing docstring in public nested class
  --> api\library_graphql.py:75:11
   |
73 | # MUTATIONS
74 | class CreateCategory(Mutation):
75 |     class Arguments:
   |           ^^^^^^^^^
76 |         category_name = String(required=True)
   |

ANN201 Missing return type annotation for public function `mutate`
  --> api\library_graphql.py:82:9
   |
80 |     error = String()
81 |
82 |     def mutate(self, info, category_name):
   |         ^^^^^^
83 |         mgr = get_library_manager()
84 |         try:
   |
help: Add return type annotation

D102 Missing docstring in public method
  --> api\library_graphql.py:82:9
   |
80 |     error = String()
81 |
82 |     def mutate(self, info, category_name):
   |         ^^^^^^
83 |         mgr = get_library_manager()
84 |         try:
   |

ANN001 Missing type annotation for function argument `info`
  --> api\library_graphql.py:82:22
   |
80 |     error = String()
81 |
82 |     def mutate(self, info, category_name):
   |                      ^^^^
83 |         mgr = get_library_manager()
84 |         try:
   |

ANN001 Missing type annotation for function argument `category_name`
  --> api\library_graphql.py:82:28
   |
80 |     error = String()
81 |
82 |     def mutate(self, info, category_name):
   |                            ^^^^^^^^^^^^^
83 |         mgr = get_library_manager()
84 |         try:
   |

D101 Missing docstring in public class
  --> api\library_graphql.py:93:7
   |
93 | class RenameCategory(Mutation):
   |       ^^^^^^^^^^^^^^
94 |     class Arguments:
95 |         category_id = Int(required=True)
   |

D106 Missing docstring in public nested class
  --> api\library_graphql.py:94:11
   |
93 | class RenameCategory(Mutation):
94 |     class Arguments:
   |           ^^^^^^^^^
95 |         category_id = Int(required=True)
96 |         category_name = String(required=True)
   |

ANN201 Missing return type annotation for public function `mutate`
   --> api\library_graphql.py:101:9
    |
 99 |     error = String()
100 |
101 |     def mutate(self, info, category_id, category_name):
    |         ^^^^^^
102 |         mgr = get_library_manager()
103 |         try:
    |
help: Add return type annotation

D102 Missing docstring in public method
   --> api\library_graphql.py:101:9
    |
 99 |     error = String()
100 |
101 |     def mutate(self, info, category_id, category_name):
    |         ^^^^^^
102 |         mgr = get_library_manager()
103 |         try:
    |

ANN001 Missing type annotation for function argument `info`
   --> api\library_graphql.py:101:22
    |
 99 |     error = String()
100 |
101 |     def mutate(self, info, category_id, category_name):
    |                      ^^^^
102 |         mgr = get_library_manager()
103 |         try:
    |

ANN001 Missing type annotation for function argument `category_id`
   --> api\library_graphql.py:101:28
    |
 99 |     error = String()
100 |
101 |     def mutate(self, info, category_id, category_name):
    |                            ^^^^^^^^^^^
102 |         mgr = get_library_manager()
103 |         try:
    |

ANN001 Missing type annotation for function argument `category_name`
   --> api\library_graphql.py:101:41
    |
 99 |     error = String()
100 |
101 |     def mutate(self, info, category_id, category_name):
    |                                         ^^^^^^^^^^^^^
102 |         mgr = get_library_manager()
103 |         try:
    |

D101 Missing docstring in public class
   --> api\library_graphql.py:110:7
    |
110 | class DeleteCategory(Mutation):
    |       ^^^^^^^^^^^^^^
111 |     class Arguments:
112 |         category_id = Int(required=True)
    |

D106 Missing docstring in public nested class
   --> api\library_graphql.py:111:11
    |
110 | class DeleteCategory(Mutation):
111 |     class Arguments:
    |           ^^^^^^^^^
112 |         category_id = Int(required=True)
    |

ANN201 Missing return type annotation for public function `mutate`
   --> api\library_graphql.py:117:9
    |
115 |     error = String()
116 |
117 |     def mutate(self, info, category_id):
    |         ^^^^^^
118 |         mgr = get_library_manager()
119 |         try:
    |
help: Add return type annotation

D102 Missing docstring in public method
   --> api\library_graphql.py:117:9
    |
115 |     error = String()
116 |
117 |     def mutate(self, info, category_id):
    |         ^^^^^^
118 |         mgr = get_library_manager()
119 |         try:
    |

ANN001 Missing type annotation for function argument `info`
   --> api\library_graphql.py:117:22
    |
115 |     error = String()
116 |
117 |     def mutate(self, info, category_id):
    |                      ^^^^
118 |         mgr = get_library_manager()
119 |         try:
    |

ANN001 Missing type annotation for function argument `category_id`
   --> api\library_graphql.py:117:28
    |
115 |     error = String()
116 |
117 |     def mutate(self, info, category_id):
    |                            ^^^^^^^^^^^
118 |         mgr = get_library_manager()
119 |         try:
    |

D101 Missing docstring in public class
   --> api\library_graphql.py:126:7
    |
126 | class CreateSnippet(Mutation):
    |       ^^^^^^^^^^^^^
127 |     class Arguments:
128 |         category_id = Int(required=True)
    |

D106 Missing docstring in public nested class
   --> api\library_graphql.py:127:11
    |
126 | class CreateSnippet(Mutation):
127 |     class Arguments:
    |           ^^^^^^^^^
128 |         category_id = Int(required=True)
129 |         snippet_name = String(required=True)
    |

ANN201 Missing return type annotation for public function `mutate`
   --> api\library_graphql.py:136:9
    |
134 |     error = String()
135 |
136 |     def mutate(self, info, category_id, snippet_name, content):
    |         ^^^^^^
137 |         mgr = get_library_manager()
138 |         try:
    |
help: Add return type annotation

D102 Missing docstring in public method
   --> api\library_graphql.py:136:9
    |
134 |     error = String()
135 |
136 |     def mutate(self, info, category_id, snippet_name, content):
    |         ^^^^^^
137 |         mgr = get_library_manager()
138 |         try:
    |

ANN001 Missing type annotation for function argument `info`
   --> api\library_graphql.py:136:22
    |
134 |     error = String()
135 |
136 |     def mutate(self, info, category_id, snippet_name, content):
    |                      ^^^^
137 |         mgr = get_library_manager()
138 |         try:
    |

ANN001 Missing type annotation for function argument `category_id`
   --> api\library_graphql.py:136:28
    |
134 |     error = String()
135 |
136 |     def mutate(self, info, category_id, snippet_name, content):
    |                            ^^^^^^^^^^^
137 |         mgr = get_library_manager()
138 |         try:
    |

ANN001 Missing type annotation for function argument `snippet_name`
   --> api\library_graphql.py:136:41
    |
134 |     error = String()
135 |
136 |     def mutate(self, info, category_id, snippet_name, content):
    |                                         ^^^^^^^^^^^^
137 |         mgr = get_library_manager()
138 |         try:
    |

ANN001 Missing type annotation for function argument `content`
   --> api\library_graphql.py:136:55
    |
134 |     error = String()
135 |
136 |     def mutate(self, info, category_id, snippet_name, content):
    |                                                       ^^^^^^^
137 |         mgr = get_library_manager()
138 |         try:
    |

D101 Missing docstring in public class
   --> api\library_graphql.py:147:7
    |
147 | class EditSnippet(Mutation):
    |       ^^^^^^^^^^^
148 |     class Arguments:
149 |         snippet_id = Int(required=True)
    |

D106 Missing docstring in public nested class
   --> api\library_graphql.py:148:11
    |
147 | class EditSnippet(Mutation):
148 |     class Arguments:
    |           ^^^^^^^^^
149 |         snippet_id = Int(required=True)
150 |         snippet_name = String(required=True)
    |

ANN201 Missing return type annotation for public function `mutate`
   --> api\library_graphql.py:157:9
    |
155 |     error = String()
156 |
157 |     def mutate(self, info, snippet_id, snippet_name, content, category_id=None):
    |         ^^^^^^
158 |         mgr = get_library_manager()
159 |         try:
    |
help: Add return type annotation

D102 Missing docstring in public method
   --> api\library_graphql.py:157:9
    |
155 |     error = String()
156 |
157 |     def mutate(self, info, snippet_id, snippet_name, content, category_id=None):
    |         ^^^^^^
158 |         mgr = get_library_manager()
159 |         try:
    |

ANN001 Missing type annotation for function argument `info`
   --> api\library_graphql.py:157:22
    |
155 |     error = String()
156 |
157 |     def mutate(self, info, snippet_id, snippet_name, content, category_id=None):
    |                      ^^^^
158 |         mgr = get_library_manager()
159 |         try:
    |

ANN001 Missing type annotation for function argument `snippet_id`
   --> api\library_graphql.py:157:28
    |
155 |     error = String()
156 |
157 |     def mutate(self, info, snippet_id, snippet_name, content, category_id=None):
    |                            ^^^^^^^^^^
158 |         mgr = get_library_manager()
159 |         try:
    |

ANN001 Missing type annotation for function argument `snippet_name`
   --> api\library_graphql.py:157:40
    |
155 |     error = String()
156 |
157 |     def mutate(self, info, snippet_id, snippet_name, content, category_id=None):
    |                                        ^^^^^^^^^^^^
158 |         mgr = get_library_manager()
159 |         try:
    |

ANN001 Missing type annotation for function argument `content`
   --> api\library_graphql.py:157:54
    |
155 |     error = String()
156 |
157 |     def mutate(self, info, snippet_id, snippet_name, content, category_id=None):
    |                                                      ^^^^^^^
158 |         mgr = get_library_manager()
159 |         try:
    |

ANN001 Missing type annotation for function argument `category_id`
   --> api\library_graphql.py:157:63
    |
155 |     error = String()
156 |
157 |     def mutate(self, info, snippet_id, snippet_name, content, category_id=None):
    |                                                               ^^^^^^^^^^^
158 |         mgr = get_library_manager()
159 |         try:
    |

D101 Missing docstring in public class
   --> api\library_graphql.py:166:7
    |
166 | class DeleteSnippet(Mutation):
    |       ^^^^^^^^^^^^^
167 |     class Arguments:
168 |         snippet_id = Int(required=True)
    |

D106 Missing docstring in public nested class
   --> api\library_graphql.py:167:11
    |
166 | class DeleteSnippet(Mutation):
167 |     class Arguments:
    |           ^^^^^^^^^
168 |         snippet_id = Int(required=True)
    |

ANN201 Missing return type annotation for public function `mutate`
   --> api\library_graphql.py:173:9
    |
171 |     error = String()
172 |
173 |     def mutate(self, info, snippet_id):
    |         ^^^^^^
174 |         mgr = get_library_manager()
175 |         try:
    |
help: Add return type annotation

D102 Missing docstring in public method
   --> api\library_graphql.py:173:9
    |
171 |     error = String()
172 |
173 |     def mutate(self, info, snippet_id):
    |         ^^^^^^
174 |         mgr = get_library_manager()
175 |         try:
    |

ANN001 Missing type annotation for function argument `info`
   --> api\library_graphql.py:173:22
    |
171 |     error = String()
172 |
173 |     def mutate(self, info, snippet_id):
    |                      ^^^^
174 |         mgr = get_library_manager()
175 |         try:
    |

ANN001 Missing type annotation for function argument `snippet_id`
   --> api\library_graphql.py:173:28
    |
171 |     error = String()
172 |
173 |     def mutate(self, info, snippet_id):
    |                            ^^^^^^^^^^
174 |         mgr = get_library_manager()
175 |         try:
    |

D101 Missing docstring in public class
   --> api\library_graphql.py:182:7
    |
182 | class Mutation(ObjectType):
    |       ^^^^^^^^
183 |     create_category = CreateCategory.Field()
184 |     rename_category = RenameCategory.Field()
    |

ANN201 Missing return type annotation for public function `graphql_api`
   --> api\library_graphql.py:195:5
    |
194 | @library_graphql.route("/", methods=["POST", "GET"])
195 | def graphql_api():
    |     ^^^^^^^^^^^
196 |     data = request.get_json()
197 |     result = schema.execute(
    |
help: Add return type annotation

D103 Missing docstring in public function
   --> api\library_graphql.py:195:5
    |
194 | @library_graphql.route("/", methods=["POST", "GET"])
195 | def graphql_api():
    |     ^^^^^^^^^^^
196 |     data = request.get_json()
197 |     result = schema.execute(
    |

D200 One-line docstring should fit on one line
 --> api\run_library_api.py:1:1
  |
1 | / """
2 | | Entrypoint to run the Snippets Library GraphQL API as a Flask app.
3 | | """
  | |___^
4 |
5 |   import os
  |
help: Reformat to one line

D212 [*] Multi-line docstring summary should start at the first line
 --> api\run_library_api.py:1:1
  |
1 | / """
2 | | Entrypoint to run the Snippets Library GraphQL API as a Flask app.
3 | | """
  | |___^
4 |
5 |   import os
  |
help: Remove whitespace after opening quotes

ANN201 Missing return type annotation for public function `init_db`
  --> api\run_library_api.py:26:5
   |
25 | # Initialize database tables on startup
26 | def init_db():
   |     ^^^^^^^
27 |     """Initialize database tables"""
28 |     print("Initializing database tables...")
   |
help: Add return type annotation: `None`

D415 First line should end with a period, question mark, or exclamation point
  --> api\run_library_api.py:27:5
   |
25 | # Initialize database tables on startup
26 | def init_db():
27 |     """Initialize database tables"""
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
28 |     print("Initializing database tables...")
29 |     db_path = app.config["DATABASE"]
   |
help: Add closing punctuation

D100 Missing docstring in public module
--> api\session_api.py:1:1

D101 Missing docstring in public class
  --> api\session_api.py:9:7
   |
 9 | class PracticeSessionCreateModel(BaseModel):
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^
10 |     snippet_id: int
11 |     snippet_index_start: int = Field(ge=0)
   |

ANN201 Missing return type annotation for public function `api_create_session`
  --> api\session_api.py:16:5
   |
15 | @session_api.route("/api/sessions", methods=["POST"])
16 | def api_create_session():
   |     ^^^^^^^^^^^^^^^^^^
17 |     try:
18 |         data = request.get_json()
   |
help: Add return type annotation

D103 Missing docstring in public function
  --> api\session_api.py:16:5
   |
15 | @session_api.route("/api/sessions", methods=["POST"])
16 | def api_create_session():
   |     ^^^^^^^^^^^^^^^^^^
17 |     try:
18 |         data = request.get_json()
   |

ANN201 Missing return type annotation for public function `api_get_session_info`
  --> api\session_api.py:34:5
   |
33 | @session_api.route("/api/session/info", methods=["GET"])
34 | def api_get_session_info():
   |     ^^^^^^^^^^^^^^^^^^^^
35 |     """Get last session indices and snippet length for a snippet_id."""
36 |     snippet_id = request.args.get("snippet_id", type=int)
   |
help: Add return type annotation

ANN201 Missing return type annotation for public function `api_get_session`
  --> api\session_api.py:48:5
   |
47 | @session_api.route("/api/sessions/<session_id>", methods=["GET"])
48 | def api_get_session(session_id):
   |     ^^^^^^^^^^^^^^^
49 |     session = Session.get_by_id(session_id)
50 |     if not session:
   |
help: Add return type annotation

D103 Missing docstring in public function
  --> api\session_api.py:48:5
   |
47 | @session_api.route("/api/sessions/<session_id>", methods=["GET"])
48 | def api_get_session(session_id):
   |     ^^^^^^^^^^^^^^^
49 |     session = Session.get_by_id(session_id)
50 |     if not session:
   |

ANN001 Missing type annotation for function argument `session_id`
  --> api\session_api.py:48:21
   |
47 | @session_api.route("/api/sessions/<session_id>", methods=["GET"])
48 | def api_get_session(session_id):
   |                     ^^^^^^^^^^
49 |     session = Session.get_by_id(session_id)
50 |     if not session:
   |

ANN201 Missing return type annotation for public function `api_update_session`
  --> api\session_api.py:56:5
   |
55 | @session_api.route("/api/sessions/<session_id>", methods=["PUT"])
56 | def api_update_session(session_id):
   |     ^^^^^^^^^^^^^^^^^^
57 |     session = Session.get_by_id(session_id)
58 |     if not session:
   |
help: Add return type annotation

D103 Missing docstring in public function
  --> api\session_api.py:56:5
   |
55 | @session_api.route("/api/sessions/<session_id>", methods=["PUT"])
56 | def api_update_session(session_id):
   |     ^^^^^^^^^^^^^^^^^^
57 |     session = Session.get_by_id(session_id)
58 |     if not session:
   |

ANN001 Missing type annotation for function argument `session_id`
  --> api\session_api.py:56:24
   |
55 | @session_api.route("/api/sessions/<session_id>", methods=["PUT"])
56 | def api_update_session(session_id):
   |                        ^^^^^^^^^^
57 |     session = Session.get_by_id(session_id)
58 |     if not session:
   |

D212 [*] Multi-line docstring summary should start at the first line
 --> api\unified_graphql.py:1:1
  |
1 | / """
2 | | Unified GraphQL API combining snippet and category operations.
3 | |
4 | | This module provides a single GraphQL schema and endpoint that serves
5 | | both snippet and category operations through a unified interface.
6 | | """
  | |___^
7 |
8 |   # Standard library imports
  |
help: Remove whitespace after opening quotes

D205 1 blank line required between summary line and description
  --> api\unified_graphql.py:39:5
   |
37 |   # Utility to get snippet manager from app context
38 |   def get_snippet_manager() -> SnippetManager:
39 | /     """
40 | |     Get the SnippetManager instance from Flask context.
41 | |     Checks both g object and app.config for the manager.
42 | |     Returns:
43 | |         SnippetManager: The snippet manager instance
44 | |     Raises:
45 | |         RuntimeError: If no snippet manager is found
46 | |     """
   | |_______^
47 |       if hasattr(g, "snippet_manager"):
48 |           return cast(SnippetManager, g.snippet_manager)
   |
help: Insert single blank line

D212 [*] Multi-line docstring summary should start at the first line
  --> api\unified_graphql.py:39:5
   |
37 |   # Utility to get snippet manager from app context
38 |   def get_snippet_manager() -> SnippetManager:
39 | /     """
40 | |     Get the SnippetManager instance from Flask context.
41 | |     Checks both g object and app.config for the manager.
42 | |     Returns:
43 | |         SnippetManager: The snippet manager instance
44 | |     Raises:
45 | |         RuntimeError: If no snippet manager is found
46 | |     """
   | |_______^
47 |       if hasattr(g, "snippet_manager"):
48 |           return cast(SnippetManager, g.snippet_manager)
   |
help: Remove whitespace after opening quotes

D415 First line should end with a period, question mark, or exclamation point
  --> api\unified_graphql.py:39:5
   |
37 |   # Utility to get snippet manager from app context
38 |   def get_snippet_manager() -> SnippetManager:
39 | /     """
40 | |     Get the SnippetManager instance from Flask context.
41 | |     Checks both g object and app.config for the manager.
42 | |     Returns:
43 | |         SnippetManager: The snippet manager instance
44 | |     Raises:
45 | |         RuntimeError: If no snippet manager is found
46 | |     """
   | |_______^
47 |       if hasattr(g, "snippet_manager"):
48 |           return cast(SnippetManager, g.snippet_manager)
   |
help: Add closing punctuation

D411 [*] Missing blank line before section ("Returns")
  --> api\unified_graphql.py:42:5
   |
40 |     Get the SnippetManager instance from Flask context.
41 |     Checks both g object and app.config for the manager.
42 |     Returns:
   |     ^^^^^^^
43 |         SnippetManager: The snippet manager instance
44 |     Raises:
   |
help: Add blank line before "Returns"

D205 1 blank line required between summary line and description
  --> api\unified_graphql.py:58:5
   |
57 |   def get_db_manager() -> DatabaseManager:
58 | /     """
59 | |     Get the DatabaseManager instance from Flask context or app config.
60 | |     Returns:
61 | |         DatabaseManager: The database manager instance
62 | |     Raises:
63 | |         RuntimeError: If no db manager is found
64 | |     """
   | |_______^
65 |       if hasattr(g, "db_manager"):
66 |           return g.db_manager
   |
help: Insert single blank line

D212 [*] Multi-line docstring summary should start at the first line
  --> api\unified_graphql.py:58:5
   |
57 |   def get_db_manager() -> DatabaseManager:
58 | /     """
59 | |     Get the DatabaseManager instance from Flask context or app config.
60 | |     Returns:
61 | |         DatabaseManager: The database manager instance
62 | |     Raises:
63 | |         RuntimeError: If no db manager is found
64 | |     """
   | |_______^
65 |       if hasattr(g, "db_manager"):
66 |           return g.db_manager
   |
help: Remove whitespace after opening quotes

D415 First line should end with a period, question mark, or exclamation point
  --> api\unified_graphql.py:58:5
   |
57 |   def get_db_manager() -> DatabaseManager:
58 | /     """
59 | |     Get the DatabaseManager instance from Flask context or app config.
60 | |     Returns:
61 | |         DatabaseManager: The database manager instance
62 | |     Raises:
63 | |         RuntimeError: If no db manager is found
64 | |     """
   | |_______^
65 |       if hasattr(g, "db_manager"):
66 |           return g.db_manager
   |
help: Add closing punctuation

D411 [*] Missing blank line before section ("Returns")
  --> api\unified_graphql.py:60:5
   |
58 |     """
59 |     Get the DatabaseManager instance from Flask context or app config.
60 |     Returns:
   |     ^^^^^^^
61 |         DatabaseManager: The database manager instance
62 |     Raises:
   |
help: Add blank line before "Returns"

D212 [*] Multi-line docstring summary should start at the first line
  --> api\unified_graphql.py:78:5
   |
77 |   class SnippetType(graphene.ObjectType):  # type: ignore
78 | /     """
79 | |     GraphQL type for snippet model.
80 | |
81 | |     Defines the fields that can be queried for a snippet.
82 | |     """
   | |_______^
83 |
84 |       snippet_id = Int(name="snippetId")
   |
help: Remove whitespace after opening quotes

D212 [*] Multi-line docstring summary should start at the first line
   --> api\unified_graphql.py:100:5
    |
 99 |   class CreateSnippet(Mutation):  # type: ignore
100 | /     """
101 | |     Mutation to create a new snippet.
102 | |
103 | |         Handles the creation of a new snippet with the provided data.
104 | |     """
    | |_______^
105 |
106 |       class Arguments:
    |
help: Remove whitespace after opening quotes

D106 Missing docstring in public nested class
   --> api\unified_graphql.py:106:11
    |
104 |     """
105 |
106 |     class Arguments:
    |           ^^^^^^^^^
107 |         category_id = Int(required=True, name="categoryId")
108 |         snippet_name = String(required=True, name="snippetName")
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `_info`
   --> api\unified_graphql.py:114:22
    |
113 |     def mutate(
114 |         self, _info: Any, category_id: int, snippet_name: str, content: str
    |                      ^^^
115 |     ) -> CreateSnippetOutput:
116 |         """Create a new snippet with the provided data."""
    |

D212 [*] Multi-line docstring summary should start at the first line
   --> api\unified_graphql.py:144:5
    |
143 |   class EditSnippet(Mutation):  # type: ignore
144 | /     """
145 | |     Mutation to edit an existing snippet.
146 | |
147 | |     Handles updating an existing snippet with new name and/or content.
148 | |     Validates the input and returns the updated snippet.
149 | |     """
    | |_______^
150 |
151 |       class Arguments:
    |
help: Remove whitespace after opening quotes

D106 Missing docstring in public nested class
   --> api\unified_graphql.py:151:11
    |
149 |     """
150 |
151 |     class Arguments:
    |           ^^^^^^^^^
152 |         snippet_id = Int(required=True, name="snippetId")
153 |         snippet_name = String(name="snippetName")
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `_info`
   --> api\unified_graphql.py:160:16
    |
158 |     def mutate(
159 |         self,
160 |         _info: Any,
    |                ^^^
161 |         snippet_id: int,
162 |         snippet_name: Optional[str] = None,
    |

D212 [*] Multi-line docstring summary should start at the first line
   --> api\unified_graphql.py:193:5
    |
192 |   class DeleteSnippet(Mutation):  # type: ignore
193 | /     """
194 | |     Mutation to delete a snippet.
195 | |
196 | |     Handles removing an existing snippet from the database.
197 | |     Returns a boolean indicator of success.
198 | |     """
    | |_______^
199 |
200 |       class Arguments:
    |
help: Remove whitespace after opening quotes

D106 Missing docstring in public nested class
   --> api\unified_graphql.py:200:11
    |
198 |     """
199 |
200 |     class Arguments:
    |           ^^^^^^^^^
201 |         snippet_id = Int(required=True, name="snippetId")
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `_info`
   --> api\unified_graphql.py:205:29
    |
203 |     Output = DeleteSnippetOutput
204 |
205 |     def mutate(self, _info: Any, snippet_id: int) -> DeleteSnippetOutput:
    |                             ^^^
206 |         """Delete a snippet by ID."""
207 |         try:
    |

D212 [*] Multi-line docstring summary should start at the first line
   --> api\unified_graphql.py:240:5
    |
239 |   class CreateCategory(Mutation):  # type: ignore
240 | /     """
241 | |     Mutation to create a new category.
242 | |
243 | |     Handles the creation of a new category with the provided name.
244 | |     Validates the input and returns the created category.
245 | |     """
    | |_______^
246 |
247 |       class Arguments:
    |
help: Remove whitespace after opening quotes

D106 Missing docstring in public nested class
   --> api\unified_graphql.py:247:11
    |
245 |     """
246 |
247 |     class Arguments:
    |           ^^^^^^^^^
248 |         category_name = String(required=True, name="categoryName")
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `_info`
   --> api\unified_graphql.py:252:29
    |
250 |     Output = CreateCategoryOutput
251 |
252 |     def mutate(self, _info: Any, category_name: str) -> CreateCategoryOutput:
    |                             ^^^
253 |         """Create a new category with the provided name."""
254 |         try:
    |

D212 [*] Multi-line docstring summary should start at the first line
   --> api\unified_graphql.py:277:5
    |
276 |   class UpdateCategory(Mutation):  # type: ignore
277 | /     """
278 | |     Mutation to update an existing category.
279 | |
280 | |     Handles renaming an existing category with the provided name.
281 | |     Validates the input and returns the updated category.
282 | |     """
    | |_______^
283 |
284 |       class Arguments:
    |
help: Remove whitespace after opening quotes

D106 Missing docstring in public nested class
   --> api\unified_graphql.py:284:11
    |
282 |     """
283 |
284 |     class Arguments:
    |           ^^^^^^^^^
285 |         category_id = Int(required=True, name="categoryId")
286 |         category_name = String(required=True, name="categoryName")
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `_info`
   --> api\unified_graphql.py:291:22
    |
290 |     def mutate(
291 |         self, _info: Any, category_id: int, category_name: str
    |                      ^^^
292 |     ) -> UpdateCategoryOutput:
293 |         """Update an existing category with the provided name."""
    |

D212 [*] Multi-line docstring summary should start at the first line
   --> api\unified_graphql.py:317:5
    |
316 |   class DeleteCategory(Mutation):  # type: ignore
317 | /     """
318 | |     Mutation to delete a category.
319 | |
320 | |     Handles removing an existing category from the database.
321 | |     Also cascades deletion to related snippets.
322 | |     Returns a boolean indicator of success.
323 | |     """
    | |_______^
324 |
325 |       class Arguments:
    |
help: Remove whitespace after opening quotes

D106 Missing docstring in public nested class
   --> api\unified_graphql.py:325:11
    |
323 |     """
324 |
325 |     class Arguments:
    |           ^^^^^^^^^
326 |         category_id = Int(required=True, name="categoryId")
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `_info`
   --> api\unified_graphql.py:330:29
    |
328 |     Output = DeleteCategoryOutput
329 |
330 |     def mutate(self, _info: Any, category_id: int) -> DeleteCategoryOutput:
    |                             ^^^
331 |         """Delete a category by ID."""
332 |         try:
    |

D212 [*] Multi-line docstring summary should start at the first line
   --> api\unified_graphql.py:347:5
    |
346 |   class Query(graphene.ObjectType):  # type: ignore
347 | /     """
348 | |     Unified GraphQL query type combining all entity queries.
349 | |
350 | |     Provides query fields for both snippets and categories,
351 | |     with resolver methods for each field.
352 | |     """
    | |_______^
353 |
354 |       # Snippet queries
    |
help: Remove whitespace after opening quotes

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `_info`
   --> api\unified_graphql.py:362:39
    |
360 |     category = Field(CategoryType, category_id=Int(required=True, name="categoryId"))
361 |
362 |     def resolve_snippets(self, _info: Any, category_id: int) -> TypedList[SnippetModel]:
    |                                       ^^^
363 |         """Resolve all snippets for a given category."""
364 |         manager = get_snippet_manager()
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `_info`
   --> api\unified_graphql.py:367:38
    |
365 |         return manager.list_snippets(category_id)
366 |
367 |     def resolve_snippet(self, _info: Any, snippet_id: int) -> Optional[SnippetModel]:
    |                                      ^^^
368 |         """Resolve a specific snippet by ID."""
369 |         try:
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `_info`
   --> api\unified_graphql.py:375:41
    |
373 |             return None
374 |
375 |     def resolve_categories(self, _info: Any) -> TypedList[Category]:
    |                                         ^^^
376 |         """Resolve all categories."""
377 |         db_manager = get_db_manager()
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `_info`
   --> api\unified_graphql.py:381:39
    |
379 |         return cat_mgr.list_categories()
380 |
381 |     def resolve_category(self, _info: Any, category_id: int) -> Optional[Category]:
    |                                       ^^^
382 |         """Resolve a specific category by ID."""
383 |         try:
    |

D212 [*] Multi-line docstring summary should start at the first line
   --> api\unified_graphql.py:392:5
    |
391 |   class Mutations(graphene.ObjectType):  # type: ignore
392 | /     """
393 | |     Unified GraphQL mutation type combining all entity mutations.
394 | |
395 | |     Contains all available mutations for snippets and categories.
396 | |     """
    | |_______^
397 |
398 |       # Snippet mutations
    |
help: Remove whitespace after opening quotes

D212 [*] Multi-line docstring summary should start at the first line
   --> api\unified_graphql.py:418:5
    |
416 |   @unified_graphql.route("/graphql", methods=["POST"])
417 |   def graphql_api() -> Response:
418 | /     """
419 | |     Unified GraphQL API endpoint for all operations.
420 | |
421 | |     Handles GraphQL queries and mutations for both snippets and categories,
422 | |     returning formatted JSON responses.
423 | |
424 | |     Returns:
425 | |         Response: JSON response with GraphQL execution result
426 | |     """
    | |_______^
427 |       data = request.get_json() or {}
428 |       query = data.get("query", "")
    |
help: Remove whitespace after opening quotes

ANN201 Missing return type annotation for public function `check_schema`
 --> check_db_schema.py:6:5
  |
6 | def check_schema(db_path: str):
  |     ^^^^^^^^^^^^
7 |     """Check the database schema."""
8 |     conn = sqlite3.connect(db_path)
  |
help: Add return type annotation: `None`

D100 Missing docstring in public module
--> conftest.py:1:1

D104 Missing docstring in public package
--> db\__init__.py:1:1

D102 Missing docstring in public method
   --> db\database_manager.py:101:9
    |
 99 |     """Minimal DB-API cursor protocol used by DatabaseManager."""
100 |
101 |     def execute(self, query: str, params: Tuple[object, ...] = ...) -> Self: ...
    |         ^^^^^^^
102 |
103 |     def executemany(self, query: str, seq_of_params: Iterable[Tuple[object, ...]]) -> Self: ...
    |

D102 Missing docstring in public method
   --> db\database_manager.py:103:9
    |
101 |     def execute(self, query: str, params: Tuple[object, ...] = ...) -> Self: ...
102 |
103 |     def executemany(self, query: str, seq_of_params: Iterable[Tuple[object, ...]]) -> Self: ...
    |         ^^^^^^^^^^^
104 |
105 |     def fetchone(self) -> Optional[Union[Dict[str, Any], Tuple[Any, ...]]]: ...
    |

D102 Missing docstring in public method
   --> db\database_manager.py:105:9
    |
103 |     def executemany(self, query: str, seq_of_params: Iterable[Tuple[object, ...]]) -> Self: ...
104 |
105 |     def fetchone(self) -> Optional[Union[Dict[str, Any], Tuple[Any, ...]]]: ...
    |         ^^^^^^^^
106 |
107 |     def fetchall(self) -> List[Union[Dict[str, Any], Tuple[Any, ...]]]: ...
    |

D102 Missing docstring in public method
   --> db\database_manager.py:107:9
    |
105 |     def fetchone(self) -> Optional[Union[Dict[str, Any], Tuple[Any, ...]]]: ...
106 |
107 |     def fetchall(self) -> List[Union[Dict[str, Any], Tuple[Any, ...]]]: ...
    |         ^^^^^^^^
108 |
109 |     def fetchmany(self, size: int = ...) -> List[Union[Dict[str, Any], Tuple[Any, ...]]]: ...
    |

D102 Missing docstring in public method
   --> db\database_manager.py:109:9
    |
107 |     def fetchall(self) -> List[Union[Dict[str, Any], Tuple[Any, ...]]]: ...
108 |
109 |     def fetchmany(self, size: int = ...) -> List[Union[Dict[str, Any], Tuple[Any, ...]]]: ...
    |         ^^^^^^^^^
110 |
111 |     def close(self) -> None: ...
    |

D102 Missing docstring in public method
   --> db\database_manager.py:111:9
    |
109 |     def fetchmany(self, size: int = ...) -> List[Union[Dict[str, Any], Tuple[Any, ...]]]: ...
110 |
111 |     def close(self) -> None: ...
    |         ^^^^^
112 |
113 |     # PostgreSQL-specifics used in bulk COPY
    |

D102 Missing docstring in public method
   --> db\database_manager.py:114:9
    |
113 |     # PostgreSQL-specifics used in bulk COPY
114 |     def copy_from(
    |         ^^^^^^^^^
115 |         self,
116 |         file: TextIO,
    |

D102 Missing docstring in public method
   --> db\database_manager.py:125:9
    |
123 |     # Optional attribute for column metadata
124 |     @property
125 |     def description(self) -> Optional[Sequence[Sequence[Any]]]: ...
    |         ^^^^^^^^^^^
    |

D212 [*] Multi-line docstring summary should start at the first line
   --> db\database_manager.py:145:5
    |
144 |   class DatabaseManager:
145 | /     """
146 | |     Centralized manager for database connections and operations.
147 | |
148 | |     Handles connection management, query execution, schema initialization, and
149 | |     exception translation for the Typing Trainer application. All database access
150 | |     should be performed through this class to ensure consistent error handling and
151 | |     schema management.
152 | |
153 | |     Supports both local SQLite and cloud AWS Aurora PostgreSQL connections.
154 | |     """
    | |_______^
155 |
156 |       def table_exists(self, table_name: str) -> bool:
    |
help: Remove whitespace after opening quotes

D205 1 blank line required between summary line and description
   --> db\database_manager.py:157:9
    |
156 |       def table_exists(self, table_name: str) -> bool:
157 | /         """
158 | |         Check if a table exists in the database (backend-agnostic).
159 | |         Args:
160 | |             table_name: Name of the table to check
161 | |         Returns:
162 | |             True if the table exists, False otherwise
163 | |         """
    | |___________^
164 |           if self.is_postgres:
165 |               query = (
    |
help: Insert single blank line

D212 [*] Multi-line docstring summary should start at the first line
   --> db\database_manager.py:157:9
    |
156 |       def table_exists(self, table_name: str) -> bool:
157 | /         """
158 | |         Check if a table exists in the database (backend-agnostic).
159 | |         Args:
160 | |             table_name: Name of the table to check
161 | |         Returns:
162 | |             True if the table exists, False otherwise
163 | |         """
    | |___________^
164 |           if self.is_postgres:
165 |               query = (
    |
help: Remove whitespace after opening quotes

D415 First line should end with a period, question mark, or exclamation point
   --> db\database_manager.py:157:9
    |
156 |       def table_exists(self, table_name: str) -> bool:
157 | /         """
158 | |         Check if a table exists in the database (backend-agnostic).
159 | |         Args:
160 | |             table_name: Name of the table to check
161 | |         Returns:
162 | |             True if the table exists, False otherwise
163 | |         """
    | |___________^
164 |           if self.is_postgres:
165 |               query = (
    |
help: Add closing punctuation

D411 [*] Missing blank line before section ("Args")
   --> db\database_manager.py:159:9
    |
157 |         """
158 |         Check if a table exists in the database (backend-agnostic).
159 |         Args:
    |         ^^^^
160 |             table_name: Name of the table to check
161 |         Returns:
    |
help: Add blank line before "Args"

D205 1 blank line required between summary line and description
   --> db\database_manager.py:178:9
    |
177 |       def list_tables(self) -> List[str]:
178 | /         """
179 | |         Return a list of all user table names in the database, backend-agnostic.
180 | |         Returns:
181 | |             A list of table names as strings
182 | |         """
    | |___________^
183 |           if self.is_postgres:
184 |               # For PostgreSQL, use information_schema
    |
help: Insert single blank line

D212 [*] Multi-line docstring summary should start at the first line
   --> db\database_manager.py:178:9
    |
177 |       def list_tables(self) -> List[str]:
178 | /         """
179 | |         Return a list of all user table names in the database, backend-agnostic.
180 | |         Returns:
181 | |             A list of table names as strings
182 | |         """
    | |___________^
183 |           if self.is_postgres:
184 |               # For PostgreSQL, use information_schema
    |
help: Remove whitespace after opening quotes

D415 First line should end with a period, question mark, or exclamation point
   --> db\database_manager.py:178:9
    |
177 |       def list_tables(self) -> List[str]:
178 | /         """
179 | |         Return a list of all user table names in the database, backend-agnostic.
180 | |         Returns:
181 | |             A list of table names as strings
182 | |         """
    | |___________^
183 |           if self.is_postgres:
184 |               # For PostgreSQL, use information_schema
    |
help: Add closing punctuation

D411 [*] Missing blank line before section ("Returns")
   --> db\database_manager.py:180:9
    |
178 |         """
179 |         Return a list of all user table names in the database, backend-agnostic.
180 |         Returns:
    |         ^^^^^^^
181 |             A list of table names as strings
182 |         """
    |
help: Add blank line before "Returns"

D212 [*] Multi-line docstring summary should start at the first line
   --> db\database_manager.py:214:9
    |
212 |           debug_util: Optional[object] = None,
213 |       ) -> None:
214 | /         """
215 | |         Initialize a DatabaseManager with the specified connection type and parameters.
216 | |
217 | |         Args:
218 | |             db_path: Path to SQLite database file or ":memory:" for in-memory database.
219 | |                     If None, creates an in-memory database.
220 | |                     Only used when connection_type is LOCAL.
221 | |             connection_type: Whether to use local SQLite or cloud Aurora PostgreSQL.
222 | |             debug_util: Optional DebugUtil instance for handling debug output.
223 | |
224 | |         Raises:
225 | |             DBConnectionError: If the database connection cannot be established.
226 | |             ImportError: If cloud dependencies are not available when cloud connection
227 | |                 is requested.
228 | |         """
    | |___________^
229 |           self.connection_type = connection_type
230 |           self.db_path: str = db_path or ":memory:"
    |
help: Remove whitespace after opening quotes

D212 [*] Multi-line docstring summary should start at the first line
   --> db\database_manager.py:254:9
    |
253 |       def _connect_sqlite(self) -> None:
254 | /         """
255 | |         Establish connection to a local SQLite database.
256 | |
257 | |         Raises:
258 | |             DBConnectionError: If the database connection cannot be established.
259 | |         """
    | |___________^
260 |           try:
261 |               self._conn = sqlite3.connect(self.db_path)
    |
help: Remove whitespace after opening quotes

D212 [*] Multi-line docstring summary should start at the first line
   --> db\database_manager.py:272:9
    |
271 |       def _connect_aurora(self) -> None:
272 | /         """
273 | |         Establish connection to AWS Aurora PostgreSQL.
274 | |
275 | |         Raises:
276 | |             DBConnectionError: If the database connection cannot be established.
277 | |         """
    | |___________^
278 |           try:
279 |               # Get secrets from AWS Secrets Manager
    |
help: Remove whitespace after opening quotes

D212 [*] Multi-line docstring summary should start at the first line
   --> db\database_manager.py:347:9
    |
346 |       def close(self) -> None:
347 | /         """
348 | |         Close the SQLite database connection.
349 | |
350 | |         Raises:
351 | |             DBConnectionError: If closing the connection fails.
352 | |         """
    | |___________^
353 |           try:
354 |               self._conn.close()
    |
help: Remove whitespace after opening quotes

D212 [*] Multi-line docstring summary should start at the first line
   --> db\database_manager.py:364:9
    |
363 |       def _get_cursor(self) -> CursorProtocol:
364 | /         """
365 | |         Get a cursor from the database connection.
366 | |
367 | |         Returns:
368 | |             A database cursor (either sqlite3.Cursor or psycopg2 cursor).
369 | |
370 | |         Raises:
371 | |             DBConnectionError: If the database connection is not established.
372 | |         """
    | |___________^
373 |           if not self._conn:
374 |               raise DBConnectionError("Database connection is not established")
    |
help: Remove whitespace after opening quotes

D205 1 blank line required between summary line and description
   --> db\database_manager.py:378:9
    |
377 |       def _execute_ddl(self, query: str) -> None:
378 | /         """
379 | |         Execute DDL (Data Definition Language) statements consistently across both
380 | |         SQLite and PostgreSQL connections using a cursor-based approach.
381 | |
382 | |         Args:
383 | |             query: SQL DDL statement to execute
384 | |
385 | |         Raises:
386 | |             Various database exceptions depending on the error type
387 | |         """
    | |___________^
388 |           cursor = self._conn.cursor()
389 |           cursor.execute(query)
    |
help: Insert single blank line

D212 [*] Multi-line docstring summary should start at the first line
   --> db\database_manager.py:378:9
    |
377 |       def _execute_ddl(self, query: str) -> None:
378 | /         """
379 | |         Execute DDL (Data Definition Language) statements consistently across both
380 | |         SQLite and PostgreSQL connections using a cursor-based approach.
381 | |
382 | |         Args:
383 | |             query: SQL DDL statement to execute
384 | |
385 | |         Raises:
386 | |             Various database exceptions depending on the error type
387 | |         """
    | |___________^
388 |           cursor = self._conn.cursor()
389 |           cursor.execute(query)
    |
help: Remove whitespace after opening quotes

D212 [*] Multi-line docstring summary should start at the first line
   --> db\database_manager.py:394:9
    |
393 |       def _qualify_schema_in_query(self, query: str) -> str:
394 | /         """
395 | |         Prepare queries for PostgreSQL execution.
396 | |
397 | |         Since the connection is configured with search_path=typing,public,
398 | |         unqualified table names will automatically resolve to the typing schema.
399 | |         This method only handles placeholder conversion and minimal DDL qualification
400 | |         where explicit schema specification is required.
401 | |         """
    | |___________^
402 |           # Convert SQLite-style placeholders to PostgreSQL-style
403 |           if "?" in query:
    |
help: Remove whitespace after opening quotes

D212 [*] Multi-line docstring summary should start at the first line
   --> db\database_manager.py:497:9
    |
496 |       def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
497 | /         """
498 | |         Execute a SQL query with parameters and commit immediately.
499 | |
500 | |         Args:
501 | |             query: SQL query string (parameterized)
502 | |             params: Query parameters
503 | |
504 | |         Returns:
505 | |             Database cursor object
506 | |
507 | |         Raises:
508 | |             DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
509 | |             ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
510 | |         """
    | |___________^
511 |           try:
512 |               cursor: CursorProtocol = self._get_cursor()
    |
help: Remove whitespace after opening quotes

B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
   --> db\database_manager.py:540:13
    |
538 |                 self._debug_message(f" Rollback failed: {rollback_exc}")
539 |             self._translate_and_raise(e)
540 |             raise AssertionError("unreachable")
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
541 |
542 |     def execute_many(
    |

B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
   --> db\database_manager.py:630:13
    |
628 |                 self._debug_message(f" Rollback failed: {rollback_exc}")
629 |             self._translate_and_raise(e)
630 |             raise AssertionError("unreachable")
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
631 |
632 |     # --- Bulk helper methods for execute_many ---
    |

D301 Use `r"""` if any backslashes in a docstring
   --> db\database_manager.py:697:9
    |
695 |           params_list: List[Tuple[object, ...]],
696 |       ) -> CursorProtocol:
697 | /         """Use ``COPY FROM STDIN`` for fast ingestion of INSERT-like data on Postgres.
698 | |
699 | |         - Backend: PostgreSQL only. Requires that the active connection has the
700 | |           search_path set (handled during connection) and the table exists in the
701 | |           configured schema.
702 | |         - Statement: must be an ``INSERT INTO <table>(cols...) VALUES (...)``-style
703 | |           statement. We parse table and columns, and stream data as TSV with ``\n``
704 | |           line terminators, ``\t`` separators, and ``\\N`` for NULLs.
705 | |         - Data sanitation: tabs/newlines in values are replaced with spaces.
706 | |         - Commit: commits when the statement is non-SELECT.
707 | |         - Errors: raises ``DatabaseTypeError`` for incompatible statements or length
708 | |           mismatches; backend errors are handled by caller via ``_translate_and_raise``.
709 | |         """
    | |___________^
710 |           import io
711 |           import re
    |
help: Add `r` prefix

D212 [*] Multi-line docstring summary should start at the first line
   --> db\database_manager.py:768:9
    |
767 |       def fetchone(self, query: str, params: Tuple[Any, ...] = ()) -> Optional[Dict[str, Any]]:
768 | /         """
769 | |         Execute a SQL query and fetch a single result.
770 | |
771 | |         Args:
772 | |             query: SQL query string (parameterized)
773 | |             params: Query parameters
774 | |
775 | |         Returns:
776 | |             Dict representing fetched row, or None if no results
777 | |             Both SQLite and PostgreSQL results are returned as dictionaries with col names as keys
778 | |
779 | |         Raises:
780 | |             DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
781 | |             ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
782 | |         """
    | |___________^
783 |           cursor = self.execute(query, params)
784 |           result = cursor.fetchone()
    |
help: Remove whitespace after opening quotes

D212 [*] Multi-line docstring summary should start at the first line
   --> db\database_manager.py:803:9
    |
801 |           self, query: str, params: Tuple[Any, ...] = (), size: int = 1
802 |       ) -> List[Dict[str, Any]]:
803 | /         """
804 | |         Execute a SQL query and fetch multiple results.
805 | |
806 | |         Args:
807 | |             query: SQL query string (parameterized)
808 | |             params: Query parameters
809 | |             size: Number of rows to fetch
810 | |
811 | |         Returns:
812 | |             List of Dict representing fetched rows
813 | |             Both SQLite and PostgreSQL results are returned as dictionaries with col names as keys
814 | |
815 | |         Raises:
816 | |             DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
817 | |             ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
818 | |         """
    | |___________^
819 |           cursor = self.execute(query, params)
820 |           results = cursor.fetchmany(size)
    |
help: Remove whitespace after opening quotes

D212 [*] Multi-line docstring summary should start at the first line
   --> db\database_manager.py:833:9
    |
832 |       def fetchall(self, query: str, params: Tuple[Any, ...] = ()) -> List[Dict[str, Any]]:
833 | /         """
834 | |         Execute a query and return all rows as a list.
835 | |
836 | |         Args:
837 | |             query: SQL query string (parameterized)
838 | |             params: Query parameters
839 | |
840 | |         Returns:
841 | |             A list of dictionaries, with each dictionary representing a row
842 | |             Both SQLite and PostgreSQL results are returned as dictionaries with col names as keys
843 | |
844 | |         Raises:
845 | |             DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
846 | |             ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
847 | |         """
    | |___________^
848 |           cursor = self.execute(query, params)
849 |           results = cursor.fetchall()
    |
help: Remove whitespace after opening quotes

D205 1 blank line required between summary line and description
    --> db\database_manager.py:1151:9
     |
1150 |       def _create_keyboards_table(self) -> None:
1151 | /         """Create the keyboards table with UUID primary key and user_id foreign key
1152 | |         if it does not exist.
1153 | |         """
     | |___________^
1154 |           self._execute_ddl(
1155 |               """
     |
help: Insert single blank line

D205 1 blank line required between summary line and description
    --> db\database_manager.py:1209:9
     |
1208 |       def init_tables(self) -> None:
1209 | /         """Initialize all database tables by creating them if they do not exist.
1210 | |         This includes core tables for categories, snippets, session data, users,
1211 | |         keyboards, and settings.
1212 | |         """
     | |___________^
1213 |           self._create_categories_table()
1214 |           self._create_words_table()
     |
help: Insert single blank line

D212 [*] Multi-line docstring summary should start at the first line
    --> db\database_manager.py:1229:9
     |
1228 |       def __enter__(self) -> "DatabaseManager":
1229 | /         """
1230 | |         Context manager protocol support.
1231 | |
1232 | |         Returns:
1233 | |             Self for using in with statements.
1234 | |         """
     | |___________^
1235 |           return self
     |
help: Remove whitespace after opening quotes

D200 One-line docstring should fit on one line
    --> db\database_manager.py:1243:9
     |
1241 |           exc_tb: object,
1242 |       ) -> None:
1243 | /         """
1244 | |         Context manager protocol support - close connection when exiting context.
1245 | |         """
     | |___________^
1246 |           self.close()
     |
help: Reformat to one line

D212 [*] Multi-line docstring summary should start at the first line
    --> db\database_manager.py:1243:9
     |
1241 |           exc_tb: object,
1242 |       ) -> None:
1243 | /         """
1244 | |         Context manager protocol support - close connection when exiting context.
1245 | |         """
     | |___________^
1246 |           self.close()
     |
help: Remove whitespace after opening quotes

D200 One-line docstring should fit on one line
 --> db\exceptions.py:1:1
  |
1 | / """
2 | | Custom database exceptions for the AI Typing Trainer application.
3 | | """
  | |___^
  |
help: Reformat to one line

D212 [*] Multi-line docstring summary should start at the first line
 --> db\exceptions.py:1:1
  |
1 | / """
2 | | Custom database exceptions for the AI Typing Trainer application.
3 | | """
  | |___^
  |
help: Remove whitespace after opening quotes

D102 Missing docstring in public method
  --> db\interfaces.py:19:9
   |
17 |     """
18 |
19 |     def execute(self, query: str, params: Tuple[object, ...] = ()) -> object:
   |         ^^^^^^^
20 |         ...
   |

D102 Missing docstring in public method
  --> db\interfaces.py:23:9
   |
22 |     @property
23 |     def execute_many_supported(self) -> bool:
   |         ^^^^^^^^^^^^^^^^^^^^^^
24 |         ...
   |

D102 Missing docstring in public method
  --> db\interfaces.py:26:9
   |
24 |         ...
25 |
26 |     def execute_many(self, query: str, params_seq: Iterable[Tuple[object, ...]]) -> object:
   |         ^^^^^^^^^^^^
27 |         ...
   |

D100 Missing docstring in public module
--> db\migrations\check_snippet_parts_count.py:1:1

ANN201 Missing return type annotation for public function `get_aurora_connection`
  --> db\migrations\check_snippet_parts_count.py:25:5
   |
23 | SCHEMA_NAME = "typing"
24 |
25 | def get_aurora_connection():
   |     ^^^^^^^^^^^^^^^^^^^^^
26 |     """Get a connection to AWS Aurora PostgreSQL."""
27 |     try:
   |
help: Add return type annotation

ANN201 Missing return type annotation for public function `get_sqlite_connection`
  --> db\migrations\check_snippet_parts_count.py:65:5
   |
63 |         raise
64 |
65 | def get_sqlite_connection(db_path):
   |     ^^^^^^^^^^^^^^^^^^^^^
66 |     """Get a connection to SQLite database."""
67 |     try:
   |
help: Add return type annotation

ANN001 Missing type annotation for function argument `db_path`
  --> db\migrations\check_snippet_parts_count.py:65:27
   |
63 |         raise
64 |
65 | def get_sqlite_connection(db_path):
   |                           ^^^^^^^
66 |     """Get a connection to SQLite database."""
67 |     try:
   |

ANN201 Missing return type annotation for public function `main`
  --> db\migrations\check_snippet_parts_count.py:74:5
   |
72 |         raise
73 |
74 | def main():
   |     ^^^^
75 |     """Main entry point for checking snippet_parts row counts."""
76 |     if len(sys.argv) != 2:
   |
help: Add return type annotation: `int | None`

D205 1 blank line required between summary line and description
  --> db\migrations\migrate_snippet_parts.py:2:1
   |
 1 |   #!/usr/bin/env python3
 2 | / """
 3 | | Migration script specifically focused on migrating the snippet_parts table
 4 | | from SQLite to AWS Aurora PostgreSQL.
 5 | |
 6 | | This script:
 7 | | 1. Extracts the snippet_parts schema from SQLite
 8 | | 2. Drops and recreates the table in Aurora with identical schema
 9 | | 3. Migrates rows one by one
10 | | 4. Verifies each row after insertion
11 | | 5. Alerts on any failures
12 | | """
   | |___^
13 |
14 |   import argparse
   |
help: Insert single blank line

D212 [*] Multi-line docstring summary should start at the first line
  --> db\migrations\migrate_snippet_parts.py:2:1
   |
 1 |   #!/usr/bin/env python3
 2 | / """
 3 | | Migration script specifically focused on migrating the snippet_parts table
 4 | | from SQLite to AWS Aurora PostgreSQL.
 5 | |
 6 | | This script:
 7 | | 1. Extracts the snippet_parts schema from SQLite
 8 | | 2. Drops and recreates the table in Aurora with identical schema
 9 | | 3. Migrates rows one by one
10 | | 4. Verifies each row after insertion
11 | | 5. Alerts on any failures
12 | | """
   | |___^
13 |
14 |   import argparse
   |
help: Remove whitespace after opening quotes

F401 [*] `traceback` imported but unused
  --> db\migrations\migrate_snippet_parts.py:19:8
   |
17 | import sqlite3
18 | import sys
19 | import traceback
   |        ^^^^^^^^^
20 | import uuid
   |
help: Remove unused import: `traceback`

ANN201 Missing return type annotation for public function `get_aurora_connection`
  --> db\migrations\migrate_snippet_parts.py:46:5
   |
44 | SCHEMA_NAME = "typing"
45 |
46 | def get_aurora_connection():
   |     ^^^^^^^^^^^^^^^^^^^^^
47 |     """Connect to AWS Aurora using credentials from Secrets Manager."""
48 |     try:
   |
help: Add return type annotation

E501 Line too long (121 > 120)
  --> db\migrations\migrate_snippet_parts.py:83:121
   |
81 |             logger.error(f"Failed to connect to Aurora database: {e}")
82 |             logger.error(
83 |                 f"Connection details: host={cfg['host']}, port={cfg['port']}, db={cfg['dbname']}, user={cfg['username']}"
   |                                                                                                                         ^
84 |             )
85 |             raise
   |

ANN201 Missing return type annotation for public function `get_sqlite_connection`
  --> db\migrations\migrate_snippet_parts.py:94:5
   |
94 | def get_sqlite_connection(db_path):
   |     ^^^^^^^^^^^^^^^^^^^^^
95 |     """Connect to SQLite database."""
96 |     if not os.path.exists(db_path):
   |
help: Add return type annotation

ANN001 Missing type annotation for function argument `db_path`
  --> db\migrations\migrate_snippet_parts.py:94:27
   |
94 | def get_sqlite_connection(db_path):
   |                           ^^^^^^^
95 |     """Connect to SQLite database."""
96 |     if not os.path.exists(db_path):
   |

ANN201 Missing return type annotation for public function `get_sqlite_schema`
   --> db\migrations\migrate_snippet_parts.py:103:5
    |
103 | def get_sqlite_schema(conn):
    |     ^^^^^^^^^^^^^^^^^
104 |     """Get the snippet_parts table schema from SQLite."""
105 |     cursor = conn.cursor()
    |
help: Add return type annotation

ANN001 Missing type annotation for function argument `conn`
   --> db\migrations\migrate_snippet_parts.py:103:23
    |
103 | def get_sqlite_schema(conn):
    |                       ^^^^
104 |     """Get the snippet_parts table schema from SQLite."""
105 |     cursor = conn.cursor()
    |

ANN201 Missing return type annotation for public function `recreate_aurora_snippet_parts_table`
   --> db\migrations\migrate_snippet_parts.py:116:5
    |
116 | def recreate_aurora_snippet_parts_table(conn):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
117 |     """Drop and recreate the snippet_parts table in Aurora with PostgreSQL-compatible syntax."""
118 |     cursor = conn.cursor()
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `conn`
   --> db\migrations\migrate_snippet_parts.py:116:41
    |
116 | def recreate_aurora_snippet_parts_table(conn):
    |                                         ^^^^
117 |     """Drop and recreate the snippet_parts table in Aurora with PostgreSQL-compatible syntax."""
118 |     cursor = conn.cursor()
    |

ANN201 Missing return type annotation for public function `row_to_dict`
   --> db\migrations\migrate_snippet_parts.py:146:5
    |
146 | def row_to_dict(cursor, row):
    |     ^^^^^^^^^^^
147 |     """Convert a row tuple to a dictionary with column names as keys."""
148 |     return {col[0]: row[idx] for idx, col in enumerate(cursor.description)}
    |
help: Add return type annotation

ANN001 Missing type annotation for function argument `cursor`
   --> db\migrations\migrate_snippet_parts.py:146:17
    |
146 | def row_to_dict(cursor, row):
    |                 ^^^^^^
147 |     """Convert a row tuple to a dictionary with column names as keys."""
148 |     return {col[0]: row[idx] for idx, col in enumerate(cursor.description)}
    |

ANN001 Missing type annotation for function argument `row`
   --> db\migrations\migrate_snippet_parts.py:146:25
    |
146 | def row_to_dict(cursor, row):
    |                         ^^^
147 |     """Convert a row tuple to a dictionary with column names as keys."""
148 |     return {col[0]: row[idx] for idx, col in enumerate(cursor.description)}
    |

ANN201 Missing return type annotation for public function `get_all_snippet_parts_rows`
   --> db\migrations\migrate_snippet_parts.py:151:5
    |
151 | def get_all_snippet_parts_rows(conn):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^
152 |     """Get all rows from the snippet_parts table in SQLite."""
153 |     cursor = conn.cursor()
    |
help: Add return type annotation

ANN001 Missing type annotation for function argument `conn`
   --> db\migrations\migrate_snippet_parts.py:151:32
    |
151 | def get_all_snippet_parts_rows(conn):
    |                                ^^^^
152 |     """Get all rows from the snippet_parts table in SQLite."""
153 |     cursor = conn.cursor()
    |

ANN201 Missing return type annotation for public function `migrate_and_verify_rows`
   --> db\migrations\migrate_snippet_parts.py:171:5
    |
171 | def migrate_and_verify_rows(sqlite_conn, aurora_conn):
    |     ^^^^^^^^^^^^^^^^^^^^^^^
172 |     """Migrate rows from SQLite to Aurora one by one, verifying each after insertion."""
173 |     rows, columns = get_all_snippet_parts_rows(sqlite_conn)
    |
help: Add return type annotation

ANN001 Missing type annotation for function argument `sqlite_conn`
   --> db\migrations\migrate_snippet_parts.py:171:29
    |
171 | def migrate_and_verify_rows(sqlite_conn, aurora_conn):
    |                             ^^^^^^^^^^^
172 |     """Migrate rows from SQLite to Aurora one by one, verifying each after insertion."""
173 |     rows, columns = get_all_snippet_parts_rows(sqlite_conn)
    |

ANN001 Missing type annotation for function argument `aurora_conn`
   --> db\migrations\migrate_snippet_parts.py:171:42
    |
171 | def migrate_and_verify_rows(sqlite_conn, aurora_conn):
    |                                          ^^^^^^^^^^^
172 |     """Migrate rows from SQLite to Aurora one by one, verifying each after insertion."""
173 |     rows, columns = get_all_snippet_parts_rows(sqlite_conn)
    |

E501 Line too long (129 > 120)
   --> db\migrations\migrate_snippet_parts.py:239:121
    |
238 |                     if sqlite_val != aurora_val:
239 |                         logger.error(f"Row {i+1}/{len(rows)} mismatch in column {col}: SQLite={sqlite_val}, Aurora={aurora_val}")
    |                                                                                                                         ^^^^^^^^^
240 |                         match = False
    |

ANN201 Missing return type annotation for public function `verify_only`
   --> db\migrations\migrate_snippet_parts.py:270:5
    |
270 | def verify_only(sqlite_conn, aurora_conn):
    |     ^^^^^^^^^^^
271 |     """Check and compare row counts between SQLite and Aurora without migration."""
272 |     # SQLite count
    |
help: Add return type annotation

ANN001 Missing type annotation for function argument `sqlite_conn`
   --> db\migrations\migrate_snippet_parts.py:270:17
    |
270 | def verify_only(sqlite_conn, aurora_conn):
    |                 ^^^^^^^^^^^
271 |     """Check and compare row counts between SQLite and Aurora without migration."""
272 |     # SQLite count
    |

ANN001 Missing type annotation for function argument `aurora_conn`
   --> db\migrations\migrate_snippet_parts.py:270:30
    |
270 | def verify_only(sqlite_conn, aurora_conn):
    |                              ^^^^^^^^^^^
271 |     """Check and compare row counts between SQLite and Aurora without migration."""
272 |     # SQLite count
    |

ANN201 Missing return type annotation for public function `main`
   --> db\migrations\migrate_snippet_parts.py:296:5
    |
296 | def main():
    |     ^^^^
297 |     """Main entry point for the snippet_parts migration script."""
298 |     parser = argparse.ArgumentParser(description="Migrate snippet_parts table from SQLite to AWS Aurora")
    |
help: Add return type annotation: `int | None`

E501 Line too long (121 > 120)
   --> db\migrations\migrate_snippet_parts.py:300:121
    |
298 |     parser = argparse.ArgumentParser(description="Migrate snippet_parts table from SQLite to AWS Aurora")
299 |     parser.add_argument("--db-path", required=True, help="Path to SQLite database")
300 |     parser.add_argument("--verify-only", action="store_true", help="Only verify row counts without performing migration")
    |                                                                                                                         ^
301 |     args = parser.parse_args()
    |

D212 [*] Multi-line docstring summary should start at the first line
  --> db\migrations\migrate_sqlite_to_aurora.py:2:1
   |
 1 |   #!/usr/bin/env python3
 2 | / """
 3 | | Migration script to move data from local SQLite database to AWS Aurora.
 4 | |
 5 | | This script connects to AWS Aurora using AWS Secrets Manager credentials,
 6 | | creates all necessary tables in Aurora with PostgreSQL compatible syntax,
 7 | | and copies all data from the local SQLite database to Aurora.
 8 | | """
   | |___^
 9 |
10 |   import argparse
   |
help: Remove whitespace after opening quotes

ANN201 Missing return type annotation for public function `get_aurora_connection`
  --> db\migrations\migrate_sqlite_to_aurora.py:36:5
   |
36 | def get_aurora_connection():
   |     ^^^^^^^^^^^^^^^^^^^^^
37 |     """Connect to AWS Aurora using credentials from Secrets Manager."""
38 |     try:
   |
help: Add return type annotation

E501 Line too long (121 > 120)
  --> db\migrations\migrate_sqlite_to_aurora.py:73:121
   |
71 |             logger.error(f"Failed to connect to Aurora database: {e}")
72 |             logger.error(
73 |                 f"Connection details: host={cfg['host']}, port={cfg['port']}, db={cfg['dbname']}, user={cfg['username']}"
   |                                                                                                                         ^
74 |             )
75 |             raise
   |

ANN201 Missing return type annotation for public function `get_sqlite_connection`
  --> db\migrations\migrate_sqlite_to_aurora.py:84:5
   |
84 | def get_sqlite_connection(db_path):
   |     ^^^^^^^^^^^^^^^^^^^^^
85 |     """Connect to SQLite database."""
86 |     try:
   |
help: Add return type annotation

ANN001 Missing type annotation for function argument `db_path`
  --> db\migrations\migrate_sqlite_to_aurora.py:84:27
   |
84 | def get_sqlite_connection(db_path):
   |                           ^^^^^^^
85 |     """Connect to SQLite database."""
86 |     try:
   |

ANN201 Missing return type annotation for public function `ensure_schema_exists`
  --> db\migrations\migrate_sqlite_to_aurora.py:95:5
   |
95 | def ensure_schema_exists(conn):
   |     ^^^^^^^^^^^^^^^^^^^^
96 |     """Create the schema if it doesn't exist."""
97 |     cursor = conn.cursor()
   |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `conn`
  --> db\migrations\migrate_sqlite_to_aurora.py:95:26
   |
95 | def ensure_schema_exists(conn):
   |                          ^^^^
96 |     """Create the schema if it doesn't exist."""
97 |     cursor = conn.cursor()
   |

ANN201 Missing return type annotation for public function `create_aurora_tables`
   --> db\migrations\migrate_sqlite_to_aurora.py:103:5
    |
103 | def create_aurora_tables(conn):
    |     ^^^^^^^^^^^^^^^^^^^^
104 |     """Create all required tables in Aurora."""
105 |     cursor = conn.cursor()
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `conn`
   --> db\migrations\migrate_sqlite_to_aurora.py:103:26
    |
103 | def create_aurora_tables(conn):
    |                          ^^^^
104 |     """Create all required tables in Aurora."""
105 |     cursor = conn.cursor()
    |

ANN201 Missing return type annotation for public function `copy_table_data`
   --> db\migrations\migrate_sqlite_to_aurora.py:268:5
    |
268 | def copy_table_data(sqlite_conn, aurora_conn, table_name, debug=False):
    |     ^^^^^^^^^^^^^^^
269 |     """Copy data from SQLite table to Aurora table."""
270 |     sqlite_cursor = sqlite_conn.cursor()
    |
help: Add return type annotation

ANN001 Missing type annotation for function argument `sqlite_conn`
   --> db\migrations\migrate_sqlite_to_aurora.py:268:21
    |
268 | def copy_table_data(sqlite_conn, aurora_conn, table_name, debug=False):
    |                     ^^^^^^^^^^^
269 |     """Copy data from SQLite table to Aurora table."""
270 |     sqlite_cursor = sqlite_conn.cursor()
    |

ANN001 Missing type annotation for function argument `aurora_conn`
   --> db\migrations\migrate_sqlite_to_aurora.py:268:34
    |
268 | def copy_table_data(sqlite_conn, aurora_conn, table_name, debug=False):
    |                                  ^^^^^^^^^^^
269 |     """Copy data from SQLite table to Aurora table."""
270 |     sqlite_cursor = sqlite_conn.cursor()
    |

ANN001 Missing type annotation for function argument `table_name`
   --> db\migrations\migrate_sqlite_to_aurora.py:268:47
    |
268 | def copy_table_data(sqlite_conn, aurora_conn, table_name, debug=False):
    |                                               ^^^^^^^^^^
269 |     """Copy data from SQLite table to Aurora table."""
270 |     sqlite_cursor = sqlite_conn.cursor()
    |

ANN001 Missing type annotation for function argument `debug`
   --> db\migrations\migrate_sqlite_to_aurora.py:268:59
    |
268 | def copy_table_data(sqlite_conn, aurora_conn, table_name, debug=False):
    |                                                           ^^^^^
269 |     """Copy data from SQLite table to Aurora table."""
270 |     sqlite_cursor = sqlite_conn.cursor()
    |

B905 [*] `zip()` without an explicit `strict=` parameter
   --> db\migrations\migrate_sqlite_to_aurora.py:287:57
    |
285 |         if debug:
286 |             logger.info(f"Table {table_name} structure: {column_names}")
287 |             logger.info(f"Sample row from SQLite: {dict(zip(column_names, rows[0]))}")
    |                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
288 |
289 |         # Build the INSERT statement for Aurora
    |
help: Add explicit value for parameter `strict=`

ANN201 Missing return type annotation for public function `migrate_single_table`
   --> db\migrations\migrate_sqlite_to_aurora.py:336:5
    |
336 | def migrate_single_table(sqlite_conn, aurora_conn, table_name):
    |     ^^^^^^^^^^^^^^^^^^^^
337 |     """Migrate just a single table with debug info."""
338 |     logger.info(f"Starting focused migration of table: {table_name}")
    |
help: Add return type annotation

ANN001 Missing type annotation for function argument `sqlite_conn`
   --> db\migrations\migrate_sqlite_to_aurora.py:336:26
    |
336 | def migrate_single_table(sqlite_conn, aurora_conn, table_name):
    |                          ^^^^^^^^^^^
337 |     """Migrate just a single table with debug info."""
338 |     logger.info(f"Starting focused migration of table: {table_name}")
    |

ANN001 Missing type annotation for function argument `aurora_conn`
   --> db\migrations\migrate_sqlite_to_aurora.py:336:39
    |
336 | def migrate_single_table(sqlite_conn, aurora_conn, table_name):
    |                                       ^^^^^^^^^^^
337 |     """Migrate just a single table with debug info."""
338 |     logger.info(f"Starting focused migration of table: {table_name}")
    |

ANN001 Missing type annotation for function argument `table_name`
   --> db\migrations\migrate_sqlite_to_aurora.py:336:52
    |
336 | def migrate_single_table(sqlite_conn, aurora_conn, table_name):
    |                                                    ^^^^^^^^^^
337 |     """Migrate just a single table with debug info."""
338 |     logger.info(f"Starting focused migration of table: {table_name}")
    |

ANN201 Missing return type annotation for public function `fix_snippet_parts`
   --> db\migrations\migrate_sqlite_to_aurora.py:363:5
    |
363 | def fix_snippet_parts(sqlite_conn, aurora_conn):
    |     ^^^^^^^^^^^^^^^^^
364 |     """Special handler for snippet_parts table to fix NULL primary key issue."""
365 |     logger.info("Using special handler for snippet_parts table")
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `sqlite_conn`
   --> db\migrations\migrate_sqlite_to_aurora.py:363:23
    |
363 | def fix_snippet_parts(sqlite_conn, aurora_conn):
    |                       ^^^^^^^^^^^
364 |     """Special handler for snippet_parts table to fix NULL primary key issue."""
365 |     logger.info("Using special handler for snippet_parts table")
    |

ANN001 Missing type annotation for function argument `aurora_conn`
   --> db\migrations\migrate_sqlite_to_aurora.py:363:36
    |
363 | def fix_snippet_parts(sqlite_conn, aurora_conn):
    |                                    ^^^^^^^^^^^
364 |     """Special handler for snippet_parts table to fix NULL primary key issue."""
365 |     logger.info("Using special handler for snippet_parts table")
    |

E501 Line too long (125 > 120)
   --> db\migrations\migrate_sqlite_to_aurora.py:425:121
    |
423 |                     import uuid
424 |                     row_values[0] = str(uuid.uuid4())
425 |                     logger.info(f"Generated new part_id {row_values[0]} for snippet_id {row_values[1]} part {row_values[2]}")
    |                                                                                                                         ^^^^^
426 |
427 |                 # Ensure content isn't too long
    |

ANN201 Missing return type annotation for public function `migrate_data`
   --> db\migrations\migrate_sqlite_to_aurora.py:472:5
    |
472 | def migrate_data(sqlite_conn, aurora_conn):
    |     ^^^^^^^^^^^^
473 |     """Copy all data from SQLite to Aurora in correct order respecting foreign keys."""
    |
help: Add return type annotation

ANN001 Missing type annotation for function argument `sqlite_conn`
   --> db\migrations\migrate_sqlite_to_aurora.py:472:18
    |
472 | def migrate_data(sqlite_conn, aurora_conn):
    |                  ^^^^^^^^^^^
473 |     """Copy all data from SQLite to Aurora in correct order respecting foreign keys."""
    |

ANN001 Missing type annotation for function argument `aurora_conn`
   --> db\migrations\migrate_sqlite_to_aurora.py:472:31
    |
472 | def migrate_data(sqlite_conn, aurora_conn):
    |                               ^^^^^^^^^^^
473 |     """Copy all data from SQLite to Aurora in correct order respecting foreign keys."""
    |

D202 [*] No blank lines allowed after function docstring (found 1)
   --> db\migrations\migrate_sqlite_to_aurora.py:473:5
    |
472 | def migrate_data(sqlite_conn, aurora_conn):
473 |     """Copy all data from SQLite to Aurora in correct order respecting foreign keys."""
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
474 |
475 |     # Define tables in the order they should be migrated (respecting foreign keys)
    |
help: Remove blank line(s) after function docstring

ANN201 Missing return type annotation for public function `get_sqlite_table_list`
   --> db\migrations\migrate_sqlite_to_aurora.py:500:5
    |
500 | def get_sqlite_table_list(conn):
    |     ^^^^^^^^^^^^^^^^^^^^^
501 |     """Get list of tables from SQLite database."""
502 |     cursor = conn.cursor()
    |
help: Add return type annotation

ANN001 Missing type annotation for function argument `conn`
   --> db\migrations\migrate_sqlite_to_aurora.py:500:27
    |
500 | def get_sqlite_table_list(conn):
    |                           ^^^^
501 |     """Get list of tables from SQLite database."""
502 |     cursor = conn.cursor()
    |

ANN201 Missing return type annotation for public function `get_aurora_table_list`
   --> db\migrations\migrate_sqlite_to_aurora.py:509:5
    |
509 | def get_aurora_table_list(conn):
    |     ^^^^^^^^^^^^^^^^^^^^^
510 |     """Get list of tables from Aurora database."""
511 |     cursor = conn.cursor()
    |
help: Add return type annotation

ANN001 Missing type annotation for function argument `conn`
   --> db\migrations\migrate_sqlite_to_aurora.py:509:27
    |
509 | def get_aurora_table_list(conn):
    |                           ^^^^
510 |     """Get list of tables from Aurora database."""
511 |     cursor = conn.cursor()
    |

ANN201 Missing return type annotation for public function `get_row_counts`
   --> db\migrations\migrate_sqlite_to_aurora.py:520:5
    |
520 | def get_row_counts(conn, table_list, is_sqlite=True):
    |     ^^^^^^^^^^^^^^
521 |     """Get row counts for all tables."""
522 |     counts = {}
    |
help: Add return type annotation

ANN001 Missing type annotation for function argument `conn`
   --> db\migrations\migrate_sqlite_to_aurora.py:520:20
    |
520 | def get_row_counts(conn, table_list, is_sqlite=True):
    |                    ^^^^
521 |     """Get row counts for all tables."""
522 |     counts = {}
    |

ANN001 Missing type annotation for function argument `table_list`
   --> db\migrations\migrate_sqlite_to_aurora.py:520:26
    |
520 | def get_row_counts(conn, table_list, is_sqlite=True):
    |                          ^^^^^^^^^^
521 |     """Get row counts for all tables."""
522 |     counts = {}
    |

ANN001 Missing type annotation for function argument `is_sqlite`
   --> db\migrations\migrate_sqlite_to_aurora.py:520:38
    |
520 | def get_row_counts(conn, table_list, is_sqlite=True):
    |                                      ^^^^^^^^^
521 |     """Get row counts for all tables."""
522 |     counts = {}
    |

ANN201 Missing return type annotation for public function `verify_migration`
   --> db\migrations\migrate_sqlite_to_aurora.py:543:5
    |
543 | def verify_migration(sqlite_conn, aurora_conn, expected_tables):
    |     ^^^^^^^^^^^^^^^^
544 |     """Verify the migration by comparing tables and row counts."""
545 |     logger.info("Verifying migration...")
    |
help: Add return type annotation

ANN001 Missing type annotation for function argument `sqlite_conn`
   --> db\migrations\migrate_sqlite_to_aurora.py:543:22
    |
543 | def verify_migration(sqlite_conn, aurora_conn, expected_tables):
    |                      ^^^^^^^^^^^
544 |     """Verify the migration by comparing tables and row counts."""
545 |     logger.info("Verifying migration...")
    |

ANN001 Missing type annotation for function argument `aurora_conn`
   --> db\migrations\migrate_sqlite_to_aurora.py:543:35
    |
543 | def verify_migration(sqlite_conn, aurora_conn, expected_tables):
    |                                   ^^^^^^^^^^^
544 |     """Verify the migration by comparing tables and row counts."""
545 |     logger.info("Verifying migration...")
    |

ANN001 Missing type annotation for function argument `expected_tables`
   --> db\migrations\migrate_sqlite_to_aurora.py:543:48
    |
543 | def verify_migration(sqlite_conn, aurora_conn, expected_tables):
    |                                                ^^^^^^^^^^^^^^^
544 |     """Verify the migration by comparing tables and row counts."""
545 |     logger.info("Verifying migration...")
    |

ANN201 Missing return type annotation for public function `main`
   --> db\migrations\migrate_sqlite_to_aurora.py:593:5
    |
593 | def main():
    |     ^^^^
594 |     """Main entry point for migration script."""
595 |     parser = argparse.ArgumentParser(description="Migrate SQLite database to AWS Aurora")
    |
help: Add return type annotation: `int | None`

D104 Missing docstring in public package
--> desktop_ui\__init__.py:1:1

D200 One-line docstring should fit on one line
 --> desktop_ui\_snippet_main.py:1:1
  |
1 | / """
2 | | Temporary file to add main entry point to snippet_scaffold.py
3 | | """
  | |___^
4 |
5 |   MAIN_CODE = """
  |
help: Reformat to one line

D212 [*] Multi-line docstring summary should start at the first line
 --> desktop_ui\_snippet_main.py:1:1
  |
1 | / """
2 | | Temporary file to add main entry point to snippet_scaffold.py
3 | | """
  | |___^
4 |
5 |   MAIN_CODE = """
  |
help: Remove whitespace after opening quotes

D415 First line should end with a period, question mark, or exclamation point
 --> desktop_ui\_snippet_main.py:1:1
  |
1 | / """
2 | | Temporary file to add main entry point to snippet_scaffold.py
3 | | """
  | |___^
4 |
5 |   MAIN_CODE = """
  |
help: Add closing punctuation

D212 [*] Multi-line docstring summary should start at the first line
 --> desktop_ui\api_key_dialog.py:1:1
  |
1 | / """
2 | | API Key Configuration Dialog.
3 | |
4 | | This module provides a dialog for configuring API keys for external services,
5 | | with secure storage and retrieval functionality.
6 | | """
  | |___^
7 |
8 |   import base64
  |
help: Remove whitespace after opening quotes

D212 [*] Multi-line docstring summary should start at the first line
  --> desktop_ui\api_key_dialog.py:45:5
   |
44 |   class APIKeyDialog(QDialog):
45 | /     """
46 | |     Dialog for configuring API keys with secure storage.
47 | |
48 | |     This dialog allows users to:
49 | |     - Enter their API keys
50 | |     - Save keys securely to disk
51 | |     - Retrieve previously saved keys
52 | |
53 | |     The keys are stored in an encrypted file using Fernet symmetric encryption.
54 | |     A machine-specific salt is used to enhance security.
55 | |     """
   | |_______^
56 |
57 |       def __init__(self, parent: Optional[QDialog] = None) -> None:
   |
help: Remove whitespace after opening quotes

D107 Missing docstring in `__init__`
  --> desktop_ui\api_key_dialog.py:57:9
   |
55 |     """
56 |
57 |     def __init__(self, parent: Optional[QDialog] = None) -> None:
   |         ^^^^^^^^
58 |         super().__init__(parent)
59 |         self.setWindowTitle("API Key Configuration")
   |

D212 [*] Multi-line docstring summary should start at the first line
   --> desktop_ui\api_key_dialog.py:200:9
    |
199 |       def get_user_env_var(self, var_name: str) -> Optional[str]:
200 | /         """
201 | |         Reads the value of a user-level environment variable from the Windows Registry.
202 | |
203 | |         Args:
204 | |             var_name: Name of the environment variable
205 | |
206 | |         Returns:
207 | |             The value as a string, or None if not set
208 | |         """
    | |___________^
209 |           if not sys.platform == "win32":
210 |               return os.environ.get(var_name)
    |
help: Remove whitespace after opening quotes

B025 try-except block with duplicate exception `Exception`
   --> desktop_ui\api_key_dialog.py:337:16
    |
335 |             self.accept()
336 |
337 |         except Exception as e:
    |                ^^^^^^^^^
338 |             QMessageBox.critical(self, "Save Error", f"Failed to save API key: {str(e)}")
    |

D212 [*] Multi-line docstring summary should start at the first line
   --> desktop_ui\api_key_dialog.py:341:9
    |
340 |       def _get_encryption_key(self) -> bytes:
341 | /         """
342 | |         Generate an encryption key based on machine-specific data.
343 | |
344 | |         This creates a deterministic but secure key based on:
345 | |         - A salt file stored in the config directory
346 | |         - Machine-specific information
347 | |
348 | |         Returns:
349 | |             bytes: A 32-byte key for Fernet encryption
350 | |         """
    | |___________^
351 |           if not CRYPTOGRAPHY_AVAILABLE:
352 |               raise ImportError("Cryptography package is not available")
    |
help: Remove whitespace after opening quotes

D205 1 blank line required between summary line and description
   --> desktop_ui\api_key_dialog.py:390:9
    |
389 |       def _set_permanent_environment_variable(self, var_name: str, var_value: str) -> None:
390 | /         """
391 | |                 Set a permanent environment variable for the current user's profile.
392 | |         {{ ... }}
393 | |                 Args:
394 | |                     var_name: Name of the environment variable
395 | |                     var_value: Value to set
396 | |         """
    | |___________^
397 |           try:
398 |               if sys.platform == "win32":
    |
help: Insert single blank line

D212 [*] Multi-line docstring summary should start at the first line
   --> desktop_ui\api_key_dialog.py:390:9
    |
389 |       def _set_permanent_environment_variable(self, var_name: str, var_value: str) -> None:
390 | /         """
391 | |                 Set a permanent environment variable for the current user's profile.
392 | |         {{ ... }}
393 | |                 Args:
394 | |                     var_name: Name of the environment variable
395 | |                     var_value: Value to set
396 | |         """
    | |___________^
397 |           try:
398 |               if sys.platform == "win32":
    |
help: Remove whitespace after opening quotes

D415 First line should end with a period, question mark, or exclamation point
   --> desktop_ui\api_key_dialog.py:390:9
    |
389 |       def _set_permanent_environment_variable(self, var_name: str, var_value: str) -> None:
390 | /         """
391 | |                 Set a permanent environment variable for the current user's profile.
392 | |         {{ ... }}
393 | |                 Args:
394 | |                     var_name: Name of the environment variable
395 | |                     var_value: Value to set
396 | |         """
    | |___________^
397 |           try:
398 |               if sys.platform == "win32":
    |
help: Add closing punctuation

D214 [*] Section is over-indented ("Args")
   --> desktop_ui\api_key_dialog.py:393:17
    |
391 |                 Set a permanent environment variable for the current user's profile.
392 |         {{ ... }}
393 |                 Args:
    |                 ^^^^
394 |                     var_name: Name of the environment variable
395 |                     var_value: Value to set
    |
help: Remove over-indentation from "Args"

D411 [*] Missing blank line before section ("Args")
   --> desktop_ui\api_key_dialog.py:393:17
    |
391 |                 Set a permanent environment variable for the current user's profile.
392 |         {{ ... }}
393 |                 Args:
    |                 ^^^^
394 |                     var_name: Name of the environment variable
395 |                     var_value: Value to set
    |
help: Add blank line before "Args"

D212 [*] Multi-line docstring summary should start at the first line
   --> desktop_ui\api_key_dialog.py:479:9
    |
477 |           cls, parent: Optional[QDialog] = None, key_type: str = "openai"
478 |       ) -> Optional[str]:
479 | /         """
480 | |         Class method to get an API key, showing the dialog if needed.
481 | |
482 | |         Args:
483 | |             parent: Parent widget
484 | |             key_type: The type of API key to retrieve (e.g., "openai")
485 | |
486 | |         Returns:
487 | |             Optional[str]: The API key if available, None otherwise
488 | |         """
    | |___________^
489 |           # First check for the OpenAPI_Key environment variable
490 |           if key_type == "openai":
    |
help: Remove whitespace after opening quotes

D212 [*] Multi-line docstring summary should start at the first line
 --> desktop_ui\api_server_manager.py:1:1
  |
1 | / """
2 | | API Server Manager for Desktop UI
3 | |
4 | | This module provides functionality to check if the GraphQL API server
5 | | is running and automatically start it if needed.
6 | | """
  | |___^
7 |
8 |   import os
  |
help: Remove whitespace after opening quotes

D415 First line should end with a period, question mark, or exclamation point
 --> desktop_ui\api_server_manager.py:1:1
  |
1 | / """
2 | | API Server Manager for Desktop UI
3 | |
4 | | This module provides functionality to check if the GraphQL API server
5 | | is running and automatically start it if needed.
6 | | """
  | |___^
7 |
8 |   import os
  |
help: Add closing punctuation

D212 [*] Multi-line docstring summary should start at the first line
  --> desktop_ui\api_server_manager.py:18:5
   |
17 |   class APIServerManager:
18 | /     """
19 | |     Manages the Flask GraphQL API server for the desktop UI.
20 | |
21 | |     This class provides methods to check if the server is running,
22 | |     start it if needed, and shut it down.
23 | |     """
   | |_______^
24 |
25 |       def __init__(self) -> None:
   |
help: Remove whitespace after opening quotes

D212 [*] Multi-line docstring summary should start at the first line
  --> desktop_ui\api_server_manager.py:32:9
   |
31 |       def _get_server_script_path(self) -> str:
32 | /         """
33 | |         Get the absolute path to the API server script.
34 | |
35 | |         Returns:
36 | |             str: Absolute path to the run_library_api.py script
37 | |         """
   | |___________^
38 |           # Get the directory of the current file
39 |           current_dir = os.path.dirname(os.path.abspath(__file__))
   |
help: Remove whitespace after opening quotes

D212 [*] Multi-line docstring summary should start at the first line
  --> desktop_ui\api_server_manager.py:45:9
   |
44 |       def is_server_running(self) -> bool:
45 | /         """
46 | |         Check if the GraphQL API server is already running.
47 | |
48 | |         Returns:
49 | |             bool: True if server is running, False otherwise
50 | |         """
   | |___________^
51 |           try:
52 |               # Try to connect to the server
   |
help: Remove whitespace after opening quotes

F841 Local variable `response` is assigned to but never used
  --> desktop_ui\api_server_manager.py:54:13
   |
52 |             # Try to connect to the server
53 |             # Even if we get a 400 error (method not allowed), it means the server is running
54 |             response = requests.get(self._api_url, timeout=2)
   |             ^^^^^^^^
55 |             return True
56 |         except requests.exceptions.ConnectionError:
   |
help: Remove assignment to unused variable `response`

D212 [*] Multi-line docstring summary should start at the first line
  --> desktop_ui\api_server_manager.py:67:9
   |
66 |       def start_server(self) -> bool:
67 | /         """
68 | |         Start the GraphQL API server as a background process.
69 | |
70 | |         Returns:
71 | |             bool: True if server was started successfully, False otherwise
72 | |         """
   | |___________^
73 |           try:
74 |               # Check if python is in PATH
   |
help: Remove whitespace after opening quotes

D212 [*] Multi-line docstring summary should start at the first line
   --> desktop_ui\api_server_manager.py:96:9
    |
 95 |       def ensure_server_running(self) -> bool:
 96 | /         """
 97 | |         Ensure the GraphQL API server is running, starting it if needed.
 98 | |
 99 | |         Returns:
100 | |             bool: True if server is running or was started successfully, False otherwise
101 | |         """
    | |___________^
102 |           if self.is_server_running():
103 |               return True
    |
help: Remove whitespace after opening quotes

D200 One-line docstring should fit on one line
   --> desktop_ui\api_server_manager.py:108:9
    |
107 |       def shutdown_server(self) -> None:
108 | /         """
109 | |         Shutdown the server if it was started by this manager.
110 | |         """
    | |___________^
111 |           if self._server_process:
112 |               try:
    |
help: Reformat to one line

D212 [*] Multi-line docstring summary should start at the first line
   --> desktop_ui\api_server_manager.py:108:9
    |
107 |       def shutdown_server(self) -> None:
108 | /         """
109 | |         Shutdown the server if it was started by this manager.
110 | |         """
    | |___________^
111 |           if self._server_process:
112 |               try:
    |
help: Remove whitespace after opening quotes

D205 1 blank line required between summary line and description
  --> desktop_ui\category_model_tester.py:1:1
   |
 1 | / """
 2 | | Category Model Tester UI
 3 | | -----------------------
 4 | | A simple PySide6-based desktop UI for directly testing the Category object model (Category, CategoryManager).
 5 | |
 6 | | - List all categories
 7 | | - Add a new category
 8 | | - Rename a category
 9 | | - Delete a category (with cascade warning)
10 | | - Show validation and error messages
11 | |
12 | | Bypasses API and service layers; interacts directly with CategoryManager and DatabaseManager.
13 | |
14 | | Author: Cascade AI
15 | | """
   | |___^
16 |
17 |   import os
   |
help: Insert single blank line

D212 [*] Multi-line docstring summary should start at the first line
  --> desktop_ui\category_model_tester.py:1:1
   |
 1 | / """
 2 | | Category Model Tester UI
 3 | | -----------------------
 4 | | A simple PySide6-based desktop UI for directly testing the Category object model (Category, CategoryManager).
 5 | |
 6 | | - List all categories
 7 | | - Add a new category
 8 | | - Rename a category
 9 | | - Delete a category (with cascade warning)
10 | | - Show validation and error messages
11 | |
12 | | Bypasses API and service layers; interacts directly with CategoryManager and DatabaseManager.
13 | |
14 | | Author: Cascade AI
15 | | """
   | |___^
16 |
17 |   import os
   |
help: Remove whitespace after opening quotes

D415 First line should end with a period, question mark, or exclamation point
  --> desktop_ui\category_model_tester.py:1:1
   |
 1 | / """
 2 | | Category Model Tester UI
 3 | | -----------------------
 4 | | A simple PySide6-based desktop UI for directly testing the Category object model (Category, CategoryManager).
 5 | |
 6 | | - List all categories
 7 | | - Add a new category
 8 | | - Rename a category
 9 | | - Delete a category (with cascade warning)
10 | | - Show validation and error messages
11 | |
12 | | Bypasses API and service layers; interacts directly with CategoryManager and DatabaseManager.
13 | |
14 | | Author: Cascade AI
15 | | """
   | |___^
16 |
17 |   import os
   |
help: Add closing punctuation

D200 One-line docstring should fit on one line
  --> desktop_ui\category_model_tester.py:42:5
   |
41 |   class CategoryModelTester(QWidget):
42 | /     """
43 | |     Simple UI to test CategoryManager CRUD and validation logic.
44 | |     """
   | |_______^
45 |
46 |       def __init__(self) -> None:
   |
help: Reformat to one line

D212 [*] Multi-line docstring summary should start at the first line
  --> desktop_ui\category_model_tester.py:42:5
   |
41 |   class CategoryModelTester(QWidget):
42 | /     """
43 | |     Simple UI to test CategoryManager CRUD and validation logic.
44 | |     """
   | |_______^
45 |
46 |       def __init__(self) -> None:
   |
help: Remove whitespace after opening quotes

D107 Missing docstring in `__init__`
  --> desktop_ui\category_model_tester.py:46:9
   |
44 |     """
45 |
46 |     def __init__(self) -> None:
   |         ^^^^^^^^
47 |         super().__init__()
48 |         self.setWindowTitle("Category Model Tester")
   |

D102 Missing docstring in public method
  --> desktop_ui\category_model_tester.py:56:9
   |
54 |         self.refresh_categories()
55 |
56 |     def init_ui(self) -> None:
   |         ^^^^^^^
57 |         layout = QVBoxLayout()
   |

D102 Missing docstring in public method
  --> desktop_ui\category_model_tester.py:84:9
   |
82 |         self.btn_delete.clicked.connect(self.delete_category)
83 |
84 |     def refresh_categories(self) -> None:
   |         ^^^^^^^^^^^^^^^^^^
85 |         self.list_widget.clear()
86 |         try:
   |

D102 Missing docstring in public method
  --> desktop_ui\category_model_tester.py:93:9
   |
91 |             self.set_status(f"Error loading categories: {e}")
92 |
93 |     def add_category(self) -> None:
   |         ^^^^^^^^^^^^
94 |         name, ok = QInputDialog.getText(self, "Add Category", "Enter category name:")
95 |         if ok and name:
   |

D102 Missing docstring in public method
   --> desktop_ui\category_model_tester.py:105:9
    |
103 |                 self.set_status(f"Error: {e}")
104 |
105 |     def get_selected_category_id(self) -> Optional[str]:
    |         ^^^^^^^^^^^^^^^^^^^^^^^^
106 |         item = self.list_widget.currentItem()
107 |         if not item:
    |

D102 Missing docstring in public method
   --> desktop_ui\category_model_tester.py:117:9
    |
115 |             return None
116 |
117 |     def rename_category(self) -> None:
    |         ^^^^^^^^^^^^^^^
118 |         cat_id = self.get_selected_category_id()
119 |         if cat_id is None:
    |

D102 Missing docstring in public method
   --> desktop_ui\category_model_tester.py:134:9
    |
132 |                 self.set_status(f"Error: {e}")
133 |
134 |     def delete_category(self) -> None:
    |         ^^^^^^^^^^^^^^^
135 |         cat_id = self.get_selected_category_id()
136 |         if cat_id is None:
    |

D102 Missing docstring in public method
   --> desktop_ui\category_model_tester.py:155:9
    |
153 |                 self.set_status(f"Error: {e}")
154 |
155 |     def set_status(self, msg: str, error: bool = True) -> None:
    |         ^^^^^^^^^^
156 |         self.status_label.setText(msg)
157 |         if error:
    |

D103 Missing docstring in public function
   --> desktop_ui\category_model_tester.py:163:5
    |
163 | def main() -> None:
    |     ^^^^
164 |     app = QApplication(sys.argv)
165 |     tester = CategoryModelTester()
    |

D212 [*] Multi-line docstring summary should start at the first line
  --> desktop_ui\cleanup_data_dialog.py:1:1
   |
 1 | / """
 2 | | CleanupDataDialog UI for managing data cleanup and regeneration operations.
 3 | |
 4 | | This dialog provides options to:
 5 | | - Delete all derived data (ngrams, analytics, summaries)
 6 | | - Recreate ngrams from session keystrokes
 7 | | - Recreate session summaries
 8 | | - Recreate ngram statistics
 9 | | """
   | |___^
10 |
11 |   import os
   |
help: Remove whitespace after opening quotes

D212 [*] Multi-line docstring summary should start at the first line
  --> desktop_ui\cleanup_data_dialog.py:36:5
   |
35 |   class CleanupDataDialog(QDialog):
36 | /     """
37 | |     Dialog for managing data cleanup and regeneration operations.
38 | |
39 | |     Provides a centralized interface for cleaning up derived data
40 | |     and regenerating it using various scaffold tools.
41 | |     """
   | |_______^
42 |
43 |       def __init__(
   |
help: Remove whitespace after opening quotes

D107 Missing docstring in `__init__`
  --> desktop_ui\cleanup_data_dialog.py:43:9
   |
41 |     """
42 |
43 |     def __init__(
   |         ^^^^^^^^
44 |         self,
45 |         parent: Optional[QtWidgets.QWidget] = None,
   |

D205 1 blank line required between summary line and description
 --> desktop_ui\consistency_typing.py:2:1
  |
1 |   # ruff: noqa: E501
2 | / """
3 | | ConsistencyTypingScreen - Interactive typing practice UI focused on rhythm consistency.
4 | | Implements consistency-focused typing drill with metronome and variability tracking.
5 | | """
  | |___^
6 |
7 |   import datetime
  |
help: Insert single blank line

D212 [*] Multi-line docstring summary should start at the first line
 --> desktop_ui\consistency_typing.py:2:1
  |
1 |   # ruff: noqa: E501
2 | / """
3 | | ConsistencyTypingScreen - Interactive typing practice UI focused on rhythm consistency.
4 | | Implements consistency-focused typing drill with metronome and variability tracking.
5 | | """
  | |___^
6 |
7 |   import datetime
  |
help: Remove whitespace after opening quotes

F401 [*] `logging` imported but unused
  --> desktop_ui\consistency_typing.py:8:8
   |
 7 | import datetime
 8 | import logging
   |        ^^^^^^^
 9 | import math
10 | import statistics
   |
help: Remove unused import: `logging`

F401 [*] `math` imported but unused
  --> desktop_ui\consistency_typing.py:9:8
   |
 7 | import datetime
 8 | import logging
 9 | import math
   |        ^^^^
10 | import statistics
11 | import time
   |
help: Remove unused import: `math`

F401 [*] `uuid` imported but unused
  --> desktop_ui\consistency_typing.py:12:8
   |
10 | import statistics
11 | import time
12 | import uuid
   |        ^^^^
13 | from typing import Any, Dict, List, Optional, Union
   |
help: Remove unused import: `uuid`

F401 [*] `typing.Union` imported but unused
  --> desktop_ui\consistency_typing.py:13:47
   |
11 | import time
12 | import uuid
13 | from typing import Any, Dict, List, Optional, Union
   |                                               ^^^^^
14 |
15 | from PySide6.QtCore import Qt, QTimer
   |
help: Remove unused import: `typing.Union`

F401 [*] `PySide6.QtWidgets.QSizePolicy` imported but unused
  --> desktop_ui\consistency_typing.py:28:5
   |
26 |     QPushButton,
27 |     QRadioButton,
28 |     QSizePolicy,
   |     ^^^^^^^^^^^
29 |     QSlider,
30 |     QSpacerItem,
   |
help: Remove unused import

F401 [*] `PySide6.QtWidgets.QSpacerItem` imported but unused
  --> desktop_ui\consistency_typing.py:30:5
   |
28 |     QSizePolicy,
29 |     QSlider,
30 |     QSpacerItem,
   |     ^^^^^^^^^^^
31 |     QSpinBox,
32 |     QStatusBar,
   |
help: Remove unused import

F401 [*] `models.keyboard_manager.KeyboardManager` imported but unused
  --> desktop_ui\consistency_typing.py:39:37
   |
38 | from db.database_manager import DatabaseManager
39 | from models.keyboard_manager import KeyboardManager, KeyboardNotFound
   |                                     ^^^^^^^^^^^^^^^
40 | from models.keystroke import Keystroke
41 | from models.keystroke_manager import KeystrokeManager
   |
help: Remove unused import

F401 [*] `models.keyboard_manager.KeyboardNotFound` imported but unused
  --> desktop_ui\consistency_typing.py:39:54
   |
38 | from db.database_manager import DatabaseManager
39 | from models.keyboard_manager import KeyboardManager, KeyboardNotFound
   |                                                      ^^^^^^^^^^^^^^^^
40 | from models.keystroke import Keystroke
41 | from models.keystroke_manager import KeystrokeManager
   |
help: Remove unused import

F401 [*] `models.keystroke.Keystroke` imported but unused
  --> desktop_ui\consistency_typing.py:40:30
   |
38 | from db.database_manager import DatabaseManager
39 | from models.keyboard_manager import KeyboardManager, KeyboardNotFound
40 | from models.keystroke import Keystroke
   |                              ^^^^^^^^^
41 | from models.keystroke_manager import KeystrokeManager
42 | from models.session import Session
   |
help: Remove unused import: `models.keystroke.Keystroke`

F401 [*] `models.keystroke_manager.KeystrokeManager` imported but unused
  --> desktop_ui\consistency_typing.py:41:38
   |
39 | from models.keyboard_manager import KeyboardManager, KeyboardNotFound
40 | from models.keystroke import Keystroke
41 | from models.keystroke_manager import KeystrokeManager
   |                                      ^^^^^^^^^^^^^^^^
42 | from models.session import Session
43 | from models.session_manager import SessionManager
   |
help: Remove unused import: `models.keystroke_manager.KeystrokeManager`

F401 [*] `models.session.Session` imported but unused
  --> desktop_ui\consistency_typing.py:42:28
   |
40 | from models.keystroke import Keystroke
41 | from models.keystroke_manager import KeystrokeManager
42 | from models.session import Session
   |                            ^^^^^^^
43 | from models.session_manager import SessionManager
44 | from models.user_manager import UserManager, UserNotFound
   |
help: Remove unused import: `models.session.Session`

F401 [*] `models.session_manager.SessionManager` imported but unused
  --> desktop_ui\consistency_typing.py:43:36
   |
41 | from models.keystroke_manager import KeystrokeManager
42 | from models.session import Session
43 | from models.session_manager import SessionManager
   |                                    ^^^^^^^^^^^^^^
44 | from models.user_manager import UserManager, UserNotFound
   |
help: Remove unused import: `models.session_manager.SessionManager`

F401 [*] `models.user_manager.UserManager` imported but unused
  --> desktop_ui\consistency_typing.py:44:33
   |
42 | from models.session import Session
43 | from models.session_manager import SessionManager
44 | from models.user_manager import UserManager, UserNotFound
   |                                 ^^^^^^^^^^^
   |
help: Remove unused import

F401 [*] `models.user_manager.UserNotFound` imported but unused
  --> desktop_ui\consistency_typing.py:44:46
   |
42 | from models.session import Session
43 | from models.session_manager import SessionManager
44 | from models.user_manager import UserManager, UserNotFound
   |                                              ^^^^^^^^^^^^
   |
help: Remove unused import

D205 1 blank line required between summary line and description
  --> desktop_ui\consistency_typing.py:48:5
   |
47 |   class ConsistencyTypingScreen(QDialog):
48 | /     """
49 | |     ConsistencyTypingScreen handles consistency-focused typing practice.
50 | |     Emphasizes rhythm and timing consistency over speed or accuracy.
51 | |     
52 | |     Supports two modes:
53 | |     - Metronome-Led: User sets target pace with audible metronome
54 | |     - User-Led: System adapts to user's natural rhythm
55 | |     """
   | |_______^
56 |
57 |       def __init__(
   |
help: Insert single blank line

D212 [*] Multi-line docstring summary should start at the first line
  --> desktop_ui\consistency_typing.py:48:5
   |
47 |   class ConsistencyTypingScreen(QDialog):
48 | /     """
49 | |     ConsistencyTypingScreen handles consistency-focused typing practice.
50 | |     Emphasizes rhythm and timing consistency over speed or accuracy.
51 | |     
52 | |     Supports two modes:
53 | |     - Metronome-Led: User sets target pace with audible metronome
54 | |     - User-Led: System adapts to user's natural rhythm
55 | |     """
   | |_______^
56 |
57 |       def __init__(
   |
help: Remove whitespace after opening quotes

D107 Missing docstring in `__init__`
  --> desktop_ui\consistency_typing.py:57:9
   |
55 |     """
56 |
57 |     def __init__(
   |         ^^^^^^^^
58 |         self,
59 |         snippet_id: str,
   |

B007 Loop control variable `char` not used within loop body
   --> desktop_ui\consistency_typing.py:435:16
    |
433 |         current_text = self.typing_input.toPlainText()
434 |         
435 |         for i, char in enumerate(self.display_text):
    |                ^^^^
436 |             cursor.setPosition(i)
437 |             cursor.setPosition(i + 1, QTextCursor.MoveMode.KeepAnchor)
    |
help: Rename unused `char` to `_char`

D212 [*] Multi-line docstring summary should start at the first line
 --> desktop_ui\db_viewer_dialog.py:1:1
  |
1 | / """
2 | | Database Viewer Dialog for AI Typing Trainer (PySide6)
3 | |
4 | | This module provides a GUI for viewing database tables in a read-only interface.
5 | | """
  | |___^
6 |
7 |   from typing import Optional, cast
  |
help: Remove whitespace after opening quotes

D415 First line should end with a period, question mark, or exclamation point
 --> desktop_ui\db_viewer_dialog.py:1:1
  |
1 | / """
2 | | Database Viewer Dialog for AI Typing Trainer (PySide6)
3 | |
4 | | This module provides a GUI for viewing database tables in a read-only interface.
5 | | """
  | |___^
6 |
7 |   from typing import Optional, cast
  |
help: Add closing punctuation

D212 [*] Multi-line docstring summary should start at the first line
  --> desktop_ui\db_viewer_dialog.py:29:5
   |
28 |   class DatabaseViewerDialog(QDialog):
29 | /     """
30 | |     Dialog for viewing database tables and content.
31 | |
32 | |     Features:
33 | |     - Table selection
34 | |     - Data display with pagination, sorting, filtering
35 | |     - Export to CSV
36 | |     - Error handling
37 | |
38 | |     Args:
39 | |         service: DatabaseViewerService instance to access table data
40 | |         parent: Optional parent widget
41 | |     """
   | |_______^
42 |
43 |       def __init__(
   |
help: Remove whitespace after opening quotes

D107 Missing docstring in `__init__`
  --> desktop_ui\db_viewer_dialog.py:43:9
   |
41 |     """
42 |
43 |     def __init__(
   |         ^^^^^^^^
44 |         self,
45 |         service: DatabaseViewerService,
   |

F821 Undefined name `QProgressBar`
   --> desktop_ui\db_viewer_dialog.py:306:24
    |
305 |             # Show progress dialog
306 |             progress = QProgressBar(self)
    |                        ^^^^^^^^^^^^
307 |             progress.setWindowTitle("Exporting data...")
308 |             progress.setRange(0, 0)  # Indeterminate
    |

D200 One-line docstring should fit on one line
 --> desktop_ui\dialogs\keyboard_dialog.py:1:1
  |
1 | / """
2 | | Keyboard dialog for adding/editing keyboards.
3 | | """
  | |___^
4 |
5 |   from typing import Optional
  |
help: Reformat to one line

D212 [*] Multi-line docstring summary should start at the first line
 --> desktop_ui\dialogs\keyboard_dialog.py:1:1
  |
1 | / """
2 | | Keyboard dialog for adding/editing keyboards.
3 | | """
  | |___^
4 |
5 |   from typing import Optional
  |
help: Remove whitespace after opening quotes

D200 One-line docstring should fit on one line
  --> desktop_ui\dialogs\keyboard_dialog.py:23:5
   |
22 |   class KeyboardDialog(QDialog):
23 | /     """
24 | |     Dialog for adding or editing a keyboard.
25 | |     """
   | |_______^
26 |
27 |       def __init__(
   |
help: Reformat to one line

D212 [*] Multi-line docstring summary should start at the first line
  --> desktop_ui\dialogs\keyboard_dialog.py:23:5
   |
22 |   class KeyboardDialog(QDialog):
23 | /     """
24 | |     Dialog for adding or editing a keyboard.
25 | |     """
   | |_______^
26 |
27 |       def __init__(
   |
help: Remove whitespace after opening quotes

D212 [*] Multi-line docstring summary should start at the first line
  --> desktop_ui\dialogs\keyboard_dialog.py:33:9
   |
31 |           parent: Optional[QWidget] = None,
32 |       ) -> None:
33 | /         """
34 | |         Initialize the keyboard dialog.
35 | |
36 | |         Args:
37 | |             user_id: ID of the user this keyboard belongs to.
38 | |             keyboard: Optional keyboard to edit. If None, create a new keyboard.
39 | |             parent: Parent widget.
40 | |         """
   | |___________^
41 |           super().__init__(parent)
42 |           self.user_id = user_id
   |
help: Remove whitespace after opening quotes

D212 [*] Multi-line docstring summary should start at the first line
   --> desktop_ui\dialogs\keyboard_dialog.py:118:9
    |
117 |       def get_keyboard(self) -> Keyboard:
118 | /         """
119 | |         Get the keyboard object with updated values.
120 | |
121 | |         Returns:
122 | |             The updated or new keyboard object.
123 | |         """
    | |___________^
124 |           return self.keyboard
    |
help: Remove whitespace after opening quotes

D200 One-line docstring should fit on one line
 --> desktop_ui\dialogs\user_dialog.py:1:1
  |
1 | / """
2 | | User dialog for adding/editing users.
3 | | """
  | |___^
4 |
5 |   from typing import Optional
  |
help: Reformat to one line

D212 [*] Multi-line docstring summary should start at the first line
 --> desktop_ui\dialogs\user_dialog.py:1:1
  |
1 | / """
2 | | User dialog for adding/editing users.
3 | | """
  | |___^
4 |
5 |   from typing import Optional
  |
help: Remove whitespace after opening quotes

D200 One-line docstring should fit on one line
  --> desktop_ui\dialogs\user_dialog.py:21:5
   |
20 |   class UserDialog(QDialog):
21 | /     """
22 | |     Dialog for adding or editing a user.
23 | |     """
   | |_______^
24 |
25 |       def __init__(
   |
help: Reformat to one line

D212 [*] Multi-line docstring summary should start at the first line
  --> desktop_ui\dialogs\user_dialog.py:21:5
   |
20 |   class UserDialog(QDialog):
21 | /     """
22 | |     Dialog for adding or editing a user.
23 | |     """
   | |_______^
24 |
25 |       def __init__(
   |
help: Remove whitespace after opening quotes

D212 [*] Multi-line docstring summary should start at the first line
  --> desktop_ui\dialogs\user_dialog.py:30:9
   |
28 |           parent: Optional[QWidget] = None,
29 |       ) -> None:
30 | /         """
31 | |         Initialize the user dialog.
32 | |
33 | |         Args:
34 | |             user: Optional user to edit. If None, create a new user.
35 | |             parent: Parent widget.
36 | |         """
   | |___________^
37 |           super().__init__(parent)
38 |           self.user = user
   |
help: Remove whitespace after opening quotes

D212 [*] Multi-line docstring summary should start at the first line
   --> desktop_ui\dialogs\user_dialog.py:119:9
    |
118 |       def get_user(self) -> User:
119 | /         """
120 | |         Get the user object with updated values.
121 | |
122 | |         Returns:
123 | |             The updated or new user object.
124 | |         """
    | |___________^
125 |           return self.user
    |
help: Remove whitespace after opening quotes

D212 [*] Multi-line docstring summary should start at the first line
 --> desktop_ui\drill_config.py:1:1
  |
1 | / """
2 | | Drill Configuration Dialog for AI Typing Trainer.
3 | |
4 | | This module provides a dialog for configuring typing drill parameters,
5 | | including snippet selection, index ranges, and launches the typing drill.
6 | | """
  | |___^
7 |
8 |   # Standard library imports
  |
help: Remove whitespace after opening quotes

D212 [*] Multi-line docstring summary should start at the first line
  --> desktop_ui\drill_config.py:37:5
   |
36 |   class DrillConfigDialog(QtWidgets.QDialog):
37 | /     """
38 | |     Dialog for configuring typing drill parameters.
39 | |
40 | |     Allows users to:
41 | |     - Select a category
42 | |     - Select a snippet from the chosen category
43 | |     - Set start and end indices for partial snippets
44 | |     - Launch the typing drill with configured parameters
45 | |
46 | |     Args:
47 | |         db_manager: Database manager instance to access categories and snippets
48 | |         user_id: Optional user ID to load user information
49 | |         keyboard_id: Optional keyboard ID to load keyboard information
50 | |         parent: Optional parent widget
51 | |     """
   | |_______^
52 |
53 |       def __init__(
   |
help: Remove whitespace after opening quotes

D107 Missing docstring in `__init__`
  --> desktop_ui\drill_config.py:53:9
   |
51 |     """
52 |
53 |     def __init__(
   |         ^^^^^^^^
54 |         self,
55 |         db_manager: DatabaseManager,
   |

E501 Line too long (134 > 120)
   --> desktop_ui\drill_config.py:109:121
    |
107 |                         self.debug_util.debugMessage(f"User type: {type(self.current_user)}")
108 |                         self.debug_util.debugMessage(
109 |                             f"User attributes: {vars(self.current_user) if hasattr(self.current_user, '__dict__') else 'No __dict__'}"
    |                                                                                                                         ^^^^^^^^^^^^^^
110 |                         )
111 |                     except Exception as e:
    |

E501 Line too long (122 > 120)
   --> desktop_ui\drill_config.py:458:121
    |
456 |                             start_idx = 0
457 |                     else:
458 |                         self.debug_util.debugMessage(" No snippet manager or user/keyboard ID, using default start index")
    |                                                                                                                         ^^
459 |                         
460 |                     self.start_index.setMaximum(len(snippet.content) - 1)
    |

D205 1 blank line required between summary line and description
  --> desktop_ui\drill_screen_tester.py:1:1
   |
 1 | / """
 2 | | Drill Screen Tester UI
 3 | | ---------------------
 4 | | A minimal PySide6 UI for selecting between snippet-based or manual text input.
 5 | | - If 'Snippet Selection' is chosen: shows a dropdown of snippets and start/end index fields.
 6 | | - If 'Manual Input' is chosen: shows a text box for manual entry.
 7 | | - A preview panel always shows the current text (subset or manual).
 8 | | - A Start button emits the relevant parameters.
 9 | | """
   | |___^
10 |
11 |   import os
   |
help: Insert single blank line

D212 [*] Multi-line docstring summary should start at the first line
  --> desktop_ui\drill_screen_tester.py:1:1
   |
 1 | / """
 2 | | Drill Screen Tester UI
 3 | | ---------------------
 4 | | A minimal PySide6 UI for selecting between snippet-based or manual text input.
 5 | | - If 'Snippet Selection' is chosen: shows a dropdown of snippets and start/end index fields.
 6 | | - If 'Manual Input' is chosen: shows a text box for manual entry.
 7 | | - A preview panel always shows the current text (subset or manual).
 8 | | - A Start button emits the relevant parameters.
 9 | | """
   | |___^
10 |
11 |   import os
   |
help: Remove whitespace after opening quotes

D415 First line should end with a period, question mark, or exclamation point
  --> desktop_ui\drill_screen_tester.py:1:1
   |
 1 | / """
 2 | | Drill Screen Tester UI
 3 | | ---------------------
 4 | | A minimal PySide6 UI for selecting between snippet-based or manual text input.
 5 | | - If 'Snippet Selection' is chosen: shows a dropdown of snippets and start/end index fields.
 6 | | - If 'Manual Input' is chosen: shows a text box for manual entry.
 7 | | - A preview panel always shows the current text (subset or manual).
 8 | | - A Start button emits the relevant parameters.
 9 | | """
   | |___^
10 |
11 |   import os
   |
help: Add closing punctuation

E402 Module level import not at top of file
  --> desktop_ui\drill_screen_tester.py:20:1
   |
18 |     sys.path.insert(0, project_root)
19 |
20 | import sys
   | ^^^^^^^^^^
21 |
22 | from PySide6 import QtWidgets
   |

E402 Module level import not at top of file
  --> desktop_ui\drill_screen_tester.py:22:1
   |
20 | import sys
21 |
22 | from PySide6 import QtWidgets
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
23 |
24 | # Dummy snippet data for demonstration
   |

D101 Missing docstring in public class
  --> desktop_ui\drill_screen_tester.py:44:7
   |
44 | class DrillScreenTester(QtWidgets.QWidget):
   |       ^^^^^^^^^^^^^^^^^
45 |     def __init__(self) -> None:
46 |         super().__init__()
   |

D107 Missing docstring in `__init__`
  --> desktop_ui\drill_screen_tester.py:45:9
   |
44 | class DrillScreenTester(QtWidgets.QWidget):
45 |     def __init__(self) -> None:
   |         ^^^^^^^^
46 |         super().__init__()
47 |         self.setWindowTitle("Drill Screen Tester")
   |

D102 Missing docstring in public method
  --> desktop_ui\drill_screen_tester.py:51:9
   |
49 |         self.init_ui()
50 |
51 |     def init_ui(self) -> None:
   |         ^^^^^^^
52 |         layout = QtWidgets.QVBoxLayout()
   |

D102 Missing docstring in public method
   --> desktop_ui\drill_screen_tester.py:125:9
    |
123 |         self.update_preview()
124 |
125 |     def on_radio_changed(self) -> None:
    |         ^^^^^^^^^^^^^^^^
126 |         snippet_mode = self.rb_snippet.isChecked()
127 |         self.snippet_panel.setVisible(snippet_mode)
    |

D102 Missing docstring in public method
   --> desktop_ui\drill_screen_tester.py:131:9
    |
129 |         self.update_preview()
130 |
131 |     def update_preview(self) -> None:
    |         ^^^^^^^^^^^^^^
132 |         if self.rb_snippet.isChecked():
133 |             idx = self.snippet_combo.currentIndex()
    |

D200 One-line docstring should fit on one line
   --> desktop_ui\drill_screen_tester.py:153:9
    |
152 |       def on_start(self) -> None:
153 | /         """
154 | |         Launch TypingDrillScreen with the selected snippet/manual text and indices.
155 | |         """
    | |___________^
156 |           print("Start button clicked!")
157 |           # Robust import for both direct script and package usage
    |
help: Reformat to one line

D212 [*] Multi-line docstring summary should start at the first line
   --> desktop_ui\drill_screen_tester.py:153:9
    |
152 |       def on_start(self) -> None:
153 | /         """
154 | |         Launch TypingDrillScreen with the selected snippet/manual text and indices.
155 | |         """
    | |___________^
156 |           print("Start button clicked!")
157 |           # Robust import for both direct script and package usage
    |
help: Remove whitespace after opening quotes

D212 [*] Multi-line docstring summary should start at the first line
 --> desktop_ui\dynamic_config.py:1:1
  |
1 | / """
2 | | Dynamic N-gram Practice Configuration Dialog.
3 | |
4 | | This module provides a dialog for configuring n-gram based practice sessions,
5 | | allowing users to target specific n-gram patterns for improvement.
6 | | """
  | |___^
7 |
8 |   from typing import Optional
  |
help: Remove whitespace after opening quotes

D212 [*] Multi-line docstring summary should start at the first line
  --> desktop_ui\dynamic_config.py:51:5
   |
50 |   class DynamicConfigDialog(QDialog):
51 | /     """
52 | |     Dialog for configuring n-gram based typing practice.
53 | |
54 | |     Allows users to:
55 | |     - Select n-gram size (3-10 characters)
56 | |     - Choose focus area (speed or accuracy)
57 | |     - Set desired practice length
58 | |     - View problematic n-grams
59 | |     - Generate and preview practice content
60 | |     - Launch the typing drill with generated content
61 | |
62 | |     Args:
63 | |         db_manager: Database manager instance
64 | |         parent: Optional parent widget
65 | |     """
   | |_______^
66 |
67 |       def __init__(
   |
help: Remove whitespace after opening quotes

D107 Missing docstring in `__init__`
  --> desktop_ui\dynamic_config.py:67:9
   |
65 |     """
66 |
67 |     def __init__(
   |         ^^^^^^^^
68 |         self,
69 |         db_manager: DatabaseManager,
   |

D205 1 blank line required between summary line and description
 --> desktop_ui\games_menu.py:2:1
  |
1 |   # ruff: noqa: E501
2 | / """
3 | | Games Menu UI for AI Typing Trainer (PySide6).
4 | | Provides access to various typing games and entertainment features.
5 | | """
  | |___^
6 |
7 |   import os
  |
help: Insert single blank line

D212 [*] Multi-line docstring summary should start at the first line
 --> desktop_ui\games_menu.py:2:1
  |
1 |   # ruff: noqa: E501
2 | / """
3 | | Games Menu UI for AI Typing Trainer (PySide6).
4 | | Provides access to various typing games and entertainment features.
5 | | """
  | |___^
6 |
7 |   import os
  |
help: Remove whitespace after opening quotes

D212 [*] Multi-line docstring summary should start at the first line
  --> desktop_ui\games_menu.py:18:5
   |
17 |   class GamesMenu(QtWidgets.QDialog):
18 | /     """
19 | |     Games Menu UI for AI Typing Trainer.
20 | |     
21 | |     Provides access to various typing games and entertainment features.
22 | |     Uses the same modern styling as the main menu for consistency.
23 | |     """
   | |_______^
24 |
25 |       def __init__(self, parent: Optional[QtWidgets.QWidget] = None) -> None:
   |
help: Remove whitespace after opening quotes

D107 Missing docstring in `__init__`
  --> desktop_ui\games_menu.py:25:9
   |
23 |     """
24 |
25 |     def __init__(self, parent: Optional[QtWidgets.QWidget] = None) -> None:
   |         ^^^^^^^^
26 |         super().__init__(parent)
27 |         self.setWindowTitle("Games Menu - AI Typing Trainer")
   |

D205 1 blank line required between summary line and description
 --> desktop_ui\graphql_client.py:1:1
  |
1 | / """
2 | | GraphQL client for PySide6 desktop UI.
3 | | Handles queries and mutations to /api/library_graphql.
4 | | """
  | |___^
5 |
6 |   from typing import Any, Dict, Optional
  |
help: Insert single blank line

D212 [*] Multi-line docstring summary should start at the first line
 --> desktop_ui\graphql_client.py:1:1
  |
1 | / """
2 | | GraphQL client for PySide6 desktop UI.
3 | | Handles queries and mutations to /api/library_graphql.
4 | | """
  | |___^
5 |
6 |   from typing import Any, Dict, Optional
  |
help: Remove whitespace after opening quotes

D101 Missing docstring in public class
  --> desktop_ui\graphql_client.py:13:7
   |
13 | class GraphQLClient:
   |       ^^^^^^^^^^^^^
14 |     def __init__(self, api_url: str = API_URL):
15 |         self.api_url = api_url
   |

ANN204 Missing return type annotation for special method `__init__`
  --> desktop_ui\graphql_client.py:14:9
   |
13 | class GraphQLClient:
14 |     def __init__(self, api_url: str = API_URL):
   |         ^^^^^^^^
15 |         self.api_url = api_url
   |
help: Add return type annotation: `None`

D107 Missing docstring in `__init__`
  --> desktop_ui\graphql_client.py:14:9
   |
13 | class GraphQLClient:
14 |     def __init__(self, api_url: str = API_URL):
   |         ^^^^^^^^
15 |         self.api_url = api_url
   |

D102 Missing docstring in public method
  --> desktop_ui\graphql_client.py:17:9
   |
15 |         self.api_url = api_url
16 |
17 |     def query(
   |         ^^^^^
18 |         self, query: str, variables: Optional[Dict[str, Any]] = None
19 |     ) -> Dict[str, Any]:
   |

D205 1 blank line required between summary line and description
 --> desktop_ui\library_main.py:1:1
  |
1 | / """PySide6 Desktop UI for the Snippets Library
2 | | - Fullscreen main window, maximized dialogs
3 | | - Category and snippet management with validation and error dialogs
4 | | - Direct integration with the model layer (no GraphQL)
5 | | """
  | |___^
6 |
7 |   import os
  |
help: Insert single blank line

D415 First line should end with a period, question mark, or exclamation point
 --> desktop_ui\library_main.py:1:1
  |
1 | / """PySide6 Desktop UI for the Snippets Library
2 | | - Fullscreen main window, maximized dialogs
3 | | - Category and snippet management with validation and error dialogs
4 | | - Direct integration with the model layer (no GraphQL)
5 | | """
  | |___^
6 |
7 |   import os
  |
help: Add closing punctuation

D205 1 blank line required between summary line and description
  --> desktop_ui\library_main.py:40:5
   |
39 |   class LibraryMainWindow(QMainWindow):
40 | /     """
41 | |     Modern Windows 11-style Snippets Library main window (PyQt5).
42 | |     Implements all category and snippet management features as per Library.md spec.
43 | |     """
   | |_______^
44 |
45 |       def __init__(
   |
help: Insert single blank line

D212 [*] Multi-line docstring summary should start at the first line
  --> desktop_ui\library_main.py:40:5
   |
39 |   class LibraryMainWindow(QMainWindow):
40 | /     """
41 | |     Modern Windows 11-style Snippets Library main window (PyQt5).
42 | |     Implements all category and snippet management features as per Library.md spec.
43 | |     """
   | |_______^
44 |
45 |       def __init__(
   |
help: Remove whitespace after opening quotes

D205 1 blank line required between summary line and description
  --> desktop_ui\library_main.py:48:9
   |
46 |           self, db_manager: Optional[DatabaseManager] = None, testing_mode: bool = False
47 |       ) -> None:
48 | /         """
49 | |         Initialize the LibraryMainWindow.
50 | |         :param db_manager: Optional DatabaseManager instance to use (for testability/
51 | |             singleton connection)
52 | |         :param testing_mode: If True, suppress modal dialogs for automated testing.
53 | |         """
   | |___________^
54 |           super().__init__()
55 |           self.testing_mode = testing_mode
   |
help: Insert single blank line

D212 [*] Multi-line docstring summary should start at the first line
  --> desktop_ui\library_main.py:48:9
   |
46 |           self, db_manager: Optional[DatabaseManager] = None, testing_mode: bool = False
47 |       ) -> None:
48 | /         """
49 | |         Initialize the LibraryMainWindow.
50 | |         :param db_manager: Optional DatabaseManager instance to use (for testability/
51 | |             singleton connection)
52 | |         :param testing_mode: If True, suppress modal dialogs for automated testing.
53 | |         """
   | |___________^
54 |           super().__init__()
55 |           self.testing_mode = testing_mode
   |
help: Remove whitespace after opening quotes

D102 Missing docstring in public method
   --> desktop_ui\library_main.py:200:9
    |
198 |             self.show_error(f"Error loading data: {e}")
199 |
200 |     def show_error(self, msg: str) -> None:
    |         ^^^^^^^^^^
201 |         if self.testing_mode:
202 |             print(f"ERROR: {msg}")
    |

D102 Missing docstring in public method
   --> desktop_ui\library_main.py:207:9
    |
205 |         self.status.setText(msg)
206 |
207 |     def show_info(self, msg: str) -> None:
    |         ^^^^^^^^^
208 |         if self.testing_mode:
209 |             print(f"INFO: {msg}")
    |

D102 Missing docstring in public method
   --> desktop_ui\library_main.py:214:9
    |
212 |         self.status.setText(msg)
213 |
214 |     def filter_snippets(self, search_text: str) -> None:
    |         ^^^^^^^^^^^^^^^
215 |         if not self.selected_category:
216 |             self.snippetList.clear()
    |

D102 Missing docstring in public method
   --> desktop_ui\library_main.py:228:9
    |
226 |             self.snippetList.addItem(item)
227 |
228 |     def refresh_categories(self) -> None:
    |         ^^^^^^^^^^^^^^^^^^
229 |         self.categoryList.clear()
230 |         for cat in self.categories:
    |

D102 Missing docstring in public method
   --> desktop_ui\library_main.py:235:9
    |
233 |             self.categoryList.addItem(item)
234 |
235 |     def on_category_selection_changed(self) -> None:
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
236 |         items = self.categoryList.selectedItems()
237 |         if not items:
    |

D102 Missing docstring in public method
   --> desktop_ui\library_main.py:248:9
    |
246 |         self.update_snippet_buttons_state(True)
247 |
248 |     def update_snippet_buttons_state(self, enabled: bool) -> None:
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
249 |         self.addSnipBtn.setEnabled(enabled)
250 |         self.editSnipBtn.setEnabled(enabled)
    |

D102 Missing docstring in public method
   --> desktop_ui\library_main.py:253:9
    |
251 |         self.delSnipBtn.setEnabled(enabled)
252 |
253 |     def on_snippet_selection_changed(self, item: QListWidgetItem) -> None:
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
254 |         snippet: Optional[Snippet] = item.data(Qt.ItemDataRole.UserRole)
255 |         self.selected_snippet = snippet
    |

D102 Missing docstring in public method
   --> desktop_ui\library_main.py:258:9
    |
256 |         # No auto-view on click; only on double-click
257 |
258 |     def load_snippets(self) -> None:
    |         ^^^^^^^^^^^^^
259 |         self.snippetList.clear()
260 |         if not self.selected_category:
    |

D102 Missing docstring in public method
   --> desktop_ui\library_main.py:273:9
    |
271 |             self.show_error(f"Error loading snippets: {e}")
272 |
273 |     def add_category(self) -> None:
    |         ^^^^^^^^^^^^
274 |         dlg = CategoryDialog("Add Category", "Category Name", parent=self)
275 |         if dlg.exec_() == QtWidgets.QDialog.DialogCode.Accepted:
    |

D102 Missing docstring in public method
   --> desktop_ui\library_main.py:286:9
    |
284 |                 self.show_error(f"Failed to add category: {e}")
285 |
286 |     def edit_category(self) -> None:
    |         ^^^^^^^^^^^^^
287 |         items = self.categoryList.selectedItems()
288 |         if not items:
    |

D102 Missing docstring in public method
   --> desktop_ui\library_main.py:306:9
    |
304 |                 self.show_error(f"Failed to update category: {e}")
305 |
306 |     def delete_category(self) -> None:
    |         ^^^^^^^^^^^^^^^
307 |         items = self.categoryList.selectedItems()
308 |         if not items:
    |

D102 Missing docstring in public method
   --> desktop_ui\library_main.py:329:9
    |
327 |             self.show_error(f"Failed to delete category: {e}")
328 |
329 |     def add_snippet(self) -> None:
    |         ^^^^^^^^^^^
330 |         if not self.selected_category:
331 |             self.show_error("No category selected.")
    |

D102 Missing docstring in public method
   --> desktop_ui\library_main.py:347:9
    |
345 |                 self.show_error(f"Failed to add snippet: {e}")
346 |
347 |     def edit_snippet(self) -> None:
    |         ^^^^^^^^^^^^
348 |         items = self.snippetList.selectedItems()
349 |         if not items:
    |

D102 Missing docstring in public method
   --> desktop_ui\library_main.py:372:9
    |
370 |                 self.show_error(f"Failed to update snippet: {e}")
371 |
372 |     def delete_snippet(self) -> None:
    |         ^^^^^^^^^^^^^^
373 |         items = self.snippetList.selectedItems()
374 |         if not items:
    |

D102 Missing docstring in public method
   --> desktop_ui\library_main.py:393:9
    |
391 |             self.show_error(f"Failed to delete snippet: {e}")
392 |
393 |     def view_snippet(self, item: QListWidgetItem) -> None:
    |         ^^^^^^^^^^^^
394 |         snippet: Optional[Snippet] = item.data(Qt.ItemDataRole.UserRole)
395 |         if snippet:
    |

D205 1 blank line required between summary line and description
   --> desktop_ui\library_main.py:406:5
    |
405 |   def _modern_qss() -> str:
406 | /     """Return QSS for a modern Windows 11 look (rounded corners, subtle shadows,
407 | |     modern palette)."""
    | |_______________________^
408 |       return """
409 |       QWidget {
    |
help: Insert single blank line

D209 [*] Multi-line docstring closing quotes should be on a separate line
   --> desktop_ui\library_main.py:406:5
    |
405 |   def _modern_qss() -> str:
406 | /     """Return QSS for a modern Windows 11 look (rounded corners, subtle shadows,
407 | |     modern palette)."""
    | |_______________________^
408 |       return """
409 |       QWidget {
    |
help: Move closing quotes to new line

D100 Missing docstring in public module
--> desktop_ui\main_menu.py:1:1

D212 [*] Multi-line docstring summary should start at the first line
  --> desktop_ui\main_menu.py:40:5
   |
39 |   class MainMenu(QWidget):
40 | /     """
41 | |     Modern Main Menu UI for AI Typing Trainer (PySide6).
42 | |
43 | |     - Uses Fusion style, Segoe UI font, and modern color palette
44 | |     - Initiates a single DatabaseManager connection to typing_data.db
45 | |     - Passes the open database connection to the Library window
46 | |     - Testable: supports dependency injection and testing_mode
47 | |     """
   | |_______^
48 |
49 |       def __init__(
   |
help: Remove whitespace after opening quotes

D107 Missing docstring in `__init__`
  --> desktop_ui\main_menu.py:49:9
   |
47 |     """
48 |
49 |     def __init__(
   |         ^^^^^^^^
50 |         self,
51 |         db_path: Optional[str] = None,
   |

D102 Missing docstring in public method
  --> desktop_ui\main_menu.py:92:9
   |
90 |         self.setup_ui()
91 |
92 |     def center_on_screen(self) -> None:
   |         ^^^^^^^^^^^^^^^^
93 |         screen = QApplication.primaryScreen()
94 |         if screen is not None:
   |

D102 Missing docstring in public method
   --> desktop_ui\main_menu.py:101:9
    |
 99 |             self.move(x, y)
100 |
101 |     def setup_ui(self) -> None:
    |         ^^^^^^^^
102 |         layout = QVBoxLayout()
103 |         header = QLabel("AI Typing Trainer")
    |

D102 Missing docstring in public method
   --> desktop_ui\main_menu.py:142:9
    |
140 |         self.setLayout(layout)
141 |
142 |     def button_stylesheet(self, normal: bool = True) -> str:
    |         ^^^^^^^^^^^^^^^^^
143 |         if normal:
144 |             return (
    |

D102 Missing docstring in public method
   --> desktop_ui\main_menu.py:155:9
    |
153 |             )
154 |
155 |     def eventFilter(self, obj: QObject, event: QEvent) -> bool:
    |         ^^^^^^^^^^^
156 |         if isinstance(obj, QPushButton):
157 |             if event.type() == QEvent.Type.Enter:
    |

E501 Line too long (125 > 120)
   --> desktop_ui\main_menu.py:306:121
    |
304 |             for i in range(self.keyboard_combo.count()):
305 |                 kbd = cast(Optional[Keyboard], self.keyboard_combo.itemData(i))
306 |                 if kbd is not None and getattr(kbd, "keyboard_id", None) is not None and str(kbd.keyboard_id) == last_kbd_id:
    |                                                                                                                         ^^^^^
307 |                     self.keyboard_combo.setCurrentIndex(i)
308 |                     return
    |

D205 1 blank line required between summary line and description
   --> desktop_ui\main_menu.py:505:9
    |
504 |       def reset_sessions(self) -> None:
505 | /         """
506 | |         Reset all session data after user confirmation.
507 | |         The following tables will be cleared:
508 | |         - practice_sessions
509 | |         - session_keystrokes
510 | |         - session_ngram_speed
511 | |         - session_ngram_errors
512 | |         """
    | |___________^
513 |           # Create confirmation dialog
514 |           confirm = QMessageBox.question(
    |
help: Insert single blank line

D212 [*] Multi-line docstring summary should start at the first line
   --> desktop_ui\main_menu.py:505:9
    |
504 |       def reset_sessions(self) -> None:
505 | /         """
506 | |         Reset all session data after user confirmation.
507 | |         The following tables will be cleared:
508 | |         - practice_sessions
509 | |         - session_keystrokes
510 | |         - session_ngram_speed
511 | |         - session_ngram_errors
512 | |         """
    | |___________^
513 |           # Create confirmation dialog
514 |           confirm = QMessageBox.question(
    |
help: Remove whitespace after opening quotes

D415 First line should end with a period, question mark, or exclamation point
   --> desktop_ui\main_menu.py:505:9
    |
504 |       def reset_sessions(self) -> None:
505 | /         """
506 | |         Reset all session data after user confirmation.
507 | |         The following tables will be cleared:
508 | |         - practice_sessions
509 | |         - session_keystrokes
510 | |         - session_ngram_speed
511 | |         - session_ngram_errors
512 | |         """
    | |___________^
513 |           # Create confirmation dialog
514 |           confirm = QMessageBox.question(
    |
help: Add closing punctuation

D205 1 blank line required between summary line and description
 --> desktop_ui\metroid_typing_game.py:2:1
  |
1 |   # ruff: noqa: E501
2 | / """
3 | | Metroid-style Typing Game for AI Typing Trainer (PySide6).
4 | | Words float in from edges toward center, user types to destroy them.
5 | | Features exponential scoring and orange highlighting for matching words.
6 | | """
  | |___^
7 |
8 |   import math
  |
help: Insert single blank line

D212 [*] Multi-line docstring summary should start at the first line
 --> desktop_ui\metroid_typing_game.py:2:1
  |
1 |   # ruff: noqa: E501
2 | / """
3 | | Metroid-style Typing Game for AI Typing Trainer (PySide6).
4 | | Words float in from edges toward center, user types to destroy them.
5 | | Features exponential scoring and orange highlighting for matching words.
6 | | """
  | |___^
7 |
8 |   import math
  |
help: Remove whitespace after opening quotes

D107 Missing docstring in `__init__`
  --> desktop_ui\metroid_typing_game.py:19:9
   |
17 |     """Represents a word floating toward the center of the screen."""
18 |     
19 |     def __init__(self, text: str, start_x: float, start_y: float, target_x: float, target_y: float, is_bonus: bool = False) -> None:
   |         ^^^^^^^^
20 |         self.text = text
21 |         self.original_text = text
   |

D205 1 blank line required between summary line and description
  --> desktop_ui\metroid_typing_game.py:90:5
   |
89 |   class MetroidTypingGame(QtWidgets.QDialog):
90 | /     """
91 | |     Metroid-style typing game where words float in from edges toward center.
92 | |     Features exponential scoring and real-time highlighting.
93 | |     """
   | |_______^
94 |
95 |       def __init__(self, parent: Optional[QtWidgets.QWidget] = None, word_list: Optional[List[str]] = None) -> None:
   |
help: Insert single blank line

D212 [*] Multi-line docstring summary should start at the first line
  --> desktop_ui\metroid_typing_game.py:90:5
   |
89 |   class MetroidTypingGame(QtWidgets.QDialog):
90 | /     """
91 | |     Metroid-style typing game where words float in from edges toward center.
92 | |     Features exponential scoring and real-time highlighting.
93 | |     """
   | |_______^
94 |
95 |       def __init__(self, parent: Optional[QtWidgets.QWidget] = None, word_list: Optional[List[str]] = None) -> None:
   |
help: Remove whitespace after opening quotes

D107 Missing docstring in `__init__`
  --> desktop_ui\metroid_typing_game.py:95:9
   |
93 |     """
94 |
95 |     def __init__(self, parent: Optional[QtWidgets.QWidget] = None, word_list: Optional[List[str]] = None) -> None:
   |         ^^^^^^^^
96 |         super().__init__(parent)
97 |         self.setWindowTitle("Metroid Typing Game - AI Typing Trainer")
   |

D205 1 blank line required between summary line and description
 --> desktop_ui\modern_dialogs.py:1:1
  |
1 | / """
2 | | Modern Windows 11-style dialogs for the Snippets Library desktop UI.
3 | | Includes: CategoryDialog, SnippetDialog (with multi-line editing), ConfirmDialog.
4 | | """
  | |___^
5 |
6 |   from typing import Optional
  |
help: Insert single blank line

D212 [*] Multi-line docstring summary should start at the first line
 --> desktop_ui\modern_dialogs.py:1:1
  |
1 | / """
2 | | Modern Windows 11-style dialogs for the Snippets Library desktop UI.
3 | | Includes: CategoryDialog, SnippetDialog (with multi-line editing), ConfirmDialog.
4 | | """
  | |___^
5 |
6 |   from typing import Optional
  |
help: Remove whitespace after opening quotes

D101 Missing docstring in public class
  --> desktop_ui\modern_dialogs.py:34:7
   |
34 | class CategoryDialog(QDialog):
   |       ^^^^^^^^^^^^^^
35 |     def __init__(
36 |         self: "CategoryDialog",
   |

D107 Missing docstring in `__init__`
  --> desktop_ui\modern_dialogs.py:35:9
   |
34 | class CategoryDialog(QDialog):
35 |     def __init__(
   |         ^^^^^^^^
36 |         self: "CategoryDialog",
37 |         title: str,
   |

D102 Missing docstring in public method
  --> desktop_ui\modern_dialogs.py:67:9
   |
65 |         self.input.returnPressed.connect(self.accept)
66 |
67 |     def get_value(self) -> str:
   |         ^^^^^^^^^
68 |         return self.input.text().strip()
   |

D101 Missing docstring in public class
  --> desktop_ui\modern_dialogs.py:71:7
   |
71 | class SnippetDialog(QDialog):
   |       ^^^^^^^^^^^^^
72 |     def __init__(
73 |         self: "SnippetDialog",
   |

D107 Missing docstring in `__init__`
  --> desktop_ui\modern_dialogs.py:72:9
   |
71 | class SnippetDialog(QDialog):
72 |     def __init__(
   |         ^^^^^^^^
73 |         self: "SnippetDialog",
74 |         title: str,
   |

D102 Missing docstring in public method
   --> desktop_ui\modern_dialogs.py:112:9
    |
110 |         self.name_input.returnPressed.connect(self.accept)
111 |
112 |     def get_values(self) -> tuple[str, str]:
    |         ^^^^^^^^^^
113 |         name = remove_non_ascii(self.name_input.text().strip())
114 |         content = remove_non_ascii(self.content_input.toPlainText().strip())
    |

D212 [*] Multi-line docstring summary should start at the first line
 --> desktop_ui\ngram_heatmap_screen.py:1:1
  |
1 | / """
2 | | NGram Speed Heatmap UI Screen.
3 | |
4 | | This module provides a desktop UI for visualizing n-gram typing speed performance
5 | | using a heatmap with filtering, sorting, and color coding capabilities.
6 | | """
  | |___^
7 |
8 |   import os
  |
help: Remove whitespace after opening quotes

D212 [*] Multi-line docstring summary should start at the first line
  --> desktop_ui\ngram_heatmap_screen.py:25:5
   |
24 |   class NGramHeatmapDialog(QtWidgets.QDialog):
25 | /     """
26 | |     N-gram Speed Heatmap visualization screen.
27 | |
28 | |     Features:
29 | |     - Interactive heatmap showing n-gram typing speeds
30 | |     - Color-coded performance indicators
31 | |     - Filtering by n-gram size, speed ranges, and performance levels
32 | |     - Sorting options for different metrics
33 | |     - Export functionality for analysis data
34 | |     """
   | |_______^
35 |
36 |       def __init__(
   |
help: Remove whitespace after opening quotes

D212 [*] Multi-line docstring summary should start at the first line
  --> desktop_ui\ngram_heatmap_screen.py:43:9
   |
41 |           parent: Optional[QtWidgets.QWidget] = None,
42 |       ) -> None:
43 | /         """
44 | |         Initialize the NGram Heatmap Dialog.
45 | |
46 | |         Args:
47 | |             db_manager: Database manager instance
48 | |             user: Current user
49 | |             keyboard: Current keyboard
50 | |             parent: Parent widget (optional)
51 | |         """
   | |___________^
52 |           super().__init__(parent)
53 |           self.db_manager = db_manager
   |
help: Remove whitespace after opening quotes

F841 Local variable `min_speed` is assigned to but never used
   --> desktop_ui\ngram_heatmap_screen.py:276:9
    |
275 |         # Get filter values
276 |         min_speed = self.speed_min_spin.value()
    |         ^^^^^^^^^
277 |         max_speed = self.speed_max_spin.value()
278 |         ngram_size = self.ngram_size_combo.currentData()
    |
help: Remove assignment to unused variable `min_speed`

F841 Local variable `max_speed` is assigned to but never used
   --> desktop_ui\ngram_heatmap_screen.py:277:9
    |
275 |         # Get filter values
276 |         min_speed = self.speed_min_spin.value()
277 |         max_speed = self.speed_max_spin.value()
    |         ^^^^^^^^^
278 |         ngram_size = self.ngram_size_combo.currentData()
    |
help: Remove assignment to unused variable `max_speed`

F841 Local variable `ngram_size` is assigned to but never used
   --> desktop_ui\ngram_heatmap_screen.py:278:9
    |
276 |         min_speed = self.speed_min_spin.value()
277 |         max_speed = self.speed_max_spin.value()
278 |         ngram_size = self.ngram_size_combo.currentData()
    |         ^^^^^^^^^^
279 |
280 |         # Update display
    |
help: Remove assignment to unused variable `ngram_size`

D100 Missing docstring in public module
--> desktop_ui\ngram_llm_screen.py:1:1

D101 Missing docstring in public class
  --> desktop_ui\ngram_llm_screen.py:21:7
   |
21 | class NgramLLMScreen(QWidget):
   |       ^^^^^^^^^^^^^^
22 |     def __init__(self, parent: Optional[Any] = None) -> None:
23 |         super().__init__(parent)
   |

D107 Missing docstring in `__init__`
  --> desktop_ui\ngram_llm_screen.py:22:9
   |
21 | class NgramLLMScreen(QWidget):
22 |     def __init__(self, parent: Optional[Any] = None) -> None:
   |         ^^^^^^^^
23 |         super().__init__(parent)
24 |         self.setWindowTitle("LLM N-Gram Word Generator")
   |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `parent`
  --> desktop_ui\ngram_llm_screen.py:22:32
   |
21 | class NgramLLMScreen(QWidget):
22 |     def __init__(self, parent: Optional[Any] = None) -> None:
   |                                ^^^^^^^^^^^^^
23 |         super().__init__(parent)
24 |         self.setWindowTitle("LLM N-Gram Word Generator")
   |

D102 Missing docstring in public method
  --> desktop_ui\ngram_llm_screen.py:63:9
   |
61 |         self.init_ui()
62 |
63 |     def init_ui(self) -> None:
   |         ^^^^^^^
64 |         layout = QVBoxLayout()
   |

D102 Missing docstring in public method
  --> desktop_ui\ngram_llm_screen.py:92:9
   |
90 |         self.setLayout(layout)
91 |
92 |     def add_snippet_input(self) -> None:
   |         ^^^^^^^^^^^^^^^^^
93 |         hbox = QHBoxLayout()
94 |         line_edit = QLineEdit()
   |

D102 Missing docstring in public method
   --> desktop_ui\ngram_llm_screen.py:104:9
    |
102 |         self.snippet_inputs.append(line_edit)
103 |
104 |     def remove_snippet_input(self, hbox: QHBoxLayout, line_edit: QLineEdit) -> None:
    |         ^^^^^^^^^^^^^^^^^^^^
105 |         # Remove from layout and list
106 |         for i in reversed(range(hbox.count())):
    |

D102 Missing docstring in public method
   --> desktop_ui\ngram_llm_screen.py:115:9
    |
113 |             self.snippet_inputs.remove(line_edit)
114 |
115 |     def call_llm(self) -> None:
    |         ^^^^^^^^
116 |         if not self.service:
117 |             QMessageBox.critical(self, "Service Error", "LLM service not available.")
    |

D212 [*] Multi-line docstring summary should start at the first line
 --> desktop_ui\query_screen.py:1:1
  |
1 | / """
2 | | SQL Query Screen for AI Typing Trainer (PySide6)
3 | |
4 | | This module provides a GUI for executing custom SQL queries on the database and viewing results.
5 | | """
  | |___^
6 |
7 |   from typing import Any, Dict, List, Optional
  |
help: Remove whitespace after opening quotes

D415 First line should end with a period, question mark, or exclamation point
 --> desktop_ui\query_screen.py:1:1
  |
1 | / """
2 | | SQL Query Screen for AI Typing Trainer (PySide6)
3 | |
4 | | This module provides a GUI for executing custom SQL queries on the database and viewing results.
5 | | """
  | |___^
6 |
7 |   from typing import Any, Dict, List, Optional
  |
help: Add closing punctuation

D212 [*] Multi-line docstring summary should start at the first line
  --> desktop_ui\query_screen.py:30:5
   |
29 |   class QueryScreen(QDialog):
30 | /     """
31 | |     Dialog for executing custom SQL queries on the database.
32 | |
33 | |     Features:
34 | |     - User and keyboard ID display
35 | |     - SQL query input
36 | |     - Dynamic results grid
37 | |     - Error handling
38 | |
39 | |     Args:
40 | |         db_manager: DatabaseManager instance to execute queries
41 | |         user_id: ID of the current user
42 | |         keyboard_id: ID of the current keyboard
43 | |         parent: Optional parent widget
44 | |     """
   | |_______^
45 |
46 |       def __init__(
   |
help: Remove whitespace after opening quotes

D107 Missing docstring in `__init__`
  --> desktop_ui\query_screen.py:46:9
   |
44 |     """
45 |
46 |     def __init__(
   |         ^^^^^^^^
47 |         self,
48 |         db_manager: DatabaseManager,
   |

D212 [*] Multi-line docstring summary should start at the first line
   --> desktop_ui\query_screen.py:181:9
    |
180 |       def _execute_raw_query(self, query: str) -> List[Dict[str, Any]]:
181 | /         """
182 | |         Execute a raw SQL query using the DatabaseManager.
183 | |
184 | |         Args:
185 | |             query: The SQL query to execute
186 | |
187 | |         Returns:
188 | |             A list of dictionaries representing the query results
189 | |         """
    | |___________^
190 |           # Ensure we have a database connection
191 |           if not self.db_manager:
    |
help: Remove whitespace after opening quotes

D212 [*] Multi-line docstring summary should start at the first line
   --> desktop_ui\query_screen.py:207:9
    |
206 |       def _populate_results_table(self, results: List[Dict[str, Any]]) -> None:
207 | /         """
208 | |         Populate the results table with query results.
209 | |
210 | |         Args:
211 | |             results: List of dictionaries representing query results
212 | |         """
    | |___________^
213 |           if not results:
214 |               return
    |
help: Remove whitespace after opening quotes

D212 [*] Multi-line docstring summary should start at the first line
 --> desktop_ui\scaffold_add_speed_summary_for_session.py:1:1
  |
1 | / """
2 | | ScaffoldAddSpeedSummaryForSession UI form for triggering speed summary for a specific session.
3 | |
4 | | This form provides an interface to run the AddSpeedSummaryForSession method
5 | | from the NGramAnalyticsService for a specific session ID.
6 | | """
  | |___^
7 |
8 |   # Standard library imports
  |
help: Remove whitespace after opening quotes

D107 Missing docstring in `__init__`
  --> desktop_ui\scaffold_add_speed_summary_for_session.py:43:9
   |
41 |     error = Signal(str)      # Signal with error message
42 |     
43 |     def __init__(self, analytics_service: NGramAnalyticsService, session_id: str) -> None:
   |         ^^^^^^^^
44 |         super().__init__()
45 |         self.analytics_service = analytics_service
   |

D102 Missing docstring in public method
  --> desktop_ui\scaffold_add_speed_summary_for_session.py:48:9
   |
46 |         self.session_id = session_id
47 |     
48 |     def run(self) -> None:
   |         ^^^
49 |         try:
50 |             result = self.analytics_service.add_speed_summary_for_session(self.session_id)
   |

D212 [*] Multi-line docstring summary should start at the first line
  --> desktop_ui\scaffold_add_speed_summary_for_session.py:57:5
   |
56 |   class ScaffoldAddSpeedSummaryForSession(QWidget):
57 | /     """
58 | |     UI form for triggering speed summary for a specific session.
59 | |     
60 | |     Provides an interface with session ID input and a button to run the 
61 | |     AddSpeedSummaryForSession method and displays progress and results.
62 | |     """
   | |_______^
63 |       
64 |       def __init__(
   |
help: Remove whitespace after opening quotes

D107 Missing docstring in `__init__`
  --> desktop_ui\scaffold_add_speed_summary_for_session.py:64:9
   |
62 |     """
63 |     
64 |     def __init__(
   |         ^^^^^^^^
65 |         self,
66 |         db_path: Optional[str] = None,
   |

D212 [*] Multi-line docstring summary should start at the first line
 --> desktop_ui\scaffold_bulk_insert_performance.py:1:1
  |
1 | / """
2 | | ScaffoldBulkInsertPerformance UI form for benchmarking bulk insert strategies on Aurora PostgreSQL.
3 | |
4 | | This screen connects to the cloud database, creates a temporary test table
5 | | `test_bulk_performance`, runs timed inserts (10,000 rows) using several methods,
6 | | then drops the table and shows results.
7 | | """
  | |___^
8 |
9 |   from __future__ import annotations
  |
help: Remove whitespace after opening quotes

F401 [*] `typing.Dict` imported but unused
  --> desktop_ui\scaffold_bulk_insert_performance.py:18:20
   |
16 | from dataclasses import dataclass
17 | from datetime import datetime, timezone
18 | from typing import Dict, List, Optional, Tuple
   |                    ^^^^
19 | from uuid import uuid4
   |
help: Remove unused import

F401 [*] `typing.Optional` imported but unused
  --> desktop_ui\scaffold_bulk_insert_performance.py:18:32
   |
16 | from dataclasses import dataclass
17 | from datetime import datetime, timezone
18 | from typing import Dict, List, Optional, Tuple
   |                                ^^^^^^^^
19 | from uuid import uuid4
   |
help: Remove unused import

E402 Module level import not at top of file
  --> desktop_ui\scaffold_bulk_insert_performance.py:40:1
   |
38 |     sys.path.insert(0, project_root)
39 |
40 | from db.database_manager import BulkMethod, ConnectionType, DatabaseManager
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |

D101 Missing docstring in public class
  --> desktop_ui\scaffold_bulk_insert_performance.py:44:7
   |
43 | @dataclass
44 | class TimingResult:
   |       ^^^^^^^^^^^^
45 |     label: str
46 |     rows: int
   |

D107 Missing docstring in `__init__`
  --> desktop_ui\scaffold_bulk_insert_performance.py:56:9
   |
54 |     TABLE_NAME = "test_bulk_performance"
55 |
56 |     def __init__(self, connection_type: ConnectionType = ConnectionType.CLOUD) -> None:
   |         ^^^^^^^^
57 |         super().__init__()
58 |         self.setWindowTitle("Bulk Insert Performance Benchmark")
   |

ANN001 Missing type annotation for function argument `func`
   --> desktop_ui\scaffold_bulk_insert_performance.py:132:35
    |
130 |         return rows
131 |
132 |     def _timeit(self, label: str, func, rows_count: int) -> float:
    |                                   ^^^^
133 |         t0 = time.perf_counter()
134 |         func()
    |

D102 Missing docstring in public method
   --> desktop_ui\scaffold_bulk_insert_performance.py:154:9
    |
153 |     # ----------------------- Benchmark actions -----------------------
154 |     def on_run(self) -> None:
    |         ^^^^^^
155 |         self.run_btn.setEnabled(False)
156 |         self._clear_previous()
    |

D102 Missing docstring in public method
   --> desktop_ui\scaffold_bulk_insert_performance.py:237:9
    |
235 |             self.run_btn.setEnabled(True)
236 |
237 |     def closeEvent(self, event: QCloseEvent) -> None:  # noqa: N802 (Qt signature)
    |         ^^^^^^^^^^
238 |         try:
239 |             self.db.close()
    |

D103 Missing docstring in public function
   --> desktop_ui\scaffold_bulk_insert_performance.py:245:5
    |
245 | def launch_scaffold_bulk_insert_performance() -> None:
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
246 |     app = QtWidgets.QApplication.instance()
247 |     if app is None:
    |

D212 [*] Multi-line docstring summary should start at the first line
 --> desktop_ui\scaffold_catchup_speed_summary.py:1:1
  |
1 | / """
2 | | ScaffoldCatchupSpeedSummary UI form for triggering speed summary catchup for all sessions.
3 | |
4 | | This form provides an interface to run the CatchupSpeedSummary method
5 | | from the NGramAnalyticsService to process all sessions from oldest to newest.
6 | | """
  | |___^
7 |
8 |   import os
  |
help: Remove whitespace after opening quotes

D107 Missing docstring in `__init__`
  --> desktop_ui\scaffold_catchup_speed_summary.py:42:9
   |
40 |     session_processed = Signal(str, int, int)  # Signal for individual session progress (session_info, current, total)
41 |
42 |     def __init__(self, analytics_service: NGramAnalyticsService) -> None:
   |         ^^^^^^^^
43 |         super().__init__()
44 |         self.analytics_service = analytics_service
   |

D102 Missing docstring in public method
  --> desktop_ui\scaffold_catchup_speed_summary.py:46:9
   |
44 |         self.analytics_service = analytics_service
45 |
46 |     def run(self) -> None:
   |         ^^^
47 |         try:
48 |             result = self.catchup_speed_summary_with_progress()
   |

D212 [*] Multi-line docstring summary should start at the first line
   --> desktop_ui\scaffold_catchup_speed_summary.py:128:5
    |
127 |   class ScaffoldCatchupSpeedSummary(QDialog):
128 | /     """
129 | |     UI form for triggering speed summary catchup for all sessions.
130 | |
131 | |     Provides an interface with a button to run the CatchupSpeedSummary method
132 | |     and displays progress and results in real-time.
133 | |     """
    | |_______^
134 |
135 |       def __init__(
    |
help: Remove whitespace after opening quotes

D107 Missing docstring in `__init__`
   --> desktop_ui\scaffold_catchup_speed_summary.py:135:9
    |
133 |     """
134 |
135 |     def __init__(
    |         ^^^^^^^^
136 |         self, db_path: Optional[str] = None, connection_type: ConnectionType = ConnectionType.CLOUD
137 |     ) -> None:
    |

E501 Line too long (141 > 120)
   --> desktop_ui\scaffold_catchup_speed_summary.py:189:121
    |
187 | 
188 | 
189 | e; padding: 12px; font-size: 14px; border-radius: 5px; font-weight: bold; }"
    |                                                         ^^^^^^^^^^^^^^^^^^^^^
190 | 
191 | 
    |

D100 Missing docstring in public module
--> desktop_ui\scaffold_llm_call.py:1:1

D205 1 blank line required between summary line and description
  --> desktop_ui\scaffold_llm_call.py:34:5
   |
33 |   class ScaffoldLLMCallDialog(QDialog):
34 | /     """
35 | |     Minimal scaffold to test an LLM call:
36 | |     - One text entry box for the prompt (editable)
37 | |     - One result box where the result content is displayed (read-only)
38 | |
39 | |     It loads the default prompt from Prompts/ngram_words_prompt.txt if available.
40 | |     Uses OPENAI_API_KEY from environment to initialize the service.
41 | |     Calls LLMNgramService.get_words_with_ngrams_2 with sensible defaults.
42 | |     """
   | |_______^
43 |
44 |       def __init__(self, parent: Optional[QWidget] = None) -> None:
   |
help: Insert single blank line

D212 [*] Multi-line docstring summary should start at the first line
  --> desktop_ui\scaffold_llm_call.py:34:5
   |
33 |   class ScaffoldLLMCallDialog(QDialog):
34 | /     """
35 | |     Minimal scaffold to test an LLM call:
36 | |     - One text entry box for the prompt (editable)
37 | |     - One result box where the result content is displayed (read-only)
38 | |
39 | |     It loads the default prompt from Prompts/ngram_words_prompt.txt if available.
40 | |     Uses OPENAI_API_KEY from environment to initialize the service.
41 | |     Calls LLMNgramService.get_words_with_ngrams_2 with sensible defaults.
42 | |     """
   | |_______^
43 |
44 |       def __init__(self, parent: Optional[QWidget] = None) -> None:
   |
help: Remove whitespace after opening quotes

D415 First line should end with a period, question mark, or exclamation point
  --> desktop_ui\scaffold_llm_call.py:34:5
   |
33 |   class ScaffoldLLMCallDialog(QDialog):
34 | /     """
35 | |     Minimal scaffold to test an LLM call:
36 | |     - One text entry box for the prompt (editable)
37 | |     - One result box where the result content is displayed (read-only)
38 | |
39 | |     It loads the default prompt from Prompts/ngram_words_prompt.txt if available.
40 | |     Uses OPENAI_API_KEY from environment to initialize the service.
41 | |     Calls LLMNgramService.get_words_with_ngrams_2 with sensible defaults.
42 | |     """
   | |_______^
43 |
44 |       def __init__(self, parent: Optional[QWidget] = None) -> None:
   |
help: Add closing punctuation

D107 Missing docstring in `__init__`
  --> desktop_ui\scaffold_llm_call.py:44:9
   |
42 |     """
43 |
44 |     def __init__(self, parent: Optional[QWidget] = None) -> None:
   |         ^^^^^^^^
45 |         super().__init__(parent)
46 |         self.setWindowTitle("LLM Call Scaffold")
   |

D103 Missing docstring in public function
   --> desktop_ui\scaffold_llm_call.py:171:5
    |
171 | def open_scaffold_llm_call(parent: Optional[QWidget] = None) -> None:
    |     ^^^^^^^^^^^^^^^^^^^^^^
172 |     dlg = ScaffoldLLMCallDialog(parent)
173 |     # exec() creates a modal dialog by default
    |

D212 [*] Multi-line docstring summary should start at the first line
 --> desktop_ui\scaffold_recreate_ngram_data.py:1:1
  |
1 | / """
2 | | ScaffoldRecreateNgramData UI form for recreating ngram data from session keystrokes.
3 | |
4 | | This form provides an interface to find all practice sessions that don't have
5 | | corresponding ngram data and recreate the ngrams from their keystrokes.
6 | | """
  | |___^
7 |
8 |   # Standard library imports
  |
help: Remove whitespace after opening quotes

D107 Missing docstring in `__init__`
  --> desktop_ui\scaffold_recreate_ngram_data.py:52:9
   |
50 |     session_processed = Signal(str, int, int)  # Signal for individual session progress
51 |
52 |     def __init__(self, db_manager: DatabaseManager, ngram_manager: NGramManager) -> None:
   |         ^^^^^^^^
53 |         super().__init__()
54 |         self.db_manager = db_manager
   |

D102 Missing docstring in public method
  --> desktop_ui\scaffold_recreate_ngram_data.py:57:9
   |
55 |         self.ngram_manager = ngram_manager
56 |
57 |     def run(self) -> None:
   |         ^^^
58 |         try:
59 |             result = self.recreate_ngram_data_with_progress()
   |

D212 [*] Multi-line docstring summary should start at the first line
   --> desktop_ui\scaffold_recreate_ngram_data.py:204:5
    |
203 |   class ScaffoldRecreateNgramData(QDialog):
204 | /     """
205 | |     UI form for recreating ngram data from session keystrokes.
206 | |
207 | |     Provides an interface with a button to run the recreate process
208 | |     and displays progress and results in real-time.
209 | |     """
    | |_______^
210 |
211 |       def __init__(
    |
help: Remove whitespace after opening quotes

D107 Missing docstring in `__init__`
   --> desktop_ui\scaffold_recreate_ngram_data.py:211:9
    |
209 |     """
210 |
211 |     def __init__(
    |         ^^^^^^^^
212 |         self, db_path: Optional[str] = None, connection_type: ConnectionType = ConnectionType.CLOUD
213 |     ) -> None:
    |

D102 Missing docstring in public method
   --> desktop_ui\scaffold_recreate_ngram_data.py:400:9
    |
398 |         scrollbar.setValue(scrollbar.maximum())
399 |
400 |     def on_recreate_finished(self, result: Dict[str, int]) -> None:
    |         ^^^^^^^^^^^^^^^^^^^^
401 |         self.progress_bar.setValue(100)
402 |         self.recreate_button.setEnabled(True)
    |

D212 [*] Multi-line docstring summary should start at the first line
 --> desktop_ui\scaffold_summarize_session_ngrams.py:1:1
  |
1 | / """
2 | | ScaffoldSummarizeSessionNgrams UI form for triggering session ngram summarization.
3 | |
4 | | This form provides a simple interface to run the SummarizeSessionNgrams method
5 | | from the NGramAnalyticsService.
6 | | """
  | |___^
7 |
8 |   import os
  |
help: Remove whitespace after opening quotes

D107 Missing docstring in `__init__`
  --> desktop_ui\scaffold_summarize_session_ngrams.py:39:9
   |
37 |     error = Signal(str)  # Signal with error message
38 |
39 |     def __init__(self, analytics_service: NGramAnalyticsService) -> None:
   |         ^^^^^^^^
40 |         super().__init__()
41 |         self.analytics_service = analytics_service
   |

D102 Missing docstring in public method
  --> desktop_ui\scaffold_summarize_session_ngrams.py:43:9
   |
41 |         self.analytics_service = analytics_service
42 |
43 |     def run(self) -> None:
   |         ^^^
44 |         try:
45 |             result = self.analytics_service.summarize_session_ngrams()
   |

D212 [*] Multi-line docstring summary should start at the first line
  --> desktop_ui\scaffold_summarize_session_ngrams.py:52:5
   |
51 |   class ScaffoldSummarizeSessionNgrams(QDialog):
52 | /     """
53 | |     UI form for triggering session ngram summarization.
54 | |
55 | |     Provides a simple interface with a button to run the SummarizeSessionNgrams method
56 | |     and displays progress and results.
57 | |     """
   | |_______^
58 |
59 |       def __init__(
   |
help: Remove whitespace after opening quotes

D107 Missing docstring in `__init__`
  --> desktop_ui\scaffold_summarize_session_ngrams.py:59:9
   |
57 |     """
58 |
59 |     def __init__(
   |         ^^^^^^^^
60 |         self, db_path: Optional[str] = None, connection_type: ConnectionType = ConnectionType.CLOUD
61 |     ) -> None:
   |

E501 Line too long (122 > 120)
   --> desktop_ui\scaffold_summarize_session_ngrams.py:107:121
    |
105 |         self.summarize_button = QPushButton("Summarize Ngrams")
106 |         self.summarize_button.setStyleSheet(
107 |             "QPushButton { background-color: #4CAF50; color: white; padding: 10px; font-size: 14px; border-radius: 5px; }"
    |                                                                                                                         ^^
108 |             "QPushButton:hover { background-color: #45a049; }"
109 |             "QPushButton:disabled { background-color: #cccccc; }"
    |

D205 1 blank line required between summary line and description
  --> desktop_ui\snippet_model_tester.py:1:1
   |
 1 | / """
 2 | | Snippet Model Tester UI
 3 | | ----------------------
 4 | | A simple PySide6-based desktop UI for directly testing the Snippet object model (SnippetModel, SnippetManager).
 5 | |
 6 | | - List all snippets (optionally filter by category)
 7 | | - Add a new snippet
 8 | | - Edit a snippet (name/content/category)
 9 | | - Delete a snippet
10 | | - Show validation and error messages
11 | |
12 | | Bypasses API and service layers; interacts directly with SnippetManager, SnippetModel, and CategoryManager.
13 | |
14 | | Author: Cascade AI
15 | | """
   | |___^
16 |
17 |   import os
   |
help: Insert single blank line

D212 [*] Multi-line docstring summary should start at the first line
  --> desktop_ui\snippet_model_tester.py:1:1
   |
 1 | / """
 2 | | Snippet Model Tester UI
 3 | | ----------------------
 4 | | A simple PySide6-based desktop UI for directly testing the Snippet object model (SnippetModel, SnippetManager).
 5 | |
 6 | | - List all snippets (optionally filter by category)
 7 | | - Add a new snippet
 8 | | - Edit a snippet (name/content/category)
 9 | | - Delete a snippet
10 | | - Show validation and error messages
11 | |
12 | | Bypasses API and service layers; interacts directly with SnippetManager, SnippetModel, and CategoryManager.
13 | |
14 | | Author: Cascade AI
15 | | """
   | |___^
16 |
17 |   import os
   |
help: Remove whitespace after opening quotes

D415 First line should end with a period, question mark, or exclamation point
  --> desktop_ui\snippet_model_tester.py:1:1
   |
 1 | / """
 2 | | Snippet Model Tester UI
 3 | | ----------------------
 4 | | A simple PySide6-based desktop UI for directly testing the Snippet object model (SnippetModel, SnippetManager).
 5 | |
 6 | | - List all snippets (optionally filter by category)
 7 | | - Add a new snippet
 8 | | - Edit a snippet (name/content/category)
 9 | | - Delete a snippet
10 | | - Show validation and error messages
11 | |
12 | | Bypasses API and service layers; interacts directly with SnippetManager, SnippetModel, and CategoryManager.
13 | |
14 | | Author: Cascade AI
15 | | """
   | |___^
16 |
17 |   import os
   |
help: Add closing punctuation

D200 One-line docstring should fit on one line
  --> desktop_ui\snippet_model_tester.py:43:5
   |
42 |   class SnippetModelTester(QWidget):
43 | /     """
44 | |     Simple UI to test SnippetManager CRUD and validation logic.
45 | |     """
   | |_______^
46 |
47 |       def __init__(self) -> None:
   |
help: Reformat to one line

D212 [*] Multi-line docstring summary should start at the first line
  --> desktop_ui\snippet_model_tester.py:43:5
   |
42 |   class SnippetModelTester(QWidget):
43 | /     """
44 | |     Simple UI to test SnippetManager CRUD and validation logic.
45 | |     """
   | |_______^
46 |
47 |       def __init__(self) -> None:
   |
help: Remove whitespace after opening quotes

D107 Missing docstring in `__init__`
  --> desktop_ui\snippet_model_tester.py:47:9
   |
45 |     """
46 |
47 |     def __init__(self) -> None:
   |         ^^^^^^^^
48 |         super().__init__()
49 |         self.setWindowTitle("Snippet Model Tester")
   |

D102 Missing docstring in public method
  --> desktop_ui\snippet_model_tester.py:60:9
   |
58 |         self.refresh_snippets()
59 |
60 |     def init_ui(self) -> None:
   |         ^^^^^^^
61 |         layout = QVBoxLayout()
   |

D102 Missing docstring in public method
  --> desktop_ui\snippet_model_tester.py:96:9
   |
94 |         self.btn_delete.clicked.connect(self.delete_snippet)
95 |
96 |     def refresh_categories(self) -> None:
   |         ^^^^^^^^^^^^^^^^^^
97 |         self.cat_combo.blockSignals(True)
98 |         self.cat_combo.clear()
   |

D102 Missing docstring in public method
   --> desktop_ui\snippet_model_tester.py:111:9
    |
109 |         self.cat_combo.blockSignals(False)
110 |
111 |     def refresh_snippets(self) -> None:
    |         ^^^^^^^^^^^^^^^^
112 |         self.list_widget.clear()
113 |         try:
    |

E501 Line too long (147 > 120)
   --> desktop_ui\snippet_model_tester.py:119:121
    |
117 | 
118 | 
119 | nip.snippet_name} - {snip.content[:40]}{'...' if len(snip.content)>40 else ''}"
    |                                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^
120 | 
121 | 
    |

D102 Missing docstring in public method
   --> desktop_ui\snippet_model_tester.py:124:9
    |
122 |             self.set_status(f"Error loading snippets: {e}")
123 |
124 |     def on_category_filter(self) -> None:
    |         ^^^^^^^^^^^^^^^^^^
125 |         self.refresh_snippets()
    |

D102 Missing docstring in public method
   --> desktop_ui\snippet_model_tester.py:127:9
    |
125 |         self.refresh_snippets()
126 |
127 |     def add_snippet(self) -> None:
    |         ^^^^^^^^^^^
128 |         cats = self.cat_mgr.list_categories()
129 |         if not cats:
    |

D102 Missing docstring in public method
   --> desktop_ui\snippet_model_tester.py:156:9
    |
154 |             self.set_status(f"Error adding snippet: {e}")
155 |
156 |     def get_selected_snippet_id(self) -> Optional[int]:
    |         ^^^^^^^^^^^^^^^^^^^^^^^
157 |         item = self.list_widget.currentItem()
158 |         if not item:
    |

D102 Missing docstring in public method
   --> desktop_ui\snippet_model_tester.py:168:9
    |
166 |             return None
167 |
168 |     def edit_snippet(self) -> None:
    |         ^^^^^^^^^^^^
169 |         snip_id = self.get_selected_snippet_id()
170 |         if snip_id is None:
    |

D102 Missing docstring in public method
   --> desktop_ui\snippet_model_tester.py:211:9
    |
209 |             self.set_status(f"Error updating snippet: {e}")
210 |
211 |     def delete_snippet(self) -> None:
    |         ^^^^^^^^^^^^^^
212 |         snip_id = self.get_selected_snippet_id()
213 |         if snip_id is None:
    |

D102 Missing docstring in public method
   --> desktop_ui\snippet_model_tester.py:230:9
    |
228 |                 self.set_status(f"Error deleting snippet: {e}")
229 |
230 |     def set_status(self, msg: str, error: bool = True) -> None:
    |         ^^^^^^^^^^
231 |         self.status_label.setText(msg)
232 |         if error:
    |

D103 Missing docstring in public function
   --> desktop_ui\snippet_model_tester.py:238:5
    |
238 | def main() -> None:
    |     ^^^^
239 |     app = QApplication(sys.argv)
240 |     tester = SnippetModelTester()
    |

D205 1 blank line required between summary line and description
 --> desktop_ui\snippet_scaffold.py:1:1
  |
1 | / """
2 | | PySide6-based development scaffold for Snippet CRUD.
3 | | This is for development/testing only. Not for production use.
4 | | """
  | |___^
5 |
6 |   from typing import Any
  |
help: Insert single blank line

D212 [*] Multi-line docstring summary should start at the first line
 --> desktop_ui\snippet_scaffold.py:1:1
  |
1 | / """
2 | | PySide6-based development scaffold for Snippet CRUD.
3 | | This is for development/testing only. Not for production use.
4 | | """
  | |___^
5 |
6 |   from typing import Any
  |
help: Remove whitespace after opening quotes

D212 [*] Multi-line docstring summary should start at the first line
  --> desktop_ui\snippet_scaffold.py:13:5
   |
12 |   class SnippetScaffold(QtWidgets.QMainWindow):
13 | /     """
14 | |     A development scaffold UI for testing snippet management functionality.
15 | |
16 | |     This class provides a simple UI for adding, editing, deleting, and viewing snippets
17 | |     using the snippet_manager. It is intended for development and testing only.
18 | |     """
   | |_______^
19 |
20 |       def __init__(self, snippet_manager: Any) -> None:
   |
help: Remove whitespace after opening quotes

D107 Missing docstring in `__init__`
  --> desktop_ui\snippet_scaffold.py:20:9
   |
18 |     """
19 |
20 |     def __init__(self, snippet_manager: Any) -> None:
   |         ^^^^^^^^
21 |         super().__init__()
22 |         self.snippet_manager = snippet_manager
   |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `snippet_manager`
  --> desktop_ui\snippet_scaffold.py:20:41
   |
18 |     """
19 |
20 |     def __init__(self, snippet_manager: Any) -> None:
   |                                         ^^^
21 |         super().__init__()
22 |         self.snippet_manager = snippet_manager
   |

D205 1 blank line required between summary line and description
   --> desktop_ui\snippet_scaffold.py:98:9
    |
 97 |       def refresh_snippets(self) -> None:
 98 | /         """
 99 | |         Refresh the snippet list widget with the latest snippets from the database.
100 | |         All snippets are loaded from category ID 1 (for demo purposes).
101 | |         """
    | |___________^
102 |           self.snippet_list.clear()
103 |           # Display a status message while loading
    |
help: Insert single blank line

D212 [*] Multi-line docstring summary should start at the first line
   --> desktop_ui\snippet_scaffold.py:98:9
    |
 97 |       def refresh_snippets(self) -> None:
 98 | /         """
 99 | |         Refresh the snippet list widget with the latest snippets from the database.
100 | |         All snippets are loaded from category ID 1 (for demo purposes).
101 | |         """
    | |___________^
102 |           self.snippet_list.clear()
103 |           # Display a status message while loading
    |
help: Remove whitespace after opening quotes

D205 1 blank line required between summary line and description
   --> desktop_ui\snippet_scaffold.py:156:9
    |
155 |       def add_snippet(self) -> None:
156 | /         """
157 | |         Add a new snippet using the values from the input fields.
158 | |         Shows an error message if the operation fails.
159 | |         """
    | |___________^
160 |           name = self.name_input.text().strip()
161 |           content = self.content_input.toPlainText().strip()
    |
help: Insert single blank line

D212 [*] Multi-line docstring summary should start at the first line
   --> desktop_ui\snippet_scaffold.py:156:9
    |
155 |       def add_snippet(self) -> None:
156 | /         """
157 | |         Add a new snippet using the values from the input fields.
158 | |         Shows an error message if the operation fails.
159 | |         """
    | |___________^
160 |           name = self.name_input.text().strip()
161 |           content = self.content_input.toPlainText().strip()
    |
help: Remove whitespace after opening quotes

D205 1 blank line required between summary line and description
   --> desktop_ui\snippet_scaffold.py:194:9
    |
193 |       def edit_snippet(self) -> None:
194 | /         """
195 | |         Edit the currently selected snippet with values from input fields.
196 | |         Shows an error message if no snippet is selected or the operation fails.
197 | |         """
    | |___________^
198 |           item = self.snippet_list.currentItem()
199 |           if not item:
    |
help: Insert single blank line

D212 [*] Multi-line docstring summary should start at the first line
   --> desktop_ui\snippet_scaffold.py:194:9
    |
193 |       def edit_snippet(self) -> None:
194 | /         """
195 | |         Edit the currently selected snippet with values from input fields.
196 | |         Shows an error message if no snippet is selected or the operation fails.
197 | |         """
    | |___________^
198 |           item = self.snippet_list.currentItem()
199 |           if not item:
    |
help: Remove whitespace after opening quotes

D205 1 blank line required between summary line and description
   --> desktop_ui\snippet_scaffold.py:235:9
    |
234 |       def delete_snippet(self) -> None:
235 | /         """
236 | |         Delete the currently selected snippet.
237 | |         Shows an error message if no snippet is selected or the operation fails.
238 | |         """
    | |___________^
239 |           item = self.snippet_list.currentItem()
240 |           if not item:
    |
help: Insert single blank line

D212 [*] Multi-line docstring summary should start at the first line
   --> desktop_ui\snippet_scaffold.py:235:9
    |
234 |       def delete_snippet(self) -> None:
235 | /         """
236 | |         Delete the currently selected snippet.
237 | |         Shows an error message if no snippet is selected or the operation fails.
238 | |         """
    | |___________^
239 |           item = self.snippet_list.currentItem()
240 |           if not item:
    |
help: Remove whitespace after opening quotes

D212 [*] Multi-line docstring summary should start at the first line
   --> desktop_ui\snippet_scaffold.py:274:9
    |
273 |       def load_selected_snippet(self, item: QtWidgets.QListWidgetItem) -> None:
274 | /         """
275 | |         Load the selected snippet into the edit fields for viewing or editing.
276 | |
277 | |         Args:
278 | |             item: The list widget item that was clicked or selected
279 | |         """
    | |___________^
280 |           if not item:
281 |               return
    |
help: Remove whitespace after opening quotes

D205 1 blank line required between summary line and description
 --> desktop_ui\space_invaders_game.py:2:1
  |
1 |   # ruff: noqa: E501
2 | / """
3 | | Space Invaders Typing Game - A fun typing game inspired by the classic Space Invaders.
4 | | Words move across the screen in formation, and players type them to destroy them.
5 | | """
  | |___^
6 |
7 |   import random
  |
help: Insert single blank line

D212 [*] Multi-line docstring summary should start at the first line
 --> desktop_ui\space_invaders_game.py:2:1
  |
1 |   # ruff: noqa: E501
2 | / """
3 | | Space Invaders Typing Game - A fun typing game inspired by the classic Space Invaders.
4 | | Words move across the screen in formation, and players type them to destroy them.
5 | | """
  | |___^
6 |
7 |   import random
  |
help: Remove whitespace after opening quotes

D107 Missing docstring in `__init__`
  --> desktop_ui\space_invaders_game.py:18:9
   |
16 |     """Represents a word in the game with position and state."""
17 |     
18 |     def __init__(self, text: str, x: int, y: int) -> None:
   |         ^^^^^^^^
19 |         self.text = text
20 |         self.original_text = text
   |

D200 One-line docstring should fit on one line
  --> desktop_ui\space_invaders_game.py:38:9
   |
37 |       def type_char(self, char: str) -> bool:
38 | /         """
39 | |         Type a character. Returns True if the character was correct.
40 | |         """
   | |___________^
41 |           if self.typed_chars < len(self.text) and self.text[self.typed_chars].lower() == char.lower():
42 |               self.typed_chars += 1
   |
help: Reformat to one line

D212 [*] Multi-line docstring summary should start at the first line
  --> desktop_ui\space_invaders_game.py:38:9
   |
37 |       def type_char(self, char: str) -> bool:
38 | /         """
39 | |         Type a character. Returns True if the character was correct.
40 | |         """
   | |___________^
41 |           if self.typed_chars < len(self.text) and self.text[self.typed_chars].lower() == char.lower():
42 |               self.typed_chars += 1
   |
help: Remove whitespace after opening quotes

D107 Missing docstring in `__init__`
  --> desktop_ui\space_invaders_game.py:68:9
   |
66 |     PLAYER_Y = 550
67 |     
68 |     def __init__(self, parent: Optional[QWidget] = None) -> None:
   |         ^^^^^^^^
69 |         super().__init__(parent)
70 |         self.setWindowTitle("Space Invaders Typing Game")
   |

D205 1 blank line required between summary line and description
  --> desktop_ui\splash.py:1:1
   |
 1 | / """
 2 | | splash.py
 3 | | AI Typing Trainer Splash Screen
 4 | | - Shows splash with large title and status label
 5 | | - Starts GraphQL server asynchronously
 6 | | - Polls server and displays snippet count in a message box
 7 | |
 8 | | Updated to use PySide6 instead of PyQt5.
 9 | | """
   | |___^
10 |
11 |   import sys
   |
help: Insert single blank line

D212 [*] Multi-line docstring summary should start at the first line
  --> desktop_ui\splash.py:1:1
   |
 1 | / """
 2 | | splash.py
 3 | | AI Typing Trainer Splash Screen
 4 | | - Shows splash with large title and status label
 5 | | - Starts GraphQL server asynchronously
 6 | | - Polls server and displays snippet count in a message box
 7 | |
 8 | | Updated to use PySide6 instead of PyQt5.
 9 | | """
   | |___^
10 |
11 |   import sys
   |
help: Remove whitespace after opening quotes

D415 First line should end with a period, question mark, or exclamation point
  --> desktop_ui\splash.py:1:1
   |
 1 | / """
 2 | | splash.py
 3 | | AI Typing Trainer Splash Screen
 4 | | - Shows splash with large title and status label
 5 | | - Starts GraphQL server asynchronously
 6 | | - Polls server and displays snippet count in a message box
 7 | |
 8 | | Updated to use PySide6 instead of PyQt5.
 9 | | """
   | |___^
10 |
11 |   import sys
   |
help: Add closing punctuation

D101 Missing docstring in public class
  --> desktop_ui\splash.py:30:7
   |
30 | class SplashConfig(BaseModel):
   |       ^^^^^^^^^^^^
31 |     graphql_url: str = GRAPHQL_URL
32 |     poll_interval_ms: int = 500
   |

D205 1 blank line required between summary line and description
  --> desktop_ui\splash.py:40:5
   |
39 |   class SplashScreen(QWidget):
40 | /     """
41 | |     Splash screen for AI Typing Trainer.
42 | |     - Frameless, no minimize/close, centered, stays on top.
43 | |     - Starts and polls GraphQL server via APIServerManager.
44 | |     - Queries snippet count via GraphQLClient.
45 | |     - Retains dummy/test mode for tests.
46 | |     """
   | |_______^
47 |
48 |       def __init__(self, graphql=None, config: Optional[SplashConfig] = None) -> None:
   |
help: Insert single blank line

D212 [*] Multi-line docstring summary should start at the first line
  --> desktop_ui\splash.py:40:5
   |
39 |   class SplashScreen(QWidget):
40 | /     """
41 | |     Splash screen for AI Typing Trainer.
42 | |     - Frameless, no minimize/close, centered, stays on top.
43 | |     - Starts and polls GraphQL server via APIServerManager.
44 | |     - Queries snippet count via GraphQLClient.
45 | |     - Retains dummy/test mode for tests.
46 | |     """
   | |_______^
47 |
48 |       def __init__(self, graphql=None, config: Optional[SplashConfig] = None) -> None:
   |
help: Remove whitespace after opening quotes

D107 Missing docstring in `__init__`
  --> desktop_ui\splash.py:48:9
   |
46 |     """
47 |
48 |     def __init__(self, graphql=None, config: Optional[SplashConfig] = None) -> None:
   |         ^^^^^^^^
49 |         super().__init__()
50 |         self.setWindowTitle("AI Typing Trainer")
   |

ANN001 Missing type annotation for function argument `graphql`
  --> desktop_ui\splash.py:48:24
   |
46 |     """
47 |
48 |     def __init__(self, graphql=None, config: Optional[SplashConfig] = None) -> None:
   |                        ^^^^^^^
49 |         super().__init__()
50 |         self.setWindowTitle("AI Typing Trainer")
   |

F821 Undefined name `GraphQLServerThread`
   --> desktop_ui\splash.py:156:30
    |
154 |     def _start_graphql_server(self) -> None:
155 |         self.status_label.setText("Starting up GraphQL")
156 |         self.server_thread = GraphQLServerThread()
    |                              ^^^^^^^^^^^^^^^^^^^
157 |         self.server_thread.started_signal.connect(self._poll_graphql)
158 |         self.server_thread.start()
    |

D200 One-line docstring should fit on one line
   --> desktop_ui\splash.py:182:9
    |
181 |       def check_graphql_and_show_count(self) -> None:
182 | /         """
183 | |         Checks if GraphQL is running; if not, updates status. If running, fetches snippet count and shows message box.
184 | |         """
    | |___________^
185 |           count = 0
186 |           error = None
    |
help: Reformat to one line

D212 [*] Multi-line docstring summary should start at the first line
   --> desktop_ui\splash.py:182:9
    |
181 |       def check_graphql_and_show_count(self) -> None:
182 | /         """
183 | |         Checks if GraphQL is running; if not, updates status. If running, fetches snippet count and shows message box.
184 | |         """
    | |___________^
185 |           count = 0
186 |           error = None
    |
help: Remove whitespace after opening quotes

D205 1 blank line required between summary line and description
   --> desktop_ui\splash.py:228:5
    |
227 |   def ensure_graphql_server_running() -> bool:
228 | /     """
229 | |     Utility function to ensure the GraphQL server is running.
230 | |     Can be called from other parts of the application.
231 | |
232 | |     Returns:
233 | |         bool: True if server is running, False otherwise
234 | |     """
    | |_______^
235 |       if SplashScreen._api_server_manager is None:
236 |           SplashScreen._api_server_manager = APIServerManager()
    |
help: Insert single blank line

D212 [*] Multi-line docstring summary should start at the first line
   --> desktop_ui\splash.py:228:5
    |
227 |   def ensure_graphql_server_running() -> bool:
228 | /     """
229 | |     Utility function to ensure the GraphQL server is running.
230 | |     Can be called from other parts of the application.
231 | |
232 | |     Returns:
233 | |         bool: True if server is running, False otherwise
234 | |     """
    | |_______^
235 |       if SplashScreen._api_server_manager is None:
236 |           SplashScreen._api_server_manager = APIServerManager()
    |
help: Remove whitespace after opening quotes

D205 1 blank line required between summary line and description
 --> desktop_ui\typing_drill.py:2:1
  |
1 |   # ruff: noqa: E501
2 | / """
3 | | TypingDrillScreen - Interactive typing practice UI with real-time feedback.
4 | | Implements full typing drill functionality including timing, statistics, and session persistence.
5 | | """
  | |___^
6 |
7 |   # Move all imports to the top of the file for PEP8 compliance
  |
help: Insert single blank line

D212 [*] Multi-line docstring summary should start at the first line
 --> desktop_ui\typing_drill.py:2:1
  |
1 |   # ruff: noqa: E501
2 | / """
3 | | TypingDrillScreen - Interactive typing practice UI with real-time feedback.
4 | | Implements full typing drill functionality including timing, statistics, and session persistence.
5 | | """
  | |___^
6 |
7 |   # Move all imports to the top of the file for PEP8 compliance
  |
help: Remove whitespace after opening quotes

D205 1 blank line required between summary line and description
  --> desktop_ui\typing_drill.py:45:5
   |
44 |   class PersistSummary(QDialog):
45 | /     """
46 | |     Dialog shown after persistence operations complete.
47 | |     Displays the results of saving session data including record counts.
48 | |     """
   | |_______^
49 |
50 |       def __init__(self, persist_results: Dict[str, Any], parent: Optional[QWidget] = None) -> None:
   |
help: Insert single blank line

D212 [*] Multi-line docstring summary should start at the first line
  --> desktop_ui\typing_drill.py:45:5
   |
44 |   class PersistSummary(QDialog):
45 | /     """
46 | |     Dialog shown after persistence operations complete.
47 | |     Displays the results of saving session data including record counts.
48 | |     """
   | |_______^
49 |
50 |       def __init__(self, persist_results: Dict[str, Any], parent: Optional[QWidget] = None) -> None:
   |
help: Remove whitespace after opening quotes

D212 [*] Multi-line docstring summary should start at the first line
  --> desktop_ui\typing_drill.py:51:9
   |
50 |       def __init__(self, persist_results: Dict[str, Any], parent: Optional[QWidget] = None) -> None:
51 | /         """
52 | |         Initialize the persistence summary dialog.
53 | |
54 | |         Args:
55 | |             persist_results (Dict[str, Any]): Results of persistence operations.
56 | |             parent (Optional[QWidget]): Parent widget for the dialog.
57 | |         """
   | |___________^
58 |           super().__init__(parent)
59 |           self.setWindowTitle("Session Saved")
   |
help: Remove whitespace after opening quotes

D212 [*] Multi-line docstring summary should start at the first line
   --> desktop_ui\typing_drill.py:150:9
    |
149 |       def _add_result_row(self, grid: QGridLayout, row: int, label: str, status: str) -> None:
150 | /         """
151 | |         Add a row to the results grid with label and status.
152 | |
153 | |         Args:
154 | |             grid (QGridLayout): The grid layout to add the row to.
155 | |             row (int): The row index.
156 | |             label (str): The label text.
157 | |             status (str): The status text.
158 | |         """
    | |___________^
159 |           label_widget = QLabel(label)
160 |           label_widget.setFont(QFont("Arial", 10, QFont.Bold))
    |
help: Remove whitespace after opening quotes

D205 1 blank line required between summary line and description
   --> desktop_ui\typing_drill.py:175:5
    |
174 |   class CompletionDialog(QDialog):
175 | /     """
176 | |     Dialog shown when the typing session is completed.
177 | |     Displays typing statistics and provides options to retry or close.
178 | |     """
    | |_______^
179 |
180 |       def __init__(self, stats: Dict[str, Any], parent: Optional[QWidget] = None) -> None:
    |
help: Insert single blank line

D212 [*] Multi-line docstring summary should start at the first line
   --> desktop_ui\typing_drill.py:175:5
    |
174 |   class CompletionDialog(QDialog):
175 | /     """
176 | |     Dialog shown when the typing session is completed.
177 | |     Displays typing statistics and provides options to retry or close.
178 | |     """
    | |_______^
179 |
180 |       def __init__(self, stats: Dict[str, Any], parent: Optional[QWidget] = None) -> None:
    |
help: Remove whitespace after opening quotes

D212 [*] Multi-line docstring summary should start at the first line
   --> desktop_ui\typing_drill.py:181:9
    |
180 |       def __init__(self, stats: Dict[str, Any], parent: Optional[QWidget] = None) -> None:
181 | /         """
182 | |         Initialize the completion dialog with typing statistics and parent widget.
183 | |
184 | |         Args:
185 | |             stats (Dict[str, Any]): Typing statistics to display.
186 | |             parent (Optional[QWidget]): Parent widget for the dialog.
187 | |         """
    | |___________^
188 |           super().__init__(parent)
189 |           self.setWindowTitle("Typing Session Completed")
    |
help: Remove whitespace after opening quotes

D212 [*] Multi-line docstring summary should start at the first line
   --> desktop_ui\typing_drill.py:264:9
    |
263 |       def _add_stat_row(self, grid: QGridLayout, row: int, label: str, value: str) -> None:
264 | /         """
265 | |         Add a row to the stats grid with label and value.
266 | |
267 | |         Args:
268 | |             grid (QGridLayout): The grid layout to add the row to.
269 | |             row (int): The row index.
270 | |             label (str): The label text.
271 | |             value (str): The value text.
272 | |         """
    | |___________^
273 |           label_widget = QLabel(label)
274 |           label_widget.setFont(QFont("Arial", 10, QFont.Bold))
    |
help: Remove whitespace after opening quotes

D200 One-line docstring should fit on one line
   --> desktop_ui\typing_drill.py:282:9
    |
281 |       def _on_retry(self) -> None:
282 | /         """
283 | |         Handle retry button click.
284 | |         """
    | |___________^
285 |           self.done(2)  # Custom return code for retry
    |
help: Reformat to one line

D212 [*] Multi-line docstring summary should start at the first line
   --> desktop_ui\typing_drill.py:282:9
    |
281 |       def _on_retry(self) -> None:
282 | /         """
283 | |         Handle retry button click.
284 | |         """
    | |___________^
285 |           self.done(2)  # Custom return code for retry
    |
help: Remove whitespace after opening quotes

D205 1 blank line required between summary line and description
   --> desktop_ui\typing_drill.py:289:5
    |
288 |   class TypingDrillScreen(QDialog):
289 | /     """
290 | |     TypingDrillScreen handles the typing drill UI and session persistence for desktop.
291 | |     Implements real-time feedback, timing, statistics, and session recording.
292 | |
293 | |     Args:
294 | |         snippet_id (str): ID of the snippet being practiced (UUID string; "-1" for manual text)
295 | |         start (int): Starting index in the snippet
296 | |         end (int): Ending index in the snippet
297 | |         content (str): Content to type (substring of snippet between start and end)
298 | |         db_manager (Optional[Any]): Database manager instance
299 | |         parent (Optional[QWidget]): Parent widget
300 | |     """
    | |_______^
301 |
302 |       def __init__(
    |
help: Insert single blank line

D212 [*] Multi-line docstring summary should start at the first line
   --> desktop_ui\typing_drill.py:289:5
    |
288 |   class TypingDrillScreen(QDialog):
289 | /     """
290 | |     TypingDrillScreen handles the typing drill UI and session persistence for desktop.
291 | |     Implements real-time feedback, timing, statistics, and session recording.
292 | |
293 | |     Args:
294 | |         snippet_id (str): ID of the snippet being practiced (UUID string; "-1" for manual text)
295 | |         start (int): Starting index in the snippet
296 | |         end (int): Ending index in the snippet
297 | |         content (str): Content to type (substring of snippet between start and end)
298 | |         db_manager (Optional[Any]): Database manager instance
299 | |         parent (Optional[QWidget]): Parent widget
300 | |     """
    | |_______^
301 |
302 |       def __init__(
    |
help: Remove whitespace after opening quotes

D212 [*] Multi-line docstring summary should start at the first line
   --> desktop_ui\typing_drill.py:313:9
    |
311 |           parent: Optional[QWidget] = None,
312 |       ) -> None:
313 | /         """
314 | |         Initialize the TypingDrillScreen dialog and session state.
315 | |
316 | |         Args:
317 | |             snippet_id (int): ID of the snippet being practiced (-1 for manual text)
318 | |             start (int): Starting index in the snippet
319 | |             end (int): Ending index in the snippet
320 | |             content (str): Content to type (substring of snippet between start and end)
321 | |             db_manager (Optional[DatabaseManager]): Database manager instance
322 | |             user_id (Optional[str]): ID of the current user
323 | |             keyboard_id (Optional[str]): ID of the keyboard being used
324 | |             parent (Optional[QWidget]): Parent widget
325 | |         """
    | |___________^
326 |           super().__init__(parent)
327 |           self.setWindowTitle("Typing Drill")
    |
help: Remove whitespace after opening quotes

D200 One-line docstring should fit on one line
   --> desktop_ui\typing_drill.py:429:9
    |
428 |       def _update_status_bar(self) -> None:
429 | /         """
430 | |         Update status bar with user and keyboard information.
431 | |         """
    | |___________^
432 |           status_text = ""
433 |           if self.current_user:
    |
help: Reformat to one line

D212 [*] Multi-line docstring summary should start at the first line
   --> desktop_ui\typing_drill.py:429:9
    |
428 |       def _update_status_bar(self) -> None:
429 | /         """
430 | |         Update status bar with user and keyboard information.
431 | |         """
    | |___________^
432 |           status_text = ""
433 |           if self.current_user:
    |
help: Remove whitespace after opening quotes

D212 [*] Multi-line docstring summary should start at the first line
   --> desktop_ui\typing_drill.py:449:9
    |
448 |       def _create_new_session(self) -> Session:
449 | /         """
450 | |         Helper to create a new Session object for this typing drill.
451 | |
452 | |         Returns:
453 | |             Session: A new Session instance with the current configuration.
454 | |         """
    | |___________^
455 |
456 |           def ensure_uuid(val):
    |
help: Remove whitespace after opening quotes

ANN202 Missing return type annotation for private function `ensure_uuid`
   --> desktop_ui\typing_drill.py:456:13
    |
454 |         """
455 |
456 |         def ensure_uuid(val):
    |             ^^^^^^^^^^^
457 |             try:
458 |                 return str(uuid.UUID(str(val)))
    |
help: Add return type annotation

ANN001 Missing type annotation for function argument `val`
   --> desktop_ui\typing_drill.py:456:25
    |
454 |         """
455 |
456 |         def ensure_uuid(val):
    |                         ^^^
457 |             try:
458 |                 return str(uuid.UUID(str(val)))
    |

D212 [*] Multi-line docstring summary should start at the first line
   --> desktop_ui\typing_drill.py:481:9
    |
480 |       def _preprocess_content(self, content: str) -> str:
481 | /         """
482 | |         Preprocess content to make whitespace and special characters visible for display.
483 | |
484 | |         Args:
485 | |             content (str): Original text content to preprocess.
486 | |
487 | |         Returns:
488 | |             str: Preprocessed content with visible whitespace markers for display.
489 | |         """
    | |___________^
490 |           # Replace spaces with visible space character (using subscript up arrow as specified)
491 |           result = content.replace(" ", "")  # Visible space character
    |
help: Remove whitespace after opening quotes

D212 [*] Multi-line docstring summary should start at the first line
   --> desktop_ui\typing_drill.py:505:9
    |
504 |       def _setup_ui(self) -> None:
505 | /         """
506 | |         Set up the UI components for the typing drill screen.
507 | |
508 | |         Returns:
509 | |             None: This method does not return a value.
510 | |         """
    | |___________^
511 |           # Main layout
512 |           main_layout = QVBoxLayout(self)
    |
help: Remove whitespace after opening quotes

D212 [*] Multi-line docstring summary should start at the first line
   --> desktop_ui\typing_drill.py:592:9
    |
591 |       def _on_text_changed(self) -> None:
592 | /         """
593 | |         Handle text changes in the typing input and update session state, stats, and UI.
594 | |
595 | |         Returns:
596 | |             None: This method does not return a value.
597 | |         """
    | |___________^
598 |           current_text = self.typing_input.toPlainText()
    |
help: Remove whitespace after opening quotes

D205 1 blank line required between summary line and description
   --> desktop_ui\typing_drill.py:702:9
    |
701 |       def _process_typing_input(self) -> None:
702 | /         """
703 | |         Process the current typing input, check progress, and update UI highlighting and
704 | |         progress bar.
705 | |
706 | |         Returns:
707 | |             None: This method does not return a value.
708 | |         """
    | |___________^
709 |           current_text = self.typing_input.toPlainText()
    |
help: Insert single blank line

D212 [*] Multi-line docstring summary should start at the first line
   --> desktop_ui\typing_drill.py:702:9
    |
701 |       def _process_typing_input(self) -> None:
702 | /         """
703 | |         Process the current typing input, check progress, and update UI highlighting and
704 | |         progress bar.
705 | |
706 | |         Returns:
707 | |             None: This method does not return a value.
708 | |         """
    | |___________^
709 |           current_text = self.typing_input.toPlainText()
    |
help: Remove whitespace after opening quotes

D212 [*] Multi-line docstring summary should start at the first line
   --> desktop_ui\typing_drill.py:721:9
    |
720 |       def _update_highlighting(self, current_text: str) -> None:
721 | /         """
722 | |         Update the display text with highlighting based on typing accuracy.
723 | |
724 | |         Args:
725 | |             current_text (str): Current text input by the user.
726 | |
727 | |         Returns:
728 | |             None: This method does not return a value.
729 | |         """
    | |___________^
730 |           # Block signals temporarily to avoid recursive calls
731 |           self.display_text.blockSignals(True)
    |
help: Remove whitespace after opening quotes

D212 [*] Multi-line docstring summary should start at the first line
   --> desktop_ui\typing_drill.py:788:9
    |
787 |       def _update_timer(self) -> None:
788 | /         """
789 | |         Update timer and stats display during the typing session.
790 | |
791 | |         Returns:
792 | |             None: This method does not return a value.
793 | |         """
    | |___________^
794 |           if self.timer_running:
795 |               self.elapsed_time = time.time() - self.start_time
    |
help: Remove whitespace after opening quotes

D212 [*] Multi-line docstring summary should start at the first line
   --> desktop_ui\typing_drill.py:800:9
    |
799 |       def _update_stats(self) -> None:
800 | /         """
801 | |         Calculate and update WPM, CPM, and accuracy statistics for the session.
802 | |
803 | |         Returns:
804 | |             None: This method does not return a value.
805 | |         """
    | |___________^
806 |           if not self.timer_running or self.elapsed_time < 0.1:
807 |               return
    |
help: Remove whitespace after opening quotes

D205 1 blank line required between summary line and description
   --> desktop_ui\typing_drill.py:826:9
    |
825 |       def _check_completion(self) -> None:
826 | /         """
827 | |         Check and handle completion of the typing session, including saving session data
828 | |         and showing completion dialog.
829 | |
830 | |         Returns:
831 | |             None: This method does not return a value.
832 | |         """
    | |___________^
833 |           logging.debug("Entering _check_completion")
834 |           if getattr(self, "session_completed", False):
    |
help: Insert single blank line

D212 [*] Multi-line docstring summary should start at the first line
   --> desktop_ui\typing_drill.py:826:9
    |
825 |       def _check_completion(self) -> None:
826 | /         """
827 | |         Check and handle completion of the typing session, including saving session data
828 | |         and showing completion dialog.
829 | |
830 | |         Returns:
831 | |             None: This method does not return a value.
832 | |         """
    | |___________^
833 |           logging.debug("Entering _check_completion")
834 |           if getattr(self, "session_completed", False):
    |
help: Remove whitespace after opening quotes

D212 [*] Multi-line docstring summary should start at the first line
   --> desktop_ui\typing_drill.py:877:9
    |
876 |       def save_session(self) -> bool:
877 | /         """
878 | |         Save the session using the local Session object and session_manager.
879 | |
880 | |         Returns:
881 | |             bool: True if the session was saved successfully, otherwise raises an exception.
882 | |         """
    | |___________^
883 |           logging.debug("Entering save_session with session: %s", self.session)
884 |           try:
    |
help: Remove whitespace after opening quotes

D200 One-line docstring should fit on one line
   --> desktop_ui\typing_drill.py:900:9
    |
899 |       def _persist_session_data(self, session: Session) -> Dict[str, Any]:
900 | /         """
901 | |         Persist the session, keystrokes, n-grams, and analytics via orchestrator and return a summary dict.
902 | |         """
    | |___________^
903 |           results = {
904 |               "session_saved": False,
    |
help: Reformat to one line

D212 [*] Multi-line docstring summary should start at the first line
   --> desktop_ui\typing_drill.py:900:9
    |
899 |       def _persist_session_data(self, session: Session) -> Dict[str, Any]:
900 | /         """
901 | |         Persist the session, keystrokes, n-grams, and analytics via orchestrator and return a summary dict.
902 | |         """
    | |___________^
903 |           results = {
904 |               "session_saved": False,
    |
help: Remove whitespace after opening quotes

D212 [*] Multi-line docstring summary should start at the first line
   --> desktop_ui\typing_drill.py:946:9
    |
945 |       def _show_completion_dialog(self, session: Session) -> None:
946 | /         """
947 | |         Show the completion dialog with the given session object and handle persistence.
948 | |
949 | |         Args:
950 | |             session (Session): The Session object containing session results.
951 | |
952 | |         Returns:
953 | |             None: This method does not return a value.
954 | |         """
    | |___________^
955 |           # Calculate final stats
956 |           stats = self._calculate_stats()
    |
help: Remove whitespace after opening quotes

D200 One-line docstring should fit on one line
   --> desktop_ui\typing_drill.py:984:9
    |
983 |       def _reset_session(self) -> None:
984 | /         """
985 | |         Reset the typing session to its initial state.
986 | |         """
    | |___________^
987 |           self.session = self._create_new_session()
988 |           self.timer_running = False
    |
help: Reformat to one line

D212 [*] Multi-line docstring summary should start at the first line
   --> desktop_ui\typing_drill.py:984:9
    |
983 |       def _reset_session(self) -> None:
984 | /         """
985 | |         Reset the typing session to its initial state.
986 | |         """
    | |___________^
987 |           self.session = self._create_new_session()
988 |           self.timer_running = False
    |
help: Remove whitespace after opening quotes

D205 1 blank line required between summary line and description
    --> desktop_ui\typing_drill.py:1008:9
     |
1007 |       def _calculate_stats(self) -> Dict[str, Any]:
1008 | /         """
1009 | |         Calculate and return typing statistics for the session.
1010 | |         Returns:
1011 | |             Dict[str, Any]: Dictionary of stats for the completion dialog.
1012 | |         """
     | |___________^
1013 |           total_time = (
1014 |               (self.session.end_time - self.session.start_time).total_seconds()
     |
help: Insert single blank line

D212 [*] Multi-line docstring summary should start at the first line
    --> desktop_ui\typing_drill.py:1008:9
     |
1007 |       def _calculate_stats(self) -> Dict[str, Any]:
1008 | /         """
1009 | |         Calculate and return typing statistics for the session.
1010 | |         Returns:
1011 | |             Dict[str, Any]: Dictionary of stats for the completion dialog.
1012 | |         """
     | |___________^
1013 |           total_time = (
1014 |               (self.session.end_time - self.session.start_time).total_seconds()
     |
help: Remove whitespace after opening quotes

D411 [*] Missing blank line before section ("Returns")
    --> desktop_ui\typing_drill.py:1010:9
     |
1008 |         """
1009 |         Calculate and return typing statistics for the session.
1010 |         Returns:
     |         ^^^^^^^
1011 |             Dict[str, Any]: Dictionary of stats for the completion dialog.
1012 |         """
     |
help: Add blank line before "Returns"

D212 [*] Multi-line docstring summary should start at the first line
 --> desktop_ui\users_and_keyboards.py:1:1
  |
1 | / """
2 | | Users and Keyboards management screen.
3 | |
4 | | This module provides a UI for managing users and their associated keyboards.
5 | | """
  | |___^
6 |
7 |   from typing import Optional
  |
help: Remove whitespace after opening quotes

D200 One-line docstring should fit on one line
  --> desktop_ui\users_and_keyboards.py:37:5
   |
36 |   class UsersAndKeyboards(QDialog):
37 | /     """
38 | |     Dialog for managing users and their keyboards.
39 | |     """
   | |_______^
40 |
41 |       def __init__(self, db_manager: DatabaseManager, parent: Optional[QWidget] = None) -> None:
   |
help: Reformat to one line

D212 [*] Multi-line docstring summary should start at the first line
  --> desktop_ui\users_and_keyboards.py:37:5
   |
36 |   class UsersAndKeyboards(QDialog):
37 | /     """
38 | |     Dialog for managing users and their keyboards.
39 | |     """
   | |_______^
40 |
41 |       def __init__(self, db_manager: DatabaseManager, parent: Optional[QWidget] = None) -> None:
   |
help: Remove whitespace after opening quotes

D212 [*] Multi-line docstring summary should start at the first line
  --> desktop_ui\users_and_keyboards.py:42:9
   |
41 |       def __init__(self, db_manager: DatabaseManager, parent: Optional[QWidget] = None) -> None:
42 | /         """
43 | |         Initialize the Users and Keyboards dialog.
44 | |
45 | |         Args:
46 | |             db_manager: Database manager instance.
47 | |             parent: Parent widget.
48 | |         """
   | |___________^
49 |           super().__init__(parent)
50 |           self.db_manager = db_manager
   |
help: Remove whitespace after opening quotes

D212 [*] Multi-line docstring summary should start at the first line
   --> desktop_ui\users_and_keyboards.py:151:9
    |
150 |       def load_keyboards_for_user(self, user_id: str) -> None:
151 | /         """
152 | |         Load keyboards for the specified user.
153 | |
154 | |         Args:
155 | |             user_id: ID of the user to load keyboards for.
156 | |         """
    | |___________^
157 |           self.keyboards_list.clear()
158 |           try:
    |
help: Remove whitespace after opening quotes

D212 [*] Multi-line docstring summary should start at the first line
 --> desktop_ui\view_snippet_dialog.py:1:1
  |
1 | / """
2 | | View Snippet Dialog for the Desktop UI
3 | |
4 | | Provides a maximized dialog for viewing snippet content with proper formatting.
5 | | Updated to use PySide6 instead of PyQt5.
6 | | """
  | |___^
7 |
8 |   from typing import Optional
  |
help: Remove whitespace after opening quotes

D415 First line should end with a period, question mark, or exclamation point
 --> desktop_ui\view_snippet_dialog.py:1:1
  |
1 | / """
2 | | View Snippet Dialog for the Desktop UI
3 | |
4 | | Provides a maximized dialog for viewing snippet content with proper formatting.
5 | | Updated to use PySide6 instead of PyQt5.
6 | | """
  | |___^
7 |
8 |   from typing import Optional
  |
help: Add closing punctuation

D205 1 blank line required between summary line and description
  --> desktop_ui\view_snippet_dialog.py:31:5
   |
30 |   class ViewSnippetDialog(QDialog):
31 | /     """
32 | |     Dialog for viewing snippet content with all its parts.
33 | |     Shows in maximized mode with proper formatting.
34 | |     """
   | |_______^
35 |
36 |       def __init__(
   |
help: Insert single blank line

D212 [*] Multi-line docstring summary should start at the first line
  --> desktop_ui\view_snippet_dialog.py:31:5
   |
30 |   class ViewSnippetDialog(QDialog):
31 | /     """
32 | |     Dialog for viewing snippet content with all its parts.
33 | |     Shows in maximized mode with proper formatting.
34 | |     """
   | |_______^
35 |
36 |       def __init__(
   |
help: Remove whitespace after opening quotes

D212 [*] Multi-line docstring summary should start at the first line
  --> desktop_ui\view_snippet_dialog.py:43:9
   |
41 |           parent: Optional[QWidget] = None,
42 |       ) -> None:
43 | /         """
44 | |         Initialize the view snippet dialog.
45 | |
46 | |         Args:
47 | |             title: Dialog title
48 | |             snippet_name: Name of the snippet
49 | |             content: Full snippet content (all parts)
50 | |             parent: Parent widget
51 | |         """
   | |___________^
52 |           super().__init__(parent)
53 |           self.setWindowTitle(title)
   |
help: Remove whitespace after opening quotes

D212 [*] Multi-line docstring summary should start at the first line
   --> desktop_ui\view_snippet_dialog.py:95:5
    |
 94 |   def _view_dialog_qss() -> str:
 95 | /     """
 96 | |     Return QSS for a modern Windows 11 view dialog look.
 97 | |
 98 | |     Returns:
 99 | |         str: QSS styling for the view dialog
100 | |     """
    | |_______^
101 |       return """
102 |       QDialog {
    |
help: Remove whitespace after opening quotes

D212 [*] Multi-line docstring summary should start at the first line
 --> examples\service_usage_example.py:1:1
  |
1 | / """
2 | | Example demonstrating the recommended way to initialize and use services.
3 | |
4 | | This example shows how to properly initialize services using dependency injection
5 | | and the new service initialization pattern.
6 | | """
  | |___^
7 |   import sys
8 |   from pathlib import Path
  |
help: Remove whitespace after opening quotes

E402 Module level import not at top of file
  --> examples\service_usage_example.py:15:1
   |
13 |     sys.path.insert(0, project_root)
14 |
15 | from services import init_services
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |

ANN201 Missing return type annotation for public function `main`
  --> examples\service_usage_example.py:18:5
   |
18 | def main():
   |     ^^^^
19 |     """Demonstrate service initialization and usage."""
20 |     try:
   |
help: Add return type annotation: `int`

D101 Missing docstring in public class
  --> examples\service_usage_example.py:48:7
   |
47 | # Example of how to use the services in a class:
48 | class MyApplication:
   |       ^^^^^^^^^^^^^
49 |     def __init__(self, snippet_manager, session_manager):
50 |         self.snippet_manager = snippet_manager
   |

ANN204 Missing return type annotation for special method `__init__`
  --> examples\service_usage_example.py:49:9
   |
47 | # Example of how to use the services in a class:
48 | class MyApplication:
49 |     def __init__(self, snippet_manager, session_manager):
   |         ^^^^^^^^
50 |         self.snippet_manager = snippet_manager
51 |         self.session_manager = session_manager
   |
help: Add return type annotation: `None`

D107 Missing docstring in `__init__`
  --> examples\service_usage_example.py:49:9
   |
47 | # Example of how to use the services in a class:
48 | class MyApplication:
49 |     def __init__(self, snippet_manager, session_manager):
   |         ^^^^^^^^
50 |         self.snippet_manager = snippet_manager
51 |         self.session_manager = session_manager
   |

ANN001 Missing type annotation for function argument `snippet_manager`
  --> examples\service_usage_example.py:49:24
   |
47 | # Example of how to use the services in a class:
48 | class MyApplication:
49 |     def __init__(self, snippet_manager, session_manager):
   |                        ^^^^^^^^^^^^^^^
50 |         self.snippet_manager = snippet_manager
51 |         self.session_manager = session_manager
   |

ANN001 Missing type annotation for function argument `session_manager`
  --> examples\service_usage_example.py:49:41
   |
47 | # Example of how to use the services in a class:
48 | class MyApplication:
49 |     def __init__(self, snippet_manager, session_manager):
   |                                         ^^^^^^^^^^^^^^^
50 |         self.snippet_manager = snippet_manager
51 |         self.session_manager = session_manager
   |

ANN201 Missing return type annotation for public function `do_something`
  --> examples\service_usage_example.py:53:9
   |
51 |         self.session_manager = session_manager
52 |
53 |     def do_something(self):
   |         ^^^^^^^^^^^^
54 |         """Example method showing service usage."""
55 |         # Use the injected services
   |
help: Add return type annotation: `None`

D212 [*] Multi-line docstring summary should start at the first line
 --> helpers\__init__.py:1:1
  |
1 | / """
2 | | Helper utilities for the AITypingTrainer application.
3 | |
4 | | This package contains various utility functions and classes that are used across
5 | | the application to provide common functionality.
6 | | """
  | |___^
7 |
8 |   # Make the error message box function available at the package level
  |
help: Remove whitespace after opening quotes

D212 [*] Multi-line docstring summary should start at the first line
 --> helpers\error_utils.py:1:1
  |
1 | / """
2 | | Error handling utilities for the AITypingTrainer application.
3 | |
4 | | This module provides utility functions for displaying error messages and handling
5 | | errors in a user-friendly way across the application.
6 | | """
  | |___^
7 |
8 |   import logging
  |
help: Remove whitespace after opening quotes

D100 Missing docstring in public module
--> inspect_db.py:1:1

ANN201 Missing return type annotation for public function `inspect_database`
 --> inspect_db.py:5:5
  |
5 | def inspect_database(db_path):
  |     ^^^^^^^^^^^^^^^^
6 |     """Inspect the database schema and print detailed information."""
7 |     print(f"\nInspecting database at: {db_path}")
  |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `db_path`
 --> inspect_db.py:5:22
  |
5 | def inspect_database(db_path):
  |                      ^^^^^^^
6 |     """Inspect the database schema and print detailed information."""
7 |     print(f"\nInspecting database at: {db_path}")
  |

ANN201 Missing return type annotation for public function `main`
  --> inspect_db.py:54:5
   |
52 |         conn.close()
53 |
54 | def main():
   |     ^^^^
55 |     """Main function to inspect the database."""
56 |     # Create a temporary database file
   |
help: Add return type annotation: `None`

E501 Line too long (161 > 120)
   --> inspect_db.py:103:121
    |
101 | 
102 | 
103 | ll else 'NULL':10} DEFAULT: {default_val or 'None':10} {'PRIMARY KEY' if pk else ''}")
    |                                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
104 | 
105 | 
    |

D100 Missing docstring in public module
--> main.py:1:1

ANN201 Missing return type annotation for public function `main`
 --> main.py:4:5
  |
4 | def main():
  |     ^^^^
5 |     desktop_ui.main_menu.launch_main_menu()
  |
help: Add return type annotation: `None`

D103 Missing docstring in public function
 --> main.py:4:5
  |
4 | def main():
  |     ^^^^
5 |     desktop_ui.main_menu.launch_main_menu()
  |

D212 [*] Multi-line docstring summary should start at the first line
  --> migrate_add_text_index.py:2:1
   |
 1 |   #!/usr/bin/env python3
 2 | / """
 3 | | Database migration script to add text_index column to session_keystrokes table.
 4 | |
 5 | | This script:
 6 | | 1. Adds a nullable text_index column to session_keystrokes table
 7 | | 2. Populates the column using ROW_NUMBER() partitioned by session_id, ordered by keystroke_time ASC
 8 | | 3. Makes the column NOT NULL after population
 9 | |
10 | | Usage:
11 | |     python migrate_add_text_index.py
12 | | """
   | |___^
13 |
14 |   import os
   |
help: Remove whitespace after opening quotes

F401 [*] `os` imported but unused
  --> migrate_add_text_index.py:14:8
   |
12 | """
13 |
14 | import os
   |        ^^
15 | import sqlite3
16 | import sys
   |
help: Remove unused import: `os`

ANN201 Missing return type annotation for public function `get_database_path`
  --> migrate_add_text_index.py:20:5
   |
20 | def get_database_path():
   |     ^^^^^^^^^^^^^^^^^
21 |     """Get the path to the typing_data.db database."""
22 |     # Get the project root directory
   |
help: Add return type annotation

ANN201 Missing return type annotation for public function `check_column_exists`
  --> migrate_add_text_index.py:33:5
   |
31 |     return str(db_path)
32 |
33 | def check_column_exists(cursor, table_name, column_name):
   |     ^^^^^^^^^^^^^^^^^^^
34 |     """Check if a column exists in the specified table."""
35 |     cursor.execute(f"PRAGMA table_info({table_name})")
   |
help: Add return type annotation

ANN001 Missing type annotation for function argument `cursor`
  --> migrate_add_text_index.py:33:25
   |
31 |     return str(db_path)
32 |
33 | def check_column_exists(cursor, table_name, column_name):
   |                         ^^^^^^
34 |     """Check if a column exists in the specified table."""
35 |     cursor.execute(f"PRAGMA table_info({table_name})")
   |

ANN001 Missing type annotation for function argument `table_name`
  --> migrate_add_text_index.py:33:33
   |
31 |     return str(db_path)
32 |
33 | def check_column_exists(cursor, table_name, column_name):
   |                                 ^^^^^^^^^^
34 |     """Check if a column exists in the specified table."""
35 |     cursor.execute(f"PRAGMA table_info({table_name})")
   |

ANN001 Missing type annotation for function argument `column_name`
  --> migrate_add_text_index.py:33:45
   |
31 |     return str(db_path)
32 |
33 | def check_column_exists(cursor, table_name, column_name):
   |                                             ^^^^^^^^^^^
34 |     """Check if a column exists in the specified table."""
35 |     cursor.execute(f"PRAGMA table_info({table_name})")
   |

ANN201 Missing return type annotation for public function `migrate_add_text_index`
  --> migrate_add_text_index.py:39:5
   |
37 |     return any(col[1] == column_name for col in columns)
38 |
39 | def migrate_add_text_index():
   |     ^^^^^^^^^^^^^^^^^^^^^^
40 |     """Add text_index column to session_keystrokes table and populate it."""
41 |     db_path = get_database_path()
   |
help: Add return type annotation: `None`

B007 Loop control variable `keystroke_time` not used within loop body
  --> migrate_add_text_index.py:93:39
   |
92 |             # Update each keystroke with its text_index (0-based)
93 |             for index, (keystroke_id, keystroke_time) in enumerate(keystrokes):
   |                                       ^^^^^^^^^^^^^^
94 |                 cursor.execute("""
95 |                     UPDATE session_keystrokes 
   |
help: Rename unused `keystroke_time` to `_keystroke_time`

D212 [*] Multi-line docstring summary should start at the first line
  --> migrate_add_text_index_cloud.py:2:1
   |
 1 |   #!/usr/bin/env python3
 2 | / """
 3 | | Database migration script to add text_index column to session_keystrokes table (CLOUD VERSION).
 4 | |
 5 | | This script:
 6 | | 1. Adds a nullable text_index column to session_keystrokes table
 7 | | 2. Populates the column using ROW_NUMBER() partitioned by session_id, ordered by keystroke_time ASC
 8 | | 3. Makes the column NOT NULL after population
 9 | |
10 | | Usage:
11 | |     python migrate_add_text_index_cloud.py
12 | | """
   | |___^
13 |
14 |   import os
   |
help: Remove whitespace after opening quotes

F401 [*] `pathlib.Path` imported but unused
  --> migrate_add_text_index_cloud.py:16:21
   |
14 | import os
15 | import sys
16 | from pathlib import Path
   |                     ^^^^
17 |
18 | # Ensure project root is in sys.path before any project imports
   |
help: Remove unused import: `pathlib.Path`

ANN201 Missing return type annotation for public function `migrate_add_text_index_cloud`
  --> migrate_add_text_index_cloud.py:24:5
   |
24 | def migrate_add_text_index_cloud():
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
25 |     """Add text_index column to session_keystrokes table and populate it (CLOUD VERSION)."""
   |
help: Add return type annotation: `None`

D202 [*] No blank lines allowed after function docstring (found 1)
  --> migrate_add_text_index_cloud.py:25:5
   |
24 | def migrate_add_text_index_cloud():
25 |     """Add text_index column to session_keystrokes table and populate it (CLOUD VERSION)."""
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
26 |     
27 |     print("=== Adding text_index column to session_keystrokes table (CLOUD) ===")
   |
help: Remove blank line(s) after function docstring

D100 Missing docstring in public module
--> models\ngram_manager.py:1:1

D205 1 blank line required between summary line and description
 --> run_snippets_library.py:1:1
  |
1 | / """
2 | | Combined runner for the Snippets Library - launches both Desktop and Web UIs.
3 | | This script starts the API server, Desktop UI, and optionally the Web UI.
4 | | """
  | |___^
5 |
6 |   import argparse
  |
help: Insert single blank line

D212 [*] Multi-line docstring summary should start at the first line
 --> run_snippets_library.py:1:1
  |
1 | / """
2 | | Combined runner for the Snippets Library - launches both Desktop and Web UIs.
3 | | This script starts the API server, Desktop UI, and optionally the Web UI.
4 | | """
  | |___^
5 |
6 |   import argparse
  |
help: Remove whitespace after opening quotes

D205 1 blank line required between summary line and description
  --> run_snippets_library.py:25:5
   |
24 |   class SnippetsLibraryRunner:
25 | /     """
26 | |     Main runner class for Snippets Library that manages all components.
27 | |     Handles starting and stopping the API server, Desktop UI, and Web UI.
28 | |     """
   | |_______^
29 |
30 |       def __init__(self) -> None:
   |
help: Insert single blank line

D212 [*] Multi-line docstring summary should start at the first line
  --> run_snippets_library.py:25:5
   |
24 |   class SnippetsLibraryRunner:
25 | /     """
26 | |     Main runner class for Snippets Library that manages all components.
27 | |     Handles starting and stopping the API server, Desktop UI, and Web UI.
28 | |     """
   | |_______^
29 |
30 |       def __init__(self) -> None:
   |
help: Remove whitespace after opening quotes

D212 [*] Multi-line docstring summary should start at the first line
  --> run_snippets_library.py:38:9
   |
37 |       def start_api_server(self) -> Optional[subprocess.Popen]:
38 | /         """
39 | |         Start the GraphQL API server.
40 | |
41 | |         Returns:
42 | |             Optional[subprocess.Popen]: Process object for the API server, or None if startup fails
43 | |         """
   | |___________^
44 |           logger.info("Starting API server...")
   |
help: Remove whitespace after opening quotes

D212 [*] Multi-line docstring summary should start at the first line
  --> run_snippets_library.py:80:9
   |
79 |       def start_desktop_ui(self) -> Optional[subprocess.Popen]:
80 | /         """
81 | |         Start the PyQt5 desktop UI.
82 | |
83 | |         Returns:
84 | |             Optional[subprocess.Popen]: Process object for the desktop UI, or None if startup fails
85 | |         """
   | |___________^
86 |           logger.info("Starting Desktop UI...")
   |
help: Remove whitespace after opening quotes

D212 [*] Multi-line docstring summary should start at the first line
   --> run_snippets_library.py:100:9
    |
 99 |       def start_web_ui(self) -> Optional[subprocess.Popen]:
100 | /         """
101 | |         Start the React Web UI using npm.
102 | |
103 | |         Returns:
104 | |             Optional[subprocess.Popen]: Process object for the web server, or None if startup fails
105 | |         """
    | |___________^
106 |           logger.info("Starting Web UI (npm start)...")
    |
help: Remove whitespace after opening quotes

D212 [*] Multi-line docstring summary should start at the first line
   --> run_snippets_library.py:125:9
    |
124 |       def run(self, include_web: bool = False) -> None:
125 | /         """
126 | |         Run all components of the Snippets Library.
127 | |
128 | |         Args:
129 | |             include_web (bool): Whether to include the web UI in addition to desktop UI
130 | |         """
    | |___________^
131 |           # Start API server first
132 |           api_process = self.start_api_server()
    |
help: Remove whitespace after opening quotes

D205 1 blank line required between summary line and description
 --> scripts\fix_all_critical_errors.py:2:1
  |
1 |   #!/usr/bin/env python3
2 | / """
3 | | Comprehensive final fix script for all critical type errors across the codebase.
4 | | Addresses missing description arguments, type mismatches, and other critical issues.
5 | | """
  | |___^
6 |
7 |   import os
  |
help: Insert single blank line

D212 [*] Multi-line docstring summary should start at the first line
 --> scripts\fix_all_critical_errors.py:2:1
  |
1 |   #!/usr/bin/env python3
2 | / """
3 | | Comprehensive final fix script for all critical type errors across the codebase.
4 | | Addresses missing description arguments, type mismatches, and other critical issues.
5 | | """
  | |___^
6 |
7 |   import os
  |
help: Remove whitespace after opening quotes

ANN201 Missing return type annotation for public function `fix_test_snippet`
  --> scripts\fix_all_critical_errors.py:32:5
   |
30 |     return False
31 |
32 | def fix_test_snippet():
   |     ^^^^^^^^^^^^^^^^
33 |     """Fix all critical errors in test_snippet.py"""
34 |     file_path = r"d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py"
   |
help: Add return type annotation

D415 First line should end with a period, question mark, or exclamation point
  --> scripts\fix_all_critical_errors.py:33:5
   |
32 | def fix_test_snippet():
33 |     """Fix all critical errors in test_snippet.py"""
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
34 |     file_path = r"d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py"
   |
help: Add closing punctuation

ANN201 Missing return type annotation for public function `fix_test_snippet_manager`
  --> scripts\fix_all_critical_errors.py:68:5
   |
66 |     return fix_file_content(file_path, fixes)
67 |
68 | def fix_test_snippet_manager():
   |     ^^^^^^^^^^^^^^^^^^^^^^^^
69 |     """Fix all critical errors in test_snippet_manager.py"""
70 |     file_path = r"d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet_manager.py"
   |
help: Add return type annotation

D415 First line should end with a period, question mark, or exclamation point
  --> scripts\fix_all_critical_errors.py:69:5
   |
68 | def fix_test_snippet_manager():
69 |     """Fix all critical errors in test_snippet_manager.py"""
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
70 |     file_path = r"d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet_manager.py"
   |
help: Add closing punctuation

E501 Line too long (123 > 120)
  --> scripts\fix_all_critical_errors.py:75:121
   |
73 |         # Fix missing description argument and category_id type
74 |         (r'Snippet\(\s*snippet_name=([^,]+),\s*content=([^,]+),\s*category_id=([^,\)]+)\s*\)',
75 |          r'Snippet(snippet_name=\1, content=\2, category_id=\3 or "default_category_id", description="Test description")'),
   |                                                                                                                         ^^^
76 |     ]
   |

ANN201 Missing return type annotation for public function `fix_conftest`
  --> scripts\fix_all_critical_errors.py:80:5
   |
78 |     return fix_file_content(file_path, fixes)
79 |
80 | def fix_conftest():
   |     ^^^^^^^^^^^^
81 |     """Fix all critical errors in conftest.py"""
82 |     file_path = r"d:\SeanDevLocal\AITypingTrainer\tests\models\conftest.py"
   |
help: Add return type annotation

D415 First line should end with a period, question mark, or exclamation point
  --> scripts\fix_all_critical_errors.py:81:5
   |
80 | def fix_conftest():
81 |     """Fix all critical errors in conftest.py"""
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
82 |     file_path = r"d:\SeanDevLocal\AITypingTrainer\tests\models\conftest.py"
   |
help: Add closing punctuation

E501 Line too long (164 > 120)
   --> scripts\fix_all_critical_errors.py:99:121
    |
 97 | 
 98 | er_id,\s*keyboard_id=([^.]+)\.keyboard_id',
 99 | =\2.user_id or "default_user_id", keyboard_id=\3.keyboard_id or "default_keyboard_id"'),
    |                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
100 | 
    |

ANN201 Missing return type annotation for public function `fix_test_ngram_size`
   --> scripts\fix_all_critical_errors.py:104:5
    |
102 |     return fix_file_content(file_path, fixes)
103 |
104 | def fix_test_ngram_size():
    |     ^^^^^^^^^^^^^^^^^^^
105 |     """Fix all critical errors in test_ngram_size.py"""
106 |     file_path = r"d:\SeanDevLocal\AITypingTrainer\tests\models\test_ngram_size.py"
    |
help: Add return type annotation

D415 First line should end with a period, question mark, or exclamation point
   --> scripts\fix_all_critical_errors.py:105:5
    |
104 | def fix_test_ngram_size():
105 |     """Fix all critical errors in test_ngram_size.py"""
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
106 |     file_path = r"d:\SeanDevLocal\AITypingTrainer\tests\models\test_ngram_size.py"
    |
help: Add closing punctuation

ANN201 Missing return type annotation for public function `fix_test_db_viewer_dialog`
   --> scripts\fix_all_critical_errors.py:120:5
    |
118 |     return fix_file_content(file_path, fixes)
119 |
120 | def fix_test_db_viewer_dialog():
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^
121 |     """Fix critical errors in test_db_viewer_dialog.py"""
122 |     file_path = r"d:\SeanDevLocal\AITypingTrainer\tests\desktop_ui\test_db_viewer_dialog.py"
    |
help: Add return type annotation

D415 First line should end with a period, question mark, or exclamation point
   --> scripts\fix_all_critical_errors.py:121:5
    |
120 | def fix_test_db_viewer_dialog():
121 |     """Fix critical errors in test_db_viewer_dialog.py"""
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
122 |     file_path = r"d:\SeanDevLocal\AITypingTrainer\tests\desktop_ui\test_db_viewer_dialog.py"
    |
help: Add closing punctuation

ANN201 Missing return type annotation for public function `main`
   --> scripts\fix_all_critical_errors.py:136:5
    |
134 |     return fix_file_content(file_path, fixes)
135 |
136 | def main():
    |     ^^^^
137 |     """Run all fixes"""
138 |     print("Starting comprehensive fix for all critical type errors...")
    |
help: Add return type annotation: `None`

D415 First line should end with a period, question mark, or exclamation point
   --> scripts\fix_all_critical_errors.py:137:5
    |
136 | def main():
137 |     """Run all fixes"""
    |     ^^^^^^^^^^^^^^^^^^^
138 |     print("Starting comprehensive fix for all critical type errors...")
    |
help: Add closing punctuation

D205 1 blank line required between summary line and description
 --> scripts\fix_all_remaining_critical_errors.py:2:1
  |
1 |   #!/usr/bin/env python3
2 | / """
3 | | Comprehensive fix script to resolve all remaining critical type errors
4 | | across multiple test files in the AI Typing Trainer project.
5 | | """
  | |___^
6 |
7 |   import re
  |
help: Insert single blank line

D212 [*] Multi-line docstring summary should start at the first line
 --> scripts\fix_all_remaining_critical_errors.py:2:1
  |
1 |   #!/usr/bin/env python3
2 | / """
3 | | Comprehensive fix script to resolve all remaining critical type errors
4 | | across multiple test files in the AI Typing Trainer project.
5 | | """
  | |___^
6 |
7 |   import re
  |
help: Remove whitespace after opening quotes

ANN201 Missing return type annotation for public function `fix_test_snippet_py`
  --> scripts\fix_all_remaining_critical_errors.py:11:5
   |
11 | def fix_test_snippet_py():
   |     ^^^^^^^^^^^^^^^^^^^
12 |     """Fix all critical type errors in test_snippet.py"""
13 |     file_path = Path("tests/models/test_snippet.py")
   |
help: Add return type annotation: `None`

D415 First line should end with a period, question mark, or exclamation point
  --> scripts\fix_all_remaining_critical_errors.py:12:5
   |
11 | def fix_test_snippet_py():
12 |     """Fix all critical type errors in test_snippet.py"""
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
13 |     file_path = Path("tests/models/test_snippet.py")
14 |     if not file_path.exists():
   |
help: Add closing punctuation

ANN201 Missing return type annotation for public function `fix_test_snippet_manager_py`
  --> scripts\fix_all_remaining_critical_errors.py:53:5
   |
51 |     print(f"Fixed critical type errors in {file_path}")
52 |
53 | def fix_test_snippet_manager_py():
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
54 |     """Fix all critical type errors in test_snippet_manager.py"""
55 |     file_path = Path("tests/models/test_snippet_manager.py")
   |
help: Add return type annotation: `None`

D415 First line should end with a period, question mark, or exclamation point
  --> scripts\fix_all_remaining_critical_errors.py:54:5
   |
53 | def fix_test_snippet_manager_py():
54 |     """Fix all critical type errors in test_snippet_manager.py"""
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
55 |     file_path = Path("tests/models/test_snippet_manager.py")
56 |     if not file_path.exists():
   |
help: Add closing punctuation

ANN201 Missing return type annotation for public function `fix_conftest_py`
  --> scripts\fix_all_remaining_critical_errors.py:75:5
   |
73 |     print(f"Fixed critical type errors in {file_path}")
74 |
75 | def fix_conftest_py():
   |     ^^^^^^^^^^^^^^^
76 |     """Fix all critical type errors in conftest.py"""
77 |     file_path = Path("tests/models/conftest.py")
   |
help: Add return type annotation: `None`

D415 First line should end with a period, question mark, or exclamation point
  --> scripts\fix_all_remaining_critical_errors.py:76:5
   |
75 | def fix_conftest_py():
76 |     """Fix all critical type errors in conftest.py"""
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
77 |     file_path = Path("tests/models/conftest.py")
78 |     if not file_path.exists():
   |
help: Add closing punctuation

E501 Line too long (157 > 120)
  --> scripts\fix_all_remaining_critical_errors.py:86:121
   |
84 | 
85 | 
86 | "user_id": user_id,\s*"keyboard_id": keyboard_id,\s*"snippet_id": snippet_id,?\s*\}',
   |                                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
87 | ',
88 | 
   |

ANN201 Missing return type annotation for public function `fix_test_ngram_size_py`
   --> scripts\fix_all_remaining_critical_errors.py:110:5
    |
108 |     print(f"Fixed critical type errors in {file_path}")
109 |
110 | def fix_test_ngram_size_py():
    |     ^^^^^^^^^^^^^^^^^^^^^^
111 |     """Fix all critical type errors in test_ngram_size.py"""
112 |     file_path = Path("tests/models/test_ngram_size.py")
    |
help: Add return type annotation: `None`

D415 First line should end with a period, question mark, or exclamation point
   --> scripts\fix_all_remaining_critical_errors.py:111:5
    |
110 | def fix_test_ngram_size_py():
111 |     """Fix all critical type errors in test_ngram_size.py"""
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
112 |     file_path = Path("tests/models/test_ngram_size.py")
113 |     if not file_path.exists():
    |
help: Add closing punctuation

ANN201 Missing return type annotation for public function `fix_test_ngram_analytics_service_py`
   --> scripts\fix_all_remaining_critical_errors.py:138:5
    |
136 |     print(f"Fixed critical type errors in {file_path}")
137 |
138 | def fix_test_ngram_analytics_service_py():
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
139 |     """Fix undefined name errors in test_ngram_analytics_service.py"""
140 |     file_path = Path("tests/models/test_ngram_analytics_service.py")
    |
help: Add return type annotation: `None`

D415 First line should end with a period, question mark, or exclamation point
   --> scripts\fix_all_remaining_critical_errors.py:139:5
    |
138 | def fix_test_ngram_analytics_service_py():
139 |     """Fix undefined name errors in test_ngram_analytics_service.py"""
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
140 |     file_path = Path("tests/models/test_ngram_analytics_service.py")
141 |     if not file_path.exists():
    |
help: Add closing punctuation

ANN201 Missing return type annotation for public function `fix_database_viewer_service_py`
   --> scripts\fix_all_remaining_critical_errors.py:153:5
    |
151 |     print(f"Fixed undefined name errors in {file_path}")
152 |
153 | def fix_database_viewer_service_py():
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
154 |     """Fix type assignment error in database_viewer_service.py"""
155 |     file_path = Path("services/database_viewer_service.py")
    |
help: Add return type annotation: `None`

D415 First line should end with a period, question mark, or exclamation point
   --> scripts\fix_all_remaining_critical_errors.py:154:5
    |
153 | def fix_database_viewer_service_py():
154 |     """Fix type assignment error in database_viewer_service.py"""
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
155 |     file_path = Path("services/database_viewer_service.py")
156 |     if not file_path.exists():
    |
help: Add closing punctuation

ANN201 Missing return type annotation for public function `fix_test_db_viewer_dialog_py`
   --> scripts\fix_all_remaining_critical_errors.py:172:5
    |
170 |     print(f"Fixed type assignment error in {file_path}")
171 |
172 | def fix_test_db_viewer_dialog_py():
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
173 |     """Fix syntax and type errors in test_db_viewer_dialog.py"""
174 |     file_path = Path("tests/desktop_ui/test_db_viewer_dialog.py")
    |
help: Add return type annotation: `None`

D415 First line should end with a period, question mark, or exclamation point
   --> scripts\fix_all_remaining_critical_errors.py:173:5
    |
172 | def fix_test_db_viewer_dialog_py():
173 |     """Fix syntax and type errors in test_db_viewer_dialog.py"""
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
174 |     file_path = Path("tests/desktop_ui/test_db_viewer_dialog.py")
175 |     if not file_path.exists():
    |
help: Add closing punctuation

B007 Loop control variable `i` not used within loop body
   --> scripts\fix_all_remaining_critical_errors.py:185:9
    |
183 |     fixed_lines = []
184 |     
185 |     for i, line in enumerate(lines):
    |         ^
186 |         # Look for unterminated strings (odd number of quotes)
187 |         if line.count('"') % 2 != 0 and not line.strip().endswith('\\'):
    |
help: Rename unused `i` to `_i`

E501 Line too long (126 > 120)
   --> scripts\fix_all_remaining_critical_errors.py:197:121
    |
195 |     content = re.sub(
196 |         r'return app if app is not None else QApplication\(\[\]\)',
197 |         r'app_instance = app if app is not None else QApplication([])\n    return app_instance  # type: ignore[return-value]',
    |                                                                                                                         ^^^^^^
198 |         content
199 |     )
    |

ANN201 Missing return type annotation for public function `main`
   --> scripts\fix_all_remaining_critical_errors.py:207:5
    |
205 |     print(f"Fixed syntax and type errors in {file_path}")
206 |
207 | def main():
    |     ^^^^
208 |     """Run all fixes"""
209 |     print("Starting comprehensive fix for all remaining critical type errors...")
    |
help: Add return type annotation: `None`

D415 First line should end with a period, question mark, or exclamation point
   --> scripts\fix_all_remaining_critical_errors.py:208:5
    |
207 | def main():
208 |     """Run all fixes"""
    |     ^^^^^^^^^^^^^^^^^^^
209 |     print("Starting comprehensive fix for all remaining critical type errors...")
    |
help: Add closing punctuation

D205 1 blank line required between summary line and description
 --> scripts\fix_db_viewer_dialog_annotations.py:2:1
  |
1 |   #!/usr/bin/env python3
2 | / """
3 | | Batch fix script to add missing type annotations to test_db_viewer_dialog.py.
4 | | This script systematically adds type annotations to all test functions.
5 | | """
  | |___^
6 |
7 |   import re
  |
help: Insert single blank line

D212 [*] Multi-line docstring summary should start at the first line
 --> scripts\fix_db_viewer_dialog_annotations.py:2:1
  |
1 |   #!/usr/bin/env python3
2 | / """
3 | | Batch fix script to add missing type annotations to test_db_viewer_dialog.py.
4 | | This script systematically adds type annotations to all test functions.
5 | | """
  | |___^
6 |
7 |   import re
  |
help: Remove whitespace after opening quotes

ANN201 Missing return type annotation for public function `fix_test_db_viewer_dialog_annotations`
  --> scripts\fix_db_viewer_dialog_annotations.py:11:5
   |
11 | def fix_test_db_viewer_dialog_annotations():
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
12 |     """Fix missing type annotations in test_db_viewer_dialog.py."""
   |
help: Add return type annotation: `None`

D202 [*] No blank lines allowed after function docstring (found 1)
  --> scripts\fix_db_viewer_dialog_annotations.py:12:5
   |
11 | def fix_test_db_viewer_dialog_annotations():
12 |     """Fix missing type annotations in test_db_viewer_dialog.py."""
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
13 |     
14 |     file_path = Path("tests/desktop_ui/test_db_viewer_dialog.py")
   |
help: Remove blank line(s) after function docstring

E501 Line too long (128 > 120)
  --> scripts\fix_db_viewer_dialog_annotations.py:37:121
   |
36 |     # Fix 3: Add type annotations to test_export_to_csv with mock decorators
37 |     export_pattern = r'def (test_export_to_csv)\(mock_info_box, mock_get_save_filename, qtapp, mock_db_viewer_service, qtbot\):'
   |                                                                                                                         ^^^^^^^^
38 |     export_replacement = r'def \1(mock_info_box: Any, mock_get_save_filename: Any, qtapp: QApplication, mock_db_viewer_service: MagicM
39 |     content = re.sub(export_pattern, export_replacement, content)
   |

E501 Line too long (162 > 120)
  --> scripts\fix_db_viewer_dialog_annotations.py:38:121
   |
36 | s
37 | ve_filename, qtapp, mock_db_viewer_service, qtbot\):'
38 | e: Any, qtapp: QApplication, mock_db_viewer_service: MagicMock, qtbot: QtBot) -> None:'
   |                                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
39 | 
   |

ANN202 Missing return type annotation for private function `fix_remaining_tests`
  --> scripts\fix_db_viewer_dialog_annotations.py:48:9
   |
46 |     # Fix 5: Handle any remaining test functions that might have been missed
47 |     remaining_test_pattern = r'def (test_\w+)\(([^)]+)\):'
48 |     def fix_remaining_tests(match):
   |         ^^^^^^^^^^^^^^^^^^^
49 |         func_name = match.group(1)
50 |         params = match.group(2)
   |
help: Add return type annotation

ANN001 Missing type annotation for function argument `match`
  --> scripts\fix_db_viewer_dialog_annotations.py:48:29
   |
46 |     # Fix 5: Handle any remaining test functions that might have been missed
47 |     remaining_test_pattern = r'def (test_\w+)\(([^)]+)\):'
48 |     def fix_remaining_tests(match):
   |                             ^^^^^
49 |         func_name = match.group(1)
50 |         params = match.group(2)
   |

D205 1 blank line required between summary line and description
 --> scripts\fix_remaining_critical_errors_targeted.py:2:1
  |
1 |   #!/usr/bin/env python3
2 | / """
3 | | Targeted fix script to resolve remaining critical type errors
4 | | without breaking existing syntax.
5 | | """
  | |___^
6 |
7 |   import re
  |
help: Insert single blank line

D212 [*] Multi-line docstring summary should start at the first line
 --> scripts\fix_remaining_critical_errors_targeted.py:2:1
  |
1 |   #!/usr/bin/env python3
2 | / """
3 | | Targeted fix script to resolve remaining critical type errors
4 | | without breaking existing syntax.
5 | | """
  | |___^
6 |
7 |   import re
  |
help: Remove whitespace after opening quotes

D415 First line should end with a period, question mark, or exclamation point
  --> scripts\fix_remaining_critical_errors_targeted.py:12:5
   |
11 | def fix_test_snippet_py() -> None:
12 |     """Fix remaining critical type errors in test_snippet.py"""
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
13 |     file_path = Path("tests/models/test_snippet.py")
14 |     if not file_path.exists():
   |
help: Add closing punctuation

ANN202 Missing return type annotation for private function `fix_snippet_constructor`
  --> scripts\fix_remaining_critical_errors_targeted.py:27:9
   |
25 |     snippet_pattern = r'Snippet\(\s*([^)]*?)\s*\)'
26 |     
27 |     def fix_snippet_constructor(match):
   |         ^^^^^^^^^^^^^^^^^^^^^^^
28 |         args = match.group(1)
29 |         # If description is not present, add it
   |
help: Add return type annotation

ANN001 Missing type annotation for function argument `match`
  --> scripts\fix_remaining_critical_errors_targeted.py:27:33
   |
25 |     snippet_pattern = r'Snippet\(\s*([^)]*?)\s*\)'
26 |     
27 |     def fix_snippet_constructor(match):
   |                                 ^^^^^
28 |         args = match.group(1)
29 |         # If description is not present, add it
   |

D415 First line should end with a period, question mark, or exclamation point
  --> scripts\fix_remaining_critical_errors_targeted.py:84:5
   |
83 | def fix_test_snippet_manager_py() -> None:
84 |     """Fix critical type errors in test_snippet_manager.py"""
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
85 |     file_path = Path("tests/models/test_snippet_manager.py")
86 |     if not file_path.exists():
   |
help: Add closing punctuation

ANN202 Missing return type annotation for private function `fix_snippet_constructor`
  --> scripts\fix_remaining_critical_errors_targeted.py:96:9
   |
94 |     snippet_pattern = r'Snippet\(\s*([^)]*?)\s*\)'
95 |     
96 |     def fix_snippet_constructor(match):
   |         ^^^^^^^^^^^^^^^^^^^^^^^
97 |         args = match.group(1)
98 |         # If description is not present, add it
   |
help: Add return type annotation: `str`

ANN001 Missing type annotation for function argument `match`
  --> scripts\fix_remaining_critical_errors_targeted.py:96:33
   |
94 |     snippet_pattern = r'Snippet\(\s*([^)]*?)\s*\)'
95 |     
96 |     def fix_snippet_constructor(match):
   |                                 ^^^^^
97 |         args = match.group(1)
98 |         # If description is not present, add it
   |

D415 First line should end with a period, question mark, or exclamation point
   --> scripts\fix_remaining_critical_errors_targeted.py:117:5
    |
116 | def fix_conftest_py() -> None:
117 |     """Fix critical type errors in conftest.py"""
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
118 |     file_path = Path("tests/models/conftest.py")
119 |     if not file_path.exists():
    |
help: Add closing punctuation

D415 First line should end with a period, question mark, or exclamation point
   --> scripts\fix_remaining_critical_errors_targeted.py:153:5
    |
152 | def fix_test_ngram_size_py() -> None:
153 |     """Fix critical type errors in test_ngram_size.py"""
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
154 |     file_path = Path("tests/models/test_ngram_size.py")
155 |     if not file_path.exists():
    |
help: Add closing punctuation

D415 First line should end with a period, question mark, or exclamation point
   --> scripts\fix_remaining_critical_errors_targeted.py:173:5
    |
172 | def fix_test_ngram_analytics_service_py() -> None:
173 |     """Fix undefined name errors in test_ngram_analytics_service.py"""
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
174 |     file_path = Path("tests/models/test_ngram_analytics_service.py")
175 |     if not file_path.exists():
    |
help: Add closing punctuation

D415 First line should end with a period, question mark, or exclamation point
   --> scripts\fix_remaining_critical_errors_targeted.py:189:5
    |
188 | def main() -> None:
189 |     """Run targeted fixes for critical type errors"""
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
190 |     print("Starting targeted fix for remaining critical type errors...")
    |
help: Add closing punctuation

D205 1 blank line required between summary line and description
 --> scripts\fix_snippet_test_errors.py:2:1
  |
1 |   #!/usr/bin/env python3
2 | / """
3 | | Script to systematically fix critical type errors in test_snippet.py.
4 | | This addresses the 80+ missing description arguments and type mismatches.
5 | | """
  | |___^
6 |
7 |   import re
  |
help: Insert single blank line

D212 [*] Multi-line docstring summary should start at the first line
 --> scripts\fix_snippet_test_errors.py:2:1
  |
1 |   #!/usr/bin/env python3
2 | / """
3 | | Script to systematically fix critical type errors in test_snippet.py.
4 | | This addresses the 80+ missing description arguments and type mismatches.
5 | | """
  | |___^
6 |
7 |   import re
  |
help: Remove whitespace after opening quotes

D202 [*] No blank lines allowed after function docstring (found 1)
  --> scripts\fix_snippet_test_errors.py:13:5
   |
12 | def fix_snippet_constructors(content: str) -> str:
13 |     """Fix missing description arguments in Snippet constructors."""
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
14 |     
15 |     # Pattern to match Snippet constructors without description
   |
help: Remove blank line(s) after function docstring

ANN202 Missing return type annotation for private function `add_description_if_missing`
  --> scripts\fix_snippet_test_errors.py:18:9
   |
16 |     snippet_pattern = r'(Snippet\(\s*(?:[^)]*?))\)'
17 |     
18 |     def add_description_if_missing(match):
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^
19 |         constructor_content = match.group(1)
20 |         if 'description=' not in constructor_content:
   |
help: Add return type annotation

ANN001 Missing type annotation for function argument `match`
  --> scripts\fix_snippet_test_errors.py:18:36
   |
16 |     snippet_pattern = r'(Snippet\(\s*(?:[^)]*?))\)'
17 |     
18 |     def add_description_if_missing(match):
   |                                    ^^^^^
19 |         constructor_content = match.group(1)
20 |         if 'description=' not in constructor_content:
   |

D202 [*] No blank lines allowed after function docstring (found 1)
  --> scripts\fix_snippet_test_errors.py:32:5
   |
31 | def fix_category_constructors(content: str) -> str:
32 |     """Fix missing description arguments in Category constructors."""
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
33 |     
34 |     # Pattern to match Category constructors without description
   |
help: Remove blank line(s) after function docstring

ANN202 Missing return type annotation for private function `add_description_if_missing`
  --> scripts\fix_snippet_test_errors.py:37:9
   |
35 |     category_pattern = r'(Category\(\s*(?:[^)]*?))\)'
36 |     
37 |     def add_description_if_missing(match):
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^
38 |         constructor_content = match.group(1)
39 |         if 'description=' not in constructor_content:
   |
help: Add return type annotation

ANN001 Missing type annotation for function argument `match`
  --> scripts\fix_snippet_test_errors.py:37:36
   |
35 |     category_pattern = r'(Category\(\s*(?:[^)]*?))\)'
36 |     
37 |     def add_description_if_missing(match):
   |                                    ^^^^^
38 |         constructor_content = match.group(1)
39 |         if 'description=' not in constructor_content:
   |

E501 Line too long (121 > 120)
  --> scripts\fix_snippet_test_errors.py:44:121
   |
42 |                 return f'{constructor_content}\n                description="Test category description",\n            )'
43 |             else:
44 |                 return f'{constructor_content},\n                description="Test category description",\n            )'
   |                                                                                                                         ^
45 |         return match.group(0)
   |

D202 [*] No blank lines allowed after function docstring (found 1)
  --> scripts\fix_snippet_test_errors.py:51:5
   |
50 | def fix_type_mismatches(content: str) -> str:
51 |     """Fix str | None vs str type mismatches by adding null checks."""
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
52 |     
53 |     # Fix category_id type mismatches in Snippet constructors
   |
help: Remove blank line(s) after function docstring

D202 [*] No blank lines allowed after function docstring (found 1)
  --> scripts\fix_snippet_test_errors.py:91:5
   |
90 | def fix_duplicate_function_names(content: str) -> str:
91 |     """Fix duplicate function name definitions."""
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
92 |     
93 |     # Find and rename duplicate test_update_nonexistent_snippet
   |
help: Remove blank line(s) after function docstring

D202 [*] No blank lines allowed after function docstring (found 1)
   --> scripts\fix_snippet_test_errors.py:112:5
    |
111 | def fix_return_type_mismatches(content: str) -> str:
112 |     """Fix return type mismatches."""
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
113 |     
114 |     # Fix incompatible return value type (got "int", expected "str")
    |
help: Remove blank line(s) after function docstring

ANN201 Missing return type annotation for public function `main`
   --> scripts\fix_snippet_test_errors.py:125:5
    |
125 | def main():
    |     ^^^^
126 |     """Main function to apply all fixes."""
    |
help: Add return type annotation: `None`

D202 [*] No blank lines allowed after function docstring (found 1)
   --> scripts\fix_snippet_test_errors.py:126:5
    |
125 | def main():
126 |     """Main function to apply all fixes."""
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
127 |     
128 |     test_file = Path("tests/models/test_snippet.py")
    |
help: Remove blank line(s) after function docstring

D205 1 blank line required between summary line and description
 --> scripts\fix_snippet_test_errors_v2.py:2:1
  |
1 |   #!/usr/bin/env python3
2 | / """
3 | | Improved batch fix script to comprehensively fix all remaining type errors in test_snippet.py.
4 | | This script addresses missing description arguments, syntax errors, and type mismatches.
5 | | """
  | |___^
6 |
7 |   import re
  |
help: Insert single blank line

D212 [*] Multi-line docstring summary should start at the first line
 --> scripts\fix_snippet_test_errors_v2.py:2:1
  |
1 |   #!/usr/bin/env python3
2 | / """
3 | | Improved batch fix script to comprehensively fix all remaining type errors in test_snippet.py.
4 | | This script addresses missing description arguments, syntax errors, and type mismatches.
5 | | """
  | |___^
6 |
7 |   import re
  |
help: Remove whitespace after opening quotes

ANN201 Missing return type annotation for public function `fix_test_snippet_errors_v2`
  --> scripts\fix_snippet_test_errors_v2.py:11:5
   |
11 | def fix_test_snippet_errors_v2():
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^
12 |     """Fix all remaining type errors in test_snippet.py comprehensively."""
   |
help: Add return type annotation: `None`

D202 [*] No blank lines allowed after function docstring (found 1)
  --> scripts\fix_snippet_test_errors_v2.py:12:5
   |
11 | def fix_test_snippet_errors_v2():
12 |     """Fix all remaining type errors in test_snippet.py comprehensively."""
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
13 |     
14 |     file_path = Path("tests/models/test_snippet.py")
   |
help: Remove blank line(s) after function docstring

ANN202 Missing return type annotation for private function `fix_snippet_constructor`
  --> scripts\fix_snippet_test_errors_v2.py:29:9
   |
27 |     # Pattern: Snippet(...) without description
28 |     snippet_pattern = r'Snippet\(\s*([^)]*?)\s*\)'
29 |     def fix_snippet_constructor(match):
   |         ^^^^^^^^^^^^^^^^^^^^^^^
30 |         args = match.group(1)
31 |         # Skip if already has description
   |
help: Add return type annotation

ANN001 Missing type annotation for function argument `match`
  --> scripts\fix_snippet_test_errors_v2.py:29:33
   |
27 |     # Pattern: Snippet(...) without description
28 |     snippet_pattern = r'Snippet\(\s*([^)]*?)\s*\)'
29 |     def fix_snippet_constructor(match):
   |                                 ^^^^^
30 |         args = match.group(1)
31 |         # Skip if already has description
   |

ANN202 Missing return type annotation for private function `fix_category_constructor`
  --> scripts\fix_snippet_test_errors_v2.py:45:9
   |
43 |     # Pattern: Category(...) without description
44 |     category_pattern = r'Category\(\s*([^)]*?)\s*\)'
45 |     def fix_category_constructor(match):
   |         ^^^^^^^^^^^^^^^^^^^^^^^^
46 |         args = match.group(1)
47 |         # Skip if already has description
   |
help: Add return type annotation

ANN001 Missing type annotation for function argument `match`
  --> scripts\fix_snippet_test_errors_v2.py:45:34
   |
43 |     # Pattern: Category(...) without description
44 |     category_pattern = r'Category\(\s*([^)]*?)\s*\)'
45 |     def fix_category_constructor(match):
   |                                  ^^^^^
46 |         args = match.group(1)
47 |         # Skip if already has description
   |

E501 Line too long (136 > 120)
  --> scripts\fix_snippet_test_errors_v2.py:80:121
   |
78 | 
79 | ne:\s*"""Test updating a non-existent snippet\."""',
80 |  None:\n    """Test updating a non-existent snippet (duplicate test)."""',
   |                                                            ^^^^^^^^^^^^^^^^
81 | 
82 | 
   |

D205 1 blank line required between summary line and description
 --> scripts\fix_snippet_test_final.py:2:1
  |
1 |   #!/usr/bin/env python3
2 | / """
3 | | Final comprehensive batch fix script for test_snippet.py
4 | | Addresses all remaining missing description arguments, type mismatches, and syntax errors.
5 | | """
  | |___^
6 |
7 |   import os
  |
help: Insert single blank line

D212 [*] Multi-line docstring summary should start at the first line
 --> scripts\fix_snippet_test_final.py:2:1
  |
1 |   #!/usr/bin/env python3
2 | / """
3 | | Final comprehensive batch fix script for test_snippet.py
4 | | Addresses all remaining missing description arguments, type mismatches, and syntax errors.
5 | | """
  | |___^
6 |
7 |   import os
  |
help: Remove whitespace after opening quotes

ANN201 Missing return type annotation for public function `fix_test_snippet_final`
  --> scripts\fix_snippet_test_final.py:11:5
   |
11 | def fix_test_snippet_final():
   |     ^^^^^^^^^^^^^^^^^^^^^^
12 |     """Apply final comprehensive fixes to test_snippet.py"""
   |
help: Add return type annotation: `None`

D202 [*] No blank lines allowed after function docstring (found 1)
  --> scripts\fix_snippet_test_final.py:12:5
   |
11 | def fix_test_snippet_final():
12 |     """Apply final comprehensive fixes to test_snippet.py"""
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
13 |     
14 |     file_path = r"d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py"
   |
help: Remove blank line(s) after function docstring

D415 First line should end with a period, question mark, or exclamation point
  --> scripts\fix_snippet_test_final.py:12:5
   |
11 | def fix_test_snippet_final():
12 |     """Apply final comprehensive fixes to test_snippet.py"""
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
13 |     
14 |     file_path = r"d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py"
   |
help: Add closing punctuation

E501 Line too long (162 > 120)
  --> scripts\fix_snippet_test_final.py:30:121
   |
28 | 
29 | ),\s*\n\s*content=([^,\)]+)\s*\n\s*\)', 
30 | \2,\n            content=\3,\n            description="Test description",\n        )'),
   |                                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
31 | 
32 | 
   |

E501 Line too long (134 > 120)
  --> scripts\fix_snippet_test_final.py:82:121
   |
81 | 
82 | [^)]+)\) -> None:\s*"""Test updating a snippet that doesn\'t exist\."""',
   |                                                             ^^^^^^^^^^^^^^
83 | plicate(\1) -> None:\n    """Test updating a snippet that doesn\'t exist (duplicate test)."""',
84 | 
   |

E501 Line too long (156 > 120)
  --> scripts\fix_snippet_test_final.py:83:121
   |
81 | 
82 |  None:\s*"""Test updating a snippet that doesn\'t exist\."""',
83 |  -> None:\n    """Test updating a snippet that doesn\'t exist (duplicate test)."""',
   |                                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
84 | 
   |

D212 [*] Multi-line docstring summary should start at the first line
 --> services\__init__.py:1:1
  |
1 | / """
2 | | Service initialization module.
3 | |
4 | | This module provides factory functions for creating and initializing service instances
5 | | with their required dependencies.
6 | | """
  | |___^
7 |
8 |   from typing import Tuple
  |
help: Remove whitespace after opening quotes

D212 [*] Multi-line docstring summary should start at the first line
  --> services\__init__.py:14:5
   |
13 |   def init_services(db_path: str) -> Tuple[DatabaseManager, object, object]:
14 | /     """
15 | |     Initialize and return all service instances with their dependencies.
16 | |
17 | |     Args:
18 | |         db_path: Path to the SQLite database file
19 | |
20 | |     Returns:
21 | |         A tuple containing (db_manager, snippet_manager, session_manager)
22 | |
23 | |     Example:
24 | |         db, snippets, sessions = init_services("path/to/db.sqlite")
25 | |     """
   | |_______^
26 |       # Initialize database manager
27 |       db_manager = DatabaseManager(db_path)
   |
help: Remove whitespace after opening quotes

D100 Missing docstring in public module
--> services\category_service.py:1:1

D415 First line should end with a period, question mark, or exclamation point
  --> services\database_viewer_service.py:1:1
   |
 1 | / """Database Viewer Service Module
 2 | |
 3 | | This module provides functionality for viewing and exploring database tables,
 4 | | including listing tables, fetching table data with pagination, sorting, filtering,
 5 | | and exporting to CSV.
 6 | |
 7 | | The service provides a read-only interface to access the database structure and content.
 8 | | """
   | |___^
 9 |
10 |   import csv
   |
help: Add closing punctuation

D205 1 blank line required between summary line and description
  --> services\database_viewer_service.py:50:5
   |
49 |   class DatabaseViewerService:
50 | /     """
51 | |     Service for database viewing operations: list tables, fetch data (with pagination,
52 | |     sorting, filtering), and export to CSV.
53 | |
54 | |     This service provides a read-only interface to inspect database tables and their contents.
55 | |     It handles pagination, sorting, and filtering of data, as well as exporting to CSV format.
56 | |     All operations are performed in a secure, read-only manner with proper input validation.
57 | |     """
   | |_______^
58 |
59 |       def __init__(self, db_manager: DatabaseManager):
   |
help: Insert single blank line

D212 [*] Multi-line docstring summary should start at the first line
  --> services\database_viewer_service.py:50:5
   |
49 |   class DatabaseViewerService:
50 | /     """
51 | |     Service for database viewing operations: list tables, fetch data (with pagination,
52 | |     sorting, filtering), and export to CSV.
53 | |
54 | |     This service provides a read-only interface to inspect database tables and their contents.
55 | |     It handles pagination, sorting, and filtering of data, as well as exporting to CSV format.
56 | |     All operations are performed in a secure, read-only manner with proper input validation.
57 | |     """
   | |_______^
58 |
59 |       def __init__(self, db_manager: DatabaseManager):
   |
help: Remove whitespace after opening quotes

ANN204 Missing return type annotation for special method `__init__`
  --> services\database_viewer_service.py:59:9
   |
57 |     """
58 |
59 |     def __init__(self, db_manager: DatabaseManager):
   |         ^^^^^^^^
60 |         """
61 |         Initialize the DatabaseViewerService with a database manager.
   |
help: Add return type annotation: `None`

D212 [*] Multi-line docstring summary should start at the first line
  --> services\database_viewer_service.py:60:9
   |
59 |       def __init__(self, db_manager: DatabaseManager):
60 | /         """
61 | |         Initialize the DatabaseViewerService with a database manager.
62 | |
63 | |         Args:
64 | |             db_manager: An instance of DatabaseManager for database access
65 | |         """
   | |___________^
66 |           self.db_manager = db_manager
   |
help: Remove whitespace after opening quotes

D200 One-line docstring should fit on one line
  --> services\database_viewer_service.py:69:9
   |
68 |       def list_tables(self) -> List[str]:
69 | /         """
70 | |         Return a list of all table names in the database (delegates to db_manager).
71 | |         """
   | |___________^
72 |           return self.db_manager.list_tables()
   |
help: Reformat to one line

D212 [*] Multi-line docstring summary should start at the first line
  --> services\database_viewer_service.py:69:9
   |
68 |       def list_tables(self) -> List[str]:
69 | /         """
70 | |         Return a list of all table names in the database (delegates to db_manager).
71 | |         """
   | |___________^
72 |           return self.db_manager.list_tables()
   |
help: Remove whitespace after opening quotes

D205 1 blank line required between summary line and description
  --> services\database_viewer_service.py:75:9
   |
74 |       def get_table_schema(self, table_name: str) -> List[Dict[str, Any]]:
75 | /         """
76 | |         Get schema information for the specified table.
77 | |         Args:
78 | |             table_name: The name of the table to get schema for
79 | |         Returns:
80 | |             A list of column definitions with name, type, etc.
81 | |         Raises:
82 | |             TableNotFoundError: If the specified table doesn't exist
83 | |         """
   | |___________^
84 |           # Verify table exists using backend-agnostic method
85 |           if not self.db_manager.table_exists(table_name):
   |
help: Insert single blank line

D212 [*] Multi-line docstring summary should start at the first line
  --> services\database_viewer_service.py:75:9
   |
74 |       def get_table_schema(self, table_name: str) -> List[Dict[str, Any]]:
75 | /         """
76 | |         Get schema information for the specified table.
77 | |         Args:
78 | |             table_name: The name of the table to get schema for
79 | |         Returns:
80 | |             A list of column definitions with name, type, etc.
81 | |         Raises:
82 | |             TableNotFoundError: If the specified table doesn't exist
83 | |         """
   | |___________^
84 |           # Verify table exists using backend-agnostic method
85 |           if not self.db_manager.table_exists(table_name):
   |
help: Remove whitespace after opening quotes

D415 First line should end with a period, question mark, or exclamation point
  --> services\database_viewer_service.py:75:9
   |
74 |       def get_table_schema(self, table_name: str) -> List[Dict[str, Any]]:
75 | /         """
76 | |         Get schema information for the specified table.
77 | |         Args:
78 | |             table_name: The name of the table to get schema for
79 | |         Returns:
80 | |             A list of column definitions with name, type, etc.
81 | |         Raises:
82 | |             TableNotFoundError: If the specified table doesn't exist
83 | |         """
   | |___________^
84 |           # Verify table exists using backend-agnostic method
85 |           if not self.db_manager.table_exists(table_name):
   |
help: Add closing punctuation

D410 [*] Missing blank line after section ("Args")
  --> services\database_viewer_service.py:77:9
   |
75 |         """
76 |         Get schema information for the specified table.
77 |         Args:
   |         ^^^^
78 |             table_name: The name of the table to get schema for
79 |         Returns:
   |
help: Add blank line after "Args"

D411 [*] Missing blank line before section ("Args")
  --> services\database_viewer_service.py:77:9
   |
75 |         """
76 |         Get schema information for the specified table.
77 |         Args:
   |         ^^^^
78 |             table_name: The name of the table to get schema for
79 |         Returns:
   |
help: Add blank line before "Args"

D411 [*] Missing blank line before section ("Raises")
  --> services\database_viewer_service.py:81:9
   |
79 |         Returns:
80 |             A list of column definitions with name, type, etc.
81 |         Raises:
   |         ^^^^^^
82 |             TableNotFoundError: If the specified table doesn't exist
83 |         """
   |
help: Add blank line before "Raises"

D212 [*] Multi-line docstring summary should start at the first line
   --> services\database_viewer_service.py:140:9
    |
138 |           filter_value: Optional[str] = None,
139 |       ) -> Dict[str, Any]:
140 | /         """
141 | |         Fetch table data with pagination, sorting, and filtering.
142 | |
143 | |         Args:
144 | |             table_name: Name of the table to query
145 | |             page: Page number (1-based)
146 | |             page_size: Number of rows per page
147 | |             sort_by: Column to sort by
148 | |             sort_order: Sort direction ('asc' or 'desc')
149 | |             filter_column: Column to filter on
150 | |             filter_value: Value to filter by (uses LIKE %value%)
151 | |
152 | |         Returns:
153 | |             Dict containing columns, rows, pagination info, etc.
154 | |
155 | |         Raises:
156 | |             TableNotFoundError: If table doesn't exist
157 | |             InvalidParameterError: If invalid parameters are provided
158 | |         """
    | |___________^
159 |           # Input validation
160 |           if page < 1:
    |
help: Remove whitespace after opening quotes

D212 [*] Multi-line docstring summary should start at the first line
   --> services\database_viewer_service.py:260:9
    |
258 |           filter_value: Optional[str] = None,
259 |       ) -> None:
260 | /         """
261 | |         Export the table data to CSV format.
262 | |
263 | |         Args:
264 | |             table_name: Name of the table to export
265 | |             output_file: File path or file-like object to write CSV to
266 | |             filter_column: Optional column to filter on
267 | |             filter_value: Optional value to filter by
268 | |
269 | |         Raises:
270 | |             TableNotFoundError: If table doesn't exist
271 | |             InvalidParameterError: If invalid parameters are provided
272 | |         """
    | |___________^
273 |           # Get table data without pagination to export all rows
274 |           table_data = self.get_table_data(
    |
help: Remove whitespace after opening quotes

D100 Missing docstring in public module
--> services\library_service.py:1:1

D101 Missing docstring in public class
  --> services\library_service.py:15:7
   |
15 | class ValidationError(Exception):
   |       ^^^^^^^^^^^^^^^
16 |     pass
   |

D101 Missing docstring in public class
  --> services\library_service.py:23:7
   |
23 | class Category(Base):
   |       ^^^^^^^^
24 |     __tablename__ = "categories"
25 |     category_id = Column(Integer, primary_key=True, autoincrement=True)
   |

D101 Missing docstring in public class
  --> services\library_service.py:32:7
   |
32 | class Snippet(Base):
   |       ^^^^^^^
33 |     __tablename__ = "snippets"
34 |     snippet_id = Column(Integer, primary_key=True, autoincrement=True)
   |

D101 Missing docstring in public class
  --> services\library_service.py:44:7
   |
44 | class LibraryService:
   |       ^^^^^^^^^^^^^^
45 |     metadata = metadata
   |

ANN204 Missing return type annotation for special method `__init__`
  --> services\library_service.py:47:9
   |
45 |     metadata = metadata
46 |
47 |     def __init__(self, session):
   |         ^^^^^^^^
48 |         self.session = session
   |
help: Add return type annotation: `None`

D107 Missing docstring in `__init__`
  --> services\library_service.py:47:9
   |
45 |     metadata = metadata
46 |
47 |     def __init__(self, session):
   |         ^^^^^^^^
48 |         self.session = session
   |

ANN001 Missing type annotation for function argument `session`
  --> services\library_service.py:47:24
   |
45 |     metadata = metadata
46 |
47 |     def __init__(self, session):
   |                        ^^^^^^^
48 |         self.session = session
   |

ANN201 Missing return type annotation for public function `add_category`
  --> services\library_service.py:51:9
   |
50 |     # Category methods
51 |     def add_category(self, name):
   |         ^^^^^^^^^^^^
52 |         if not name or len(name) > 50 or not name.isascii():
53 |             raise ValidationError("Invalid category name")
   |
help: Add return type annotation

D102 Missing docstring in public method
  --> services\library_service.py:51:9
   |
50 |     # Category methods
51 |     def add_category(self, name):
   |         ^^^^^^^^^^^^
52 |         if not name or len(name) > 50 or not name.isascii():
53 |             raise ValidationError("Invalid category name")
   |

ANN001 Missing type annotation for function argument `name`
  --> services\library_service.py:51:28
   |
50 |     # Category methods
51 |     def add_category(self, name):
   |                            ^^^^
52 |         if not name or len(name) > 50 or not name.isascii():
53 |             raise ValidationError("Invalid category name")
   |

ANN201 Missing return type annotation for public function `get_categories`
  --> services\library_service.py:60:9
   |
58 |         return cat
59 |
60 |     def get_categories(self):
   |         ^^^^^^^^^^^^^^
61 |         return self.session.query(Category).all()
   |
help: Add return type annotation

D102 Missing docstring in public method
  --> services\library_service.py:60:9
   |
58 |         return cat
59 |
60 |     def get_categories(self):
   |         ^^^^^^^^^^^^^^
61 |         return self.session.query(Category).all()
   |

ANN201 Missing return type annotation for public function `edit_category`
  --> services\library_service.py:63:9
   |
61 |         return self.session.query(Category).all()
62 |
63 |     def edit_category(self, category_id, new_name):
   |         ^^^^^^^^^^^^^
64 |         if not new_name or len(new_name) > 50 or not new_name.isascii():
65 |             raise ValidationError("Invalid category name")
   |
help: Add return type annotation

D102 Missing docstring in public method
  --> services\library_service.py:63:9
   |
61 |         return self.session.query(Category).all()
62 |
63 |     def edit_category(self, category_id, new_name):
   |         ^^^^^^^^^^^^^
64 |         if not new_name or len(new_name) > 50 or not new_name.isascii():
65 |             raise ValidationError("Invalid category name")
   |

ANN001 Missing type annotation for function argument `category_id`
  --> services\library_service.py:63:29
   |
61 |         return self.session.query(Category).all()
62 |
63 |     def edit_category(self, category_id, new_name):
   |                             ^^^^^^^^^^^
64 |         if not new_name or len(new_name) > 50 or not new_name.isascii():
65 |             raise ValidationError("Invalid category name")
   |

ANN001 Missing type annotation for function argument `new_name`
  --> services\library_service.py:63:42
   |
61 |         return self.session.query(Category).all()
62 |
63 |     def edit_category(self, category_id, new_name):
   |                                          ^^^^^^^^
64 |         if not new_name or len(new_name) > 50 or not new_name.isascii():
65 |             raise ValidationError("Invalid category name")
   |

ANN201 Missing return type annotation for public function `delete_category`
  --> services\library_service.py:78:9
   |
76 |         return cat
77 |
78 |     def delete_category(self, category_id):
   |         ^^^^^^^^^^^^^^^
79 |         cat = self.session.query(Category).filter_by(category_id=category_id).first()
80 |         if not cat:
   |
help: Add return type annotation: `None`

D102 Missing docstring in public method
  --> services\library_service.py:78:9
   |
76 |         return cat
77 |
78 |     def delete_category(self, category_id):
   |         ^^^^^^^^^^^^^^^
79 |         cat = self.session.query(Category).filter_by(category_id=category_id).first()
80 |         if not cat:
   |

ANN001 Missing type annotation for function argument `category_id`
  --> services\library_service.py:78:31
   |
76 |         return cat
77 |
78 |     def delete_category(self, category_id):
   |                               ^^^^^^^^^^^
79 |         cat = self.session.query(Category).filter_by(category_id=category_id).first()
80 |         if not cat:
   |

ANN201 Missing return type annotation for public function `add_snippet`
  --> services\library_service.py:85:9
   |
84 |     # Snippet methods
85 |     def add_snippet(self, category_id, name, content):
   |         ^^^^^^^^^^^
86 |         if not name or len(name) > 50 or not name.isascii():
87 |             raise ValidationError("Invalid snippet name")
   |
help: Add return type annotation

D102 Missing docstring in public method
  --> services\library_service.py:85:9
   |
84 |     # Snippet methods
85 |     def add_snippet(self, category_id, name, content):
   |         ^^^^^^^^^^^
86 |         if not name or len(name) > 50 or not name.isascii():
87 |             raise ValidationError("Invalid snippet name")
   |

ANN001 Missing type annotation for function argument `category_id`
  --> services\library_service.py:85:27
   |
84 |     # Snippet methods
85 |     def add_snippet(self, category_id, name, content):
   |                           ^^^^^^^^^^^
86 |         if not name or len(name) > 50 or not name.isascii():
87 |             raise ValidationError("Invalid snippet name")
   |

ANN001 Missing type annotation for function argument `name`
  --> services\library_service.py:85:40
   |
84 |     # Snippet methods
85 |     def add_snippet(self, category_id, name, content):
   |                                        ^^^^
86 |         if not name or len(name) > 50 or not name.isascii():
87 |             raise ValidationError("Invalid snippet name")
   |

ANN001 Missing type annotation for function argument `content`
  --> services\library_service.py:85:46
   |
84 |     # Snippet methods
85 |     def add_snippet(self, category_id, name, content):
   |                                              ^^^^^^^
86 |         if not name or len(name) > 50 or not name.isascii():
87 |             raise ValidationError("Invalid snippet name")
   |

ANN201 Missing return type annotation for public function `get_snippets`
   --> services\library_service.py:100:9
    |
 98 |         return snip
 99 |
100 |     def get_snippets(self, category_id):
    |         ^^^^^^^^^^^^
101 |         return self.session.query(Snippet).filter_by(category_id=category_id).all()
    |
help: Add return type annotation

D102 Missing docstring in public method
   --> services\library_service.py:100:9
    |
 98 |         return snip
 99 |
100 |     def get_snippets(self, category_id):
    |         ^^^^^^^^^^^^
101 |         return self.session.query(Snippet).filter_by(category_id=category_id).all()
    |

ANN001 Missing type annotation for function argument `category_id`
   --> services\library_service.py:100:28
    |
 98 |         return snip
 99 |
100 |     def get_snippets(self, category_id):
    |                            ^^^^^^^^^^^
101 |         return self.session.query(Snippet).filter_by(category_id=category_id).all()
    |

ANN201 Missing return type annotation for public function `edit_snippet`
   --> services\library_service.py:103:9
    |
101 |         return self.session.query(Snippet).filter_by(category_id=category_id).all()
102 |
103 |     def edit_snippet(self, snippet_id, new_name, new_content, new_category_id=None):
    |         ^^^^^^^^^^^^
104 |         if not new_name or len(new_name) > 50 or not new_name.isascii():
105 |             raise ValidationError("Invalid snippet name")
    |
help: Add return type annotation

D102 Missing docstring in public method
   --> services\library_service.py:103:9
    |
101 |         return self.session.query(Snippet).filter_by(category_id=category_id).all()
102 |
103 |     def edit_snippet(self, snippet_id, new_name, new_content, new_category_id=None):
    |         ^^^^^^^^^^^^
104 |         if not new_name or len(new_name) > 50 or not new_name.isascii():
105 |             raise ValidationError("Invalid snippet name")
    |

ANN001 Missing type annotation for function argument `snippet_id`
   --> services\library_service.py:103:28
    |
101 |         return self.session.query(Snippet).filter_by(category_id=category_id).all()
102 |
103 |     def edit_snippet(self, snippet_id, new_name, new_content, new_category_id=None):
    |                            ^^^^^^^^^^
104 |         if not new_name or len(new_name) > 50 or not new_name.isascii():
105 |             raise ValidationError("Invalid snippet name")
    |

ANN001 Missing type annotation for function argument `new_name`
   --> services\library_service.py:103:40
    |
101 |         return self.session.query(Snippet).filter_by(category_id=category_id).all()
102 |
103 |     def edit_snippet(self, snippet_id, new_name, new_content, new_category_id=None):
    |                                        ^^^^^^^^
104 |         if not new_name or len(new_name) > 50 or not new_name.isascii():
105 |             raise ValidationError("Invalid snippet name")
    |

ANN001 Missing type annotation for function argument `new_content`
   --> services\library_service.py:103:50
    |
101 |         return self.session.query(Snippet).filter_by(category_id=category_id).all()
102 |
103 |     def edit_snippet(self, snippet_id, new_name, new_content, new_category_id=None):
    |                                                  ^^^^^^^^^^^
104 |         if not new_name or len(new_name) > 50 or not new_name.isascii():
105 |             raise ValidationError("Invalid snippet name")
    |

ANN001 Missing type annotation for function argument `new_category_id`
   --> services\library_service.py:103:63
    |
101 |         return self.session.query(Snippet).filter_by(category_id=category_id).all()
102 |
103 |     def edit_snippet(self, snippet_id, new_name, new_content, new_category_id=None):
    |                                                               ^^^^^^^^^^^^^^^
104 |         if not new_name or len(new_name) > 50 or not new_name.isascii():
105 |             raise ValidationError("Invalid snippet name")
    |

ANN201 Missing return type annotation for public function `delete_snippet`
   --> services\library_service.py:129:9
    |
127 |         return snip
128 |
129 |     def delete_snippet(self, snippet_id):
    |         ^^^^^^^^^^^^^^
130 |         snip = self.session.query(Snippet).filter_by(snippet_id=snippet_id).first()
131 |         if not snip:
    |
help: Add return type annotation: `None`

D102 Missing docstring in public method
   --> services\library_service.py:129:9
    |
127 |         return snip
128 |
129 |     def delete_snippet(self, snippet_id):
    |         ^^^^^^^^^^^^^^
130 |         snip = self.session.query(Snippet).filter_by(snippet_id=snippet_id).first()
131 |         if not snip:
    |

ANN001 Missing type annotation for function argument `snippet_id`
   --> services\library_service.py:129:30
    |
127 |         return snip
128 |
129 |     def delete_snippet(self, snippet_id):
    |                              ^^^^^^^^^^
130 |         snip = self.session.query(Snippet).filter_by(snippet_id=snippet_id).first()
131 |         if not snip:
    |

D100 Missing docstring in public module
--> session_fix_script.py:1:1

D100 Missing docstring in public module
--> setup.py:1:1

D100 Missing docstring in public module
--> snippet_api.py:1:1

D100 Missing docstring in public module
--> temp_fix_script.py:1:1

D212 [*] Multi-line docstring summary should start at the first line
 --> test_debug_mode.py:2:1
  |
1 |   #!/usr/bin/env python3
2 | / """
3 | | Test script to demonstrate the debug mode functionality.
4 | |
5 | | This script shows how the debug_mode parameter controls debug output
6 | | in the AI Typing Trainer application.
7 | | """
  | |___^
8 |
9 |   import os
  |
help: Remove whitespace after opening quotes

ANN201 Missing return type annotation for public function `test_debug_mode_functionality`
  --> test_debug_mode.py:18:5
   |
18 | def test_debug_mode_functionality():
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
19 |     """Test the debug mode functionality with different settings."""
   |
help: Add return type annotation: `None`

D202 [*] No blank lines allowed after function docstring (found 1)
  --> test_debug_mode.py:19:5
   |
18 | def test_debug_mode_functionality():
19 |     """Test the debug mode functionality with different settings."""
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
20 |     
21 |     print("=== Testing Debug Mode Functionality ===\n")
   |
help: Remove blank line(s) after function docstring

ANN201 Missing return type annotation for public function `test_main_menu_integration`
  --> test_debug_mode.py:55:5
   |
55 | def test_main_menu_integration():
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^
56 |     """Test the main menu integration with debug mode."""
   |
help: Add return type annotation: `None`

D202 [*] No blank lines allowed after function docstring (found 1)
  --> test_debug_mode.py:56:5
   |
55 | def test_main_menu_integration():
56 |     """Test the main menu integration with debug mode."""
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
57 |     
58 |     print("\n=== Testing Main Menu Integration ===\n")
   |
help: Remove blank line(s) after function docstring

D200 One-line docstring should fit on one line
 --> test_debug_util_integration.py:2:1
  |
1 |   #!/usr/bin/env python3
2 | / """
3 | | Test script to verify DebugUtil integration with main_menu and DatabaseManager.
4 | | """
  | |___^
5 |
6 |   import os
  |
help: Reformat to one line

D212 [*] Multi-line docstring summary should start at the first line
 --> test_debug_util_integration.py:2:1
  |
1 |   #!/usr/bin/env python3
2 | / """
3 | | Test script to verify DebugUtil integration with main_menu and DatabaseManager.
4 | | """
  | |___^
5 |
6 |   import os
  |
help: Remove whitespace after opening quotes

ANN201 Missing return type annotation for public function `test_debug_util_standalone`
  --> test_debug_util_integration.py:19:5
   |
19 | def test_debug_util_standalone():
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^
20 |     """Test the DebugUtil class functionality standalone."""
   |
help: Add return type annotation: `None`

D202 [*] No blank lines allowed after function docstring (found 1)
  --> test_debug_util_integration.py:20:5
   |
19 | def test_debug_util_standalone():
20 |     """Test the DebugUtil class functionality standalone."""
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
21 |     
22 |     print("=== Testing DebugUtil Standalone ===\n")
   |
help: Remove blank line(s) after function docstring

ANN201 Missing return type annotation for public function `test_database_manager_integration`
  --> test_debug_util_integration.py:59:5
   |
59 | def test_database_manager_integration():
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
60 |     """Test DatabaseManager integration with DebugUtil."""
   |
help: Add return type annotation: `None`

D202 [*] No blank lines allowed after function docstring (found 1)
  --> test_debug_util_integration.py:60:5
   |
59 | def test_database_manager_integration():
60 |     """Test DatabaseManager integration with DebugUtil."""
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
61 |     
62 |     print("=== Testing DatabaseManager Integration ===\n")
   |
help: Remove blank line(s) after function docstring

E722 Do not use bare `except`
   --> test_debug_util_integration.py:106:9
    |
104 |         try:
105 |             os.unlink(temp_db_path)
106 |         except:
    |         ^^^^^^
107 |             pass
    |

E722 Do not use bare `except`
   --> test_debug_util_integration.py:135:9
    |
133 |         try:
134 |             os.unlink(temp_db_path)
135 |         except:
    |         ^^^^^^
136 |             pass
    |

ANN201 Missing return type annotation for public function `test_fallback_behavior`
   --> test_debug_util_integration.py:141:5
    |
141 | def test_fallback_behavior():
    |     ^^^^^^^^^^^^^^^^^^^^^^
142 |     """Test fallback behavior when DebugUtil is not provided."""
    |
help: Add return type annotation: `None`

D202 [*] No blank lines allowed after function docstring (found 1)
   --> test_debug_util_integration.py:142:5
    |
141 | def test_fallback_behavior():
142 |     """Test fallback behavior when DebugUtil is not provided."""
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
143 |     
144 |     print("=== Testing Fallback Behavior ===\n")
    |
help: Remove blank line(s) after function docstring

E722 Do not use bare `except`
   --> test_debug_util_integration.py:174:9
    |
172 |         try:
173 |             os.unlink(temp_db_path)
174 |         except:
    |         ^^^^^^
175 |             pass
    |

D200 One-line docstring should fit on one line
 --> test_main_menu_args.py:2:1
  |
1 |   #!/usr/bin/env python3
2 | / """
3 | | Test script to verify command line argument parsing in main_menu.py
4 | | """
  | |___^
5 |
6 |   import os
  |
help: Reformat to one line

D212 [*] Multi-line docstring summary should start at the first line
 --> test_main_menu_args.py:2:1
  |
1 |   #!/usr/bin/env python3
2 | / """
3 | | Test script to verify command line argument parsing in main_menu.py
4 | | """
  | |___^
5 |
6 |   import os
  |
help: Remove whitespace after opening quotes

D415 First line should end with a period, question mark, or exclamation point
 --> test_main_menu_args.py:2:1
  |
1 |   #!/usr/bin/env python3
2 | / """
3 | | Test script to verify command line argument parsing in main_menu.py
4 | | """
  | |___^
5 |
6 |   import os
  |
help: Add closing punctuation

ANN201 Missing return type annotation for public function `test_argument_parsing`
  --> test_main_menu_args.py:12:5
   |
10 | sys.path.insert(0, os.path.dirname(__file__))
11 |
12 | def test_argument_parsing():
   |     ^^^^^^^^^^^^^^^^^^^^^
13 |     """Test the command line argument parsing logic from main_menu.py"""
   |
help: Add return type annotation: `None`

D202 [*] No blank lines allowed after function docstring (found 1)
  --> test_main_menu_args.py:13:5
   |
12 | def test_argument_parsing():
13 |     """Test the command line argument parsing logic from main_menu.py"""
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
14 |     
15 |     print("=== Testing Main Menu Command Line Argument Parsing ===\n")
   |
help: Remove blank line(s) after function docstring

D415 First line should end with a period, question mark, or exclamation point
  --> test_main_menu_args.py:13:5
   |
12 | def test_argument_parsing():
13 |     """Test the command line argument parsing logic from main_menu.py"""
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
14 |     
15 |     print("=== Testing Main Menu Command Line Argument Parsing ===\n")
   |
help: Add closing punctuation

D104 Missing docstring in public package
--> tests\__init__.py:1:1

D200 One-line docstring should fit on one line
 --> tests\conftest.py:1:1
  |
1 | / """
2 | | Pytest configuration for the test suite.
3 | | """
  | |___^
4 |   # Standard library imports
5 |   import os
  |
help: Reformat to one line

D212 [*] Multi-line docstring summary should start at the first line
 --> tests\conftest.py:1:1
  |
1 | / """
2 | | Pytest configuration for the test suite.
3 | | """
  | |___^
4 |   # Standard library imports
5 |   import os
  |
help: Remove whitespace after opening quotes

D200 One-line docstring should fit on one line
 --> tests\db\__init__.py:1:1
  |
1 | / """
2 | | Test package for database-related tests.
3 | | """
  | |___^
  |
help: Reformat to one line

D212 [*] Multi-line docstring summary should start at the first line
 --> tests\db\__init__.py:1:1
  |
1 | / """
2 | | Test package for database-related tests.
3 | | """
  | |___^
  |
help: Remove whitespace after opening quotes

D212 [*] Multi-line docstring summary should start at the first line
 --> tests\db\conftest.py:1:1
  |
1 | / """
2 | | Pytest configuration for database tests.
3 | |
4 | | This file imports fixtures from the db_helpers module to make them available to all
5 | | test files in the db directory without explicit imports.
6 | | """
  | |___^
  |
help: Remove whitespace after opening quotes

D200 One-line docstring should fit on one line
 --> tests\db\test_database_exceptions.py:1:1
  |
1 | / """
2 | | Tests for database exception handling in DatabaseManager.
3 | | """
  | |___^
4 |
5 |   import pytest
  |
help: Reformat to one line

D212 [*] Multi-line docstring summary should start at the first line
 --> tests\db\test_database_exceptions.py:1:1
  |
1 | / """
2 | | Tests for database exception handling in DatabaseManager.
3 | | """
  | |___^
4 |
5 |   import pytest
  |
help: Remove whitespace after opening quotes

D212 [*] Multi-line docstring summary should start at the first line
 --> tests\db\test_database_manager.py:1:1
  |
1 | / """
2 | | Tests for the DatabaseManager class.
3 | |
4 | | This module contains comprehensive tests for the DatabaseManager class,
5 | | verifying its functionality, error handling, and edge cases.
6 | | """
  | |___^
7 |
8 |   import os
  |
help: Remove whitespace after opening quotes

D212 [*] Multi-line docstring summary should start at the first line
  --> tests\db\test_database_manager.py:43:5
   |
41 |   @pytest.fixture(scope="function")
42 |   def temp_db_path() -> Generator[str, None, None]:
43 | /     """
44 | |     Create a temporary database file for testing.
45 | |
46 | |     Yields:
47 | |         str: Path to the temporary database file
48 | |
49 | |     The database file is automatically deleted after the test completes.
50 | |     """
   | |_______^
51 |       with tempfile.NamedTemporaryFile(delete=False, suffix=".db") as tmp:
52 |           db_path = tmp.name
   |
help: Remove whitespace after opening quotes

D212 [*] Multi-line docstring summary should start at the first line
  --> tests\db\test_database_manager.py:65:5
   |
63 |   @pytest.fixture(scope="function")
64 |   def db_manager(temp_db_path: str) -> DatabaseManager:
65 | /     """
66 | |     Create a DatabaseManager instance with a temporary database.
67 | |
68 | |     Args:
69 | |         temp_db_path: Path to the temporary database file
70 | |
71 | |     Returns:
72 | |         DatabaseManager: A new DatabaseManager instance
73 | |     """
   | |_______^
74 |       return DatabaseManager(temp_db_path)
   |
help: Remove whitespace after opening quotes

D212 [*] Multi-line docstring summary should start at the first line
  --> tests\db\test_database_manager.py:79:5
   |
77 |   @pytest.fixture(scope="function")
78 |   def initialized_db(db_manager: DatabaseManager) -> DatabaseManager:
79 | /     """
80 | |     Create a database with a test table and sample data.
81 | |
82 | |     Args:
83 | |         db_manager: DatabaseManager instance
84 | |
85 | |     Returns:
86 | |         DatabaseManager: The same DatabaseManager instance with test data
87 | |     """
   | |_______^
88 |       # Create a test table
89 |       db_manager.execute(
   |
help: Remove whitespace after opening quotes

D102 Missing docstring in public method
   --> tests\db\test_database_manager.py:293:9
    |
292 |     @pytest.fixture()
293 |     def sqlite_db(self, temp_db_path: str) -> Generator[DatabaseManager, None, None]:
    |         ^^^^^^^^^
294 |         with DatabaseManager(temp_db_path) as db:
295 |             self._drop_table(db)
    |

D102 Missing docstring in public method
   --> tests\db\test_database_manager.py:308:9
    |
307 |     @pytest.fixture()
308 |     def cloud_db(self) -> Generator[DatabaseManager, None, None]:
    |         ^^^^^^^^
309 |         if not self._cloud_available():
310 |             pytest.skip("Cloud DB tests disabled or dependencies unavailable")
    |

D102 Missing docstring in public method
   --> tests\db\test_database_manager.py:319:9
    |
317 |     # -------- SQLite positive and error scenarios --------
318 |
319 |     def test_execute_many_insert_success_sqlite(self, sqlite_db: DatabaseManager) -> None:
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
320 |         rows = [
321 |             (1, "Alice", 12.5, "2025-08-09T07:21:55-04:00", "a@example.com", 1),
    |

D102 Missing docstring in public method
   --> tests\db\test_database_manager.py:334:9
    |
332 |         assert [tuple(r.values()) for r in results] == rows
333 |
334 |     def test_execute_many_pk_violation_sqlite(self, sqlite_db: DatabaseManager) -> None:
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
335 |         sqlite_db.execute_many(
336 |             f"INSERT INTO {self.TEST_TABLE} (id, name) VALUES (?, ?)",
    |

D102 Missing docstring in public method
   --> tests\db\test_database_manager.py:345:9
    |
343 |             )
344 |
345 |     def test_execute_many_unique_violation_sqlite(self, sqlite_db: DatabaseManager) -> None:
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
346 |         sqlite_db.execute_many(
347 |             f"INSERT INTO {self.TEST_TABLE} (id, name, email) VALUES (?, ?, ?)",
    |

D102 Missing docstring in public method
   --> tests\db\test_database_manager.py:356:9
    |
354 |             )
355 |
356 |     def test_execute_many_not_null_violation_sqlite(self, sqlite_db: DatabaseManager) -> None:
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
357 |         with pytest.raises(ConstraintError):
358 |             sqlite_db.execute_many(
    |

D102 Missing docstring in public method
   --> tests\db\test_database_manager.py:363:9
    |
361 |             )
362 |
363 |     def test_execute_many_table_not_found_sqlite(self, sqlite_db: DatabaseManager) -> None:
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
364 |         with pytest.raises(TableNotFoundError):
365 |             sqlite_db.execute_many(
    |

D102 Missing docstring in public method
   --> tests\db\test_database_manager.py:372:9
    |
370 |     # -------- Cloud (Postgres) scenarios, conditional --------
371 |
372 |     def test_execute_many_insert_success_cloud(self, cloud_db: DatabaseManager) -> None:
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
373 |         rows = [
374 |             (100, "P-Alice", 1.25, "2025-08-09T07:21:55Z", "pa@example.com", 1),
    |

D102 Missing docstring in public method
   --> tests\db\test_database_manager.py:401:9
    |
399 |         assert got == exp
400 |
401 |     def test_execute_many_method_options_sqlite(self, sqlite_db: DatabaseManager) -> None:
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
402 |         rows = [
403 |             (11, "M1", 1.0, None, None, None),
    |

D102 Missing docstring in public method
   --> tests\db\test_database_manager.py:442:9
    |
440 |         ],
441 |     )
442 |     def test_execute_many_method_options_cloud(
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
443 |         self, cloud_db: DatabaseManager, method: BulkMethod, base_id: int, rows: list[tuple]
444 |     ) -> None:
    |

D102 Missing docstring in public method
   --> tests\db\test_database_manager.py:466:9
    |
464 |         assert [r["id"] for r in results] == ids
465 |
466 |     def test_postgres_bulk_insert_performance(self, cloud_db: DatabaseManager, capsys: Any) -> None:
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
467 |         import time
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `capsys`
   --> tests\db\test_database_manager.py:466:88
    |
464 |         assert [r["id"] for r in results] == ids
465 |
466 |     def test_postgres_bulk_insert_performance(self, cloud_db: DatabaseManager, capsys: Any) -> None:
    |                                                                                        ^^^
467 |         import time
    |

D102 Missing docstring in public method
   --> tests\db\test_database_manager.py:499:9
    |
497 |         assert "ms total" in captured.out
498 |
499 |     def test_execute_many_pk_violation_cloud(self, cloud_db: DatabaseManager) -> None:
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
500 |         cloud_db.execute_many(
501 |             f"INSERT INTO {self.TEST_TABLE} (id, name) VALUES (?, ?)",
    |

D102 Missing docstring in public method
   --> tests\db\test_database_manager.py:510:9
    |
508 |             )
509 |
510 |     def test_execute_many_unique_violation_cloud(self, cloud_db: DatabaseManager) -> None:
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
511 |         cloud_db.execute_many(
512 |             f"INSERT INTO {self.TEST_TABLE} (id, name, email) VALUES (?, ?, ?)",
    |

D102 Missing docstring in public method
   --> tests\db\test_database_manager.py:521:9
    |
519 |             )
520 |
521 |     def test_execute_many_not_null_violation_cloud(self, cloud_db: DatabaseManager) -> None:
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
522 |         with pytest.raises(ConstraintError):
523 |             cloud_db.execute_many(
    |

D102 Missing docstring in public method
   --> tests\db\test_database_manager.py:532:9
    |
530 |     """Explicit unit tests for execute_many helper methods and schema qualifier."""
531 |
532 |     def test__bulk_executemany_sqlite_inserts(self, db_manager: DatabaseManager) -> None:
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
533 |         # Arrange: create table
534 |         db_manager.execute(
    |

D102 Missing docstring in public method
   --> tests\db\test_database_manager.py:552:9
    |
550 |         assert [tuple(r.values()) for r in got] == rows
551 |
552 |     def test__bulk_execute_values_calls_psycopg2_extras(
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
553 |         self,
554 |         db_manager: DatabaseManager,
    |

D102 Missing docstring in public method
   --> tests\db\test_database_manager.py:613:9
    |
611 |             )
612 |
613 |     def test__bulk_copy_from_builds_tsv_and_calls_copy(self, db_manager: DatabaseManager) -> None:
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
614 |         # Arrange fake cursor to capture copy_from inputs
615 |         captured = {"table": None, "columns": None, "content": None}
    |

E501 Line too long (143 > 120)
   --> tests\db\test_database_manager.py:657:121
    |
655 | oo WHERE id=%s"),
656 | 
657 | s WHERE table_schema = %s AND table_type = 'BASE TABLE' ORDER BY table_name",
    |                                                        ^^^^^^^^^^^^^^^^^^^^^^^
658 | s WHERE table_schema = typing AND table_type = 'BASE TABLE' ORDER BY table_name",
659 | 
    |

E501 Line too long (147 > 120)
   --> tests\db\test_database_manager.py:658:121
    |
656 | 
657 | WHERE table_schema = %s AND table_type = 'BASE TABLE' ORDER BY table_name",
658 | WHERE table_schema = typing AND table_type = 'BASE TABLE' ORDER BY table_name",
    |                                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^
659 | 
660 | .foo WHERE id=%s"),
    |

D104 Missing docstring in public package
--> tests\desktop_ui\__init__.py:1:1

D200 One-line docstring should fit on one line
 --> tests\desktop_ui\conftest.py:1:1
  |
1 | / """
2 | | Pytest configuration and fixtures for desktop_ui tests.
3 | | """
  | |___^
4 |   import os
5 |   import tempfile
  |
help: Reformat to one line

D212 [*] Multi-line docstring summary should start at the first line
 --> tests\desktop_ui\conftest.py:1:1
  |
1 | / """
2 | | Pytest configuration and fixtures for desktop_ui tests.
3 | | """
  | |___^
4 |   import os
5 |   import tempfile
  |
help: Remove whitespace after opening quotes

D212 [*] Multi-line docstring summary should start at the first line
   --> tests\desktop_ui\conftest.py:118:5
    |
116 |   @pytest.fixture(scope="session")
117 |   def app() -> Generator[QApplication, None, None]:
118 | /     """
119 | |     Fixture providing a QApplication instance for GUI tests.
120 | |
121 | |     Yields:
122 | |         QApplication: The application instance
123 | |     """
    | |_______^
124 |       app = QApplication.instance()
125 |       if app is None:
    |
help: Remove whitespace after opening quotes

D200 One-line docstring should fit on one line
 --> tests\desktop_ui\test_db_viewer_dialog.py:1:1
  |
1 | / """
2 | | Tests for the Database Viewer Dialog UI component.
3 | | """
  | |___^
4 |
5 |   import os
  |
help: Reformat to one line

D212 [*] Multi-line docstring summary should start at the first line
 --> tests\desktop_ui\test_db_viewer_dialog.py:1:1
  |
1 | / """
2 | | Tests for the Database Viewer Dialog UI component.
3 | | """
  | |___^
4 |
5 |   import os
  |
help: Remove whitespace after opening quotes

ANN201 Missing return type annotation for public function `qtapp`
  --> tests\desktop_ui\test_db_viewer_dialog.py:22:5
   |
21 | @pytest.fixture
22 | def qtapp():
   |     ^^^^^
23 |     """Create a QApplication instance for testing.
24 |     This avoids conflicts with pytest-flask by creating a dedicated QApplication for Qt tests.
   |
help: Add return type annotation

D205 1 blank line required between summary line and description
  --> tests\desktop_ui\test_db_viewer_dialog.py:23:5
   |
21 |   @pytest.fixture
22 |   def qtapp():
23 | /     """Create a QApplication instance for testing.
24 | |     This avoids conflicts with pytest-flask by creating a dedicated QApplication for Qt tests.
25 | |     """
   | |_______^
26 |       app = QApplication.instance()
27 |       if app is None:
   |
help: Insert single blank line

ANN204 Missing return type annotation for special method `__init__`
  --> tests\desktop_ui\test_db_viewer_dialog.py:35:9
   |
33 |     """Simple QtBot class to replace pytest-qt's qtbot when it's not available."""
34 |
35 |     def __init__(self, app):
   |         ^^^^^^^^
36 |         self.app = app
37 |         self.widgets = []
   |
help: Add return type annotation: `None`

D107 Missing docstring in `__init__`
  --> tests\desktop_ui\test_db_viewer_dialog.py:35:9
   |
33 |     """Simple QtBot class to replace pytest-qt's qtbot when it's not available."""
34 |
35 |     def __init__(self, app):
   |         ^^^^^^^^
36 |         self.app = app
37 |         self.widgets = []
   |

ANN001 Missing type annotation for function argument `app`
  --> tests\desktop_ui\test_db_viewer_dialog.py:35:24
   |
33 |     """Simple QtBot class to replace pytest-qt's qtbot when it's not available."""
34 |
35 |     def __init__(self, app):
   |                        ^^^
36 |         self.app = app
37 |         self.widgets = []
   |

ANN201 Missing return type annotation for public function `addWidget`
  --> tests\desktop_ui\test_db_viewer_dialog.py:39:9
   |
37 |         self.widgets = []
38 |
39 |     def addWidget(self, widget):
   |         ^^^^^^^^^
40 |         """Keep track of widgets to ensure they don't get garbage collected."""
41 |         self.widgets.append(widget)
   |
help: Add return type annotation

ANN001 Missing type annotation for function argument `widget`
  --> tests\desktop_ui\test_db_viewer_dialog.py:39:25
   |
37 |         self.widgets = []
38 |
39 |     def addWidget(self, widget):
   |                         ^^^^^^
40 |         """Keep track of widgets to ensure they don't get garbage collected."""
41 |         self.widgets.append(widget)
   |

ANN201 Missing return type annotation for public function `mouseClick`
  --> tests\desktop_ui\test_db_viewer_dialog.py:44:9
   |
42 |         return widget
43 |
44 |     def mouseClick(self, widget, button=Qt.LeftButton, pos=None):
   |         ^^^^^^^^^^
45 |         """Simulate mouse click."""
46 |         if pos is None:
   |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `widget`
  --> tests\desktop_ui\test_db_viewer_dialog.py:44:26
   |
42 |         return widget
43 |
44 |     def mouseClick(self, widget, button=Qt.LeftButton, pos=None):
   |                          ^^^^^^
45 |         """Simulate mouse click."""
46 |         if pos is None:
   |

ANN001 Missing type annotation for function argument `button`
  --> tests\desktop_ui\test_db_viewer_dialog.py:44:34
   |
42 |         return widget
43 |
44 |     def mouseClick(self, widget, button=Qt.LeftButton, pos=None):
   |                                  ^^^^^^
45 |         """Simulate mouse click."""
46 |         if pos is None:
   |

ANN001 Missing type annotation for function argument `pos`
  --> tests\desktop_ui\test_db_viewer_dialog.py:44:56
   |
42 |         return widget
43 |
44 |     def mouseClick(self, widget, button=Qt.LeftButton, pos=None):
   |                                                        ^^^
45 |         """Simulate mouse click."""
46 |         if pos is None:
   |

ANN201 Missing return type annotation for public function `qtbot`
  --> tests\desktop_ui\test_db_viewer_dialog.py:57:5
   |
56 | @pytest.fixture
57 | def qtbot(qtapp):
   |     ^^^^^
58 |     """Create a QtBot instance for testing when pytest-qt's qtbot isn't available."""
59 |     return QtBot(qtapp)
   |
help: Add return type annotation

ANN001 Missing type annotation for function argument `qtapp`
  --> tests\desktop_ui\test_db_viewer_dialog.py:57:11
   |
56 | @pytest.fixture
57 | def qtbot(qtapp):
   |           ^^^^^
58 |     """Create a QtBot instance for testing when pytest-qt's qtbot isn't available."""
59 |     return QtBot(qtapp)
   |

ANN201 Missing return type annotation for public function `mock_db_viewer_service`
  --> tests\desktop_ui\test_db_viewer_dialog.py:63:5
   |
62 | @pytest.fixture
63 | def mock_db_viewer_service():
   |     ^^^^^^^^^^^^^^^^^^^^^^
64 |     """Create a mock DatabaseViewerService for testing."""
65 |     service = MagicMock(spec=DatabaseViewerService)
   |
help: Add return type annotation

ANN201 Missing return type annotation for public function `test_db_viewer_dialog_initialization`
  --> tests\desktop_ui\test_db_viewer_dialog.py:85:5
   |
85 | def test_db_viewer_dialog_initialization(qtapp, mock_db_viewer_service, qtbot):
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
86 |     """Test that the DatabaseViewerDialog initializes correctly."""
87 |     # Setup mock for table data with more complete structure
   |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `qtapp`
  --> tests\desktop_ui\test_db_viewer_dialog.py:85:42
   |
85 | def test_db_viewer_dialog_initialization(qtapp, mock_db_viewer_service, qtbot):
   |                                          ^^^^^
86 |     """Test that the DatabaseViewerDialog initializes correctly."""
87 |     # Setup mock for table data with more complete structure
   |

ANN001 Missing type annotation for function argument `mock_db_viewer_service`
  --> tests\desktop_ui\test_db_viewer_dialog.py:85:49
   |
85 | def test_db_viewer_dialog_initialization(qtapp, mock_db_viewer_service, qtbot):
   |                                                 ^^^^^^^^^^^^^^^^^^^^^^
86 |     """Test that the DatabaseViewerDialog initializes correctly."""
87 |     # Setup mock for table data with more complete structure
   |

ANN001 Missing type annotation for function argument `qtbot`
  --> tests\desktop_ui\test_db_viewer_dialog.py:85:73
   |
85 | def test_db_viewer_dialog_initialization(qtapp, mock_db_viewer_service, qtbot):
   |                                                                         ^^^^^
86 |     """Test that the DatabaseViewerDialog initializes correctly."""
87 |     # Setup mock for table data with more complete structure
   |

ANN201 Missing return type annotation for public function `test_table_selection`
   --> tests\desktop_ui\test_db_viewer_dialog.py:137:5
    |
137 | def test_table_selection(qtapp, mock_db_viewer_service, qtbot):
    |     ^^^^^^^^^^^^^^^^^^^^
138 |     """Test that selecting a table loads its data."""
139 |     dialog = DatabaseViewerDialog(service=mock_db_viewer_service)
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `qtapp`
   --> tests\desktop_ui\test_db_viewer_dialog.py:137:26
    |
137 | def test_table_selection(qtapp, mock_db_viewer_service, qtbot):
    |                          ^^^^^
138 |     """Test that selecting a table loads its data."""
139 |     dialog = DatabaseViewerDialog(service=mock_db_viewer_service)
    |

ANN001 Missing type annotation for function argument `mock_db_viewer_service`
   --> tests\desktop_ui\test_db_viewer_dialog.py:137:33
    |
137 | def test_table_selection(qtapp, mock_db_viewer_service, qtbot):
    |                                 ^^^^^^^^^^^^^^^^^^^^^^
138 |     """Test that selecting a table loads its data."""
139 |     dialog = DatabaseViewerDialog(service=mock_db_viewer_service)
    |

ANN001 Missing type annotation for function argument `qtbot`
   --> tests\desktop_ui\test_db_viewer_dialog.py:137:57
    |
137 | def test_table_selection(qtapp, mock_db_viewer_service, qtbot):
    |                                                         ^^^^^
138 |     """Test that selecting a table loads its data."""
139 |     dialog = DatabaseViewerDialog(service=mock_db_viewer_service)
    |

ANN201 Missing return type annotation for public function `test_pagination`
   --> tests\desktop_ui\test_db_viewer_dialog.py:184:5
    |
184 | def test_pagination(qtapp, mock_db_viewer_service, qtbot):
    |     ^^^^^^^^^^^^^^^
185 |     """Test pagination controls."""
186 |     # First prepare the mock to return pagination data
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `qtapp`
   --> tests\desktop_ui\test_db_viewer_dialog.py:184:21
    |
184 | def test_pagination(qtapp, mock_db_viewer_service, qtbot):
    |                     ^^^^^
185 |     """Test pagination controls."""
186 |     # First prepare the mock to return pagination data
    |

ANN001 Missing type annotation for function argument `mock_db_viewer_service`
   --> tests\desktop_ui\test_db_viewer_dialog.py:184:28
    |
184 | def test_pagination(qtapp, mock_db_viewer_service, qtbot):
    |                            ^^^^^^^^^^^^^^^^^^^^^^
185 |     """Test pagination controls."""
186 |     # First prepare the mock to return pagination data
    |

ANN001 Missing type annotation for function argument `qtbot`
   --> tests\desktop_ui\test_db_viewer_dialog.py:184:52
    |
184 | def test_pagination(qtapp, mock_db_viewer_service, qtbot):
    |                                                    ^^^^^
185 |     """Test pagination controls."""
186 |     # First prepare the mock to return pagination data
    |

ANN201 Missing return type annotation for public function `test_sorting`
   --> tests\desktop_ui\test_db_viewer_dialog.py:241:5
    |
241 | def test_sorting(qtapp, mock_db_viewer_service, qtbot):
    |     ^^^^^^^^^^^^
242 |     """Test column sorting."""
243 |     dialog = DatabaseViewerDialog(service=mock_db_viewer_service)
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `qtapp`
   --> tests\desktop_ui\test_db_viewer_dialog.py:241:18
    |
241 | def test_sorting(qtapp, mock_db_viewer_service, qtbot):
    |                  ^^^^^
242 |     """Test column sorting."""
243 |     dialog = DatabaseViewerDialog(service=mock_db_viewer_service)
    |

ANN001 Missing type annotation for function argument `mock_db_viewer_service`
   --> tests\desktop_ui\test_db_viewer_dialog.py:241:25
    |
241 | def test_sorting(qtapp, mock_db_viewer_service, qtbot):
    |                         ^^^^^^^^^^^^^^^^^^^^^^
242 |     """Test column sorting."""
243 |     dialog = DatabaseViewerDialog(service=mock_db_viewer_service)
    |

ANN001 Missing type annotation for function argument `qtbot`
   --> tests\desktop_ui\test_db_viewer_dialog.py:241:49
    |
241 | def test_sorting(qtapp, mock_db_viewer_service, qtbot):
    |                                                 ^^^^^
242 |     """Test column sorting."""
243 |     dialog = DatabaseViewerDialog(service=mock_db_viewer_service)
    |

ANN201 Missing return type annotation for public function `test_filtering`
   --> tests\desktop_ui\test_db_viewer_dialog.py:310:5
    |
310 | def test_filtering(qtapp, mock_db_viewer_service, qtbot):
    |     ^^^^^^^^^^^^^^
311 |     """Test table filtering."""
312 |     dialog = DatabaseViewerDialog(service=mock_db_viewer_service)
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `qtapp`
   --> tests\desktop_ui\test_db_viewer_dialog.py:310:20
    |
310 | def test_filtering(qtapp, mock_db_viewer_service, qtbot):
    |                    ^^^^^
311 |     """Test table filtering."""
312 |     dialog = DatabaseViewerDialog(service=mock_db_viewer_service)
    |

ANN001 Missing type annotation for function argument `mock_db_viewer_service`
   --> tests\desktop_ui\test_db_viewer_dialog.py:310:27
    |
310 | def test_filtering(qtapp, mock_db_viewer_service, qtbot):
    |                           ^^^^^^^^^^^^^^^^^^^^^^
311 |     """Test table filtering."""
312 |     dialog = DatabaseViewerDialog(service=mock_db_viewer_service)
    |

ANN001 Missing type annotation for function argument `qtbot`
   --> tests\desktop_ui\test_db_viewer_dialog.py:310:51
    |
310 | def test_filtering(qtapp, mock_db_viewer_service, qtbot):
    |                                                   ^^^^^
311 |     """Test table filtering."""
312 |     dialog = DatabaseViewerDialog(service=mock_db_viewer_service)
    |

ANN201 Missing return type annotation for public function `test_export_to_csv`
   --> tests\desktop_ui\test_db_viewer_dialog.py:352:5
    |
350 | @patch("PySide6.QtWidgets.QFileDialog.getSaveFileName")
351 | @patch("PySide6.QtWidgets.QMessageBox.information")
352 | def test_export_to_csv(mock_info_box, mock_get_save_filename, qtapp, mock_db_viewer_service, qtbot):
    |     ^^^^^^^^^^^^^^^^^^
353 |     """Test exporting to CSV."""
354 |     # Setup mock to return a file path
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `mock_info_box`
   --> tests\desktop_ui\test_db_viewer_dialog.py:352:24
    |
350 | @patch("PySide6.QtWidgets.QFileDialog.getSaveFileName")
351 | @patch("PySide6.QtWidgets.QMessageBox.information")
352 | def test_export_to_csv(mock_info_box, mock_get_save_filename, qtapp, mock_db_viewer_service, qtbot):
    |                        ^^^^^^^^^^^^^
353 |     """Test exporting to CSV."""
354 |     # Setup mock to return a file path
    |

ANN001 Missing type annotation for function argument `mock_get_save_filename`
   --> tests\desktop_ui\test_db_viewer_dialog.py:352:39
    |
350 | @patch("PySide6.QtWidgets.QFileDialog.getSaveFileName")
351 | @patch("PySide6.QtWidgets.QMessageBox.information")
352 | def test_export_to_csv(mock_info_box, mock_get_save_filename, qtapp, mock_db_viewer_service, qtbot):
    |                                       ^^^^^^^^^^^^^^^^^^^^^^
353 |     """Test exporting to CSV."""
354 |     # Setup mock to return a file path
    |

ANN001 Missing type annotation for function argument `qtapp`
   --> tests\desktop_ui\test_db_viewer_dialog.py:352:63
    |
350 | @patch("PySide6.QtWidgets.QFileDialog.getSaveFileName")
351 | @patch("PySide6.QtWidgets.QMessageBox.information")
352 | def test_export_to_csv(mock_info_box, mock_get_save_filename, qtapp, mock_db_viewer_service, qtbot):
    |                                                               ^^^^^
353 |     """Test exporting to CSV."""
354 |     # Setup mock to return a file path
    |

ANN001 Missing type annotation for function argument `mock_db_viewer_service`
   --> tests\desktop_ui\test_db_viewer_dialog.py:352:70
    |
350 | @patch("PySide6.QtWidgets.QFileDialog.getSaveFileName")
351 | @patch("PySide6.QtWidgets.QMessageBox.information")
352 | def test_export_to_csv(mock_info_box, mock_get_save_filename, qtapp, mock_db_viewer_service, qtbot):
    |                                                                      ^^^^^^^^^^^^^^^^^^^^^^
353 |     """Test exporting to CSV."""
354 |     # Setup mock to return a file path
    |

ANN001 Missing type annotation for function argument `qtbot`
   --> tests\desktop_ui\test_db_viewer_dialog.py:352:94
    |
350 | @patch("PySide6.QtWidgets.QFileDialog.getSaveFileName")
351 | @patch("PySide6.QtWidgets.QMessageBox.information")
352 | def test_export_to_csv(mock_info_box, mock_get_save_filename, qtapp, mock_db_viewer_service, qtbot):
    |                                                                                              ^^^^^
353 |     """Test exporting to CSV."""
354 |     # Setup mock to return a file path
    |

ANN202 Missing return type annotation for private function `custom_export`
   --> tests\desktop_ui\test_db_viewer_dialog.py:371:9
    |
370 |     # Create a custom implementation of export_to_csv to bypass QFileDialog issue
371 |     def custom_export():
    |         ^^^^^^^^^^^^^
372 |         # This simulates user selecting a file name from QFileDialog
373 |         # and the method proceeding with that file name
    |
help: Add return type annotation: `None`

ANN201 Missing return type annotation for public function `test_error_handling`
   --> tests\desktop_ui\test_db_viewer_dialog.py:405:5
    |
405 | def test_error_handling(qtapp, mock_db_viewer_service, qtbot):
    |     ^^^^^^^^^^^^^^^^^^^
406 |     """Test error handling for service exceptions."""
407 |     dialog = DatabaseViewerDialog(service=mock_db_viewer_service)
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `qtapp`
   --> tests\desktop_ui\test_db_viewer_dialog.py:405:25
    |
405 | def test_error_handling(qtapp, mock_db_viewer_service, qtbot):
    |                         ^^^^^
406 |     """Test error handling for service exceptions."""
407 |     dialog = DatabaseViewerDialog(service=mock_db_viewer_service)
    |

ANN001 Missing type annotation for function argument `mock_db_viewer_service`
   --> tests\desktop_ui\test_db_viewer_dialog.py:405:32
    |
405 | def test_error_handling(qtapp, mock_db_viewer_service, qtbot):
    |                                ^^^^^^^^^^^^^^^^^^^^^^
406 |     """Test error handling for service exceptions."""
407 |     dialog = DatabaseViewerDialog(service=mock_db_viewer_service)
    |

ANN001 Missing type annotation for function argument `qtbot`
   --> tests\desktop_ui\test_db_viewer_dialog.py:405:56
    |
405 | def test_error_handling(qtapp, mock_db_viewer_service, qtbot):
    |                                                        ^^^^^
406 |     """Test error handling for service exceptions."""
407 |     dialog = DatabaseViewerDialog(service=mock_db_viewer_service)
    |

ANN201 Missing return type annotation for public function `test_empty_table_handling`
   --> tests\desktop_ui\test_db_viewer_dialog.py:429:5
    |
429 | def test_empty_table_handling(qtapp, mock_db_viewer_service, qtbot):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^
430 |     """Test handling of empty tables."""
431 |     # Configure service to return empty table data
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `qtapp`
   --> tests\desktop_ui\test_db_viewer_dialog.py:429:31
    |
429 | def test_empty_table_handling(qtapp, mock_db_viewer_service, qtbot):
    |                               ^^^^^
430 |     """Test handling of empty tables."""
431 |     # Configure service to return empty table data
    |

ANN001 Missing type annotation for function argument `mock_db_viewer_service`
   --> tests\desktop_ui\test_db_viewer_dialog.py:429:38
    |
429 | def test_empty_table_handling(qtapp, mock_db_viewer_service, qtbot):
    |                                      ^^^^^^^^^^^^^^^^^^^^^^
430 |     """Test handling of empty tables."""
431 |     # Configure service to return empty table data
    |

ANN001 Missing type annotation for function argument `qtbot`
   --> tests\desktop_ui\test_db_viewer_dialog.py:429:62
    |
429 | def test_empty_table_handling(qtapp, mock_db_viewer_service, qtbot):
    |                                                              ^^^^^
430 |     """Test handling of empty tables."""
431 |     # Configure service to return empty table data
    |

ANN201 Missing return type annotation for public function `test_count_result_edge_cases`
   --> tests\desktop_ui\test_db_viewer_dialog.py:460:5
    |
460 | def test_count_result_edge_cases(qtapp, qtbot):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
461 |     """Test edge cases in count result handling that could cause tuple index out of range."""
462 |     from unittest.mock import MagicMock
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `qtapp`
   --> tests\desktop_ui\test_db_viewer_dialog.py:460:34
    |
460 | def test_count_result_edge_cases(qtapp, qtbot):
    |                                  ^^^^^
461 |     """Test edge cases in count result handling that could cause tuple index out of range."""
462 |     from unittest.mock import MagicMock
    |

ANN001 Missing type annotation for function argument `qtbot`
   --> tests\desktop_ui\test_db_viewer_dialog.py:460:41
    |
460 | def test_count_result_edge_cases(qtapp, qtbot):
    |                                         ^^^^^
461 |     """Test edge cases in count result handling that could cause tuple index out of range."""
462 |     from unittest.mock import MagicMock
    |

ANN201 Missing return type annotation for public function `test_pagination_with_zero_total_pages`
   --> tests\desktop_ui\test_db_viewer_dialog.py:504:5
    |
504 | def test_pagination_with_zero_total_pages(qtapp, mock_db_viewer_service, qtbot):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
505 |     """Test pagination controls when total_pages is 0."""
506 |     # Configure service to return data with 0 total pages
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `qtapp`
   --> tests\desktop_ui\test_db_viewer_dialog.py:504:43
    |
504 | def test_pagination_with_zero_total_pages(qtapp, mock_db_viewer_service, qtbot):
    |                                           ^^^^^
505 |     """Test pagination controls when total_pages is 0."""
506 |     # Configure service to return data with 0 total pages
    |

ANN001 Missing type annotation for function argument `mock_db_viewer_service`
   --> tests\desktop_ui\test_db_viewer_dialog.py:504:50
    |
504 | def test_pagination_with_zero_total_pages(qtapp, mock_db_viewer_service, qtbot):
    |                                                  ^^^^^^^^^^^^^^^^^^^^^^
505 |     """Test pagination controls when total_pages is 0."""
506 |     # Configure service to return data with 0 total pages
    |

ANN001 Missing type annotation for function argument `qtbot`
   --> tests\desktop_ui\test_db_viewer_dialog.py:504:74
    |
504 | def test_pagination_with_zero_total_pages(qtapp, mock_db_viewer_service, qtbot):
    |                                                                          ^^^^^
505 |     """Test pagination controls when total_pages is 0."""
506 |     # Configure service to return data with 0 total pages
    |

ANN201 Missing return type annotation for public function `test_service_integration_with_real_count_scenarios`
   --> tests\desktop_ui\test_db_viewer_dialog.py:532:5
    |
532 | def test_service_integration_with_real_count_scenarios(qtapp, qtbot):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
533 |     """Test service integration with various count result scenarios."""
534 |     from unittest.mock import MagicMock
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `qtapp`
   --> tests\desktop_ui\test_db_viewer_dialog.py:532:56
    |
532 | def test_service_integration_with_real_count_scenarios(qtapp, qtbot):
    |                                                        ^^^^^
533 |     """Test service integration with various count result scenarios."""
534 |     from unittest.mock import MagicMock
    |

ANN001 Missing type annotation for function argument `qtbot`
   --> tests\desktop_ui\test_db_viewer_dialog.py:532:63
    |
532 | def test_service_integration_with_real_count_scenarios(qtapp, qtbot):
    |                                                               ^^^^^
533 |     """Test service integration with various count result scenarios."""
534 |     from unittest.mock import MagicMock
    |

D200 One-line docstring should fit on one line
 --> tests\desktop_ui\test_db_viewer_dialog_fixed.py:1:1
  |
1 | / """
2 | | Tests for the Database Viewer Dialog UI component.
3 | | """
  | |___^
4 |
5 |   import os
  |
help: Reformat to one line

D212 [*] Multi-line docstring summary should start at the first line
 --> tests\desktop_ui\test_db_viewer_dialog_fixed.py:1:1
  |
1 | / """
2 | | Tests for the Database Viewer Dialog UI component.
3 | | """
  | |___^
4 |
5 |   import os
  |
help: Remove whitespace after opening quotes

D205 1 blank line required between summary line and description
  --> tests\desktop_ui\test_db_viewer_dialog_fixed.py:24:5
   |
22 |   @pytest.fixture
23 |   def qtapp() -> QApplication:
24 | /     """Create a QApplication instance for testing.
25 | |     This avoids conflicts with pytest-flask by creating a dedicated QApplication for Qt tests.
26 | |     """
   | |_______^
27 |       app = QApplication.instance()
28 |       if app is None:
   |
help: Insert single blank line

D107 Missing docstring in `__init__`
  --> tests\desktop_ui\test_db_viewer_dialog_fixed.py:37:9
   |
35 |     """Simple QtBot class to replace pytest-qt's qtbot when it's not available."""
36 |
37 |     def __init__(self, app: QApplication) -> None:
   |         ^^^^^^^^
38 |         self.app = app
39 |         self.widgets: List[Any] = []
   |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `widget`
  --> tests\desktop_ui\test_db_viewer_dialog_fixed.py:41:33
   |
39 |         self.widgets: List[Any] = []
40 |
41 |     def addWidget(self, widget: Any) -> Any:
   |                                 ^^^
42 |         """Keep track of widgets to ensure they don't get garbage collected."""
43 |         self.widgets.append(widget)
   |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `addWidget`
  --> tests\desktop_ui\test_db_viewer_dialog_fixed.py:41:41
   |
39 |         self.widgets: List[Any] = []
40 |
41 |     def addWidget(self, widget: Any) -> Any:
   |                                         ^^^
42 |         """Keep track of widgets to ensure they don't get garbage collected."""
43 |         self.widgets.append(widget)
   |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `widget`
  --> tests\desktop_ui\test_db_viewer_dialog_fixed.py:46:34
   |
44 |         return widget
45 |
46 |     def mouseClick(self, widget: Any, button: Any = Qt.LeftButton, pos: Any = None) -> None:
   |                                  ^^^
47 |         """Simulate mouse click."""
48 |         if pos is None:
   |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `button`
  --> tests\desktop_ui\test_db_viewer_dialog_fixed.py:46:47
   |
44 |         return widget
45 |
46 |     def mouseClick(self, widget: Any, button: Any = Qt.LeftButton, pos: Any = None) -> None:
   |                                               ^^^
47 |         """Simulate mouse click."""
48 |         if pos is None:
   |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `pos`
  --> tests\desktop_ui\test_db_viewer_dialog_fixed.py:46:73
   |
44 |         return widget
45 |
46 |     def mouseClick(self, widget: Any, button: Any = Qt.LeftButton, pos: Any = None) -> None:
   |                                                                         ^^^
47 |         """Simulate mouse click."""
48 |         if pos is None:
   |

D107 Missing docstring in `__init__`
  --> tests\desktop_ui\test_db_viewer_dialog_fixed.py:67:9
   |
65 |     """Mock QTableWidgetItem for testing."""
66 |
67 |     def __init__(self, text: str = "") -> None:
   |         ^^^^^^^^
68 |         self._text = text
   |

D102 Missing docstring in public method
  --> tests\desktop_ui\test_db_viewer_dialog_fixed.py:70:9
   |
68 |         self._text = text
69 |
70 |     def text(self) -> str:
   |         ^^^^
71 |         return self._text
   |

D100 Missing docstring in public module
--> tests\desktop_ui\test_drill_config.py:1:1

D212 [*] Multi-line docstring summary should start at the first line
 --> tests\desktop_ui\test_library_main_ui_new.py:1:1
  |
1 | / """
2 | | Tests for LibraryManager and Snippets Library functionality.
3 | |
4 | | This test suite covers only the models/library.py logic (categories, snippets, CRUD, validation).
5 | | """
  | |___^
6 |
7 |   import os
  |
help: Remove whitespace after opening quotes

D212 [*] Multi-line docstring summary should start at the first line
  --> tests\desktop_ui\test_library_main_ui_new.py:45:5
   |
43 |   @pytest.fixture
44 |   def db_manager(temp_db: str) -> Generator[DatabaseManager, None, None]:
45 | /     """
46 | |     Provide a DatabaseManager instance with a temporary database.
47 | |
48 | |     Args:
49 | |         temp_db: Path to the temporary database file
50 | |
51 | |     Yields:
52 | |         DatabaseManager: A database manager instance connected to the temp database
53 | |     """
   | |_______^
54 |       db = None
55 |       try:
   |
help: Remove whitespace after opening quotes

ANN201 Missing return type annotation for public function `qt_app`
  --> tests\desktop_ui\test_library_main_ui_new.py:76:5
   |
75 | @pytest.fixture(scope="module")
76 | def qt_app():
   |     ^^^^^^
77 |     """Provide a QApplication instance for UI tests."""
78 |     app = QApplication.instance()
   |
help: Add return type annotation

ANN201 Missing return type annotation for public function `mock_db_manager`
  --> tests\desktop_ui\test_library_main_ui_new.py:85:5
   |
84 | @pytest.fixture
85 | def mock_db_manager(db_manager):
   |     ^^^^^^^^^^^^^^^
86 |     # Patch CategoryManager and SnippetManager to use the test db
87 |     return db_manager
   |
help: Add return type annotation

D103 Missing docstring in public function
  --> tests\desktop_ui\test_library_main_ui_new.py:85:5
   |
84 | @pytest.fixture
85 | def mock_db_manager(db_manager):
   |     ^^^^^^^^^^^^^^^
86 |     # Patch CategoryManager and SnippetManager to use the test db
87 |     return db_manager
   |

ANN001 Missing type annotation for function argument `db_manager`
  --> tests\desktop_ui\test_library_main_ui_new.py:85:21
   |
84 | @pytest.fixture
85 | def mock_db_manager(db_manager):
   |                     ^^^^^^^^^^
86 |     # Patch CategoryManager and SnippetManager to use the test db
87 |     return db_manager
   |

ANN201 Missing return type annotation for public function `main_window`
  --> tests\desktop_ui\test_library_main_ui_new.py:91:5
   |
90 | @pytest.fixture
91 | def main_window(qt_app, mock_db_manager):
   |     ^^^^^^^^^^^
92 |     win = library_main.LibraryMainWindow(db_manager=mock_db_manager, testing_mode=True)
93 |     yield win
   |
help: Add return type annotation

D103 Missing docstring in public function
  --> tests\desktop_ui\test_library_main_ui_new.py:91:5
   |
90 | @pytest.fixture
91 | def main_window(qt_app, mock_db_manager):
   |     ^^^^^^^^^^^
92 |     win = library_main.LibraryMainWindow(db_manager=mock_db_manager, testing_mode=True)
93 |     yield win
   |

ANN001 Missing type annotation for function argument `qt_app`
  --> tests\desktop_ui\test_library_main_ui_new.py:91:17
   |
90 | @pytest.fixture
91 | def main_window(qt_app, mock_db_manager):
   |                 ^^^^^^
92 |     win = library_main.LibraryMainWindow(db_manager=mock_db_manager, testing_mode=True)
93 |     yield win
   |

ANN001 Missing type annotation for function argument `mock_db_manager`
  --> tests\desktop_ui\test_library_main_ui_new.py:91:25
   |
90 | @pytest.fixture
91 | def main_window(qt_app, mock_db_manager):
   |                         ^^^^^^^^^^^^^^^
92 |     win = library_main.LibraryMainWindow(db_manager=mock_db_manager, testing_mode=True)
93 |     yield win
   |

B017 Do not assert blind exception: `Exception`
   --> tests\desktop_ui\test_library_main_ui_new.py:153:10
    |
151 | def test_create_snippet_invalid_category(library_manager: LibraryManager) -> None:
152 |     """Test creating a snippet with an invalid category."""
153 |     with pytest.raises(Exception):
    |          ^^^^^^^^^^^^^^^^^^^^^^^^
154 |         library_manager.create_snippet("nonexistent", "Name", "Content")
    |

B017 Do not assert blind exception: `Exception`
   --> tests\desktop_ui\test_library_main_ui_new.py:159:10
    |
157 | def test_edit_snippet_invalid_id(library_manager: LibraryManager) -> None:
158 |     """Test editing a snippet with an invalid ID."""
159 |     with pytest.raises(Exception):
    |          ^^^^^^^^^^^^^^^^^^^^^^^^
160 |         library_manager.edit_snippet("badid", "Name", "Content")
    |

D101 Missing docstring in public class
   --> tests\desktop_ui\test_library_main_ui_new.py:182:7
    |
182 | class TestLibraryMainWindowUI:
    |       ^^^^^^^^^^^^^^^^^^^^^^^
183 |     def test_load_data_and_initial_state(self, main_window):
184 |         win = main_window
    |

ANN201 Missing return type annotation for public function `test_load_data_and_initial_state`
   --> tests\desktop_ui\test_library_main_ui_new.py:183:9
    |
182 | class TestLibraryMainWindowUI:
183 |     def test_load_data_and_initial_state(self, main_window):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
184 |         win = main_window
185 |         # Should load with no categories/snippets
    |
help: Add return type annotation: `None`

D102 Missing docstring in public method
   --> tests\desktop_ui\test_library_main_ui_new.py:183:9
    |
182 | class TestLibraryMainWindowUI:
183 |     def test_load_data_and_initial_state(self, main_window):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
184 |         win = main_window
185 |         # Should load with no categories/snippets
    |

ANN001 Missing type annotation for function argument `main_window`
   --> tests\desktop_ui\test_library_main_ui_new.py:183:48
    |
182 | class TestLibraryMainWindowUI:
183 |     def test_load_data_and_initial_state(self, main_window):
    |                                                ^^^^^^^^^^^
184 |         win = main_window
185 |         # Should load with no categories/snippets
    |

ANN201 Missing return type annotation for public function `test_add_category`
   --> tests\desktop_ui\test_library_main_ui_new.py:190:9
    |
188 |         assert win.status.text() == ""
189 |
190 |     def test_add_category(self, main_window, monkeypatch):
    |         ^^^^^^^^^^^^^^^^^
191 |         win = main_window
192 |         # Simulate dialog returning Accepted and a name
    |
help: Add return type annotation: `None`

D102 Missing docstring in public method
   --> tests\desktop_ui\test_library_main_ui_new.py:190:9
    |
188 |         assert win.status.text() == ""
189 |
190 |     def test_add_category(self, main_window, monkeypatch):
    |         ^^^^^^^^^^^^^^^^^
191 |         win = main_window
192 |         # Simulate dialog returning Accepted and a name
    |

ANN001 Missing type annotation for function argument `main_window`
   --> tests\desktop_ui\test_library_main_ui_new.py:190:33
    |
188 |         assert win.status.text() == ""
189 |
190 |     def test_add_category(self, main_window, monkeypatch):
    |                                 ^^^^^^^^^^^
191 |         win = main_window
192 |         # Simulate dialog returning Accepted and a name
    |

ANN001 Missing type annotation for function argument `monkeypatch`
   --> tests\desktop_ui\test_library_main_ui_new.py:190:46
    |
188 |         assert win.status.text() == ""
189 |
190 |     def test_add_category(self, main_window, monkeypatch):
    |                                              ^^^^^^^^^^^
191 |         win = main_window
192 |         # Simulate dialog returning Accepted and a name
    |

ANN201 Missing return type annotation for public function `test_edit_category`
   --> tests\desktop_ui\test_library_main_ui_new.py:202:9
    |
200 |         assert win.categoryList.count() > 0
201 |
202 |     def test_edit_category(self, main_window, monkeypatch):
    |         ^^^^^^^^^^^^^^^^^^
203 |         win = main_window
204 |         # Ensure there is at least one category to edit
    |
help: Add return type annotation: `None`

D102 Missing docstring in public method
   --> tests\desktop_ui\test_library_main_ui_new.py:202:9
    |
200 |         assert win.categoryList.count() > 0
201 |
202 |     def test_edit_category(self, main_window, monkeypatch):
    |         ^^^^^^^^^^^^^^^^^^
203 |         win = main_window
204 |         # Ensure there is at least one category to edit
    |

ANN001 Missing type annotation for function argument `main_window`
   --> tests\desktop_ui\test_library_main_ui_new.py:202:34
    |
200 |         assert win.categoryList.count() > 0
201 |
202 |     def test_edit_category(self, main_window, monkeypatch):
    |                                  ^^^^^^^^^^^
203 |         win = main_window
204 |         # Ensure there is at least one category to edit
    |

ANN001 Missing type annotation for function argument `monkeypatch`
   --> tests\desktop_ui\test_library_main_ui_new.py:202:47
    |
200 |         assert win.categoryList.count() > 0
201 |
202 |     def test_edit_category(self, main_window, monkeypatch):
    |                                               ^^^^^^^^^^^
203 |         win = main_window
204 |         # Ensure there is at least one category to edit
    |

ANN202 Missing return type annotation for private function `exec_`
   --> tests\desktop_ui\test_library_main_ui_new.py:208:21
    |
207 |             class FakeAddDialog:
208 |                 def exec_(self):
    |                     ^^^^^
209 |                     return 1
    |
help: Add return type annotation: `int`

ANN202 Missing return type annotation for private function `get_value`
   --> tests\desktop_ui\test_library_main_ui_new.py:211:21
    |
209 |                     return 1
210 |
211 |                 def get_value(self):
    |                     ^^^^^^^^^
212 |                     return "Initial Cat"
    |
help: Add return type annotation: `str`

ANN202 Missing return type annotation for private function `exec_`
   --> tests\desktop_ui\test_library_main_ui_new.py:220:17
    |
219 |         class FakeEditDialog:
220 |             def exec_(self):
    |                 ^^^^^
221 |                 return 1
    |
help: Add return type annotation: `int`

ANN202 Missing return type annotation for private function `get_value`
   --> tests\desktop_ui\test_library_main_ui_new.py:223:17
    |
221 |                 return 1
222 |
223 |             def get_value(self):
    |                 ^^^^^^^^^
224 |                 return "Renamed Cat"
    |
help: Add return type annotation: `str`

ANN201 Missing return type annotation for public function `test_delete_category`
   --> tests\desktop_ui\test_library_main_ui_new.py:231:9
    |
229 |         assert win.status.text() == "Category updated."
230 |
231 |     def test_delete_category(self, main_window, monkeypatch):
    |         ^^^^^^^^^^^^^^^^^^^^
232 |         win = main_window
233 |         win.categoryList.setCurrentRow(0)
    |
help: Add return type annotation: `None`

D102 Missing docstring in public method
   --> tests\desktop_ui\test_library_main_ui_new.py:231:9
    |
229 |         assert win.status.text() == "Category updated."
230 |
231 |     def test_delete_category(self, main_window, monkeypatch):
    |         ^^^^^^^^^^^^^^^^^^^^
232 |         win = main_window
233 |         win.categoryList.setCurrentRow(0)
    |

ANN001 Missing type annotation for function argument `main_window`
   --> tests\desktop_ui\test_library_main_ui_new.py:231:36
    |
229 |         assert win.status.text() == "Category updated."
230 |
231 |     def test_delete_category(self, main_window, monkeypatch):
    |                                    ^^^^^^^^^^^
232 |         win = main_window
233 |         win.categoryList.setCurrentRow(0)
    |

ANN001 Missing type annotation for function argument `monkeypatch`
   --> tests\desktop_ui\test_library_main_ui_new.py:231:49
    |
229 |         assert win.status.text() == "Category updated."
230 |
231 |     def test_delete_category(self, main_window, monkeypatch):
    |                                                 ^^^^^^^^^^^
232 |         win = main_window
233 |         win.categoryList.setCurrentRow(0)
    |

ANN201 Missing return type annotation for public function `test_add_snippet`
   --> tests\desktop_ui\test_library_main_ui_new.py:241:9
    |
239 |         assert win.status.text() == "Category deleted."
240 |
241 |     def test_add_snippet(self, main_window, monkeypatch):
    |         ^^^^^^^^^^^^^^^^
242 |         win = main_window
243 |         # Add a category first
    |
help: Add return type annotation: `None`

D102 Missing docstring in public method
   --> tests\desktop_ui\test_library_main_ui_new.py:241:9
    |
239 |         assert win.status.text() == "Category deleted."
240 |
241 |     def test_add_snippet(self, main_window, monkeypatch):
    |         ^^^^^^^^^^^^^^^^
242 |         win = main_window
243 |         # Add a category first
    |

ANN001 Missing type annotation for function argument `main_window`
   --> tests\desktop_ui\test_library_main_ui_new.py:241:32
    |
239 |         assert win.status.text() == "Category deleted."
240 |
241 |     def test_add_snippet(self, main_window, monkeypatch):
    |                                ^^^^^^^^^^^
242 |         win = main_window
243 |         # Add a category first
    |

ANN001 Missing type annotation for function argument `monkeypatch`
   --> tests\desktop_ui\test_library_main_ui_new.py:241:45
    |
239 |         assert win.status.text() == "Category deleted."
240 |
241 |     def test_add_snippet(self, main_window, monkeypatch):
    |                                             ^^^^^^^^^^^
242 |         win = main_window
243 |         # Add a category first
    |

ANN201 Missing return type annotation for public function `test_edit_snippet`
   --> tests\desktop_ui\test_library_main_ui_new.py:259:9
    |
257 |         assert win.status.text() == "Snippet added."
258 |
259 |     def test_edit_snippet(self, main_window, monkeypatch):
    |         ^^^^^^^^^^^^^^^^^
260 |         win = main_window
261 |         win.snippetList.setCurrentRow(0)
    |
help: Add return type annotation: `None`

D102 Missing docstring in public method
   --> tests\desktop_ui\test_library_main_ui_new.py:259:9
    |
257 |         assert win.status.text() == "Snippet added."
258 |
259 |     def test_edit_snippet(self, main_window, monkeypatch):
    |         ^^^^^^^^^^^^^^^^^
260 |         win = main_window
261 |         win.snippetList.setCurrentRow(0)
    |

ANN001 Missing type annotation for function argument `main_window`
   --> tests\desktop_ui\test_library_main_ui_new.py:259:33
    |
257 |         assert win.status.text() == "Snippet added."
258 |
259 |     def test_edit_snippet(self, main_window, monkeypatch):
    |                                 ^^^^^^^^^^^
260 |         win = main_window
261 |         win.snippetList.setCurrentRow(0)
    |

ANN001 Missing type annotation for function argument `monkeypatch`
   --> tests\desktop_ui\test_library_main_ui_new.py:259:46
    |
257 |         assert win.status.text() == "Snippet added."
258 |
259 |     def test_edit_snippet(self, main_window, monkeypatch):
    |                                              ^^^^^^^^^^^
260 |         win = main_window
261 |         win.snippetList.setCurrentRow(0)
    |

ANN201 Missing return type annotation for public function `test_delete_snippet`
   --> tests\desktop_ui\test_library_main_ui_new.py:271:9
    |
269 |         assert win.status.text() == "Snippet updated."
270 |
271 |     def test_delete_snippet(self, main_window, monkeypatch):
    |         ^^^^^^^^^^^^^^^^^^^
272 |         win = main_window
273 |         win.snippetList.setCurrentRow(0)
    |
help: Add return type annotation: `None`

D102 Missing docstring in public method
   --> tests\desktop_ui\test_library_main_ui_new.py:271:9
    |
269 |         assert win.status.text() == "Snippet updated."
270 |
271 |     def test_delete_snippet(self, main_window, monkeypatch):
    |         ^^^^^^^^^^^^^^^^^^^
272 |         win = main_window
273 |         win.snippetList.setCurrentRow(0)
    |

ANN001 Missing type annotation for function argument `main_window`
   --> tests\desktop_ui\test_library_main_ui_new.py:271:35
    |
269 |         assert win.status.text() == "Snippet updated."
270 |
271 |     def test_delete_snippet(self, main_window, monkeypatch):
    |                                   ^^^^^^^^^^^
272 |         win = main_window
273 |         win.snippetList.setCurrentRow(0)
    |

ANN001 Missing type annotation for function argument `monkeypatch`
   --> tests\desktop_ui\test_library_main_ui_new.py:271:48
    |
269 |         assert win.status.text() == "Snippet updated."
270 |
271 |     def test_delete_snippet(self, main_window, monkeypatch):
    |                                                ^^^^^^^^^^^
272 |         win = main_window
273 |         win.snippetList.setCurrentRow(0)
    |

ANN201 Missing return type annotation for public function `test_filter_snippets`
   --> tests\desktop_ui\test_library_main_ui_new.py:279:9
    |
277 |         assert win.status.text() == "Snippet deleted."
278 |
279 |     def test_filter_snippets(self, main_window, monkeypatch):
    |         ^^^^^^^^^^^^^^^^^^^^
280 |         win = main_window
281 |         # Add a snippet again
    |
help: Add return type annotation: `None`

D102 Missing docstring in public method
   --> tests\desktop_ui\test_library_main_ui_new.py:279:9
    |
277 |         assert win.status.text() == "Snippet deleted."
278 |
279 |     def test_filter_snippets(self, main_window, monkeypatch):
    |         ^^^^^^^^^^^^^^^^^^^^
280 |         win = main_window
281 |         # Add a snippet again
    |

ANN001 Missing type annotation for function argument `main_window`
   --> tests\desktop_ui\test_library_main_ui_new.py:279:36
    |
277 |         assert win.status.text() == "Snippet deleted."
278 |
279 |     def test_filter_snippets(self, main_window, monkeypatch):
    |                                    ^^^^^^^^^^^
280 |         win = main_window
281 |         # Add a snippet again
    |

ANN001 Missing type annotation for function argument `monkeypatch`
   --> tests\desktop_ui\test_library_main_ui_new.py:279:49
    |
277 |         assert win.status.text() == "Snippet deleted."
278 |
279 |     def test_filter_snippets(self, main_window, monkeypatch):
    |                                                 ^^^^^^^^^^^
280 |         win = main_window
281 |         # Add a snippet again
    |

ANN201 Missing return type annotation for public function `test_show_error_and_info`
   --> tests\desktop_ui\test_library_main_ui_new.py:297:9
    |
295 |         assert win.snippetList.count() == 2
296 |
297 |     def test_show_error_and_info(self, main_window):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^
298 |         win = main_window
299 |         win.show_error("ErrMsg")
    |
help: Add return type annotation: `None`

D102 Missing docstring in public method
   --> tests\desktop_ui\test_library_main_ui_new.py:297:9
    |
295 |         assert win.snippetList.count() == 2
296 |
297 |     def test_show_error_and_info(self, main_window):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^
298 |         win = main_window
299 |         win.show_error("ErrMsg")
    |

ANN001 Missing type annotation for function argument `main_window`
   --> tests\desktop_ui\test_library_main_ui_new.py:297:40
    |
295 |         assert win.snippetList.count() == 2
296 |
297 |     def test_show_error_and_info(self, main_window):
    |                                        ^^^^^^^^^^^
298 |         win = main_window
299 |         win.show_error("ErrMsg")
    |

ANN201 Missing return type annotation for public function `test_update_snippet_buttons_state`
   --> tests\desktop_ui\test_library_main_ui_new.py:304:9
    |
302 |         assert win.status.text() == "InfoMsg"
303 |
304 |     def test_update_snippet_buttons_state(self, main_window):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
305 |         win = main_window
306 |         win.update_snippet_buttons_state(True)
    |
help: Add return type annotation: `None`

D102 Missing docstring in public method
   --> tests\desktop_ui\test_library_main_ui_new.py:304:9
    |
302 |         assert win.status.text() == "InfoMsg"
303 |
304 |     def test_update_snippet_buttons_state(self, main_window):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
305 |         win = main_window
306 |         win.update_snippet_buttons_state(True)
    |

ANN001 Missing type annotation for function argument `main_window`
   --> tests\desktop_ui\test_library_main_ui_new.py:304:49
    |
302 |         assert win.status.text() == "InfoMsg"
303 |
304 |     def test_update_snippet_buttons_state(self, main_window):
    |                                                 ^^^^^^^^^^^
305 |         win = main_window
306 |         win.update_snippet_buttons_state(True)
    |

ANN201 Missing return type annotation for public function `test_on_category_selection_changed_and_load_snippets`
   --> tests\desktop_ui\test_library_main_ui_new.py:315:9
    |
313 |         assert not win.delSnipBtn.isEnabled()
314 |
315 |     def test_on_category_selection_changed_and_load_snippets(self, main_window):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
316 |         win = main_window
317 |         win.categoryList.setCurrentRow(0)
    |
help: Add return type annotation: `None`

D102 Missing docstring in public method
   --> tests\desktop_ui\test_library_main_ui_new.py:315:9
    |
313 |         assert not win.delSnipBtn.isEnabled()
314 |
315 |     def test_on_category_selection_changed_and_load_snippets(self, main_window):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
316 |         win = main_window
317 |         win.categoryList.setCurrentRow(0)
    |

ANN001 Missing type annotation for function argument `main_window`
   --> tests\desktop_ui\test_library_main_ui_new.py:315:68
    |
313 |         assert not win.delSnipBtn.isEnabled()
314 |
315 |     def test_on_category_selection_changed_and_load_snippets(self, main_window):
    |                                                                    ^^^^^^^^^^^
316 |         win = main_window
317 |         win.categoryList.setCurrentRow(0)
    |

ANN201 Missing return type annotation for public function `test_on_snippet_selection_changed`
   --> tests\desktop_ui\test_library_main_ui_new.py:322:9
    |
320 |         assert win.snippetList.count() >= 0
321 |
322 |     def test_on_snippet_selection_changed(self, main_window):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
323 |         win = main_window
324 |         if win.snippetList.count() > 0:
    |
help: Add return type annotation: `None`

D102 Missing docstring in public method
   --> tests\desktop_ui\test_library_main_ui_new.py:322:9
    |
320 |         assert win.snippetList.count() >= 0
321 |
322 |     def test_on_snippet_selection_changed(self, main_window):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
323 |         win = main_window
324 |         if win.snippetList.count() > 0:
    |

ANN001 Missing type annotation for function argument `main_window`
   --> tests\desktop_ui\test_library_main_ui_new.py:322:49
    |
320 |         assert win.snippetList.count() >= 0
321 |
322 |     def test_on_snippet_selection_changed(self, main_window):
    |                                                 ^^^^^^^^^^^
323 |         win = main_window
324 |         if win.snippetList.count() > 0:
    |

ANN201 Missing return type annotation for public function `test_view_snippet`
   --> tests\desktop_ui\test_library_main_ui_new.py:329:9
    |
327 |             assert win.selected_snippet is not None
328 |
329 |     def test_view_snippet(self, main_window, monkeypatch):
    |         ^^^^^^^^^^^^^^^^^
330 |         win = main_window
331 |         if win.snippetList.count() > 0:
    |
help: Add return type annotation: `None`

D102 Missing docstring in public method
   --> tests\desktop_ui\test_library_main_ui_new.py:329:9
    |
327 |             assert win.selected_snippet is not None
328 |
329 |     def test_view_snippet(self, main_window, monkeypatch):
    |         ^^^^^^^^^^^^^^^^^
330 |         win = main_window
331 |         if win.snippetList.count() > 0:
    |

ANN001 Missing type annotation for function argument `main_window`
   --> tests\desktop_ui\test_library_main_ui_new.py:329:33
    |
327 |             assert win.selected_snippet is not None
328 |
329 |     def test_view_snippet(self, main_window, monkeypatch):
    |                                 ^^^^^^^^^^^
330 |         win = main_window
331 |         if win.snippetList.count() > 0:
    |

ANN001 Missing type annotation for function argument `monkeypatch`
   --> tests\desktop_ui\test_library_main_ui_new.py:329:46
    |
327 |             assert win.selected_snippet is not None
328 |
329 |     def test_view_snippet(self, main_window, monkeypatch):
    |                                              ^^^^^^^^^^^
330 |         win = main_window
331 |         if win.snippetList.count() > 0:
    |

ANN201 Missing return type annotation for public function `test_add_category_error`
   --> tests\desktop_ui\test_library_main_ui_new.py:339:9
    |
337 |             win.view_snippet(item)
338 |
339 |     def test_add_category_error(self, main_window, monkeypatch):
    |         ^^^^^^^^^^^^^^^^^^^^^^^
340 |         win = main_window
341 |         # Simulate dialog accepted but error in save_category
    |
help: Add return type annotation: `None`

D102 Missing docstring in public method
   --> tests\desktop_ui\test_library_main_ui_new.py:339:9
    |
337 |             win.view_snippet(item)
338 |
339 |     def test_add_category_error(self, main_window, monkeypatch):
    |         ^^^^^^^^^^^^^^^^^^^^^^^
340 |         win = main_window
341 |         # Simulate dialog accepted but error in save_category
    |

ANN001 Missing type annotation for function argument `main_window`
   --> tests\desktop_ui\test_library_main_ui_new.py:339:39
    |
337 |             win.view_snippet(item)
338 |
339 |     def test_add_category_error(self, main_window, monkeypatch):
    |                                       ^^^^^^^^^^^
340 |         win = main_window
341 |         # Simulate dialog accepted but error in save_category
    |

ANN001 Missing type annotation for function argument `monkeypatch`
   --> tests\desktop_ui\test_library_main_ui_new.py:339:52
    |
337 |             win.view_snippet(item)
338 |
339 |     def test_add_category_error(self, main_window, monkeypatch):
    |                                                    ^^^^^^^^^^^
340 |         win = main_window
341 |         # Simulate dialog accepted but error in save_category
    |

ANN201 Missing return type annotation for public function `test_add_snippet_error`
   --> tests\desktop_ui\test_library_main_ui_new.py:354:9
    |
352 |         assert "Failed to add category" in win.status.text()
353 |
354 |     def test_add_snippet_error(self, main_window, monkeypatch):
    |         ^^^^^^^^^^^^^^^^^^^^^^
355 |         # Ensure a category exists and is selected
356 |         if not main_window.categories:
    |
help: Add return type annotation: `None`

D102 Missing docstring in public method
   --> tests\desktop_ui\test_library_main_ui_new.py:354:9
    |
352 |         assert "Failed to add category" in win.status.text()
353 |
354 |     def test_add_snippet_error(self, main_window, monkeypatch):
    |         ^^^^^^^^^^^^^^^^^^^^^^
355 |         # Ensure a category exists and is selected
356 |         if not main_window.categories:
    |

ANN001 Missing type annotation for function argument `main_window`
   --> tests\desktop_ui\test_library_main_ui_new.py:354:38
    |
352 |         assert "Failed to add category" in win.status.text()
353 |
354 |     def test_add_snippet_error(self, main_window, monkeypatch):
    |                                      ^^^^^^^^^^^
355 |         # Ensure a category exists and is selected
356 |         if not main_window.categories:
    |

ANN001 Missing type annotation for function argument `monkeypatch`
   --> tests\desktop_ui\test_library_main_ui_new.py:354:51
    |
352 |         assert "Failed to add category" in win.status.text()
353 |
354 |     def test_add_snippet_error(self, main_window, monkeypatch):
    |                                                   ^^^^^^^^^^^
355 |         # Ensure a category exists and is selected
356 |         if not main_window.categories:
    |

ANN202 Missing return type annotation for private function `exec_`
   --> tests\desktop_ui\test_library_main_ui_new.py:359:21
    |
358 |             class FakeCatDialog:
359 |                 def exec_(self):
    |                     ^^^^^
360 |                     return 1
    |
help: Add return type annotation: `int`

ANN202 Missing return type annotation for private function `get_value`
   --> tests\desktop_ui\test_library_main_ui_new.py:362:21
    |
360 |                     return 1
361 |
362 |                 def get_value(self):
    |                     ^^^^^^^^^
363 |                     return "CatForError"
    |
help: Add return type annotation: `str`

ANN202 Missing return type annotation for private function `exec_`
   --> tests\desktop_ui\test_library_main_ui_new.py:370:17
    |
369 |         class FakeDialog:
370 |             def exec_(self):
    |                 ^^^^^
371 |                 return 1
    |
help: Add return type annotation: `int`

ANN202 Missing return type annotation for private function `get_values`
   --> tests\desktop_ui\test_library_main_ui_new.py:373:17
    |
371 |                 return 1
372 |
373 |             def get_values(self):
    |                 ^^^^^^^^^^
374 |                 return ("ErrSnip", "X")
    |
help: Add return type annotation

ANN202 Missing return type annotation for private function `fail_save_snippet`
   --> tests\desktop_ui\test_library_main_ui_new.py:378:13
    |
376 |         monkeypatch.setattr(library_main, "SnippetDialog", lambda *a, **k: FakeDialog())
377 |
378 |         def fail_save_snippet(snip):
    |             ^^^^^^^^^^^^^^^^^
379 |             raise Exception("failsnip")
    |
help: Add return type annotation: `Never`

ANN001 Missing type annotation for function argument `snip`
   --> tests\desktop_ui\test_library_main_ui_new.py:378:31
    |
376 |         monkeypatch.setattr(library_main, "SnippetDialog", lambda *a, **k: FakeDialog())
377 |
378 |         def fail_save_snippet(snip):
    |                               ^^^^
379 |             raise Exception("failsnip")
    |

ANN201 Missing return type annotation for public function `test_edit_category_error`
   --> tests\desktop_ui\test_library_main_ui_new.py:385:9
    |
383 |         assert "failsnip" in main_window.status.text()
384 |
385 |     def test_edit_category_error(self, main_window, monkeypatch):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^
386 |         win = main_window
387 |         # Ensure a category exists and is selected
    |
help: Add return type annotation: `None`

D102 Missing docstring in public method
   --> tests\desktop_ui\test_library_main_ui_new.py:385:9
    |
383 |         assert "failsnip" in main_window.status.text()
384 |
385 |     def test_edit_category_error(self, main_window, monkeypatch):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^
386 |         win = main_window
387 |         # Ensure a category exists and is selected
    |

ANN001 Missing type annotation for function argument `main_window`
   --> tests\desktop_ui\test_library_main_ui_new.py:385:40
    |
383 |         assert "failsnip" in main_window.status.text()
384 |
385 |     def test_edit_category_error(self, main_window, monkeypatch):
    |                                        ^^^^^^^^^^^
386 |         win = main_window
387 |         # Ensure a category exists and is selected
    |

ANN001 Missing type annotation for function argument `monkeypatch`
   --> tests\desktop_ui\test_library_main_ui_new.py:385:53
    |
383 |         assert "failsnip" in main_window.status.text()
384 |
385 |     def test_edit_category_error(self, main_window, monkeypatch):
    |                                                     ^^^^^^^^^^^
386 |         win = main_window
387 |         # Ensure a category exists and is selected
    |

ANN202 Missing return type annotation for private function `exec_`
   --> tests\desktop_ui\test_library_main_ui_new.py:391:21
    |
390 |             class FakeAddDialog:
391 |                 def exec_(self):
    |                     ^^^^^
392 |                     return 1
    |
help: Add return type annotation: `int`

ANN202 Missing return type annotation for private function `get_value`
   --> tests\desktop_ui\test_library_main_ui_new.py:394:21
    |
392 |                     return 1
393 |
394 |                 def get_value(self):
    |                     ^^^^^^^^^
395 |                     return "ErrEditCat"
    |
help: Add return type annotation: `str`

ANN201 Missing return type annotation for public function `test_edit_snippet_error`
   --> tests\desktop_ui\test_library_main_ui_new.py:412:9
    |
410 |         assert "Failed to update category" in win.status.text() or "failcat2" in win.status.text()
411 |
412 |     def test_edit_snippet_error(self, main_window, monkeypatch):
    |         ^^^^^^^^^^^^^^^^^^^^^^^
413 |         win = main_window
414 |         # Ensure a snippet exists and is selected
    |
help: Add return type annotation: `None`

D102 Missing docstring in public method
   --> tests\desktop_ui\test_library_main_ui_new.py:412:9
    |
410 |         assert "Failed to update category" in win.status.text() or "failcat2" in win.status.text()
411 |
412 |     def test_edit_snippet_error(self, main_window, monkeypatch):
    |         ^^^^^^^^^^^^^^^^^^^^^^^
413 |         win = main_window
414 |         # Ensure a snippet exists and is selected
    |

ANN001 Missing type annotation for function argument `main_window`
   --> tests\desktop_ui\test_library_main_ui_new.py:412:39
    |
410 |         assert "Failed to update category" in win.status.text() or "failcat2" in win.status.text()
411 |
412 |     def test_edit_snippet_error(self, main_window, monkeypatch):
    |                                       ^^^^^^^^^^^
413 |         win = main_window
414 |         # Ensure a snippet exists and is selected
    |

ANN001 Missing type annotation for function argument `monkeypatch`
   --> tests\desktop_ui\test_library_main_ui_new.py:412:52
    |
410 |         assert "Failed to update category" in win.status.text() or "failcat2" in win.status.text()
411 |
412 |     def test_edit_snippet_error(self, main_window, monkeypatch):
    |                                                    ^^^^^^^^^^^
413 |         win = main_window
414 |         # Ensure a snippet exists and is selected
    |

ANN202 Missing return type annotation for private function `exec_`
   --> tests\desktop_ui\test_library_main_ui_new.py:420:25
    |
419 |                 class FakeCatDialog:
420 |                     def exec_(self):
    |                         ^^^^^
421 |                         return 1
    |
help: Add return type annotation: `int`

ANN202 Missing return type annotation for private function `get_value`
   --> tests\desktop_ui\test_library_main_ui_new.py:423:25
    |
421 |                         return 1
422 |
423 |                     def get_value(self):
    |                         ^^^^^^^^^
424 |                         return "CatForEditError"
    |
help: Add return type annotation: `str`

ANN202 Missing return type annotation for private function `exec_`
   --> tests\desktop_ui\test_library_main_ui_new.py:431:21
    |
430 |             class FakeAddDialog:
431 |                 def exec_(self):
    |                     ^^^^^
432 |                     return 1
    |
help: Add return type annotation: `int`

ANN202 Missing return type annotation for private function `get_values`
   --> tests\desktop_ui\test_library_main_ui_new.py:434:21
    |
432 |                     return 1
433 |
434 |                 def get_values(self):
    |                     ^^^^^^^^^^
435 |                     return ("SnippetToEditError", "ContentToEditError")
    |
help: Add return type annotation

ANN202 Missing return type annotation for private function `exec_`
   --> tests\desktop_ui\test_library_main_ui_new.py:442:17
    |
441 |         class FakeDialog:
442 |             def exec_(self):
    |                 ^^^^^
443 |                 return 1
    |
help: Add return type annotation: `int`

ANN202 Missing return type annotation for private function `get_values`
   --> tests\desktop_ui\test_library_main_ui_new.py:445:17
    |
443 |                 return 1
444 |
445 |             def get_values(self):
    |                 ^^^^^^^^^^
446 |                 return ("ErrEditSnip", "X")
    |
help: Add return type annotation

ANN202 Missing return type annotation for private function `fail_save_snippet`
   --> tests\desktop_ui\test_library_main_ui_new.py:450:13
    |
448 |         monkeypatch.setattr(library_main, "SnippetDialog", lambda *a, **k: FakeDialog())
449 |
450 |         def fail_save_snippet(snip):
    |             ^^^^^^^^^^^^^^^^^
451 |             raise Exception("failsnip2")
    |
help: Add return type annotation: `Never`

ANN001 Missing type annotation for function argument `snip`
   --> tests\desktop_ui\test_library_main_ui_new.py:450:31
    |
448 |         monkeypatch.setattr(library_main, "SnippetDialog", lambda *a, **k: FakeDialog())
449 |
450 |         def fail_save_snippet(snip):
    |                               ^^^^
451 |             raise Exception("failsnip2")
    |

ANN201 Missing return type annotation for public function `test_delete_category_error`
   --> tests\desktop_ui\test_library_main_ui_new.py:457:9
    |
455 |         assert "Failed to update snippet" in win.status.text() or "failsnip2" in win.status.text()
456 |
457 |     def test_delete_category_error(self, main_window, monkeypatch):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^
458 |         # Ensure a category exists and is selected
459 |         if not main_window.categories:
    |
help: Add return type annotation: `None`

D102 Missing docstring in public method
   --> tests\desktop_ui\test_library_main_ui_new.py:457:9
    |
455 |         assert "Failed to update snippet" in win.status.text() or "failsnip2" in win.status.text()
456 |
457 |     def test_delete_category_error(self, main_window, monkeypatch):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^
458 |         # Ensure a category exists and is selected
459 |         if not main_window.categories:
    |

ANN001 Missing type annotation for function argument `main_window`
   --> tests\desktop_ui\test_library_main_ui_new.py:457:42
    |
455 |         assert "Failed to update snippet" in win.status.text() or "failsnip2" in win.status.text()
456 |
457 |     def test_delete_category_error(self, main_window, monkeypatch):
    |                                          ^^^^^^^^^^^
458 |         # Ensure a category exists and is selected
459 |         if not main_window.categories:
    |

ANN001 Missing type annotation for function argument `monkeypatch`
   --> tests\desktop_ui\test_library_main_ui_new.py:457:55
    |
455 |         assert "Failed to update snippet" in win.status.text() or "failsnip2" in win.status.text()
456 |
457 |     def test_delete_category_error(self, main_window, monkeypatch):
    |                                                       ^^^^^^^^^^^
458 |         # Ensure a category exists and is selected
459 |         if not main_window.categories:
    |

ANN202 Missing return type annotation for private function `exec_`
   --> tests\desktop_ui\test_library_main_ui_new.py:462:21
    |
461 |             class FakeCatDialog:
462 |                 def exec_(self):
    |                     ^^^^^
463 |                     return 1
    |
help: Add return type annotation: `int`

ANN202 Missing return type annotation for private function `get_value`
   --> tests\desktop_ui\test_library_main_ui_new.py:465:21
    |
463 |                     return 1
464 |
465 |                 def get_value(self):
    |                     ^^^^^^^^^
466 |                     return "CatForDeleteError"
    |
help: Add return type annotation: `str`

ANN202 Missing return type annotation for private function `fail_delete_category_by_id`
   --> tests\desktop_ui\test_library_main_ui_new.py:477:13
    |
475 |         )
476 |
477 |         def fail_delete_category_by_id(cid):
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^
478 |             raise Exception("faildelcat")
    |
help: Add return type annotation: `Never`

ANN001 Missing type annotation for function argument `cid`
   --> tests\desktop_ui\test_library_main_ui_new.py:477:40
    |
475 |         )
476 |
477 |         def fail_delete_category_by_id(cid):
    |                                        ^^^
478 |             raise Exception("faildelcat")
    |

ANN201 Missing return type annotation for public function `test_delete_snippet_error`
   --> tests\desktop_ui\test_library_main_ui_new.py:489:9
    |
487 |         )
488 |
489 |     def test_delete_snippet_error(self, main_window, monkeypatch):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^
490 |         win = main_window
491 |         # Ensure a category exists and is selected
    |
help: Add return type annotation: `None`

D102 Missing docstring in public method
   --> tests\desktop_ui\test_library_main_ui_new.py:489:9
    |
487 |         )
488 |
489 |     def test_delete_snippet_error(self, main_window, monkeypatch):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^
490 |         win = main_window
491 |         # Ensure a category exists and is selected
    |

ANN001 Missing type annotation for function argument `main_window`
   --> tests\desktop_ui\test_library_main_ui_new.py:489:41
    |
487 |         )
488 |
489 |     def test_delete_snippet_error(self, main_window, monkeypatch):
    |                                         ^^^^^^^^^^^
490 |         win = main_window
491 |         # Ensure a category exists and is selected
    |

ANN001 Missing type annotation for function argument `monkeypatch`
   --> tests\desktop_ui\test_library_main_ui_new.py:489:54
    |
487 |         )
488 |
489 |     def test_delete_snippet_error(self, main_window, monkeypatch):
    |                                                      ^^^^^^^^^^^
490 |         win = main_window
491 |         # Ensure a category exists and is selected
    |

ANN202 Missing return type annotation for private function `exec_`
   --> tests\desktop_ui\test_library_main_ui_new.py:495:21
    |
494 |             class FakeCatDialog:
495 |                 def exec_(self):
    |                     ^^^^^
496 |                     return 1
    |
help: Add return type annotation: `int`

ANN202 Missing return type annotation for private function `get_value`
   --> tests\desktop_ui\test_library_main_ui_new.py:498:21
    |
496 |                     return 1
497 |
498 |                 def get_value(self):
    |                     ^^^^^^^^^
499 |                     return "CatForDeleteError"
    |
help: Add return type annotation: `str`

ANN202 Missing return type annotation for private function `exec_`
   --> tests\desktop_ui\test_library_main_ui_new.py:508:21
    |
507 |             class FakeSnipDialog:
508 |                 def exec_(self):
    |                     ^^^^^
509 |                     return 1
    |
help: Add return type annotation: `int`

ANN202 Missing return type annotation for private function `get_values`
   --> tests\desktop_ui\test_library_main_ui_new.py:511:21
    |
509 |                     return 1
510 |
511 |                 def get_values(self):
    |                     ^^^^^^^^^^
512 |                     return ("ToDelError", "X")
    |
help: Add return type annotation

ANN202 Missing return type annotation for private function `fail_delete_snippet`
   --> tests\desktop_ui\test_library_main_ui_new.py:519:13
    |
517 |         monkeypatch.setattr("PySide6.QtWidgets.QMessageBox.question", lambda *a, **k: 16384)  # Yes
518 |
519 |         def fail_delete_snippet(sid):
    |             ^^^^^^^^^^^^^^^^^^^
520 |             raise Exception("faildelsnip")
    |
help: Add return type annotation: `Never`

ANN001 Missing type annotation for function argument `sid`
   --> tests\desktop_ui\test_library_main_ui_new.py:519:33
    |
517 |         monkeypatch.setattr("PySide6.QtWidgets.QMessageBox.question", lambda *a, **k: 16384)  # Yes
518 |
519 |         def fail_delete_snippet(sid):
    |                                 ^^^
520 |             raise Exception("faildelsnip")
    |

ANN201 Missing return type annotation for public function `test_load_data_error`
   --> tests\desktop_ui\test_library_main_ui_new.py:526:9
    |
524 |         assert "Failed to delete snippet" in win.status.text() or "faildelsnip" in win.status.text()
525 |
526 |     def test_load_data_error(self, main_window, monkeypatch):
    |         ^^^^^^^^^^^^^^^^^^^^
527 |         win = main_window
528 |         monkeypatch.setattr(
    |
help: Add return type annotation: `None`

D102 Missing docstring in public method
   --> tests\desktop_ui\test_library_main_ui_new.py:526:9
    |
524 |         assert "Failed to delete snippet" in win.status.text() or "faildelsnip" in win.status.text()
525 |
526 |     def test_load_data_error(self, main_window, monkeypatch):
    |         ^^^^^^^^^^^^^^^^^^^^
527 |         win = main_window
528 |         monkeypatch.setattr(
    |

ANN001 Missing type annotation for function argument `main_window`
   --> tests\desktop_ui\test_library_main_ui_new.py:526:36
    |
524 |         assert "Failed to delete snippet" in win.status.text() or "faildelsnip" in win.status.text()
525 |
526 |     def test_load_data_error(self, main_window, monkeypatch):
    |                                    ^^^^^^^^^^^
527 |         win = main_window
528 |         monkeypatch.setattr(
    |

ANN001 Missing type annotation for function argument `monkeypatch`
   --> tests\desktop_ui\test_library_main_ui_new.py:526:49
    |
524 |         assert "Failed to delete snippet" in win.status.text() or "faildelsnip" in win.status.text()
525 |
526 |     def test_load_data_error(self, main_window, monkeypatch):
    |                                                 ^^^^^^^^^^^
527 |         win = main_window
528 |         monkeypatch.setattr(
    |

ANN201 Missing return type annotation for public function `test_load_snippets_error`
   --> tests\desktop_ui\test_library_main_ui_new.py:536:9
    |
534 |         assert "Error loading data" in win.status.text()
535 |
536 |     def test_load_snippets_error(self, main_window, monkeypatch):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^
537 |         win = main_window
538 |         win.categoryList.setCurrentRow(0)
    |
help: Add return type annotation: `None`

D102 Missing docstring in public method
   --> tests\desktop_ui\test_library_main_ui_new.py:536:9
    |
534 |         assert "Error loading data" in win.status.text()
535 |
536 |     def test_load_snippets_error(self, main_window, monkeypatch):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^
537 |         win = main_window
538 |         win.categoryList.setCurrentRow(0)
    |

ANN001 Missing type annotation for function argument `main_window`
   --> tests\desktop_ui\test_library_main_ui_new.py:536:40
    |
534 |         assert "Error loading data" in win.status.text()
535 |
536 |     def test_load_snippets_error(self, main_window, monkeypatch):
    |                                        ^^^^^^^^^^^
537 |         win = main_window
538 |         win.categoryList.setCurrentRow(0)
    |

ANN001 Missing type annotation for function argument `monkeypatch`
   --> tests\desktop_ui\test_library_main_ui_new.py:536:53
    |
534 |         assert "Error loading data" in win.status.text()
535 |
536 |     def test_load_snippets_error(self, main_window, monkeypatch):
    |                                                     ^^^^^^^^^^^
537 |         win = main_window
538 |         win.categoryList.setCurrentRow(0)
    |

ANN201 Missing return type annotation for public function `test_window_initialization`
   --> tests\desktop_ui\test_library_main_ui_new.py:551:5
    |
551 | def test_window_initialization(main_window):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^
552 |     """Test that the main window initializes with the correct default state.
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `main_window`
   --> tests\desktop_ui\test_library_main_ui_new.py:551:32
    |
551 | def test_window_initialization(main_window):
    |                                ^^^^^^^^^^^
552 |     """Test that the main window initializes with the correct default state.
    |

ANN201 Missing return type annotation for public function `test_add_category_ui`
   --> tests\desktop_ui\test_library_main_ui_new.py:597:5
    |
597 | def test_add_category_ui(main_window, monkeypatch):
    |     ^^^^^^^^^^^^^^^^^^^^
598 |     # Simulate CategoryDialog returning Accepted and a name
599 |     class FakeDialog:
    |
help: Add return type annotation: `None`

D103 Missing docstring in public function
   --> tests\desktop_ui\test_library_main_ui_new.py:597:5
    |
597 | def test_add_category_ui(main_window, monkeypatch):
    |     ^^^^^^^^^^^^^^^^^^^^
598 |     # Simulate CategoryDialog returning Accepted and a name
599 |     class FakeDialog:
    |

ANN001 Missing type annotation for function argument `main_window`
   --> tests\desktop_ui\test_library_main_ui_new.py:597:26
    |
597 | def test_add_category_ui(main_window, monkeypatch):
    |                          ^^^^^^^^^^^
598 |     # Simulate CategoryDialog returning Accepted and a name
599 |     class FakeDialog:
    |

ANN001 Missing type annotation for function argument `monkeypatch`
   --> tests\desktop_ui\test_library_main_ui_new.py:597:39
    |
597 | def test_add_category_ui(main_window, monkeypatch):
    |                                       ^^^^^^^^^^^
598 |     # Simulate CategoryDialog returning Accepted and a name
599 |     class FakeDialog:
    |

ANN202 Missing return type annotation for private function `exec_`
   --> tests\desktop_ui\test_library_main_ui_new.py:600:13
    |
598 |     # Simulate CategoryDialog returning Accepted and a name
599 |     class FakeDialog:
600 |         def exec_(self):
    |             ^^^^^
601 |             return 1  # Accepted
    |
help: Add return type annotation: `int`

ANN202 Missing return type annotation for private function `get_value`
   --> tests\desktop_ui\test_library_main_ui_new.py:603:13
    |
601 |             return 1  # Accepted
602 |
603 |         def get_value(self):
    |             ^^^^^^^^^
604 |             return "UI Cat"
    |
help: Add return type annotation: `str`

ANN201 Missing return type annotation for public function `test_edit_category_ui`
   --> tests\desktop_ui\test_library_main_ui_new.py:612:5
    |
612 | def test_edit_category_ui(main_window, monkeypatch):
    |     ^^^^^^^^^^^^^^^^^^^^^
613 |     # Ensure there is at least one category to edit
614 |     if not main_window.categories:
    |
help: Add return type annotation: `None`

D103 Missing docstring in public function
   --> tests\desktop_ui\test_library_main_ui_new.py:612:5
    |
612 | def test_edit_category_ui(main_window, monkeypatch):
    |     ^^^^^^^^^^^^^^^^^^^^^
613 |     # Ensure there is at least one category to edit
614 |     if not main_window.categories:
    |

ANN001 Missing type annotation for function argument `main_window`
   --> tests\desktop_ui\test_library_main_ui_new.py:612:27
    |
612 | def test_edit_category_ui(main_window, monkeypatch):
    |                           ^^^^^^^^^^^
613 |     # Ensure there is at least one category to edit
614 |     if not main_window.categories:
    |

ANN001 Missing type annotation for function argument `monkeypatch`
   --> tests\desktop_ui\test_library_main_ui_new.py:612:40
    |
612 | def test_edit_category_ui(main_window, monkeypatch):
    |                                        ^^^^^^^^^^^
613 |     # Ensure there is at least one category to edit
614 |     if not main_window.categories:
    |

ANN202 Missing return type annotation for private function `exec_`
   --> tests\desktop_ui\test_library_main_ui_new.py:617:17
    |
616 |         class FakeAddDialog:
617 |             def exec_(self):
    |                 ^^^^^
618 |                 return 1
    |
help: Add return type annotation: `int`

ANN202 Missing return type annotation for private function `get_value`
   --> tests\desktop_ui\test_library_main_ui_new.py:620:17
    |
618 |                 return 1
619 |
620 |             def get_value(self):
    |                 ^^^^^^^^^
621 |                 return "Initial Cat"
    |
help: Add return type annotation: `str`

ANN202 Missing return type annotation for private function `exec_`
   --> tests\desktop_ui\test_library_main_ui_new.py:629:13
    |
628 |     class FakeEditDialog:
629 |         def exec_(self):
    |             ^^^^^
630 |             return 1
    |
help: Add return type annotation: `int`

ANN202 Missing return type annotation for private function `get_value`
   --> tests\desktop_ui\test_library_main_ui_new.py:632:13
    |
630 |             return 1
631 |
632 |         def get_value(self):
    |             ^^^^^^^^^
633 |             return "Renamed Cat"
    |
help: Add return type annotation: `str`

ANN201 Missing return type annotation for public function `test_delete_category_ui`
   --> tests\desktop_ui\test_library_main_ui_new.py:641:5
    |
641 | def test_delete_category_ui(main_window, monkeypatch):
    |     ^^^^^^^^^^^^^^^^^^^^^^^
642 |     # Add a category to delete
643 |     cat = library_main.Category(category_name="ToDelete", description="")
    |
help: Add return type annotation: `None`

D103 Missing docstring in public function
   --> tests\desktop_ui\test_library_main_ui_new.py:641:5
    |
641 | def test_delete_category_ui(main_window, monkeypatch):
    |     ^^^^^^^^^^^^^^^^^^^^^^^
642 |     # Add a category to delete
643 |     cat = library_main.Category(category_name="ToDelete", description="")
    |

ANN001 Missing type annotation for function argument `main_window`
   --> tests\desktop_ui\test_library_main_ui_new.py:641:29
    |
641 | def test_delete_category_ui(main_window, monkeypatch):
    |                             ^^^^^^^^^^^
642 |     # Add a category to delete
643 |     cat = library_main.Category(category_name="ToDelete", description="")
    |

ANN001 Missing type annotation for function argument `monkeypatch`
   --> tests\desktop_ui\test_library_main_ui_new.py:641:42
    |
641 | def test_delete_category_ui(main_window, monkeypatch):
    |                                          ^^^^^^^^^^^
642 |     # Add a category to delete
643 |     cat = library_main.Category(category_name="ToDelete", description="")
    |

ANN201 Missing return type annotation for public function `test_add_snippet_ui`
   --> tests\desktop_ui\test_library_main_ui_new.py:660:5
    |
660 | def test_add_snippet_ui(main_window, monkeypatch):
    |     ^^^^^^^^^^^^^^^^^^^
661 |     # Ensure a category exists and is selected
662 |     if not main_window.categories:
    |
help: Add return type annotation: `None`

D103 Missing docstring in public function
   --> tests\desktop_ui\test_library_main_ui_new.py:660:5
    |
660 | def test_add_snippet_ui(main_window, monkeypatch):
    |     ^^^^^^^^^^^^^^^^^^^
661 |     # Ensure a category exists and is selected
662 |     if not main_window.categories:
    |

ANN001 Missing type annotation for function argument `main_window`
   --> tests\desktop_ui\test_library_main_ui_new.py:660:25
    |
660 | def test_add_snippet_ui(main_window, monkeypatch):
    |                         ^^^^^^^^^^^
661 |     # Ensure a category exists and is selected
662 |     if not main_window.categories:
    |

ANN001 Missing type annotation for function argument `monkeypatch`
   --> tests\desktop_ui\test_library_main_ui_new.py:660:38
    |
660 | def test_add_snippet_ui(main_window, monkeypatch):
    |                                      ^^^^^^^^^^^
661 |     # Ensure a category exists and is selected
662 |     if not main_window.categories:
    |

ANN202 Missing return type annotation for private function `exec_`
   --> tests\desktop_ui\test_library_main_ui_new.py:665:17
    |
664 |         class FakeCatDialog:
665 |             def exec_(self):
    |                 ^^^^^
666 |                 return 1
    |
help: Add return type annotation: `int`

ANN202 Missing return type annotation for private function `get_value`
   --> tests\desktop_ui\test_library_main_ui_new.py:668:17
    |
666 |                 return 1
667 |
668 |             def get_value(self):
    |                 ^^^^^^^^^
669 |                 return "CatForSnippet"
    |
help: Add return type annotation: `str`

ANN202 Missing return type annotation for private function `exec_`
   --> tests\desktop_ui\test_library_main_ui_new.py:676:13
    |
675 |     class FakeDialog:
676 |         def exec_(self):
    |             ^^^^^
677 |             return 1
    |
help: Add return type annotation: `int`

ANN202 Missing return type annotation for private function `get_values`
   --> tests\desktop_ui\test_library_main_ui_new.py:679:13
    |
677 |             return 1
678 |
679 |         def get_values(self):
    |             ^^^^^^^^^^
680 |             return ("SnippetA", "ContentA")
    |
help: Add return type annotation

ANN201 Missing return type annotation for public function `test_edit_snippet_ui`
   --> tests\desktop_ui\test_library_main_ui_new.py:688:5
    |
688 | def test_edit_snippet_ui(main_window, monkeypatch):
    |     ^^^^^^^^^^^^^^^^^^^^
689 |     # Ensure there is at least one snippet to edit
690 |     if not main_window.snippets:
    |
help: Add return type annotation: `None`

D103 Missing docstring in public function
   --> tests\desktop_ui\test_library_main_ui_new.py:688:5
    |
688 | def test_edit_snippet_ui(main_window, monkeypatch):
    |     ^^^^^^^^^^^^^^^^^^^^
689 |     # Ensure there is at least one snippet to edit
690 |     if not main_window.snippets:
    |

ANN001 Missing type annotation for function argument `main_window`
   --> tests\desktop_ui\test_library_main_ui_new.py:688:26
    |
688 | def test_edit_snippet_ui(main_window, monkeypatch):
    |                          ^^^^^^^^^^^
689 |     # Ensure there is at least one snippet to edit
690 |     if not main_window.snippets:
    |

ANN001 Missing type annotation for function argument `monkeypatch`
   --> tests\desktop_ui\test_library_main_ui_new.py:688:39
    |
688 | def test_edit_snippet_ui(main_window, monkeypatch):
    |                                       ^^^^^^^^^^^
689 |     # Ensure there is at least one snippet to edit
690 |     if not main_window.snippets:
    |

ANN202 Missing return type annotation for private function `exec_`
   --> tests\desktop_ui\test_library_main_ui_new.py:695:21
    |
694 |             class FakeCatDialog:
695 |                 def exec_(self):
    |                     ^^^^^
696 |                     return 1
    |
help: Add return type annotation: `int`

ANN202 Missing return type annotation for private function `get_value`
   --> tests\desktop_ui\test_library_main_ui_new.py:698:21
    |
696 |                     return 1
697 |
698 |                 def get_value(self):
    |                     ^^^^^^^^^
699 |                     return "CatForEdit"
    |
help: Add return type annotation: `str`

ANN202 Missing return type annotation for private function `exec_`
   --> tests\desktop_ui\test_library_main_ui_new.py:706:17
    |
705 |         class FakeAddDialog:
706 |             def exec_(self):
    |                 ^^^^^
707 |                 return 1
    |
help: Add return type annotation: `int`

ANN202 Missing return type annotation for private function `get_values`
   --> tests\desktop_ui\test_library_main_ui_new.py:709:17
    |
707 |                 return 1
708 |
709 |             def get_values(self):
    |                 ^^^^^^^^^^
710 |                 return ("SnippetToEdit", "ContentToEdit")
    |
help: Add return type annotation

ANN202 Missing return type annotation for private function `exec_`
   --> tests\desktop_ui\test_library_main_ui_new.py:717:13
    |
716 |     class FakeEditDialog:
717 |         def exec_(self):
    |             ^^^^^
718 |             return 1
    |
help: Add return type annotation: `int`

ANN202 Missing return type annotation for private function `get_values`
   --> tests\desktop_ui\test_library_main_ui_new.py:720:13
    |
718 |             return 1
719 |
720 |         def get_values(self):
    |             ^^^^^^^^^^
721 |             return ("SnippetA-Edit", "ContentA-Edit")
    |
help: Add return type annotation

ANN201 Missing return type annotation for public function `test_delete_snippet_ui`
   --> tests\desktop_ui\test_library_main_ui_new.py:729:5
    |
729 | def test_delete_snippet_ui(main_window, monkeypatch):
    |     ^^^^^^^^^^^^^^^^^^^^^^
730 |     # Ensure a category exists and is selected
731 |     if not main_window.categories:
    |
help: Add return type annotation: `None`

D103 Missing docstring in public function
   --> tests\desktop_ui\test_library_main_ui_new.py:729:5
    |
729 | def test_delete_snippet_ui(main_window, monkeypatch):
    |     ^^^^^^^^^^^^^^^^^^^^^^
730 |     # Ensure a category exists and is selected
731 |     if not main_window.categories:
    |

ANN001 Missing type annotation for function argument `main_window`
   --> tests\desktop_ui\test_library_main_ui_new.py:729:28
    |
729 | def test_delete_snippet_ui(main_window, monkeypatch):
    |                            ^^^^^^^^^^^
730 |     # Ensure a category exists and is selected
731 |     if not main_window.categories:
    |

ANN001 Missing type annotation for function argument `monkeypatch`
   --> tests\desktop_ui\test_library_main_ui_new.py:729:41
    |
729 | def test_delete_snippet_ui(main_window, monkeypatch):
    |                                         ^^^^^^^^^^^
730 |     # Ensure a category exists and is selected
731 |     if not main_window.categories:
    |

ANN202 Missing return type annotation for private function `exec_`
   --> tests\desktop_ui\test_library_main_ui_new.py:734:17
    |
733 |         class FakeCatDialog:
734 |             def exec_(self):
    |                 ^^^^^
735 |                 return 1
    |
help: Add return type annotation: `int`

ANN202 Missing return type annotation for private function `get_value`
   --> tests\desktop_ui\test_library_main_ui_new.py:737:17
    |
735 |                 return 1
736 |
737 |             def get_value(self):
    |                 ^^^^^^^^^
738 |                 return "CatForDelete"
    |
help: Add return type annotation: `str`

ANN202 Missing return type annotation for private function `exec_`
   --> tests\desktop_ui\test_library_main_ui_new.py:747:17
    |
746 |         class FakeSnipDialog:
747 |             def exec_(self):
    |                 ^^^^^
748 |                 return 1
    |
help: Add return type annotation: `int`

ANN202 Missing return type annotation for private function `get_values`
   --> tests\desktop_ui\test_library_main_ui_new.py:750:17
    |
748 |                 return 1
749 |
750 |             def get_values(self):
    |                 ^^^^^^^^^^
751 |                 return ("ToDel", "X")
    |
help: Add return type annotation

ANN201 Missing return type annotation for public function `test_filter_snippets`
   --> tests\desktop_ui\test_library_main_ui_new.py:766:5
    |
766 | def test_filter_snippets(main_window):
    |     ^^^^^^^^^^^^^^^^^^^^
767 |     main_window.search_input.setText("Edit")
768 |     # Should only show snippets with 'Edit' in name
    |
help: Add return type annotation: `None`

D103 Missing docstring in public function
   --> tests\desktop_ui\test_library_main_ui_new.py:766:5
    |
766 | def test_filter_snippets(main_window):
    |     ^^^^^^^^^^^^^^^^^^^^
767 |     main_window.search_input.setText("Edit")
768 |     # Should only show snippets with 'Edit' in name
    |

ANN001 Missing type annotation for function argument `main_window`
   --> tests\desktop_ui\test_library_main_ui_new.py:766:26
    |
766 | def test_filter_snippets(main_window):
    |                          ^^^^^^^^^^^
767 |     main_window.search_input.setText("Edit")
768 |     # Should only show snippets with 'Edit' in name
    |

ANN201 Missing return type annotation for public function `test_show_error_and_info`
   --> tests\desktop_ui\test_library_main_ui_new.py:775:5
    |
775 | def test_show_error_and_info(main_window):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^
776 |     main_window.show_error("errormsg")
777 |     assert main_window.status.text() == "errormsg"
    |
help: Add return type annotation: `None`

D103 Missing docstring in public function
   --> tests\desktop_ui\test_library_main_ui_new.py:775:5
    |
775 | def test_show_error_and_info(main_window):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^
776 |     main_window.show_error("errormsg")
777 |     assert main_window.status.text() == "errormsg"
    |

ANN001 Missing type annotation for function argument `main_window`
   --> tests\desktop_ui\test_library_main_ui_new.py:775:30
    |
775 | def test_show_error_and_info(main_window):
    |                              ^^^^^^^^^^^
776 |     main_window.show_error("errormsg")
777 |     assert main_window.status.text() == "errormsg"
    |

ANN201 Missing return type annotation for public function `test_update_snippet_buttons_state`
   --> tests\desktop_ui\test_library_main_ui_new.py:782:5
    |
782 | def test_update_snippet_buttons_state(main_window):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
783 |     main_window.update_snippet_buttons_state(True)
784 |     assert main_window.addSnipBtn.isEnabled()
    |
help: Add return type annotation: `None`

D103 Missing docstring in public function
   --> tests\desktop_ui\test_library_main_ui_new.py:782:5
    |
782 | def test_update_snippet_buttons_state(main_window):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
783 |     main_window.update_snippet_buttons_state(True)
784 |     assert main_window.addSnipBtn.isEnabled()
    |

ANN001 Missing type annotation for function argument `main_window`
   --> tests\desktop_ui\test_library_main_ui_new.py:782:39
    |
782 | def test_update_snippet_buttons_state(main_window):
    |                                       ^^^^^^^^^^^
783 |     main_window.update_snippet_buttons_state(True)
784 |     assert main_window.addSnipBtn.isEnabled()
    |

ANN201 Missing return type annotation for public function `test_add_category_error`
   --> tests\desktop_ui\test_library_main_ui_new.py:789:5
    |
789 | def test_add_category_error(monkeypatch, main_window):
    |     ^^^^^^^^^^^^^^^^^^^^^^^
790 |     class FakeDialog:
791 |         def exec_(self):
    |
help: Add return type annotation: `None`

D103 Missing docstring in public function
   --> tests\desktop_ui\test_library_main_ui_new.py:789:5
    |
789 | def test_add_category_error(monkeypatch, main_window):
    |     ^^^^^^^^^^^^^^^^^^^^^^^
790 |     class FakeDialog:
791 |         def exec_(self):
    |

ANN001 Missing type annotation for function argument `monkeypatch`
   --> tests\desktop_ui\test_library_main_ui_new.py:789:29
    |
789 | def test_add_category_error(monkeypatch, main_window):
    |                             ^^^^^^^^^^^
790 |     class FakeDialog:
791 |         def exec_(self):
    |

ANN001 Missing type annotation for function argument `main_window`
   --> tests\desktop_ui\test_library_main_ui_new.py:789:42
    |
789 | def test_add_category_error(monkeypatch, main_window):
    |                                          ^^^^^^^^^^^
790 |     class FakeDialog:
791 |         def exec_(self):
    |

ANN202 Missing return type annotation for private function `exec_`
   --> tests\desktop_ui\test_library_main_ui_new.py:791:13
    |
789 | def test_add_category_error(monkeypatch, main_window):
790 |     class FakeDialog:
791 |         def exec_(self):
    |             ^^^^^
792 |             return 1
    |
help: Add return type annotation: `int`

ANN202 Missing return type annotation for private function `get_value`
   --> tests\desktop_ui\test_library_main_ui_new.py:794:13
    |
792 |             return 1
793 |
794 |         def get_value(self):
    |             ^^^^^^^^^
795 |             return "ErrorCat"
    |
help: Add return type annotation: `str`

ANN202 Missing return type annotation for private function `fail_save_category`
   --> tests\desktop_ui\test_library_main_ui_new.py:799:9
    |
797 |     monkeypatch.setattr(library_main, "CategoryDialog", lambda *a, **k: FakeDialog())
798 |
799 |     def fail_save_category(cat):
    |         ^^^^^^^^^^^^^^^^^^
800 |         raise Exception("failcat")
    |
help: Add return type annotation: `Never`

ANN001 Missing type annotation for function argument `cat`
   --> tests\desktop_ui\test_library_main_ui_new.py:799:28
    |
797 |     monkeypatch.setattr(library_main, "CategoryDialog", lambda *a, **k: FakeDialog())
798 |
799 |     def fail_save_category(cat):
    |                            ^^^
800 |         raise Exception("failcat")
    |

ANN201 Missing return type annotation for public function `test_add_snippet_error`
   --> tests\desktop_ui\test_library_main_ui_new.py:807:5
    |
807 | def test_add_snippet_error(monkeypatch, main_window):
    |     ^^^^^^^^^^^^^^^^^^^^^^
808 |     # Ensure a category exists and is selected
809 |     if not main_window.categories:
    |
help: Add return type annotation: `None`

D103 Missing docstring in public function
   --> tests\desktop_ui\test_library_main_ui_new.py:807:5
    |
807 | def test_add_snippet_error(monkeypatch, main_window):
    |     ^^^^^^^^^^^^^^^^^^^^^^
808 |     # Ensure a category exists and is selected
809 |     if not main_window.categories:
    |

ANN001 Missing type annotation for function argument `monkeypatch`
   --> tests\desktop_ui\test_library_main_ui_new.py:807:28
    |
807 | def test_add_snippet_error(monkeypatch, main_window):
    |                            ^^^^^^^^^^^
808 |     # Ensure a category exists and is selected
809 |     if not main_window.categories:
    |

ANN001 Missing type annotation for function argument `main_window`
   --> tests\desktop_ui\test_library_main_ui_new.py:807:41
    |
807 | def test_add_snippet_error(monkeypatch, main_window):
    |                                         ^^^^^^^^^^^
808 |     # Ensure a category exists and is selected
809 |     if not main_window.categories:
    |

ANN202 Missing return type annotation for private function `exec_`
   --> tests\desktop_ui\test_library_main_ui_new.py:812:17
    |
811 |         class FakeCatDialog:
812 |             def exec_(self):
    |                 ^^^^^
813 |                 return 1
    |
help: Add return type annotation: `int`

ANN202 Missing return type annotation for private function `get_value`
   --> tests\desktop_ui\test_library_main_ui_new.py:815:17
    |
813 |                 return 1
814 |
815 |             def get_value(self):
    |                 ^^^^^^^^^
816 |                 return "CatForError"
    |
help: Add return type annotation: `str`

ANN202 Missing return type annotation for private function `exec_`
   --> tests\desktop_ui\test_library_main_ui_new.py:823:13
    |
822 |     class FakeDialog:
823 |         def exec_(self):
    |             ^^^^^
824 |             return 1
    |
help: Add return type annotation: `int`

ANN202 Missing return type annotation for private function `get_values`
   --> tests\desktop_ui\test_library_main_ui_new.py:826:13
    |
824 |             return 1
825 |
826 |         def get_values(self):
    |             ^^^^^^^^^^
827 |             return ("ErrSnip", "X")
    |
help: Add return type annotation

ANN202 Missing return type annotation for private function `fail_save_snippet`
   --> tests\desktop_ui\test_library_main_ui_new.py:831:9
    |
829 |     monkeypatch.setattr(library_main, "SnippetDialog", lambda *a, **k: FakeDialog())
830 |
831 |     def fail_save_snippet(snip):
    |         ^^^^^^^^^^^^^^^^^
832 |         raise Exception("failsnip")
    |
help: Add return type annotation: `Never`

ANN001 Missing type annotation for function argument `snip`
   --> tests\desktop_ui\test_library_main_ui_new.py:831:27
    |
829 |     monkeypatch.setattr(library_main, "SnippetDialog", lambda *a, **k: FakeDialog())
830 |
831 |     def fail_save_snippet(snip):
    |                           ^^^^
832 |         raise Exception("failsnip")
    |

ANN201 Missing return type annotation for public function `test_edit_category_no_selection`
   --> tests\desktop_ui\test_library_main_ui_new.py:839:5
    |
839 | def test_edit_category_no_selection(main_window):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
840 |     main_window.categoryList.clearSelection()
841 |     main_window.edit_category()
    |
help: Add return type annotation: `None`

D103 Missing docstring in public function
   --> tests\desktop_ui\test_library_main_ui_new.py:839:5
    |
839 | def test_edit_category_no_selection(main_window):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
840 |     main_window.categoryList.clearSelection()
841 |     main_window.edit_category()
    |

ANN001 Missing type annotation for function argument `main_window`
   --> tests\desktop_ui\test_library_main_ui_new.py:839:37
    |
839 | def test_edit_category_no_selection(main_window):
    |                                     ^^^^^^^^^^^
840 |     main_window.categoryList.clearSelection()
841 |     main_window.edit_category()
    |

ANN201 Missing return type annotation for public function `test_delete_category_no_selection`
   --> tests\desktop_ui\test_library_main_ui_new.py:845:5
    |
845 | def test_delete_category_no_selection(main_window):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
846 |     main_window.categoryList.clearSelection()
847 |     main_window.delete_category()
    |
help: Add return type annotation: `None`

D103 Missing docstring in public function
   --> tests\desktop_ui\test_library_main_ui_new.py:845:5
    |
845 | def test_delete_category_no_selection(main_window):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
846 |     main_window.categoryList.clearSelection()
847 |     main_window.delete_category()
    |

ANN001 Missing type annotation for function argument `main_window`
   --> tests\desktop_ui\test_library_main_ui_new.py:845:39
    |
845 | def test_delete_category_no_selection(main_window):
    |                                       ^^^^^^^^^^^
846 |     main_window.categoryList.clearSelection()
847 |     main_window.delete_category()
    |

ANN201 Missing return type annotation for public function `test_add_snippet_no_category`
   --> tests\desktop_ui\test_library_main_ui_new.py:851:5
    |
851 | def test_add_snippet_no_category(main_window):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
852 |     main_window.selected_category = None
853 |     main_window.add_snippet()
    |
help: Add return type annotation: `None`

D103 Missing docstring in public function
   --> tests\desktop_ui\test_library_main_ui_new.py:851:5
    |
851 | def test_add_snippet_no_category(main_window):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
852 |     main_window.selected_category = None
853 |     main_window.add_snippet()
    |

ANN001 Missing type annotation for function argument `main_window`
   --> tests\desktop_ui\test_library_main_ui_new.py:851:34
    |
851 | def test_add_snippet_no_category(main_window):
    |                                  ^^^^^^^^^^^
852 |     main_window.selected_category = None
853 |     main_window.add_snippet()
    |

ANN201 Missing return type annotation for public function `test_edit_snippet_no_selection`
   --> tests\desktop_ui\test_library_main_ui_new.py:857:5
    |
857 | def test_edit_snippet_no_selection(main_window):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
858 |     main_window.snippetList.clearSelection()
859 |     main_window.edit_snippet()
    |
help: Add return type annotation: `None`

D103 Missing docstring in public function
   --> tests\desktop_ui\test_library_main_ui_new.py:857:5
    |
857 | def test_edit_snippet_no_selection(main_window):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
858 |     main_window.snippetList.clearSelection()
859 |     main_window.edit_snippet()
    |

ANN001 Missing type annotation for function argument `main_window`
   --> tests\desktop_ui\test_library_main_ui_new.py:857:36
    |
857 | def test_edit_snippet_no_selection(main_window):
    |                                    ^^^^^^^^^^^
858 |     main_window.snippetList.clearSelection()
859 |     main_window.edit_snippet()
    |

ANN201 Missing return type annotation for public function `test_delete_snippet_no_selection`
   --> tests\desktop_ui\test_library_main_ui_new.py:863:5
    |
863 | def test_delete_snippet_no_selection(main_window):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
864 |     main_window.snippetList.clearSelection()
865 |     main_window.delete_snippet()
    |
help: Add return type annotation: `None`

D103 Missing docstring in public function
   --> tests\desktop_ui\test_library_main_ui_new.py:863:5
    |
863 | def test_delete_snippet_no_selection(main_window):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
864 |     main_window.snippetList.clearSelection()
865 |     main_window.delete_snippet()
    |

ANN001 Missing type annotation for function argument `main_window`
   --> tests\desktop_ui\test_library_main_ui_new.py:863:38
    |
863 | def test_delete_snippet_no_selection(main_window):
    |                                      ^^^^^^^^^^^
864 |     main_window.snippetList.clearSelection()
865 |     main_window.delete_snippet()
    |

ANN201 Missing return type annotation for public function `test_edit_category_error`
   --> tests\desktop_ui\test_library_main_ui_new.py:869:5
    |
869 | def test_edit_category_error(monkeypatch, main_window):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^
870 |     # Ensure a category exists and is selected
871 |     if not main_window.categories:
    |
help: Add return type annotation: `None`

D103 Missing docstring in public function
   --> tests\desktop_ui\test_library_main_ui_new.py:869:5
    |
869 | def test_edit_category_error(monkeypatch, main_window):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^
870 |     # Ensure a category exists and is selected
871 |     if not main_window.categories:
    |

ANN001 Missing type annotation for function argument `monkeypatch`
   --> tests\desktop_ui\test_library_main_ui_new.py:869:30
    |
869 | def test_edit_category_error(monkeypatch, main_window):
    |                              ^^^^^^^^^^^
870 |     # Ensure a category exists and is selected
871 |     if not main_window.categories:
    |

ANN001 Missing type annotation for function argument `main_window`
   --> tests\desktop_ui\test_library_main_ui_new.py:869:43
    |
869 | def test_edit_category_error(monkeypatch, main_window):
    |                                           ^^^^^^^^^^^
870 |     # Ensure a category exists and is selected
871 |     if not main_window.categories:
    |

ANN202 Missing return type annotation for private function `exec_`
   --> tests\desktop_ui\test_library_main_ui_new.py:874:17
    |
873 |         class FakeCatDialog:
874 |             def exec_(self):
    |                 ^^^^^
875 |                 return 1
    |
help: Add return type annotation: `int`

ANN202 Missing return type annotation for private function `get_value`
   --> tests\desktop_ui\test_library_main_ui_new.py:877:17
    |
875 |                 return 1
876 |
877 |             def get_value(self):
    |                 ^^^^^^^^^
878 |                 return "ErrEditCat"
    |
help: Add return type annotation: `str`

ANN202 Missing return type annotation for private function `exec_`
   --> tests\desktop_ui\test_library_main_ui_new.py:885:13
    |
884 |     class FakeDialog:
885 |         def exec_(self):
    |             ^^^^^
886 |             return 1
    |
help: Add return type annotation: `int`

ANN202 Missing return type annotation for private function `get_value`
   --> tests\desktop_ui\test_library_main_ui_new.py:888:13
    |
886 |             return 1
887 |
888 |         def get_value(self):
    |             ^^^^^^^^^
889 |             return "ErrEditCat"
    |
help: Add return type annotation: `str`

ANN202 Missing return type annotation for private function `fail_save_category`
   --> tests\desktop_ui\test_library_main_ui_new.py:893:9
    |
891 |     monkeypatch.setattr(library_main, "CategoryDialog", lambda *a, **k: FakeDialog())
892 |
893 |     def fail_save_category(cat):
    |         ^^^^^^^^^^^^^^^^^^
894 |         raise Exception("failcat2")
    |
help: Add return type annotation: `Never`

ANN001 Missing type annotation for function argument `cat`
   --> tests\desktop_ui\test_library_main_ui_new.py:893:28
    |
891 |     monkeypatch.setattr(library_main, "CategoryDialog", lambda *a, **k: FakeDialog())
892 |
893 |     def fail_save_category(cat):
    |                            ^^^
894 |         raise Exception("failcat2")
    |

ANN201 Missing return type annotation for public function `test_edit_snippet_error`
   --> tests\desktop_ui\test_library_main_ui_new.py:904:5
    |
904 | def test_edit_snippet_error(monkeypatch, main_window):
    |     ^^^^^^^^^^^^^^^^^^^^^^^
905 |     # Ensure a snippet exists and is selected
906 |     if not main_window.snippets:
    |
help: Add return type annotation: `None`

D103 Missing docstring in public function
   --> tests\desktop_ui\test_library_main_ui_new.py:904:5
    |
904 | def test_edit_snippet_error(monkeypatch, main_window):
    |     ^^^^^^^^^^^^^^^^^^^^^^^
905 |     # Ensure a snippet exists and is selected
906 |     if not main_window.snippets:
    |

ANN001 Missing type annotation for function argument `monkeypatch`
   --> tests\desktop_ui\test_library_main_ui_new.py:904:29
    |
904 | def test_edit_snippet_error(monkeypatch, main_window):
    |                             ^^^^^^^^^^^
905 |     # Ensure a snippet exists and is selected
906 |     if not main_window.snippets:
    |

ANN001 Missing type annotation for function argument `main_window`
   --> tests\desktop_ui\test_library_main_ui_new.py:904:42
    |
904 | def test_edit_snippet_error(monkeypatch, main_window):
    |                                          ^^^^^^^^^^^
905 |     # Ensure a snippet exists and is selected
906 |     if not main_window.snippets:
    |

ANN202 Missing return type annotation for private function `exec_`
   --> tests\desktop_ui\test_library_main_ui_new.py:911:21
    |
910 |             class FakeCatDialog:
911 |                 def exec_(self):
    |                     ^^^^^
912 |                     return 1
    |
help: Add return type annotation: `int`

ANN202 Missing return type annotation for private function `get_value`
   --> tests\desktop_ui\test_library_main_ui_new.py:914:21
    |
912 |                     return 1
913 |
914 |                 def get_value(self):
    |                     ^^^^^^^^^
915 |                     return "CatForEditError"
    |
help: Add return type annotation: `str`

ANN202 Missing return type annotation for private function `exec_`
   --> tests\desktop_ui\test_library_main_ui_new.py:922:17
    |
921 |         class FakeAddDialog:
922 |             def exec_(self):
    |                 ^^^^^
923 |                 return 1
    |
help: Add return type annotation: `int`

ANN202 Missing return type annotation for private function `get_values`
   --> tests\desktop_ui\test_library_main_ui_new.py:925:17
    |
923 |                 return 1
924 |
925 |             def get_values(self):
    |                 ^^^^^^^^^^
926 |                 return ("SnippetToEditError", "ContentToEditError")
    |
help: Add return type annotation

ANN202 Missing return type annotation for private function `exec_`
   --> tests\desktop_ui\test_library_main_ui_new.py:933:13
    |
932 |     class FakeDialog:
933 |         def exec_(self):
    |             ^^^^^
934 |             return 1
    |
help: Add return type annotation: `int`

ANN202 Missing return type annotation for private function `get_values`
   --> tests\desktop_ui\test_library_main_ui_new.py:936:13
    |
934 |             return 1
935 |
936 |         def get_values(self):
    |             ^^^^^^^^^^
937 |             return ("ErrEditSnip", "X")
    |
help: Add return type annotation

ANN202 Missing return type annotation for private function `fail_save_snippet`
   --> tests\desktop_ui\test_library_main_ui_new.py:941:9
    |
939 |     monkeypatch.setattr(library_main, "SnippetDialog", lambda *a, **k: FakeDialog())
940 |
941 |     def fail_save_snippet(snip):
    |         ^^^^^^^^^^^^^^^^^
942 |         raise Exception("failsnip2")
    |
help: Add return type annotation: `Never`

ANN001 Missing type annotation for function argument `snip`
   --> tests\desktop_ui\test_library_main_ui_new.py:941:27
    |
939 |     monkeypatch.setattr(library_main, "SnippetDialog", lambda *a, **k: FakeDialog())
940 |
941 |     def fail_save_snippet(snip):
    |                           ^^^^
942 |         raise Exception("failsnip2")
    |

ANN201 Missing return type annotation for public function `test_delete_category_error`
   --> tests\desktop_ui\test_library_main_ui_new.py:952:5
    |
952 | def test_delete_category_error(monkeypatch, main_window):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^
953 |     # Ensure a category exists and is selected
954 |     if not main_window.categories:
    |
help: Add return type annotation: `None`

D103 Missing docstring in public function
   --> tests\desktop_ui\test_library_main_ui_new.py:952:5
    |
952 | def test_delete_category_error(monkeypatch, main_window):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^
953 |     # Ensure a category exists and is selected
954 |     if not main_window.categories:
    |

ANN001 Missing type annotation for function argument `monkeypatch`
   --> tests\desktop_ui\test_library_main_ui_new.py:952:32
    |
952 | def test_delete_category_error(monkeypatch, main_window):
    |                                ^^^^^^^^^^^
953 |     # Ensure a category exists and is selected
954 |     if not main_window.categories:
    |

ANN001 Missing type annotation for function argument `main_window`
   --> tests\desktop_ui\test_library_main_ui_new.py:952:45
    |
952 | def test_delete_category_error(monkeypatch, main_window):
    |                                             ^^^^^^^^^^^
953 |     # Ensure a category exists and is selected
954 |     if not main_window.categories:
    |

ANN202 Missing return type annotation for private function `exec_`
   --> tests\desktop_ui\test_library_main_ui_new.py:957:17
    |
956 |         class FakeCatDialog:
957 |             def exec_(self):
    |                 ^^^^^
958 |                 return 1
    |
help: Add return type annotation: `int`

ANN202 Missing return type annotation for private function `get_value`
   --> tests\desktop_ui\test_library_main_ui_new.py:960:17
    |
958 |                 return 1
959 |
960 |             def get_value(self):
    |                 ^^^^^^^^^
961 |                 return "CatForDelete"
    |
help: Add return type annotation: `str`

ANN202 Missing return type annotation for private function `fail_delete_category_by_id`
   --> tests\desktop_ui\test_library_main_ui_new.py:972:9
    |
970 |     )
971 |
972 |     def fail_delete_category_by_id(cid):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^
973 |         raise Exception("faildelcat")
    |
help: Add return type annotation: `Never`

ANN001 Missing type annotation for function argument `cid`
   --> tests\desktop_ui\test_library_main_ui_new.py:972:36
    |
970 |     )
971 |
972 |     def fail_delete_category_by_id(cid):
    |                                    ^^^
973 |         raise Exception("faildelcat")
    |

ANN201 Missing return type annotation for public function `test_delete_snippet_error`
   --> tests\desktop_ui\test_library_main_ui_new.py:982:5
    |
982 | def test_delete_snippet_error(monkeypatch, main_window):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^
983 |     # Ensure a category exists and is selected
984 |     if not main_window.categories:
    |
help: Add return type annotation: `None`

D103 Missing docstring in public function
   --> tests\desktop_ui\test_library_main_ui_new.py:982:5
    |
982 | def test_delete_snippet_error(monkeypatch, main_window):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^
983 |     # Ensure a category exists and is selected
984 |     if not main_window.categories:
    |

ANN001 Missing type annotation for function argument `monkeypatch`
   --> tests\desktop_ui\test_library_main_ui_new.py:982:31
    |
982 | def test_delete_snippet_error(monkeypatch, main_window):
    |                               ^^^^^^^^^^^
983 |     # Ensure a category exists and is selected
984 |     if not main_window.categories:
    |

ANN001 Missing type annotation for function argument `main_window`
   --> tests\desktop_ui\test_library_main_ui_new.py:982:44
    |
982 | def test_delete_snippet_error(monkeypatch, main_window):
    |                                            ^^^^^^^^^^^
983 |     # Ensure a category exists and is selected
984 |     if not main_window.categories:
    |

ANN202 Missing return type annotation for private function `exec_`
   --> tests\desktop_ui\test_library_main_ui_new.py:987:17
    |
986 |         class FakeCatDialog:
987 |             def exec_(self):
    |                 ^^^^^
988 |                 return 1
    |
help: Add return type annotation: `int`

ANN202 Missing return type annotation for private function `get_value`
   --> tests\desktop_ui\test_library_main_ui_new.py:990:17
    |
988 |                 return 1
989 |
990 |             def get_value(self):
    |                 ^^^^^^^^^
991 |                 return "CatForDeleteError"
    |
help: Add return type annotation: `str`

ANN202 Missing return type annotation for private function `exec_`
    --> tests\desktop_ui\test_library_main_ui_new.py:1000:17
     |
 999 |         class FakeSnipDialog:
1000 |             def exec_(self):
     |                 ^^^^^
1001 |                 return 1
     |
help: Add return type annotation: `int`

ANN202 Missing return type annotation for private function `get_values`
    --> tests\desktop_ui\test_library_main_ui_new.py:1003:17
     |
1001 |                 return 1
1002 |
1003 |             def get_values(self):
     |                 ^^^^^^^^^^
1004 |                 return ("ToDelError", "X")
     |
help: Add return type annotation

ANN202 Missing return type annotation for private function `fail_delete_snippet`
    --> tests\desktop_ui\test_library_main_ui_new.py:1015:9
     |
1013 |     )
1014 |
1015 |     def fail_delete_snippet(sid):
     |         ^^^^^^^^^^^^^^^^^^^
1016 |         raise Exception("faildelsnip")
     |
help: Add return type annotation: `Never`

ANN001 Missing type annotation for function argument `sid`
    --> tests\desktop_ui\test_library_main_ui_new.py:1015:29
     |
1013 |     )
1014 |
1015 |     def fail_delete_snippet(sid):
     |                             ^^^
1016 |         raise Exception("faildelsnip")
     |

ANN201 Missing return type annotation for public function `test_view_snippet_dialog`
    --> tests\desktop_ui\test_library_main_ui_new.py:1026:5
     |
1026 | def test_view_snippet_dialog(monkeypatch, main_window):
     |     ^^^^^^^^^^^^^^^^^^^^^^^^
1027 |     # Ensure a category exists and is selected
1028 |     if not main_window.categories:
     |
help: Add return type annotation: `None`

D103 Missing docstring in public function
    --> tests\desktop_ui\test_library_main_ui_new.py:1026:5
     |
1026 | def test_view_snippet_dialog(monkeypatch, main_window):
     |     ^^^^^^^^^^^^^^^^^^^^^^^^
1027 |     # Ensure a category exists and is selected
1028 |     if not main_window.categories:
     |

ANN001 Missing type annotation for function argument `monkeypatch`
    --> tests\desktop_ui\test_library_main_ui_new.py:1026:30
     |
1026 | def test_view_snippet_dialog(monkeypatch, main_window):
     |                              ^^^^^^^^^^^
1027 |     # Ensure a category exists and is selected
1028 |     if not main_window.categories:
     |

ANN001 Missing type annotation for function argument `main_window`
    --> tests\desktop_ui\test_library_main_ui_new.py:1026:43
     |
1026 | def test_view_snippet_dialog(monkeypatch, main_window):
     |                                           ^^^^^^^^^^^
1027 |     # Ensure a category exists and is selected
1028 |     if not main_window.categories:
     |

ANN202 Missing return type annotation for private function `exec_`
    --> tests\desktop_ui\test_library_main_ui_new.py:1031:17
     |
1030 |         class FakeCatDialog:
1031 |             def exec_(self):
     |                 ^^^^^
1032 |                 return 1
     |
help: Add return type annotation: `int`

ANN202 Missing return type annotation for private function `get_value`
    --> tests\desktop_ui\test_library_main_ui_new.py:1034:17
     |
1032 |                 return 1
1033 |
1034 |             def get_value(self):
     |                 ^^^^^^^^^
1035 |                 return "CatForView"
     |
help: Add return type annotation: `str`

ANN202 Missing return type annotation for private function `exec_`
    --> tests\desktop_ui\test_library_main_ui_new.py:1044:17
     |
1043 |         class FakeSnipDialog:
1044 |             def exec_(self):
     |                 ^^^^^
1045 |                 return 1
     |
help: Add return type annotation: `int`

ANN202 Missing return type annotation for private function `get_values`
    --> tests\desktop_ui\test_library_main_ui_new.py:1047:17
     |
1045 |                 return 1
1046 |
1047 |             def get_values(self):
     |                 ^^^^^^^^^^
1048 |                 return ("ViewMe", "Content")
     |
help: Add return type annotation

ANN204 Missing return type annotation for special method `__init__`
    --> tests\desktop_ui\test_library_main_ui_new.py:1056:13
     |
1055 |     class FakeViewDialog:
1056 |         def __init__(self, **kwargs):
     |             ^^^^^^^^
1057 |             called["shown"] = True
     |
help: Add return type annotation: `None`

ANN003 Missing type annotation for `**kwargs`
    --> tests\desktop_ui\test_library_main_ui_new.py:1056:28
     |
1055 |     class FakeViewDialog:
1056 |         def __init__(self, **kwargs):
     |                            ^^^^^^^^
1057 |             called["shown"] = True
     |

ANN202 Missing return type annotation for private function `exec_`
    --> tests\desktop_ui\test_library_main_ui_new.py:1059:13
     |
1057 |             called["shown"] = True
1058 |
1059 |         def exec_(self):
     |             ^^^^^
1060 |             called["exec"] = True
     |
help: Add return type annotation: `None`

D212 [*] Multi-line docstring summary should start at the first line
 --> tests\desktop_ui\test_ngram_heatmap_dialog.py:1:1
  |
1 | / """
2 | | Test suite for NGram Heatmap Dialog.
3 | |
4 | | This module tests the modal dialog functionality, UI initialization,
5 | | and interaction with the NGramAnalyticsService.
6 | | """
  | |___^
7 |
8 |   import os
  |
help: Remove whitespace after opening quotes

D100 Missing docstring in public module
--> tests\desktop_ui\test_typing_drill.py:1:1

D212 [*] Multi-line docstring summary should start at the first line
 --> tests\desktop_ui\test_users_and_keyboards.py:1:1
  |
1 | / """
2 | | Tests for the UsersAndKeyboards dialog in the AI Typing Trainer application.
3 | |
4 | | Updated to use PySide6 instead of PyQt5.
5 | | """
  | |___^
6 |   from typing import Generator, List, Tuple
7 |   from unittest.mock import MagicMock, patch
  |
help: Remove whitespace after opening quotes

D212 [*] Multi-line docstring summary should start at the first line
   --> tests\desktop_ui\test_users_and_keyboards.py:192:5
    |
190 |       mock_keyboard_manager: MagicMock,
191 |   ) -> Generator[Tuple[UsersAndKeyboards, MagicMock, MagicMock], None, None]:
192 | /     """
193 | |     Create and return a UsersAndKeyboards dialog for testing.
194 | |
195 | |     Yields:
196 | |         A tuple containing the dialog and the mock managers.
197 | |     """
    | |_______^
198 |       with (
199 |           patch("desktop_ui.users_and_keyboards.UserManager", return_value=mock_user_manager),
    |
help: Remove whitespace after opening quotes

D212 [*] Multi-line docstring summary should start at the first line
 --> tests\helpers\__init__.py:1:1
  |
1 | / """
2 | | Helper functions and fixtures for testing database operations.
3 | |
4 | | This module provides reusable test fixtures and utilities for database testing
5 | | across the test suite. These helpers ensure consistent database setup and
6 | | tear down for all tests.
7 | | """
  | |___^
8 |
9 |   # Import db_helpers to make fixtures available at the package level
  |
help: Remove whitespace after opening quotes

D212 [*] Multi-line docstring summary should start at the first line
 --> tests\helpers\db_helpers.py:1:1
  |
1 | / """
2 | | Database testing helpers and fixtures.
3 | |
4 | | This module provides reusable fixtures and helper functions for testing database operations.
5 | | It includes fixtures for creating temporary databases and handling database connections.
6 | | """
  | |___^
7 |
8 |   import os
  |
help: Remove whitespace after opening quotes

D212 [*] Multi-line docstring summary should start at the first line
  --> tests\helpers\db_helpers.py:20:5
   |
18 |   @pytest.fixture(scope="function")
19 |   def temp_db() -> Generator[str, None, None]:
20 | /     """
21 | |     Create a temporary database file for testing.
22 | |
23 | |     Yields:
24 | |         str: Path to the temporary database file
25 | |
26 | |     The database file is automatically deleted after the test completes.
27 | |     """
   | |_______^
28 |       with tempfile.NamedTemporaryFile(delete=False, suffix=".db") as tmp:
29 |           db_path = tmp.name
   |
help: Remove whitespace after opening quotes

D212 [*] Multi-line docstring summary should start at the first line
  --> tests\helpers\db_helpers.py:42:5
   |
40 |   @pytest.fixture(scope="function")
41 |   def db_manager(temp_db: str) -> DatabaseManager:
42 | /     """
43 | |     Create a DatabaseManager instance with a temporary database.
44 | |
45 | |     Args:
46 | |         temp_db: Path to the temporary database file (provided by temp_db fixture)
47 | |
48 | |     Returns:
49 | |         DatabaseManager: A new DatabaseManager instance
50 | |     """
   | |_______^
51 |       return DatabaseManager(temp_db)
   |
help: Remove whitespace after opening quotes

D212 [*] Multi-line docstring summary should start at the first line
  --> tests\helpers\db_helpers.py:56:5
   |
54 |   @pytest.fixture(scope="function")
55 |   def db_with_tables(db_manager: DatabaseManager) -> DatabaseManager:
56 | /     """
57 | |     Create a database with all tables initialized.
58 | |
59 | |     Args:
60 | |         db_manager: DatabaseManager instance (provided by db_manager fixture)
61 | |
62 | |     Returns:
63 | |         DatabaseManager: The same DatabaseManager instance with tables initialized
64 | |     """
   | |_______^
65 |       db_manager.init_tables()
66 |       return db_manager
   |
help: Remove whitespace after opening quotes

D212 [*] Multi-line docstring summary should start at the first line
  --> tests\helpers\db_helpers.py:70:5
   |
69 |   def create_connection_error_db() -> str:
70 | /     """
71 | |     Create a database path that will cause a connection error.
72 | |
73 | |     Returns:
74 | |         str: A path that will cause a connection error when used
75 | |     """
   | |_______^
76 |       with tempfile.TemporaryDirectory() as temp_dir:
77 |           return str(Path(temp_dir) / "nonexistent" / "database.db")
   |
help: Remove whitespace after opening quotes

D104 Missing docstring in public package
--> tests\models\__init__.py:1:1

D100 Missing docstring in public module
--> tests\models\conftest.py:1:1

D212 [*] Multi-line docstring summary should start at the first line
  --> tests\models\conftest.py:35:5
   |
33 |   @pytest.fixture(scope="function")
34 |   def temp_db() -> Generator[str, None, None]:
35 | /     """
36 | |     Create a temporary database file for testing.
37 | |
38 | |     Yields:
39 | |         str: Path to the temporary database file
40 | |
41 | |     The database file is automatically deleted after the test completes.
42 | |     """
   | |_______^
43 |       with tempfile.NamedTemporaryFile(delete=False, suffix=".db") as tmp:
44 |           db_path = tmp.name
   |
help: Remove whitespace after opening quotes

D212 [*] Multi-line docstring summary should start at the first line
  --> tests\models\conftest.py:57:5
   |
55 |   @pytest.fixture(scope="function")
56 |   def db_manager(temp_db: str) -> DatabaseManager:
57 | /     """
58 | |     Create a DatabaseManager instance with a temporary database using LOCAL connection type.
59 | |
60 | |     Args:
61 | |         temp_db: Path to the temporary database file (provided by temp_db fixture)
62 | |
63 | |     Returns:
64 | |         DatabaseManager: A new DatabaseManager instance with LOCAL connection type
65 | |     """
   | |_______^
66 |       return DatabaseManager(temp_db, connection_type=ConnectionType.LOCAL)
   |
help: Remove whitespace after opening quotes

D212 [*] Multi-line docstring summary should start at the first line
  --> tests\models\conftest.py:71:5
   |
69 |   @pytest.fixture(scope="function")
70 |   def db_with_tables(db_manager: DatabaseManager) -> DatabaseManager:
71 | /     """
72 | |     Create a database with all tables initialized.
73 | |
74 | |     Args:
75 | |         db_manager: DatabaseManager instance (provided by db_manager fixture)
76 | |
77 | |     Returns:
78 | |         DatabaseManager: The same DatabaseManager instance with tables initialized
79 | |     """
   | |_______^
80 |       db_manager.init_tables()
81 |       return db_manager
   |
help: Remove whitespace after opening quotes

D212 [*] Multi-line docstring summary should start at the first line
  --> tests\models\conftest.py:85:5
   |
84 |   def create_connection_error_db() -> str:
85 | /     """
86 | |     Create a database path that will cause a connection error.
87 | |
88 | |     Returns:
89 | |         str: A path that will cause a connection error when used
90 | |     """
   | |_______^
91 |       with tempfile.TemporaryDirectory() as temp_dir:
92 |           return str(Path(temp_dir) / "nonexistent" / "database.db")
   |
help: Remove whitespace after opening quotes

D205 1 blank line required between summary line and description
   --> tests\models\conftest.py:97:5
    |
 95 |   @pytest.fixture(scope="function")
 96 |   def test_user(db_with_tables: DatabaseManager) -> User:
 97 | /     """
 98 | |     Creates and saves a test user, returning the User object.
 99 | |     This fixture is function-scoped to ensure a fresh user for each test,
100 | |     preventing side effects between tests.
101 | |     """
    | |_______^
102 |       user_manager = UserManager(db_with_tables)
103 |       user = User(
    |
help: Insert single blank line

D212 [*] Multi-line docstring summary should start at the first line
   --> tests\models\conftest.py:97:5
    |
 95 |   @pytest.fixture(scope="function")
 96 |   def test_user(db_with_tables: DatabaseManager) -> User:
 97 | /     """
 98 | |     Creates and saves a test user, returning the User object.
 99 | |     This fixture is function-scoped to ensure a fresh user for each test,
100 | |     preventing side effects between tests.
101 | |     """
    | |_______^
102 |       user_manager = UserManager(db_with_tables)
103 |       user = User(
    |
help: Remove whitespace after opening quotes

D205 1 blank line required between summary line and description
   --> tests\models\conftest.py:114:5
    |
112 |   @pytest.fixture(scope="function")
113 |   def test_keyboard(db_with_tables: DatabaseManager, test_user: User) -> Keyboard:
114 | /     """
115 | |     Creates and saves a test keyboard associated with the test_user,
116 | |     returning the Keyboard object.
117 | |     This fixture is function-scoped for test isolation.
118 | |     """
    | |_______^
119 |       keyboard_manager = KeyboardManager(db_with_tables)
120 |       keyboard = Keyboard(
    |
help: Insert single blank line

D212 [*] Multi-line docstring summary should start at the first line
   --> tests\models\conftest.py:114:5
    |
112 |   @pytest.fixture(scope="function")
113 |   def test_keyboard(db_with_tables: DatabaseManager, test_user: User) -> Keyboard:
114 | /     """
115 | |     Creates and saves a test keyboard associated with the test_user,
116 | |     returning the Keyboard object.
117 | |     This fixture is function-scoped for test isolation.
118 | |     """
    | |_______^
119 |       keyboard_manager = KeyboardManager(db_with_tables)
120 |       keyboard = Keyboard(
    |
help: Remove whitespace after opening quotes

D200 One-line docstring should fit on one line
 --> tests\models\debug_session_test.py:1:1
  |
1 | / """
2 | | Temporary debug test for the session creation tests.
3 | | """
  | |___^
4 |
5 |   from datetime import datetime
  |
help: Reformat to one line

D212 [*] Multi-line docstring summary should start at the first line
 --> tests\models\debug_session_test.py:1:1
  |
1 | / """
2 | | Temporary debug test for the session creation tests.
3 | | """
  | |___^
4 |
5 |   from datetime import datetime
  |
help: Remove whitespace after opening quotes

D103 Missing docstring in public function
  --> tests\models\debug_session_tests.py:15:5
   |
14 | @pytest.fixture
15 | def valid_session_dict_fixture() -> Dict[str, object]:
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^
16 |     now = datetime.now()
17 |     return {
   |

F841 Local variable `s` is assigned to but never used
   --> tests\models\debug_session_tests.py:119:13
    |
118 |         try:
119 |             s = Session.from_dict(data)
    |             ^
120 |             print(f"Case {idx} passed successfully")
121 |             if expected_exception_type:
    |
help: Remove assignment to unused variable `s`

D200 One-line docstring should fit on one line
 --> tests\models\debug_snippet_specific.py:1:1
  |
1 | / """
2 | | Script to debug tests in test_snippet.py with improved error reporting
3 | | """
  | |___^
4 |   import sys
  |
help: Reformat to one line

D212 [*] Multi-line docstring summary should start at the first line
 --> tests\models\debug_snippet_specific.py:1:1
  |
1 | / """
2 | | Script to debug tests in test_snippet.py with improved error reporting
3 | | """
  | |___^
4 |   import sys
  |
help: Remove whitespace after opening quotes

D415 First line should end with a period, question mark, or exclamation point
 --> tests\models\debug_snippet_specific.py:1:1
  |
1 | / """
2 | | Script to debug tests in test_snippet.py with improved error reporting
3 | | """
  | |___^
4 |   import sys
  |
help: Add closing punctuation

D200 One-line docstring should fit on one line
 --> tests\models\debug_test_snippet_manager.py:1:1
  |
1 | / """
2 | | Debug script to run specific tests from test_snippet_manager.py and get detailed output
3 | | """
  | |___^
4 |   import sys
  |
help: Reformat to one line

D212 [*] Multi-line docstring summary should start at the first line
 --> tests\models\debug_test_snippet_manager.py:1:1
  |
1 | / """
2 | | Debug script to run specific tests from test_snippet_manager.py and get detailed output
3 | | """
  | |___^
4 |   import sys
  |
help: Remove whitespace after opening quotes

D415 First line should end with a period, question mark, or exclamation point
 --> tests\models\debug_test_snippet_manager.py:1:1
  |
1 | / """
2 | | Debug script to run specific tests from test_snippet_manager.py and get detailed output
3 | | """
  | |___^
4 |   import sys
  |
help: Add closing punctuation

E501 Line too long (121 > 120)
  --> tests\models\debug_test_snippet_manager.py:11:121
   |
 9 |     # Run the tests with detailed error reporting
10 |     # Run a specific test that might be failing
11 |     test_path = "tests/models/test_snippet_manager.py::TestCreateSnippet::test_create_snippet_pydantic_validation_errors"
   |                                                                                                                         ^
12 |     print(f"\nRunning test: {test_path}\n")
13 |     exit_code = pytest.main([test_path, "-vv"])
   |

F401 `models.ngram_analyzer.NGram` imported but unused; consider using `importlib.util.find_spec` to test for availability
  --> tests\models\import_test.py:10:39
   |
 8 | try:
 9 |     # Import and print what's available in the module
10 |     from models.ngram_analyzer import NGram, NGramAnalyzer
   |                                       ^^^^^
11 |
12 |     print("Successfully imported NGramAnalyzer and NGram")
   |
help: Remove unused import

F401 `models.ngram_analyzer.NGramAnalyzer` imported but unused; consider using `importlib.util.find_spec` to test for availability
  --> tests\models\import_test.py:10:46
   |
 8 | try:
 9 |     # Import and print what's available in the module
10 |     from models.ngram_analyzer import NGram, NGramAnalyzer
   |                                              ^^^^^^^^^^^^^
11 |
12 |     print("Successfully imported NGramAnalyzer and NGram")
   |
help: Remove unused import

F401 `models.ngram_analyzer.NGramStats` imported but unused; consider using `importlib.util.find_spec` to test for availability
  --> tests\models\import_test.py:16:43
   |
14 |     # Try to access the required imports that are failing
15 |     try:
16 |         from models.ngram_analyzer import NGramStats
   |                                           ^^^^^^^^^^
17 |         print("NGramStats exists")
18 |     except ImportError:
   |
help: Remove unused import: `models.ngram_analyzer.NGramStats`

F401 `models.ngram_analyzer.Session` imported but unused; consider using `importlib.util.find_spec` to test for availability
  --> tests\models\import_test.py:22:43
   |
21 |     try:
22 |         from models.ngram_analyzer import Session
   |                                           ^^^^^^^
23 |         print("Session exists")
24 |     except ImportError:
   |
help: Remove unused import: `models.ngram_analyzer.Session`

D205 1 blank line required between summary line and description
 --> tests\models\test_category.py:1:1
  |
1 | / """
2 | | Unit tests for the Category Pydantic model in models.category.
3 | | Focuses on validation logic within the Category model itself.
4 | | """
  | |___^
5 |
6 |   # Standard library imports
  |
help: Insert single blank line

D212 [*] Multi-line docstring summary should start at the first line
 --> tests\models\test_category.py:1:1
  |
1 | / """
2 | | Unit tests for the Category Pydantic model in models.category.
3 | | Focuses on validation logic within the Category model itself.
4 | | """
  | |___^
5 |
6 |   # Standard library imports
  |
help: Remove whitespace after opening quotes

D200 One-line docstring should fit on one line
  --> tests\models\test_category.py:40:9
   |
38 |       )
39 |       def test_category_name_validation(self, name: str, expected_error_message_part: str) -> None:
40 | /         """
41 | |         Test objective: Verify Category model's name validation for format, length, and ASCII.
42 | |         """
   | |___________^
43 |           with pytest.raises(ValidationError) as exc_info:
44 |               Category(category_id=str(uuid.uuid4()), category_name=name)
   |
help: Reformat to one line

D212 [*] Multi-line docstring summary should start at the first line
  --> tests\models\test_category.py:40:9
   |
38 |       )
39 |       def test_category_name_validation(self, name: str, expected_error_message_part: str) -> None:
40 | /         """
41 | |         Test objective: Verify Category model's name validation for format, length, and ASCII.
42 | |         """
   | |___________^
43 |           with pytest.raises(ValidationError) as exc_info:
44 |               Category(category_id=str(uuid.uuid4()), category_name=name)
   |
help: Remove whitespace after opening quotes

D205 1 blank line required between summary line and description
 --> tests\models\test_category_manager.py:1:1
  |
1 | / """
2 | | Unit tests for models.category_manager.CategoryManager.
3 | | Covers CRUD, validation (including DB uniqueness), cascade deletion, and error handling.
4 | | """
  | |___^
5 |
6 |   import uuid
  |
help: Insert single blank line

D212 [*] Multi-line docstring summary should start at the first line
 --> tests\models\test_category_manager.py:1:1
  |
1 | / """
2 | | Unit tests for models.category_manager.CategoryManager.
3 | | Covers CRUD, validation (including DB uniqueness), cascade deletion, and error handling.
4 | | """
  | |___^
5 |
6 |   import uuid
  |
help: Remove whitespace after opening quotes

D200 One-line docstring should fit on one line
  --> tests\models\test_category_manager.py:19:5
   |
17 |   @pytest.fixture(scope="function")
18 |   def category_mgr(db_with_tables: DatabaseManager) -> CategoryManager:
19 | /     """
20 | |     Fixture: Provides a CategoryManager with a fresh, initialized database.
21 | |     """
   | |_______^
22 |       return CategoryManager(db_with_tables)
   |
help: Reformat to one line

D212 [*] Multi-line docstring summary should start at the first line
  --> tests\models\test_category_manager.py:19:5
   |
17 |   @pytest.fixture(scope="function")
18 |   def category_mgr(db_with_tables: DatabaseManager) -> CategoryManager:
19 | /     """
20 | |     Fixture: Provides a CategoryManager with a fresh, initialized database.
21 | |     """
   | |_______^
22 |       return CategoryManager(db_with_tables)
   |
help: Remove whitespace after opening quotes

D200 One-line docstring should fit on one line
  --> tests\models\test_category_manager.py:27:5
   |
25 |   @pytest.fixture(scope="function")
26 |   def snippet_mgr(db_with_tables: DatabaseManager) -> SnippetManager:
27 | /     """
28 | |     Fixture: Provides a SnippetManager with a fresh, initialized database.
29 | |     """
   | |_______^
30 |       return SnippetManager(db_with_tables)
   |
help: Reformat to one line

D212 [*] Multi-line docstring summary should start at the first line
  --> tests\models\test_category_manager.py:27:5
   |
25 |   @pytest.fixture(scope="function")
26 |   def snippet_mgr(db_with_tables: DatabaseManager) -> SnippetManager:
27 | /     """
28 | |     Fixture: Provides a SnippetManager with a fresh, initialized database.
29 | |     """
   | |_______^
30 |       return SnippetManager(db_with_tables)
   |
help: Remove whitespace after opening quotes

D200 One-line docstring should fit on one line
  --> tests\models\test_category_manager.py:37:9
   |
36 |       def test_create_category_valid(self, category_mgr: CategoryManager) -> None:
37 | /         """
38 | |         Test objective: Create a category with a valid name and verify persistence.
39 | |         """
   | |___________^
40 |           category = Category(category_name="Alpha", description="")
41 |           assert category_mgr.save_category(category)
   |
help: Reformat to one line

D212 [*] Multi-line docstring summary should start at the first line
  --> tests\models\test_category_manager.py:37:9
   |
36 |       def test_create_category_valid(self, category_mgr: CategoryManager) -> None:
37 | /         """
38 | |         Test objective: Create a category with a valid name and verify persistence.
39 | |         """
   | |___________^
40 |           category = Category(category_name="Alpha", description="")
41 |           assert category_mgr.save_category(category)
   |
help: Remove whitespace after opening quotes

D200 One-line docstring should fit on one line
  --> tests\models\test_category_manager.py:60:9
   |
58 |           self, category_mgr: CategoryManager, name: str, err_msg_part: str
59 |       ) -> None:
60 | /         """
61 | |         Test objective: Attempt to create a category with an invalid name format.
62 | |         """
   | |___________^
63 |           with pytest.raises((ValueError, CategoryValidationError)) as e:
64 |               category = Category(category_name=name, description="")
   |
help: Reformat to one line

D212 [*] Multi-line docstring summary should start at the first line
  --> tests\models\test_category_manager.py:60:9
   |
58 |           self, category_mgr: CategoryManager, name: str, err_msg_part: str
59 |       ) -> None:
60 | /         """
61 | |         Test objective: Attempt to create a category with an invalid name format.
62 | |         """
   | |___________^
63 |           with pytest.raises((ValueError, CategoryValidationError)) as e:
64 |               category = Category(category_name=name, description="")
   |
help: Remove whitespace after opening quotes

D200 One-line docstring should fit on one line
  --> tests\models\test_category_manager.py:69:9
   |
68 |       def test_create_category_duplicate_name(self, category_mgr: CategoryManager) -> None:
69 | /         """
70 | |         Test objective: Attempt to create a category with a duplicate name.
71 | |         """
   | |___________^
72 |           category1 = Category(category_name="UniqueName", description="")
73 |           category_mgr.save_category(category1)
   |
help: Reformat to one line

D212 [*] Multi-line docstring summary should start at the first line
  --> tests\models\test_category_manager.py:69:9
   |
68 |       def test_create_category_duplicate_name(self, category_mgr: CategoryManager) -> None:
69 | /         """
70 | |         Test objective: Attempt to create a category with a duplicate name.
71 | |         """
   | |___________^
72 |           category1 = Category(category_name="UniqueName", description="")
73 |           category_mgr.save_category(category1)
   |
help: Remove whitespace after opening quotes

D200 One-line docstring should fit on one line
  --> tests\models\test_category_manager.py:80:9
   |
79 |       def test_get_category_by_id(self, category_mgr: CategoryManager) -> None:
80 | /         """
81 | |         Test objective: Retrieve a category by its ID.
82 | |         """
   | |___________^
83 |           category = Category(category_name="Test Category", description="")
84 |           category_mgr.save_category(category)
   |
help: Reformat to one line

D212 [*] Multi-line docstring summary should start at the first line
  --> tests\models\test_category_manager.py:80:9
   |
79 |       def test_get_category_by_id(self, category_mgr: CategoryManager) -> None:
80 | /         """
81 | |         Test objective: Retrieve a category by its ID.
82 | |         """
   | |___________^
83 |           category = Category(category_name="Test Category", description="")
84 |           category_mgr.save_category(category)
   |
help: Remove whitespace after opening quotes

D200 One-line docstring should fit on one line
  --> tests\models\test_category_manager.py:91:9
   |
90 |       def test_get_category_by_id_not_found(self, category_mgr: CategoryManager) -> None:
91 | /         """
92 | |         Test objective: Attempt to retrieve a non-existent category by ID.
93 | |         """
   | |___________^
94 |           with pytest.raises(CategoryNotFound):
95 |               category_mgr.get_category_by_id(str(uuid.uuid4()))
   |
help: Reformat to one line

D212 [*] Multi-line docstring summary should start at the first line
  --> tests\models\test_category_manager.py:91:9
   |
90 |       def test_get_category_by_id_not_found(self, category_mgr: CategoryManager) -> None:
91 | /         """
92 | |         Test objective: Attempt to retrieve a non-existent category by ID.
93 | |         """
   | |___________^
94 |           with pytest.raises(CategoryNotFound):
95 |               category_mgr.get_category_by_id(str(uuid.uuid4()))
   |
help: Remove whitespace after opening quotes

D200 One-line docstring should fit on one line
   --> tests\models\test_category_manager.py:98:9
    |
 97 |       def test_get_category_by_id_invalid_uuid(self, category_mgr: CategoryManager) -> None:
 98 | /         """
 99 | |         Test objective: Attempt to retrieve a category with an invalid (non-UUID) ID string.
100 | |         """
    | |___________^
101 |           with pytest.raises(CategoryNotFound):
102 |               category_mgr.get_category_by_id("not-a-uuid")
    |
help: Reformat to one line

D212 [*] Multi-line docstring summary should start at the first line
   --> tests\models\test_category_manager.py:98:9
    |
 97 |       def test_get_category_by_id_invalid_uuid(self, category_mgr: CategoryManager) -> None:
 98 | /         """
 99 | |         Test objective: Attempt to retrieve a category with an invalid (non-UUID) ID string.
100 | |         """
    | |___________^
101 |           with pytest.raises(CategoryNotFound):
102 |               category_mgr.get_category_by_id("not-a-uuid")
    |
help: Remove whitespace after opening quotes

D200 One-line docstring should fit on one line
   --> tests\models\test_category_manager.py:105:9
    |
104 |       def test_get_category_by_name(self, category_mgr: CategoryManager) -> None:
105 | /         """
106 | |         Test objective: Retrieve a category by its name.
107 | |         """
    | |___________^
108 |           cat_name = "Named Category"
109 |           category = Category(category_name=cat_name, description="")
    |
help: Reformat to one line

D212 [*] Multi-line docstring summary should start at the first line
   --> tests\models\test_category_manager.py:105:9
    |
104 |       def test_get_category_by_name(self, category_mgr: CategoryManager) -> None:
105 | /         """
106 | |         Test objective: Retrieve a category by its name.
107 | |         """
    | |___________^
108 |           cat_name = "Named Category"
109 |           category = Category(category_name=cat_name, description="")
    |
help: Remove whitespace after opening quotes

D200 One-line docstring should fit on one line
   --> tests\models\test_category_manager.py:117:9
    |
116 |       def test_get_category_by_name_not_found(self, category_mgr: CategoryManager) -> None:
117 | /         """
118 | |         Test objective: Attempt to retrieve a non-existent category by name.
119 | |         """
    | |___________^
120 |           with pytest.raises(CategoryNotFound):
121 |               category_mgr.get_category_by_name("NonExistent Name")
    |
help: Reformat to one line

D212 [*] Multi-line docstring summary should start at the first line
   --> tests\models\test_category_manager.py:117:9
    |
116 |       def test_get_category_by_name_not_found(self, category_mgr: CategoryManager) -> None:
117 | /         """
118 | |         Test objective: Attempt to retrieve a non-existent category by name.
119 | |         """
    | |___________^
120 |           with pytest.raises(CategoryNotFound):
121 |               category_mgr.get_category_by_name("NonExistent Name")
    |
help: Remove whitespace after opening quotes

D200 One-line docstring should fit on one line
   --> tests\models\test_category_manager.py:124:9
    |
123 |       def test_get_category_by_name_case_sensitive(self, category_mgr: CategoryManager) -> None:
124 | /         """
125 | |         Test objective: Verify category name retrieval is case-sensitive.
126 | |         """
    | |___________^
127 |           cat_name = "CaseSensitive"
128 |           category = Category(category_name=cat_name, description="")
    |
help: Reformat to one line

D212 [*] Multi-line docstring summary should start at the first line
   --> tests\models\test_category_manager.py:124:9
    |
123 |       def test_get_category_by_name_case_sensitive(self, category_mgr: CategoryManager) -> None:
124 | /         """
125 | |         Test objective: Verify category name retrieval is case-sensitive.
126 | |         """
    | |___________^
127 |           cat_name = "CaseSensitive"
128 |           category = Category(category_name=cat_name, description="")
    |
help: Remove whitespace after opening quotes

D200 One-line docstring should fit on one line
   --> tests\models\test_category_manager.py:141:9
    |
140 |       def test_list_all_categories_empty(self, category_mgr: CategoryManager) -> None:
141 | /         """
142 | |         Test objective: List categories when none exist.
143 | |         """
    | |___________^
144 |           cats = category_mgr.list_all_categories()
145 |           assert len(cats) == 0
    |
help: Reformat to one line

D212 [*] Multi-line docstring summary should start at the first line
   --> tests\models\test_category_manager.py:141:9
    |
140 |       def test_list_all_categories_empty(self, category_mgr: CategoryManager) -> None:
141 | /         """
142 | |         Test objective: List categories when none exist.
143 | |         """
    | |___________^
144 |           cats = category_mgr.list_all_categories()
145 |           assert len(cats) == 0
    |
help: Remove whitespace after opening quotes

D200 One-line docstring should fit on one line
   --> tests\models\test_category_manager.py:148:9
    |
147 |       def test_list_all_categories_populated(self, category_mgr: CategoryManager) -> None:
148 | /         """
149 | |         Test objective: List categories when multiple exist, ensuring order.
150 | |         """
    | |___________^
151 |           names = ["Charlie", "Alpha", "Beta"]
152 |           for n in names:
    |
help: Reformat to one line

D212 [*] Multi-line docstring summary should start at the first line
   --> tests\models\test_category_manager.py:148:9
    |
147 |       def test_list_all_categories_populated(self, category_mgr: CategoryManager) -> None:
148 | /         """
149 | |         Test objective: List categories when multiple exist, ensuring order.
150 | |         """
    | |___________^
151 |           names = ["Charlie", "Alpha", "Beta"]
152 |           for n in names:
    |
help: Remove whitespace after opening quotes

D200 One-line docstring should fit on one line
   --> tests\models\test_category_manager.py:160:9
    |
159 |       def test_update_category_valid_name(self, category_mgr: CategoryManager) -> None:
160 | /         """
161 | |         Test objective: Update a category's name successfully using save_category.
162 | |         """
    | |___________^
163 |           category = Category(category_name="Original Name", description="")
164 |           category_mgr.save_category(category)
    |
help: Reformat to one line

D212 [*] Multi-line docstring summary should start at the first line
   --> tests\models\test_category_manager.py:160:9
    |
159 |       def test_update_category_valid_name(self, category_mgr: CategoryManager) -> None:
160 | /         """
161 | |         Test objective: Update a category's name successfully using save_category.
162 | |         """
    | |___________^
163 |           category = Category(category_name="Original Name", description="")
164 |           category_mgr.save_category(category)
    |
help: Remove whitespace after opening quotes

D205 1 blank line required between summary line and description
   --> tests\models\test_category_manager.py:181:9
    |
179 |           self, category_mgr: CategoryManager, new_name: str, err_msg_part: str
180 |       ) -> None:
181 | /         """
182 | |         Test objective: Attempt to update a category with an invalid new name format using
183 | |         save_category.
184 | |         """
    | |___________^
185 |           category = Category(category_name="ValidOriginal", description="")
186 |           category_mgr.save_category(category)
    |
help: Insert single blank line

D212 [*] Multi-line docstring summary should start at the first line
   --> tests\models\test_category_manager.py:181:9
    |
179 |           self, category_mgr: CategoryManager, new_name: str, err_msg_part: str
180 |       ) -> None:
181 | /         """
182 | |         Test objective: Attempt to update a category with an invalid new name format using
183 | |         save_category.
184 | |         """
    | |___________^
185 |           category = Category(category_name="ValidOriginal", description="")
186 |           category_mgr.save_category(category)
    |
help: Remove whitespace after opening quotes

D205 1 blank line required between summary line and description
   --> tests\models\test_category_manager.py:193:9
    |
192 |       def test_update_category_to_duplicate_name(self, category_mgr: CategoryManager) -> None:
193 | /         """
194 | |         Test objective: Attempt to update a category name to an existing different category's name
195 | |         using save_category.
196 | |         """
    | |___________^
197 |           category1 = Category(category_name="ExistingName", description="")
198 |           category2 = Category(category_name="ToBeUpdated", description="")
    |
help: Insert single blank line

D212 [*] Multi-line docstring summary should start at the first line
   --> tests\models\test_category_manager.py:193:9
    |
192 |       def test_update_category_to_duplicate_name(self, category_mgr: CategoryManager) -> None:
193 | /         """
194 | |         Test objective: Attempt to update a category name to an existing different category's name
195 | |         using save_category.
196 | |         """
    | |___________^
197 |           category1 = Category(category_name="ExistingName", description="")
198 |           category2 = Category(category_name="ToBeUpdated", description="")
    |
help: Remove whitespace after opening quotes

D205 1 blank line required between summary line and description
   --> tests\models\test_category_manager.py:207:9
    |
206 |       def test_update_category_to_case_variant_duplicate(self, category_mgr: CategoryManager) -> None:
207 | /         """
208 | |         Test objective: Attempt to update a category name to a case-variant of an existing name
209 | |         using save_category.
210 | |         """
    | |___________^
211 |           category1 = Category(category_name="CaseName", description="")
212 |           category2 = Category(category_name="OtherName", description="")
    |
help: Insert single blank line

D212 [*] Multi-line docstring summary should start at the first line
   --> tests\models\test_category_manager.py:207:9
    |
206 |       def test_update_category_to_case_variant_duplicate(self, category_mgr: CategoryManager) -> None:
207 | /         """
208 | |         Test objective: Attempt to update a category name to a case-variant of an existing name
209 | |         using save_category.
210 | |         """
    | |___________^
211 |           category1 = Category(category_name="CaseName", description="")
212 |           category2 = Category(category_name="OtherName", description="")
    |
help: Remove whitespace after opening quotes

D205 1 blank line required between summary line and description
   --> tests\models\test_category_manager.py:224:9
    |
223 |       def test_update_category_to_same_name(self, category_mgr: CategoryManager) -> None:
224 | /         """
225 | |         Test objective: Update a category to its current name (should be a no-op) using
226 | |         save_category.
227 | |         """
    | |___________^
228 |           cat_name = "SameName"
229 |           category = Category(category_name=cat_name, description="")
    |
help: Insert single blank line

D212 [*] Multi-line docstring summary should start at the first line
   --> tests\models\test_category_manager.py:224:9
    |
223 |       def test_update_category_to_same_name(self, category_mgr: CategoryManager) -> None:
224 | /         """
225 | |         Test objective: Update a category to its current name (should be a no-op) using
226 | |         save_category.
227 | |         """
    | |___________^
228 |           cat_name = "SameName"
229 |           category = Category(category_name=cat_name, description="")
    |
help: Remove whitespace after opening quotes

D200 One-line docstring should fit on one line
   --> tests\models\test_category_manager.py:237:9
    |
236 |       def test_delete_category_by_id(self, category_mgr: CategoryManager) -> None:
237 | /         """
238 | |         Test objective: Delete an existing category.
239 | |         """
    | |___________^
240 |           category = Category(category_name="ToDelete", description="")
241 |           category_mgr.save_category(category)
    |
help: Reformat to one line

D212 [*] Multi-line docstring summary should start at the first line
   --> tests\models\test_category_manager.py:237:9
    |
236 |       def test_delete_category_by_id(self, category_mgr: CategoryManager) -> None:
237 | /         """
238 | |         Test objective: Delete an existing category.
239 | |         """
    | |___________^
240 |           category = Category(category_name="ToDelete", description="")
241 |           category_mgr.save_category(category)
    |
help: Remove whitespace after opening quotes

D200 One-line docstring should fit on one line
   --> tests\models\test_category_manager.py:247:9
    |
246 |       def test_delete_category_by_id_invalid_uuid(self, category_mgr: CategoryManager) -> None:
247 | /         """
248 | |         Test objective: Attempt to delete a category with an invalid (non-UUID) ID string.
249 | |         """
    | |___________^
250 |           assert category_mgr.delete_category_by_id("not-a-uuid") is False
    |
help: Reformat to one line

D212 [*] Multi-line docstring summary should start at the first line
   --> tests\models\test_category_manager.py:247:9
    |
246 |       def test_delete_category_by_id_invalid_uuid(self, category_mgr: CategoryManager) -> None:
247 | /         """
248 | |         Test objective: Attempt to delete a category with an invalid (non-UUID) ID string.
249 | |         """
    | |___________^
250 |           assert category_mgr.delete_category_by_id("not-a-uuid") is False
    |
help: Remove whitespace after opening quotes

D200 One-line docstring should fit on one line
   --> tests\models\test_category_manager.py:253:9
    |
252 |       def test_delete_nonexistent_category(self, category_mgr: CategoryManager) -> None:
253 | /         """
254 | |         Test objective: Attempt to delete a non-existent category.
255 | |         """
    | |___________^
256 |           assert category_mgr.delete_category(str(uuid.uuid4())) is False
    |
help: Reformat to one line

D212 [*] Multi-line docstring summary should start at the first line
   --> tests\models\test_category_manager.py:253:9
    |
252 |       def test_delete_nonexistent_category(self, category_mgr: CategoryManager) -> None:
253 | /         """
254 | |         Test objective: Attempt to delete a non-existent category.
255 | |         """
    | |___________^
256 |           assert category_mgr.delete_category(str(uuid.uuid4())) is False
    |
help: Remove whitespace after opening quotes

D200 One-line docstring should fit on one line
   --> tests\models\test_category_manager.py:259:9
    |
258 |       def test_delete_all_categories(self, category_mgr: CategoryManager) -> None:
259 | /         """
260 | |         Test objective: Delete all categories and verify the action.
261 | |         """
    | |___________^
262 |           category_mgr.save_category(Category(category_name="A", description=""))
263 |           category_mgr.save_category(Category(category_name="B", description=""))
    |
help: Reformat to one line

D212 [*] Multi-line docstring summary should start at the first line
   --> tests\models\test_category_manager.py:259:9
    |
258 |       def test_delete_all_categories(self, category_mgr: CategoryManager) -> None:
259 | /         """
260 | |         Test objective: Delete all categories and verify the action.
261 | |         """
    | |___________^
262 |           category_mgr.save_category(Category(category_name="A", description=""))
263 |           category_mgr.save_category(Category(category_name="B", description=""))
    |
help: Remove whitespace after opening quotes

D200 One-line docstring should fit on one line
   --> tests\models\test_category_manager.py:271:9
    |
270 |       def test_category_validation_blank_and_duplicate(self, category_mgr: CategoryManager) -> None:
271 | /         """
272 | |         Test objective: Destructively test blank and duplicate category names.
273 | |         """
    | |___________^
274 |           # Blank
275 |           with pytest.raises((ValueError, CategoryValidationError)):
    |
help: Reformat to one line

D212 [*] Multi-line docstring summary should start at the first line
   --> tests\models\test_category_manager.py:271:9
    |
270 |       def test_category_validation_blank_and_duplicate(self, category_mgr: CategoryManager) -> None:
271 | /         """
272 | |         Test objective: Destructively test blank and duplicate category names.
273 | |         """
    | |___________^
274 |           # Blank
275 |           with pytest.raises((ValueError, CategoryValidationError)):
    |
help: Remove whitespace after opening quotes

D205 1 blank line required between summary line and description
   --> tests\models\test_category_manager.py:284:9
    |
283 |       def test_save_category_non_string_name(self, category_mgr: CategoryManager) -> None:
284 | /         """
285 | |         Test objective: Attempt to save a category with a non-string name (should
286 | |         raise ValueError or CategoryValidationError).
287 | |         """
    | |___________^
288 |           with pytest.raises((ValueError, CategoryValidationError, ValidationError)):
289 |               Category(category_name=12345, description="")
    |
help: Insert single blank line

D212 [*] Multi-line docstring summary should start at the first line
   --> tests\models\test_category_manager.py:284:9
    |
283 |       def test_save_category_non_string_name(self, category_mgr: CategoryManager) -> None:
284 | /         """
285 | |         Test objective: Attempt to save a category with a non-string name (should
286 | |         raise ValueError or CategoryValidationError).
287 | |         """
    | |___________^
288 |           with pytest.raises((ValueError, CategoryValidationError, ValidationError)):
289 |               Category(category_name=12345, description="")
    |
help: Remove whitespace after opening quotes

D100 Missing docstring in public module
--> tests\models\test_keyboard.py:1:1

D103 Missing docstring in public function
  --> tests\models\test_keyboard.py:9:5
   |
 9 | def test_keyboard_valid() -> None:
   |     ^^^^^^^^^^^^^^^^^^^
10 |     k = Keyboard(
11 |         keyboard_id=str(uuid4()),
   |

D103 Missing docstring in public function
  --> tests\models\test_keyboard.py:20:5
   |
20 | def test_keyboard_empty_name() -> None:
   |     ^^^^^^^^^^^^^^^^^^^^^^^^
21 |     with pytest.raises(ValidationError):
22 |         Keyboard(keyboard_id=str(uuid4()), user_id=str(uuid4()), keyboard_name="  ")
   |

D103 Missing docstring in public function
  --> tests\models\test_keyboard.py:25:5
   |
25 | def test_keyboard_name_strip() -> None:
   |     ^^^^^^^^^^^^^^^^^^^^^^^^
26 |     k = Keyboard(keyboard_id=str(uuid4()), user_id=str(uuid4()), keyboard_name="  Test  ")
27 |     assert k.keyboard_name == "Test"
   |

D103 Missing docstring in public function
  --> tests\models\test_keyboard.py:30:5
   |
30 | def test_keyboard_default_target_ms() -> None:
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
31 |     # Test that default value of 600 is used when not specified
32 |     k = Keyboard(keyboard_id=str(uuid4()), user_id=str(uuid4()), keyboard_name="Test")
   |

D103 Missing docstring in public function
  --> tests\models\test_keyboard.py:36:5
   |
36 | def test_keyboard_custom_target_ms() -> None:
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
37 |     # Test that custom value is stored correctly
38 |     k = Keyboard(
   |

D103 Missing docstring in public function
  --> tests\models\test_keyboard.py:47:5
   |
47 | def test_keyboard_target_ms_too_low() -> None:
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
48 |     # Test that validator rejects values below 50
49 |     with pytest.raises(ValidationError) as excinfo:
   |

D103 Missing docstring in public function
  --> tests\models\test_keyboard.py:59:5
   |
59 | def test_keyboard_target_ms_too_high() -> None:
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
60 |     # Test that validator rejects values above 5000
61 |     with pytest.raises(ValidationError) as excinfo:
   |

D103 Missing docstring in public function
  --> tests\models\test_keyboard.py:71:5
   |
71 | def test_keyboard_target_ms_none() -> None:
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
72 |     # Test that validator rejects None values
73 |     with pytest.raises(ValidationError) as excinfo:
   |

F841 Local variable `excinfo` is assigned to but never used
  --> tests\models\test_keyboard.py:73:44
   |
71 | def test_keyboard_target_ms_none() -> None:
72 |     # Test that validator rejects None values
73 |     with pytest.raises(ValidationError) as excinfo:
   |                                            ^^^^^^^
74 |         # We need to use a dict and model_validate to bypass Pydantic's type checking
75 |         # and test our explicit None validator
   |
help: Remove assignment to unused variable `excinfo`

D100 Missing docstring in public module
--> tests\models\test_keyboard_manager.py:1:1

D103 Missing docstring in public function
  --> tests\models\test_keyboard_manager.py:11:5
   |
10 | @pytest.fixture
11 | def keyboard_manager(db_with_tables: DatabaseManager) -> KeyboardManager:
   |     ^^^^^^^^^^^^^^^^
12 |     return KeyboardManager(db_with_tables)
   |

D103 Missing docstring in public function
  --> tests\models\test_keyboard_manager.py:15:5
   |
15 | def test_create_keyboard(keyboard_manager: KeyboardManager, test_user: User) -> None:
   |     ^^^^^^^^^^^^^^^^^^^^
16 |     k = Keyboard(user_id=str(test_user.user_id), keyboard_name="Alpha")
17 |     assert keyboard_manager.save_keyboard(k)
   |

D103 Missing docstring in public function
  --> tests\models\test_keyboard_manager.py:24:5
   |
24 | def test_get_keyboard(keyboard_manager: KeyboardManager, test_user: User) -> None:
   |     ^^^^^^^^^^^^^^^^^
25 |     k = Keyboard(user_id=str(test_user.user_id), keyboard_name="Beta")
26 |     keyboard_manager.save_keyboard(k)
   |

D103 Missing docstring in public function
  --> tests\models\test_keyboard_manager.py:32:5
   |
32 | def test_update_keyboard_name(keyboard_manager: KeyboardManager, test_user: User) -> None:
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^
33 |     k = Keyboard(user_id=str(test_user.user_id), keyboard_name="Gamma")
34 |     keyboard_manager.save_keyboard(k)
   |

D103 Missing docstring in public function
  --> tests\models\test_keyboard_manager.py:74:5
   |
74 | def test_delete_keyboard(keyboard_manager: KeyboardManager, test_user: User) -> None:
   |     ^^^^^^^^^^^^^^^^^^^^
75 |     k = Keyboard(user_id=str(test_user.user_id), keyboard_name="Zeta")
76 |     keyboard_manager.save_keyboard(k)
   |

D205 1 blank line required between summary line and description
 --> tests\models\test_keystroke.py:1:1
  |
1 | / """
2 | | Comprehensive tests for the Keystroke Pydantic model.
3 | | Tests cover creation, serialization, validation, and edge cases.
4 | | Based on Keystroke.md specification requirements.
5 | | """
  | |___^
6 |
7 |   import datetime
  |
help: Insert single blank line

D212 [*] Multi-line docstring summary should start at the first line
 --> tests\models\test_keystroke.py:1:1
  |
1 | / """
2 | | Comprehensive tests for the Keystroke Pydantic model.
3 | | Tests cover creation, serialization, validation, and edge cases.
4 | | Based on Keystroke.md specification requirements.
5 | | """
  | |___^
6 |
7 |   import datetime
  |
help: Remove whitespace after opening quotes

D212 [*] Multi-line docstring summary should start at the first line
 --> tests\models\test_keystroke_manager.py:1:1
  |
1 | / """
2 | | Comprehensive tests for the KeystrokeManager class.
3 | |
4 | | This module provides extensive test coverage for the KeystrokeManager class,
5 | | including all methods, edge cases, error conditions, and integration scenarios.
6 | | Tests aim for >95% coverage and validate the manager's behavior under various conditions.
7 | | """
  | |___^
8 |
9 |   import os
  |
help: Remove whitespace after opening quotes

D102 Missing docstring in public method
   --> tests\models\test_keystroke_manager.py:546:9
    |
545 |     @pytest.fixture
546 |     def integration_manager(self) -> KeystrokeManager:
    |         ^^^^^^^^^^^^^^^^^^^
547 |         db = DatabaseManager(":memory:")
548 |         db.init_tables()
    |

E501 Line too long (246 > 120)
   --> tests\models\test_keystroke_manager.py:602:121
    |
600 | 
601 | 
602 | pet_index_end, content, start_time, end_time, actual_chars, errors, ms_per_keystroke) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)",
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
603 | 
604 | 
    |

E501 Line too long (250 > 120)
   --> tests\models\test_keystroke_manager.py:684:121
    |
682 | 
683 | 
684 | snippet_index_end, content, start_time, end_time, actual_chars, errors, ms_per_keystroke) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)",
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
685 | 
686 | 
    |

D103 Missing docstring in public function
    --> tests\models\test_keystroke_manager.py:1042:5
     |
1041 | @pytest.fixture(scope="module")
1042 | def test_user(request: pytest.FixtureRequest) -> str:
     |     ^^^^^^^^^
1043 |     db: DatabaseManager = getattr(request, "db", None)
1044 |     if db is None:
     |

D103 Missing docstring in public function
    --> tests\models\test_keystroke_manager.py:1056:5
     |
1055 | @pytest.fixture(scope="module")
1056 | def test_keyboard(request: pytest.FixtureRequest, test_user: str) -> str:
     |     ^^^^^^^^^^^^^
1057 |     db: DatabaseManager = getattr(request, "db", None)
1058 |     if db is None:
     |

D103 Missing docstring in public function
    --> tests\models\test_keystroke_manager.py:1070:5
     |
1069 | @pytest.fixture(scope="module")
1070 | def test_session(request: pytest.FixtureRequest, test_user: str, test_keyboard: str) -> str:
     |     ^^^^^^^^^^^^
1071 |     db: DatabaseManager = getattr(request, "db", None)
1072 |     if db is None:
     |

D103 Missing docstring in public function
    --> tests\models\test_keystroke_manager.py:1109:5
     |
1108 | @pytest.fixture
1109 | def manager(test_db_path: str) -> KeystrokeManager:
     |     ^^^^^^^
1110 |     db = DatabaseManager(test_db_path)
1111 |     return KeystrokeManager(db_manager=db)
     |

D100 Missing docstring in public module
--> tests\models\test_llm_ngram_service.py:1:1

ANN201 Missing return type annotation for public function `test_missing_api_key`
  --> tests\models\test_llm_ngram_service.py:9:5
   |
 9 | def test_missing_api_key():
   |     ^^^^^^^^^^^^^^^^^^^^
10 |     with pytest.raises(LLMMissingAPIKeyError):
11 |         LLMNgramService(api_key=None)  # type: ignore
   |
help: Add return type annotation: `None`

D103 Missing docstring in public function
  --> tests\models\test_llm_ngram_service.py:9:5
   |
 9 | def test_missing_api_key():
   |     ^^^^^^^^^^^^^^^^^^^^
10 |     with pytest.raises(LLMMissingAPIKeyError):
11 |         LLMNgramService(api_key=None)  # type: ignore
   |

ANN201 Missing return type annotation for public function `test_invalid_ngrams`
  --> tests\models\test_llm_ngram_service.py:14:5
   |
14 | def test_invalid_ngrams():
   |     ^^^^^^^^^^^^^^^^^^^
15 |     svc = LLMNgramService(api_key="sk-test")
16 |     with pytest.raises(ValueError):
   |
help: Add return type annotation: `None`

D103 Missing docstring in public function
  --> tests\models\test_llm_ngram_service.py:14:5
   |
14 | def test_invalid_ngrams():
   |     ^^^^^^^^^^^^^^^^^^^
15 |     svc = LLMNgramService(api_key="sk-test")
16 |     with pytest.raises(ValueError):
   |

D103 Missing docstring in public function
  --> tests\models\test_llm_ngram_service.py:22:5
   |
22 | def test_llm_success() -> None:
   |     ^^^^^^^^^^^^^^^^
23 |     svc = LLMNgramService(api_key="sk-test")
24 |     with patch.object(
   |

D103 Missing docstring in public function
  --> tests\models\test_llm_ngram_service.py:31:5
   |
31 | def test_llm_trims_to_max_length() -> None:
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
32 |     svc = LLMNgramService(api_key="sk-test")
33 |     long_text = "one two three four five six seven eight nine ten"
   |

D200 One-line docstring should fit on one line
 --> tests\models\test_next_session_position.py:1:1
  |
1 | / """
2 | | Tests for determining the next session position based on previous sessions.
3 | | """
  | |___^
4 |
5 |   import datetime
  |
help: Reformat to one line

D212 [*] Multi-line docstring summary should start at the first line
 --> tests\models\test_next_session_position.py:1:1
  |
1 | / """
2 | | Tests for determining the next session position based on previous sessions.
3 | | """
  | |___^
4 |
5 |   import datetime
  |
help: Remove whitespace after opening quotes

E402 Module level import not at top of file
  --> tests\models\test_next_session_position.py:18:1
   |
16 |     sys.path.insert(0, project_root)
17 |
18 | from db.database_manager import DatabaseManager
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
19 | from models.session import Session
20 | from models.session_manager import SessionManager
   |

E402 Module level import not at top of file
  --> tests\models\test_next_session_position.py:19:1
   |
18 | from db.database_manager import DatabaseManager
19 | from models.session import Session
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
20 | from models.session_manager import SessionManager
   |

E402 Module level import not at top of file
  --> tests\models\test_next_session_position.py:20:1
   |
18 | from db.database_manager import DatabaseManager
19 | from models.session import Session
20 | from models.session_manager import SessionManager
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |

ANN201 Missing return type annotation for public function `temp_db`
  --> tests\models\test_next_session_position.py:24:5
   |
23 | @pytest.fixture
24 | def temp_db():
   |     ^^^^^^^
25 |     """Create a temporary in-memory database for testing."""
26 |     db_manager = DatabaseManager(":memory:")
   |
help: Add return type annotation

F841 Local variable `snippet_length` is assigned to but never used
   --> tests\models\test_next_session_position.py:151:5
    |
149 |     session_manager = temp_db["session_manager"]
150 |     snippet_id = temp_db["snippet_id"]
151 |     snippet_length = len(temp_db["snippet_content"])
    |     ^^^^^^^^^^^^^^
152 |
153 |     # Create a session with end position beyond actual snippet length (simulating content change)
    |
help: Remove assignment to unused variable `snippet_length`

D100 Missing docstring in public module
--> tests\models\test_ngram.py:1:1

F401 [*] `models.ngram.MIN_NGRAM_SIZE` imported but unused
  --> tests\models\test_ngram.py:8:5
   |
 6 | from models.ngram import (
 7 |     MAX_NGRAM_SIZE,
 8 |     MIN_NGRAM_SIZE,
   |     ^^^^^^^^^^^^^^
 9 |     ErrorNGram,
10 |     Keystroke,
   |
help: Remove unused import

F401 [*] `models.ngram.nfc` imported but unused
  --> tests\models\test_ngram.py:15:5
   |
13 |     has_sequence_separators,
14 |     is_valid_ngram_text,
15 |     nfc,
   |     ^^^
16 | )
   |
help: Remove unused import

D103 Missing docstring in public function
  --> tests\models\test_ngram.py:19:5
   |
19 | def ts(ms: int) -> datetime:
   |     ^^
20 |     return datetime(2025, 1, 1, 8, 0, 0, tzinfo=timezone.utc) + timedelta(milliseconds=ms)
   |

D101 Missing docstring in public class
  --> tests\models\test_ngram.py:23:7
   |
23 | class TestKeystroke:
   |       ^^^^^^^^^^^^^
24 |     def test_keystroke_basic(self):
25 |         k = Keystroke(keystroke_time=ts(0), text_index=0, expected_char="a", keystroke_char="a", is_error=False)
   |

ANN201 Missing return type annotation for public function `test_keystroke_basic`
  --> tests\models\test_ngram.py:24:9
   |
23 | class TestKeystroke:
24 |     def test_keystroke_basic(self):
   |         ^^^^^^^^^^^^^^^^^^^^
25 |         k = Keystroke(keystroke_time=ts(0), text_index=0, expected_char="a", keystroke_char="a", is_error=False)
26 |         assert k.expected_char == "a"
   |
help: Add return type annotation: `None`

D102 Missing docstring in public method
  --> tests\models\test_ngram.py:24:9
   |
23 | class TestKeystroke:
24 |     def test_keystroke_basic(self):
   |         ^^^^^^^^^^^^^^^^^^^^
25 |         k = Keystroke(keystroke_time=ts(0), text_index=0, expected_char="a", keystroke_char="a", is_error=False)
26 |         assert k.expected_char == "a"
   |

ANN201 Missing return type annotation for public function `test_keystroke_nfc_single_char`
  --> tests\models\test_ngram.py:29:9
   |
27 |         assert k.keystroke_char == "a"
28 |
29 |     def test_keystroke_nfc_single_char(self):
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
30 |         # composed e + 
31 |         k = Keystroke(keystroke_time=ts(0), text_index=0, expected_char="e\u0301", keystroke_char="", is_error=False)
   |
help: Add return type annotation: `None`

D102 Missing docstring in public method
  --> tests\models\test_ngram.py:29:9
   |
27 |         assert k.keystroke_char == "a"
28 |
29 |     def test_keystroke_nfc_single_char(self):
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
30 |         # composed e + 
31 |         k = Keystroke(keystroke_time=ts(0), text_index=0, expected_char="e\u0301", keystroke_char="", is_error=False)
   |

D101 Missing docstring in public class
  --> tests\models\test_ngram.py:36:7
   |
36 | class TestNGramTextRules:
   |       ^^^^^^^^^^^^^^^^^^
37 |     def test_has_sequence_separators(self):
38 |         assert has_sequence_separators("a b") is True
   |

ANN201 Missing return type annotation for public function `test_has_sequence_separators`
  --> tests\models\test_ngram.py:37:9
   |
36 | class TestNGramTextRules:
37 |     def test_has_sequence_separators(self):
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
38 |         assert has_sequence_separators("a b") is True
39 |         assert has_sequence_separators("ab") is False
   |
help: Add return type annotation: `None`

D102 Missing docstring in public method
  --> tests\models\test_ngram.py:37:9
   |
36 | class TestNGramTextRules:
37 |     def test_has_sequence_separators(self):
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
38 |         assert has_sequence_separators("a b") is True
39 |         assert has_sequence_separators("ab") is False
   |

ANN201 Missing return type annotation for public function `test_is_valid_ngram_text`
  --> tests\models\test_ngram.py:41:9
   |
39 |         assert has_sequence_separators("ab") is False
40 |
41 |     def test_is_valid_ngram_text(self):
   |         ^^^^^^^^^^^^^^^^^^^^^^^^
42 |         assert is_valid_ngram_text("ab") is True
43 |         assert is_valid_ngram_text("a") is False  # too short
   |
help: Add return type annotation: `None`

D102 Missing docstring in public method
  --> tests\models\test_ngram.py:41:9
   |
39 |         assert has_sequence_separators("ab") is False
40 |
41 |     def test_is_valid_ngram_text(self):
   |         ^^^^^^^^^^^^^^^^^^^^^^^^
42 |         assert is_valid_ngram_text("ab") is True
43 |         assert is_valid_ngram_text("a") is False  # too short
   |

D101 Missing docstring in public class
  --> tests\models\test_ngram.py:47:7
   |
47 | class TestSpeedNGram:
   |       ^^^^^^^^^^^^^^
48 |     def test_speed_ngram_computes_ms_per_keystroke(self):
49 |         ng = SpeedNGram(
   |

ANN201 Missing return type annotation for public function `test_speed_ngram_computes_ms_per_keystroke`
  --> tests\models\test_ngram.py:48:9
   |
47 | class TestSpeedNGram:
48 |     def test_speed_ngram_computes_ms_per_keystroke(self):
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
49 |         ng = SpeedNGram(
50 |             id=uuid.uuid4(),
   |
help: Add return type annotation: `None`

D102 Missing docstring in public method
  --> tests\models\test_ngram.py:48:9
   |
47 | class TestSpeedNGram:
48 |     def test_speed_ngram_computes_ms_per_keystroke(self):
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
49 |         ng = SpeedNGram(
50 |             id=uuid.uuid4(),
   |

ANN201 Missing return type annotation for public function `test_speed_ngram_rejects_separators`
  --> tests\models\test_ngram.py:60:9
   |
58 |         assert ng.ms_per_keystroke == pytest.approx(50.0)
59 |
60 |     def test_speed_ngram_rejects_separators(self):
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
61 |         with pytest.raises(Exception):
62 |             SpeedNGram(
   |
help: Add return type annotation: `None`

D102 Missing docstring in public method
  --> tests\models\test_ngram.py:60:9
   |
58 |         assert ng.ms_per_keystroke == pytest.approx(50.0)
59 |
60 |     def test_speed_ngram_rejects_separators(self):
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
61 |         with pytest.raises(Exception):
62 |             SpeedNGram(
   |

B017 Do not assert blind exception: `Exception`
  --> tests\models\test_ngram.py:61:14
   |
60 |     def test_speed_ngram_rejects_separators(self):
61 |         with pytest.raises(Exception):
   |              ^^^^^^^^^^^^^^^^^^^^^^^^
62 |             SpeedNGram(
63 |                 id=uuid.uuid4(),
   |

ANN201 Missing return type annotation for public function `test_speed_ngram_invalid_size`
  --> tests\models\test_ngram.py:71:9
   |
69 |             )
70 |
71 |     def test_speed_ngram_invalid_size(self):
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
72 |         with pytest.raises(Exception):
73 |             SpeedNGram(
   |
help: Add return type annotation: `None`

D102 Missing docstring in public method
  --> tests\models\test_ngram.py:71:9
   |
69 |             )
70 |
71 |     def test_speed_ngram_invalid_size(self):
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
72 |         with pytest.raises(Exception):
73 |             SpeedNGram(
   |

B017 Do not assert blind exception: `Exception`
  --> tests\models\test_ngram.py:72:14
   |
71 |     def test_speed_ngram_invalid_size(self):
72 |         with pytest.raises(Exception):
   |              ^^^^^^^^^^^^^^^^^^^^^^^^
73 |             SpeedNGram(
74 |                 id=uuid.uuid4(),
   |

ANN201 Missing return type annotation for public function `test_speed_ngram_at_max_size`
  --> tests\models\test_ngram.py:82:9
   |
80 |             )
81 |
82 |     def test_speed_ngram_at_max_size(self):
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
83 |         text = "a" * MAX_NGRAM_SIZE
84 |         ng = SpeedNGram(
   |
help: Add return type annotation: `None`

D102 Missing docstring in public method
  --> tests\models\test_ngram.py:82:9
   |
80 |             )
81 |
82 |     def test_speed_ngram_at_max_size(self):
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
83 |         text = "a" * MAX_NGRAM_SIZE
84 |         ng = SpeedNGram(
   |

ANN201 Missing return type annotation for public function `test_speed_ngram_rejects_over_max`
  --> tests\models\test_ngram.py:96:9
   |
94 |         assert ng.ms_per_keystroke == pytest.approx(10.0)
95 |
96 |     def test_speed_ngram_rejects_over_max(self):
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
97 |         text = "a" * (MAX_NGRAM_SIZE + 1)
98 |         with pytest.raises(Exception):
   |
help: Add return type annotation: `None`

D102 Missing docstring in public method
  --> tests\models\test_ngram.py:96:9
   |
94 |         assert ng.ms_per_keystroke == pytest.approx(10.0)
95 |
96 |     def test_speed_ngram_rejects_over_max(self):
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
97 |         text = "a" * (MAX_NGRAM_SIZE + 1)
98 |         with pytest.raises(Exception):
   |

B017 Do not assert blind exception: `Exception`
   --> tests\models\test_ngram.py:98:14
    |
 96 |     def test_speed_ngram_rejects_over_max(self):
 97 |         text = "a" * (MAX_NGRAM_SIZE + 1)
 98 |         with pytest.raises(Exception):
    |              ^^^^^^^^^^^^^^^^^^^^^^^^
 99 |             SpeedNGram(
100 |                 id=uuid.uuid4(),
    |

D101 Missing docstring in public class
   --> tests\models\test_ngram.py:109:7
    |
109 | class TestErrorNGram:
    |       ^^^^^^^^^^^^^^
110 |     def test_error_ngram_pattern_last_char_only(self):
111 |         # differs only on last char
    |

ANN201 Missing return type annotation for public function `test_error_ngram_pattern_last_char_only`
   --> tests\models\test_ngram.py:110:9
    |
109 | class TestErrorNGram:
110 |     def test_error_ngram_pattern_last_char_only(self):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
111 |         # differs only on last char
112 |         ErrorNGram(
    |
help: Add return type annotation: `None`

D102 Missing docstring in public method
   --> tests\models\test_ngram.py:110:9
    |
109 | class TestErrorNGram:
110 |     def test_error_ngram_pattern_last_char_only(self):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
111 |         # differs only on last char
112 |         ErrorNGram(
    |

ANN201 Missing return type annotation for public function `test_error_ngram_pattern_invalid_first_char`
   --> tests\models\test_ngram.py:121:9
    |
119 |         )
120 |
121 |     def test_error_ngram_pattern_invalid_first_char(self):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
122 |         with pytest.raises(Exception):
123 |             ErrorNGram(
    |
help: Add return type annotation: `None`

D102 Missing docstring in public method
   --> tests\models\test_ngram.py:121:9
    |
119 |         )
120 |
121 |     def test_error_ngram_pattern_invalid_first_char(self):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
122 |         with pytest.raises(Exception):
123 |             ErrorNGram(
    |

B017 Do not assert blind exception: `Exception`
   --> tests\models\test_ngram.py:122:14
    |
121 |     def test_error_ngram_pattern_invalid_first_char(self):
122 |         with pytest.raises(Exception):
    |              ^^^^^^^^^^^^^^^^^^^^^^^^
123 |             ErrorNGram(
124 |                 id=uuid.uuid4(),
    |

ANN201 Missing return type annotation for public function `test_error_ngram_rejects_separators`
   --> tests\models\test_ngram.py:132:9
    |
130 |             )
131 |
132 |     def test_error_ngram_rejects_separators(self):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
133 |         with pytest.raises(Exception):
134 |             ErrorNGram(
    |
help: Add return type annotation: `None`

D102 Missing docstring in public method
   --> tests\models\test_ngram.py:132:9
    |
130 |             )
131 |
132 |     def test_error_ngram_rejects_separators(self):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
133 |         with pytest.raises(Exception):
134 |             ErrorNGram(
    |

B017 Do not assert blind exception: `Exception`
   --> tests\models\test_ngram.py:133:14
    |
132 |     def test_error_ngram_rejects_separators(self):
133 |         with pytest.raises(Exception):
    |              ^^^^^^^^^^^^^^^^^^^^^^^^
134 |             ErrorNGram(
135 |                 id=uuid.uuid4(),
    |

ANN201 Missing return type annotation for public function `test_error_ngram_at_max_size`
   --> tests\models\test_ngram.py:143:9
    |
141 |             )
142 |
143 |     def test_error_ngram_at_max_size(self):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
144 |         exp = "a" * (MAX_NGRAM_SIZE - 1) + "b"
145 |         act = "a" * (MAX_NGRAM_SIZE - 1) + "x"
    |
help: Add return type annotation: `None`

D102 Missing docstring in public method
   --> tests\models\test_ngram.py:143:9
    |
141 |             )
142 |
143 |     def test_error_ngram_at_max_size(self):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
144 |         exp = "a" * (MAX_NGRAM_SIZE - 1) + "b"
145 |         act = "a" * (MAX_NGRAM_SIZE - 1) + "x"
    |

ANN201 Missing return type annotation for public function `test_error_ngram_rejects_over_max`
   --> tests\models\test_ngram.py:156:9
    |
154 |         assert e.size == MAX_NGRAM_SIZE
155 |
156 |     def test_error_ngram_rejects_over_max(self):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
157 |         exp = "a" * MAX_NGRAM_SIZE + "b"
158 |         act = "a" * MAX_NGRAM_SIZE + "x"
    |
help: Add return type annotation: `None`

D102 Missing docstring in public method
   --> tests\models\test_ngram.py:156:9
    |
154 |         assert e.size == MAX_NGRAM_SIZE
155 |
156 |     def test_error_ngram_rejects_over_max(self):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
157 |         exp = "a" * MAX_NGRAM_SIZE + "b"
158 |         act = "a" * MAX_NGRAM_SIZE + "x"
    |

B017 Do not assert blind exception: `Exception`
   --> tests\models\test_ngram.py:159:14
    |
157 |         exp = "a" * MAX_NGRAM_SIZE + "b"
158 |         act = "a" * MAX_NGRAM_SIZE + "x"
159 |         with pytest.raises(Exception):
    |              ^^^^^^^^^^^^^^^^^^^^^^^^
160 |             ErrorNGram(
161 |                 id=uuid.uuid4(),
    |

D212 [*] Multi-line docstring summary should start at the first line
 --> tests\models\test_ngram_analytics_service.py:1:1
  |
1 | / """
2 | | Tests for NGramAnalyticsService class.
3 | |
4 | | This module contains comprehensive tests for the NGramAnalyticsService class,
5 | | including tests for decaying average calculations, performance summaries,
6 | | historical analysis, and analytics methods moved from NGramManager.
7 | | """
  | |___^
8 |
9 |   import sys
  |
help: Remove whitespace after opening quotes

D212 [*] Multi-line docstring summary should start at the first line
  --> tests\models\test_ngram_analytics_service.py:41:9
   |
40 |       def test_calculate_decaying_average_basic(self) -> None:
41 | /         """
42 | |         Test objective: Verify basic decaying average calculation.
43 | |
44 | |         Tests that the calculator properly computes a decaying average
45 | |         where more recent values have higher weights.
46 | |         """
   | |___________^
47 |           calc = DecayingAverageCalculator(decay_factor=0.9, max_samples=20)
   |
help: Remove whitespace after opening quotes

D212 [*] Multi-line docstring summary should start at the first line
  --> tests\models\test_ngram_analytics_service.py:68:9
   |
67 |       def test_calculate_decaying_average_single_value(self) -> None:
68 | /         """
69 | |         Test objective: Verify decaying average with single value.
70 | |
71 | |         Tests that a single value returns itself as the average.
72 | |         """
   | |___________^
73 |           calc = DecayingAverageCalculator(decay_factor=0.9, max_samples=20)
   |
help: Remove whitespace after opening quotes

D212 [*] Multi-line docstring summary should start at the first line
  --> tests\models\test_ngram_analytics_service.py:82:9
   |
81 |       def test_calculate_decaying_average_empty_values(self) -> None:
82 | /         """
83 | |         Test objective: Verify decaying average with empty input.
84 | |
85 | |         Tests that empty input returns 0.0.
86 | |         """
   | |___________^
87 |           calc = DecayingAverageCalculator(decay_factor=0.9, max_samples=20)
   |
help: Remove whitespace after opening quotes

D212 [*] Multi-line docstring summary should start at the first line
  --> tests\models\test_ngram_analytics_service.py:93:9
   |
92 |       def test_calculate_decaying_average_max_samples(self) -> None:
93 | /         """
94 | |         Test objective: Verify decaying average respects max_samples limit.
95 | |
96 | |         Tests that only the most recent max_samples values are used.
97 | |         """
   | |___________^
98 |           calc = DecayingAverageCalculator(decay_factor=0.9, max_samples=3)
   |
help: Remove whitespace after opening quotes

D212 [*] Multi-line docstring summary should start at the first line
   --> tests\models\test_ngram_analytics_service.py:122:9
    |
121 |       def test_init_with_valid_dependencies(self, db_with_tables: DatabaseManager) -> None:
122 | /         """
123 | |         Test objective: Verify NGramAnalyticsService initialization.
124 | |
125 | |         Tests that the service initializes properly with valid dependencies.
126 | |         """
    | |___________^
127 |           ngram_manager = NGramManager()
128 |           service = NGramAnalyticsService(db_with_tables, ngram_manager)
    |
help: Remove whitespace after opening quotes

D212 [*] Multi-line docstring summary should start at the first line
   --> tests\models\test_ngram_analytics_service.py:135:9
    |
134 |       def test_init_with_none_dependencies(self) -> None:
135 | /         """
136 | |         Test objective: Verify NGramAnalyticsService handles None dependencies.
137 | |
138 | |         Tests that the service handles None dependencies gracefully.
139 | |         """
    | |___________^
140 |           service = NGramAnalyticsService(None, None)
    |
help: Remove whitespace after opening quotes

D212 [*] Multi-line docstring summary should start at the first line
   --> tests\models\test_ngram_analytics_service.py:150:9
    |
148 |           ngram_speed_test_data: Tuple[DatabaseManager, NGramAnalyticsService, str, str, str],
149 |       ) -> None:
150 | /         """
151 | |         Test objective: Verify speed summaries refresh functionality.
152 | |
153 | |         Tests that speed summaries are properly calculated and stored
154 | |         in the summary table.
155 | |         """
    | |___________^
156 |           db, service, _session_id, user_id, keyboard_id = ngram_speed_test_data
157 |           # Run refresh on preloaded mock data
    |
help: Remove whitespace after opening quotes

D212 [*] Multi-line docstring summary should start at the first line
   --> tests\models\test_ngram_analytics_service.py:170:9
    |
168 |           self, db_with_tables: DatabaseManager
169 |       ) -> None:
170 | /         """
171 | |         Test objective: Verify speed heatmap data retrieval.
172 | |
173 | |         Tests that heatmap data is properly retrieved with correct
174 | |         performance calculations and color coding.
175 | |         """
    | |___________^
176 |           ngram_manager = NGramManager()
177 |           service = NGramAnalyticsService(db_with_tables, ngram_manager)
    |
help: Remove whitespace after opening quotes

D212 [*] Multi-line docstring summary should start at the first line
   --> tests\models\test_ngram_analytics_service.py:192:9
    |
190 |           self, db_with_tables: DatabaseManager
191 |       ) -> None:
192 | /         """
193 | |         Test objective: Verify performance trends calculation.
194 | |
195 | |         Tests that historical performance trends are properly calculated
196 | |         over the specified time window.
197 | |         """
    | |___________^
198 |           ngram_manager = NGramManager(temp_db)
199 |           service = NGramAnalyticsService(temp_db, ngram_manager)
    |
help: Remove whitespace after opening quotes

F821 Undefined name `temp_db`
   --> tests\models\test_ngram_analytics_service.py:198:38
    |
196 |         over the specified time window.
197 |         """
198 |         ngram_manager = NGramManager(temp_db)
    |                                      ^^^^^^^
199 |         service = NGramAnalyticsService(temp_db, ngram_manager)
    |

F821 Undefined name `temp_db`
   --> tests\models\test_ngram_analytics_service.py:199:41
    |
197 |         """
198 |         ngram_manager = NGramManager(temp_db)
199 |         service = NGramAnalyticsService(temp_db, ngram_manager)
    |                                         ^^^^^^^
200 |
201 |         # TODO: Set up test data
    |

D212 [*] Multi-line docstring summary should start at the first line
   --> tests\models\test_ngram_analytics_service.py:215:9
    |
213 |           ngram_speed_test_data: Tuple[DatabaseManager, NGramAnalyticsService, str, str, str]
214 |       ) -> None:
215 | /         """
216 | |         Test objective: Verify slowest_n method moved from NGramManager.
217 | |
218 | |         Tests that the slowest_n method works correctly in the analytics service
219 | |         with proper parameter handling and filtering.
220 | |         """
    | |___________^
221 |           temp_db, service, session_id, user_id, keyboard_id = ngram_speed_test_data
    |
help: Remove whitespace after opening quotes

D212 [*] Multi-line docstring summary should start at the first line
   --> tests\models\test_ngram_analytics_service.py:258:9
    |
256 |           self, db_with_tables: DatabaseManager
257 |       ) -> None:
258 | /         """
259 | |         Test objective: Verify error_n method moved from NGramManager.
260 | |
261 | |         Tests that the error_n method works correctly in the analytics service
262 | |         with proper parameter handling and filtering.
263 | |         """
    | |___________^
264 |           ngram_manager = NGramManager(temp_db)
265 |           service = NGramAnalyticsService(temp_db, ngram_manager)
    |
help: Remove whitespace after opening quotes

F821 Undefined name `temp_db`
   --> tests\models\test_ngram_analytics_service.py:264:38
    |
262 |         with proper parameter handling and filtering.
263 |         """
264 |         ngram_manager = NGramManager(temp_db)
    |                                      ^^^^^^^
265 |         service = NGramAnalyticsService(temp_db, ngram_manager)
    |

F821 Undefined name `temp_db`
   --> tests\models\test_ngram_analytics_service.py:265:41
    |
263 |         """
264 |         ngram_manager = NGramManager(temp_db)
265 |         service = NGramAnalyticsService(temp_db, ngram_manager)
    |                                         ^^^^^^^
266 |
267 |         # Set up test data - create practice session and n-gram error data
    |

F821 Undefined name `temp_db`
   --> tests\models\test_ngram_analytics_service.py:273:9
    |
272 |         # Insert test session with all required fields
273 |         temp_db.execute(
    |         ^^^^^^^
274 |             """INSERT INTO practice_sessions 
275 |             (session_id, user_id, keyboard_id, snippet_id, snippet_index_start, snippet_index_end, 
    |

F821 Undefined name `temp_db`
   --> tests\models\test_ngram_analytics_service.py:295:9
    |
294 |         # Insert test n-gram error data
295 |         temp_db.execute(
    |         ^^^^^^^
296 |             "INSERT INTO session_ngram_errors (session_id, ngram_text, ngram_size) VALUES (?, ?, ?)",
297 |             (session_id, "th", 2),
    |

F821 Undefined name `temp_db`
   --> tests\models\test_ngram_analytics_service.py:299:9
    |
297 |             (session_id, "th", 2),
298 |         )
299 |         temp_db.execute(
    |         ^^^^^^^
300 |             "INSERT INTO session_ngram_errors (session_id, ngram_text, ngram_size) VALUES (?, ?, ?)",
301 |             (session_id, "the", 3),
    |

F821 Undefined name `temp_db`
   --> tests\models\test_ngram_analytics_service.py:303:9
    |
301 |             (session_id, "the", 3),
302 |         )
303 |         temp_db.execute(
    |         ^^^^^^^
304 |             "INSERT INTO session_ngram_errors (session_id, ngram_text, ngram_size) VALUES (?, ?, ?)",
305 |             (session_id, "er", 2),
    |

F821 Undefined name `temp_db`
   --> tests\models\test_ngram_analytics_service.py:308:9
    |
306 |         )
307 |         # Add more occurrences to meet minimum count requirement
308 |         temp_db.execute(
    |         ^^^^^^^
309 |             "INSERT INTO session_ngram_errors (session_id, ngram_text, ngram_size) VALUES (?, ?, ?)",
310 |             (session_id, "th", 2),
    |

F821 Undefined name `temp_db`
   --> tests\models\test_ngram_analytics_service.py:312:9
    |
310 |             (session_id, "th", 2),
311 |         )
312 |         temp_db.execute(
    |         ^^^^^^^
313 |             "INSERT INTO session_ngram_errors (session_id, ngram_text, ngram_size) VALUES (?, ?, ?)",
314 |             (session_id, "the", 3),
    |

D212 [*] Multi-line docstring summary should start at the first line
   --> tests\models\test_ngram_analytics_service.py:354:9
    |
352 |           mock_ngram_data: List[MockNGramSpeedData],
353 |       ) -> None:
354 | /         """
355 | |         Test objective: Verify dual-insert creates records in both current and history tables.
356 | |
357 | |         Tests that when refresh_speed_summaries is called, records are created
358 | |         in both ngram_speed_summary_curr and ngram_speed_summary_hist tables.
359 | |         """
    | |___________^
360 |           ngram_manager = NGramManager(temp_db)
361 |           service = NGramAnalyticsService(temp_db, ngram_manager)
    |
help: Remove whitespace after opening quotes

D212 [*] Multi-line docstring summary should start at the first line
   --> tests\models\test_ngram_analytics_service.py:427:9
    |
425 |           mock_ngram_data: List[MockNGramSpeedData],
426 |       ) -> None:
427 | /         """
428 | |         Test objective: Verify history table contains all records over multiple refreshes.
429 | |
430 | |         Tests that the history table accumulates all records from multiple
431 | |         refresh operations while current table only contains latest values.
432 | |         """
    | |___________^
433 |           ngram_manager = NGramManager(temp_db)
434 |           service = NGramAnalyticsService(temp_db, ngram_manager)
    |
help: Remove whitespace after opening quotes

D212 [*] Multi-line docstring summary should start at the first line
   --> tests\models\test_ngram_analytics_service.py:537:9
    |
535 |           mock_ngram_data: List[MockNGramSpeedData],
536 |       ) -> None:
537 | /         """
538 | |         Test objective: Verify history retrieval functionality.
539 | |
540 | |         Tests that historical data can be retrieved properly with correct
541 | |         timestamps and performance metrics.
542 | |         """
    | |___________^
543 |           ngram_manager = NGramManager(temp_db)
544 |           service = NGramAnalyticsService(temp_db, ngram_manager)
    |
help: Remove whitespace after opening quotes

D212 [*] Multi-line docstring summary should start at the first line
   --> tests\models\test_ngram_analytics_service.py:606:9
    |
604 |           self, temp_db: DatabaseManager
605 |       ) -> None:
606 | /         """
607 | |         Test objective: Verify history table schema matches current table.
608 | |
609 | |         Tests that the history table has the same essential columns as
610 | |         the current table plus additional history-specific fields.
611 | |         """
    | |___________^
612 |           ngram_manager = NGramManager(temp_db)
613 |           service = NGramAnalyticsService(temp_db, ngram_manager)
    |
help: Remove whitespace after opening quotes

F841 Local variable `service` is assigned to but never used
   --> tests\models\test_ngram_analytics_service.py:613:9
    |
611 |         """
612 |         ngram_manager = NGramManager(temp_db)
613 |         service = NGramAnalyticsService(temp_db, ngram_manager)
    |         ^^^^^^^
614 |
615 |         # Verify table schemas are compatible
    |
help: Remove assignment to unused variable `service`

D212 [*] Multi-line docstring summary should start at the first line
   --> tests\models\test_ngram_analytics_service.py:651:9
    |
650 |       def test_valid_performance_data(self) -> None:
651 | /         """
652 | |         Test objective: Verify NGramPerformanceData model validation.
653 | |
654 | |         Tests that the model properly validates correct performance data.
655 | |         """
    | |___________^
656 |           data = NGramPerformanceData(
657 |               ngram_text="th",
    |
help: Remove whitespace after opening quotes

D212 [*] Multi-line docstring summary should start at the first line
   --> tests\models\test_ngram_analytics_service.py:674:9
    |
673 |       def test_invalid_performance_data(self) -> None:
674 | /         """
675 | |         Test objective: Verify NGramPerformanceData model validation errors.
676 | |
677 | |         Tests that the model properly rejects invalid performance data.
678 | |         """
    | |___________^
679 |           with pytest.raises(ValidationError):
680 |               NGramPerformanceData(
    |
help: Remove whitespace after opening quotes

D212 [*] Multi-line docstring summary should start at the first line
   --> tests\models\test_ngram_analytics_service.py:695:9
    |
694 |       def test_valid_heatmap_data(self) -> None:
695 | /         """
696 | |         Test objective: Verify NGramHeatmapData model validation.
697 | |
698 | |         Tests that the model properly validates correct heatmap data.
699 | |         """
    | |___________^
700 |           data = NGramHeatmapData(
701 |               ngram_text="th",
    |
help: Remove whitespace after opening quotes

D212 [*] Multi-line docstring summary should start at the first line
  --> tests\models\test_ngram_analytics_service_session_methods.py:1:1
   |
 1 | / """
 2 | | Comprehensive tests for NGramAnalyticsService session-level methods.
 3 | |
 4 | | Tests the three new methods:
 5 | | - SummarizeSessionNgrams
 6 | | - AddSpeedSummaryForSession  
 7 | | - CatchupSpeedSummary
 8 | |
 9 | | These tests use real database connections and do not mock database operations
10 | | as per the requirement to test database pushdown functionality.
11 | | """
   | |___^
12 |
13 |   import uuid
   |
help: Remove whitespace after opening quotes

ANN201 Missing return type annotation for public function `test_summarize_with_ngram_speed_only`
  --> tests\models\test_ngram_analytics_service_session_methods.py:63:9
   |
61 |         (3, 3),  # Multiple ngram speed entries
62 |     ])
63 |     def test_summarize_with_ngram_speed_only(
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
64 |         self, 
65 |         analytics_service: NGramAnalyticsService,
   |
help: Add return type annotation: `None`

ANN201 Missing return type annotation for public function `test_summarize_with_ngram_errors_only`
   --> tests\models\test_ngram_analytics_service_session_methods.py:111:9
    |
109 |         (2, 2),  # Multiple error entries
110 |     ])
111 |     def test_summarize_with_ngram_errors_only(
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
112 |         self,
113 |         analytics_service: NGramAnalyticsService,
    |
help: Add return type annotation: `None`

B007 Loop control variable `i` not used within loop body
   --> tests\models\test_ngram_analytics_service_session_methods.py:133:13
    |
131 |         # Create error data
132 |         error_data = []
133 |         for i in range(error_count):
    |             ^
134 |             error_data.append({
135 |                 'ngram_size': 2,
    |
help: Rename unused `i` to `_i`

ANN201 Missing return type annotation for public function `test_summarize_with_speed_and_errors`
   --> tests\models\test_ngram_analytics_service_session_methods.py:156:9
    |
154 |         assert summary_records[0]['error_count'] == expected_errors
155 |     
156 |     def test_summarize_with_speed_and_errors(
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
157 |         self,
158 |         analytics_service: NGramAnalyticsService,
    |
help: Add return type annotation: `None`

ANN201 Missing return type annotation for public function `test_summarize_with_keystrokes`
   --> tests\models\test_ngram_analytics_service_session_methods.py:217:9
    |
215 |         (3, 3),  # Multiple keystrokes
216 |     ])
217 |     def test_summarize_with_keystrokes(
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
218 |         self,
219 |         analytics_service: NGramAnalyticsService,
    |
help: Add return type annotation: `None`

ANN201 Missing return type annotation for public function `test_no_sessions_missing`
   --> tests\models\test_ngram_analytics_service_session_methods.py:262:9
    |
260 |             assert record['avg_ms_per_keystroke'] > 0
261 |     
262 |     def test_no_sessions_missing(
    |         ^^^^^^^^^^^^^^^^^^^^^^^^
263 |         self,
264 |         analytics_service: NGramAnalyticsService,
    |
help: Add return type annotation: `None`

ANN201 Missing return type annotation for public function `test_sessions_missing_no_data`
   --> tests\models\test_ngram_analytics_service_session_methods.py:293:9
    |
291 |         assert result == 0
292 |     
293 |     def test_sessions_missing_no_data(
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
294 |         self,
295 |         analytics_service: NGramAnalyticsService,
    |
help: Add return type annotation: `None`

ANN201 Missing return type annotation for public function `test_single_session_processing`
   --> tests\models\test_ngram_analytics_service_session_methods.py:311:9
    |
309 |     """Test cases for AddSpeedSummaryForSession method."""
310 |     
311 |     def test_single_session_processing(
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
312 |         self,
313 |         analytics_service: NGramAnalyticsService,
    |
help: Add return type annotation: `None`

ANN201 Missing return type annotation for public function `test_nonexistent_session`
   --> tests\models\test_ngram_analytics_service_session_methods.py:346:9
    |
344 |         assert result['curr_updated'] >= 0
345 |     
346 |     def test_nonexistent_session(
    |         ^^^^^^^^^^^^^^^^^^^^^^^^
347 |         self,
348 |         analytics_service: NGramAnalyticsService
    |
help: Add return type annotation: `None`

ANN201 Missing return type annotation for public function `test_multiple_ngrams_processing`
   --> tests\models\test_ngram_analytics_service_session_methods.py:356:9
    |
354 |             analytics_service.add_speed_summary_for_session(fake_session_id)
355 |     
356 |     def test_multiple_ngrams_processing(
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
357 |         self,
358 |         analytics_service: NGramAnalyticsService,
    |
help: Add return type annotation: `None`

ANN201 Missing return type annotation for public function `test_empty_database_catchup`
   --> tests\models\test_ngram_analytics_service_session_methods.py:405:9
    |
403 |     """Test cases for CatchupSpeedSummary method."""
404 |     
405 |     def test_empty_database_catchup(
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^
406 |         self,
407 |         analytics_service: NGramAnalyticsService
    |
help: Add return type annotation: `None`

ANN201 Missing return type annotation for public function `test_single_session_catchup`
   --> tests\models\test_ngram_analytics_service_session_methods.py:417:9
    |
415 |         assert result['total_curr_updated'] == 0
416 |     
417 |     def test_single_session_catchup(
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^
418 |         self,
419 |         analytics_service: NGramAnalyticsService,
    |
help: Add return type annotation: `None`

ANN201 Missing return type annotation for public function `test_multiple_sessions_catchup`
   --> tests\models\test_ngram_analytics_service_session_methods.py:451:9
    |
449 |         assert result['total_curr_updated'] >= 0
450 |     
451 |     def test_multiple_sessions_catchup(
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
452 |         self,
453 |         analytics_service: NGramAnalyticsService,
    |
help: Add return type annotation: `None`

ANN201 Missing return type annotation for public function `test_catchup_with_session_errors`
   --> tests\models\test_ngram_analytics_service_session_methods.py:486:9
    |
484 |         # (verified by the method's internal logging)
485 |     
486 |     def test_catchup_with_session_errors(
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
487 |         self,
488 |         analytics_service: NGramAnalyticsService,
    |
help: Add return type annotation: `None`

ANN201 Missing return type annotation for public function `test_full_workflow_integration`
   --> tests\models\test_ngram_analytics_service_session_methods.py:524:9
    |
522 |     """Integration tests combining multiple methods."""
523 |     
524 |     def test_full_workflow_integration(
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
525 |         self,
526 |         analytics_service: NGramAnalyticsService,
    |
help: Add return type annotation: `None`

D100 Missing docstring in public module
--> tests\models\test_ngram_clean.py:1:1

D100 Missing docstring in public module
--> tests\models\test_ngram_error.py:1:1

D100 Missing docstring in public module
--> tests\models\test_ngram_manager.py:1:1

F401 [*] `sqlite3` imported but unused
 --> tests\models\test_ngram_manager.py:1:8
  |
1 | import sqlite3
  |        ^^^^^^^
2 | import uuid
3 | from datetime import datetime, timedelta, timezone
  |
help: Remove unused import: `sqlite3`

F401 [*] `models.ngram.MAX_NGRAM_SIZE` imported but unused
 --> tests\models\test_ngram_manager.py:7:26
  |
5 | import pytest
6 |
7 | from models.ngram import MAX_NGRAM_SIZE, Keystroke, SpeedMode
  |                          ^^^^^^^^^^^^^^
8 | from models.ngram_manager import NGramManager
  |
help: Remove unused import

F401 [*] `models.ngram.SpeedMode` imported but unused
 --> tests\models\test_ngram_manager.py:7:53
  |
5 | import pytest
6 |
7 | from models.ngram import MAX_NGRAM_SIZE, Keystroke, SpeedMode
  |                                                     ^^^^^^^^^
8 | from models.ngram_manager import NGramManager
  |
help: Remove unused import

D103 Missing docstring in public function
  --> tests\models\test_ngram_manager.py:11:5
   |
11 | def ts(ms: int) -> datetime:
   |     ^^
12 |     return datetime(2025, 1, 1, 8, 0, 0, tzinfo=timezone.utc) + timedelta(milliseconds=ms)
   |

ANN201 Missing return type annotation for public function `make_k`
  --> tests\models\test_ngram_manager.py:15:5
   |
15 | def make_k(text: str, start_ms: int = 0, step_ms: int = 100):
   |     ^^^^^^
16 |     # Build keystrokes for expected text with perfect typing
17 |     ks = []
   |
help: Add return type annotation

D103 Missing docstring in public function
  --> tests\models\test_ngram_manager.py:15:5
   |
15 | def make_k(text: str, start_ms: int = 0, step_ms: int = 100):
   |     ^^^^^^
16 |     # Build keystrokes for expected text with perfect typing
17 |     ks = []
   |

D101 Missing docstring in public class
  --> tests\models\test_ngram_manager.py:25:7
   |
25 | class TestAnalyzeBasic:
   |       ^^^^^^^^^^^^^^^^
26 |     def test_clean_windows_and_gross_up(self):
27 |         mgr = NGramManager()
   |

ANN201 Missing return type annotation for public function `test_clean_windows_and_gross_up`
  --> tests\models\test_ngram_manager.py:26:9
   |
25 | class TestAnalyzeBasic:
26 |     def test_clean_windows_and_gross_up(self):
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
27 |         mgr = NGramManager()
28 |         expected = "Then"  # no separators
   |
help: Add return type annotation: `None`

D102 Missing docstring in public method
  --> tests\models\test_ngram_manager.py:26:9
   |
25 | class TestAnalyzeBasic:
26 |     def test_clean_windows_and_gross_up(self):
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
27 |         mgr = NGramManager()
28 |         expected = "Then"  # no separators
   |

ANN201 Missing return type annotation for public function `test_ignored_zero_duration`
  --> tests\models\test_ngram_manager.py:44:9
   |
42 |         assert first4.duration_ms == pytest.approx(2666.6666666667, rel=1e-3)
43 |
44 |     def test_ignored_zero_duration(self):
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^
45 |         mgr = NGramManager()
46 |         expected = "ab"
   |
help: Add return type annotation: `None`

D102 Missing docstring in public method
  --> tests\models\test_ngram_manager.py:44:9
   |
42 |         assert first4.duration_ms == pytest.approx(2666.6666666667, rel=1e-3)
43 |
44 |     def test_ignored_zero_duration(self):
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^
45 |         mgr = NGramManager()
46 |         expected = "ab"
   |

ANN201 Missing return type annotation for public function `test_separators_split_runs`
  --> tests\models\test_ngram_manager.py:54:9
   |
52 |         assert speed == [] and errors == []
53 |
54 |     def test_separators_split_runs(self):
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^
55 |         mgr = NGramManager()
56 |         expected = "hi there"  # space splits
   |
help: Add return type annotation: `None`

D102 Missing docstring in public method
  --> tests\models\test_ngram_manager.py:54:9
   |
52 |         assert speed == [] and errors == []
53 |
54 |     def test_separators_split_runs(self):
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^
55 |         mgr = NGramManager()
56 |         expected = "hi there"  # space splits
   |

D101 Missing docstring in public class
  --> tests\models\test_ngram_manager.py:64:7
   |
64 | class TestErrorClassification:
   |       ^^^^^^^^^^^^^^^^^^^^^^^
65 |     def test_error_last_only(self):
66 |         mgr = NGramManager()
   |

ANN201 Missing return type annotation for public function `test_error_last_only`
  --> tests\models\test_ngram_manager.py:65:9
   |
64 | class TestErrorClassification:
65 |     def test_error_last_only(self):
   |         ^^^^^^^^^^^^^^^^^^^^
66 |         mgr = NGramManager()
67 |         expected = "th"
   |
help: Add return type annotation: `None`

D102 Missing docstring in public method
  --> tests\models\test_ngram_manager.py:65:9
   |
64 | class TestErrorClassification:
65 |     def test_error_last_only(self):
   |         ^^^^^^^^^^^^^^^^^^^^
66 |         mgr = NGramManager()
67 |         expected = "th"
   |

ANN201 Missing return type annotation for public function `test_error_not_last_is_ignored`
  --> tests\models\test_ngram_manager.py:81:9
   |
79 |         assert err.duration_ms > 0
80 |
81 |     def test_error_not_last_is_ignored(self):
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
82 |         mgr = NGramManager()
83 |         expected = "th"
   |
help: Add return type annotation: `None`

D102 Missing docstring in public method
  --> tests\models\test_ngram_manager.py:81:9
   |
79 |         assert err.duration_ms > 0
80 |
81 |     def test_error_not_last_is_ignored(self):
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
82 |         mgr = NGramManager()
83 |         expected = "th"
   |

D212 [*] Multi-line docstring summary should start at the first line
 --> tests\models\test_ngram_orchestrator_process_end_of_session.py:1:1
  |
1 | / """
2 | | Integration-style tests for NGramAnalyticsService.process_end_of_session orchestrator.
3 | |
4 | | Validates strict sequencing and DB side effects on the success path using real DB.
5 | | """
  | |___^
6 |
7 |   import uuid
  |
help: Remove whitespace after opening quotes

ANN201 Missing return type annotation for public function `test_process_end_of_session_success_path`
  --> tests\models\test_ngram_orchestrator_process_end_of_session.py:36:5
   |
36 | def test_process_end_of_session_success_path(db_with_tables, test_user, test_keyboard):
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
37 |     # Arrange: create snippet (for FK completeness) and a new Session not yet in DB
38 |     from tests.models.conftest import TestSessionMethodsFixtures
   |
help: Add return type annotation: `None`

D103 Missing docstring in public function
  --> tests\models\test_ngram_orchestrator_process_end_of_session.py:36:5
   |
36 | def test_process_end_of_session_success_path(db_with_tables, test_user, test_keyboard):
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
37 |     # Arrange: create snippet (for FK completeness) and a new Session not yet in DB
38 |     from tests.models.conftest import TestSessionMethodsFixtures
   |

ANN001 Missing type annotation for function argument `db_with_tables`
  --> tests\models\test_ngram_orchestrator_process_end_of_session.py:36:46
   |
36 | def test_process_end_of_session_success_path(db_with_tables, test_user, test_keyboard):
   |                                              ^^^^^^^^^^^^^^
37 |     # Arrange: create snippet (for FK completeness) and a new Session not yet in DB
38 |     from tests.models.conftest import TestSessionMethodsFixtures
   |

ANN001 Missing type annotation for function argument `test_user`
  --> tests\models\test_ngram_orchestrator_process_end_of_session.py:36:62
   |
36 | def test_process_end_of_session_success_path(db_with_tables, test_user, test_keyboard):
   |                                                              ^^^^^^^^^
37 |     # Arrange: create snippet (for FK completeness) and a new Session not yet in DB
38 |     from tests.models.conftest import TestSessionMethodsFixtures
   |

ANN001 Missing type annotation for function argument `test_keyboard`
  --> tests\models\test_ngram_orchestrator_process_end_of_session.py:36:73
   |
36 | def test_process_end_of_session_success_path(db_with_tables, test_user, test_keyboard):
   |                                                                         ^^^^^^^^^^^^^
37 |     # Arrange: create snippet (for FK completeness) and a new Session not yet in DB
38 |     from tests.models.conftest import TestSessionMethodsFixtures
   |

ANN201 Missing return type annotation for public function `test_process_end_of_session_session_save_failure`
   --> tests\models\test_ngram_orchestrator_process_end_of_session.py:124:5
    |
124 | def test_process_end_of_session_session_save_failure(db_with_tables, test_user):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
125 |     """Fails at step 1: session save should raise due to FK violation (invalid keyboard_id)."""
126 |     from tests.models.conftest import TestSessionMethodsFixtures
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `db_with_tables`
   --> tests\models\test_ngram_orchestrator_process_end_of_session.py:124:54
    |
124 | def test_process_end_of_session_session_save_failure(db_with_tables, test_user):
    |                                                      ^^^^^^^^^^^^^^
125 |     """Fails at step 1: session save should raise due to FK violation (invalid keyboard_id)."""
126 |     from tests.models.conftest import TestSessionMethodsFixtures
    |

ANN001 Missing type annotation for function argument `test_user`
   --> tests\models\test_ngram_orchestrator_process_end_of_session.py:124:70
    |
124 | def test_process_end_of_session_session_save_failure(db_with_tables, test_user):
    |                                                                      ^^^^^^^^^
125 |     """Fails at step 1: session save should raise due to FK violation (invalid keyboard_id)."""
126 |     from tests.models.conftest import TestSessionMethodsFixtures
    |

ANN201 Missing return type annotation for public function `test_process_end_of_session_keystrokes_save_failure`
   --> tests\models\test_ngram_orchestrator_process_end_of_session.py:166:5
    |
166 | def test_process_end_of_session_keystrokes_save_failure(db_with_tables, test_user, test_keyboard):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
167 |     """Fails at step 2: keystrokes save should return False due to invalid keystroke session_id."""
168 |     from tests.models.conftest import TestSessionMethodsFixtures
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `db_with_tables`
   --> tests\models\test_ngram_orchestrator_process_end_of_session.py:166:57
    |
166 | def test_process_end_of_session_keystrokes_save_failure(db_with_tables, test_user, test_keyboard):
    |                                                         ^^^^^^^^^^^^^^
167 |     """Fails at step 2: keystrokes save should return False due to invalid keystroke session_id."""
168 |     from tests.models.conftest import TestSessionMethodsFixtures
    |

ANN001 Missing type annotation for function argument `test_user`
   --> tests\models\test_ngram_orchestrator_process_end_of_session.py:166:73
    |
166 | def test_process_end_of_session_keystrokes_save_failure(db_with_tables, test_user, test_keyboard):
    |                                                                         ^^^^^^^^^
167 |     """Fails at step 2: keystrokes save should return False due to invalid keystroke session_id."""
168 |     from tests.models.conftest import TestSessionMethodsFixtures
    |

ANN001 Missing type annotation for function argument `test_keyboard`
   --> tests\models\test_ngram_orchestrator_process_end_of_session.py:166:84
    |
166 | def test_process_end_of_session_keystrokes_save_failure(db_with_tables, test_user, test_keyboard):
    |                                                                                    ^^^^^^^^^^^^^
167 |     """Fails at step 2: keystrokes save should return False due to invalid keystroke session_id."""
168 |     from tests.models.conftest import TestSessionMethodsFixtures
    |

ANN201 Missing return type annotation for public function `test_process_end_of_session_summarization_failure`
   --> tests\models\test_ngram_orchestrator_process_end_of_session.py:215:5
    |
215 | def test_process_end_of_session_summarization_failure(db_with_tables, test_user, test_keyboard):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
216 |     """Fails at step 4: drop summary table to force summarization SQL to fail after n-grams."""
217 |     from tests.models.conftest import TestSessionMethodsFixtures
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `db_with_tables`
   --> tests\models\test_ngram_orchestrator_process_end_of_session.py:215:55
    |
215 | def test_process_end_of_session_summarization_failure(db_with_tables, test_user, test_keyboard):
    |                                                       ^^^^^^^^^^^^^^
216 |     """Fails at step 4: drop summary table to force summarization SQL to fail after n-grams."""
217 |     from tests.models.conftest import TestSessionMethodsFixtures
    |

ANN001 Missing type annotation for function argument `test_user`
   --> tests\models\test_ngram_orchestrator_process_end_of_session.py:215:71
    |
215 | def test_process_end_of_session_summarization_failure(db_with_tables, test_user, test_keyboard):
    |                                                                       ^^^^^^^^^
216 |     """Fails at step 4: drop summary table to force summarization SQL to fail after n-grams."""
217 |     from tests.models.conftest import TestSessionMethodsFixtures
    |

ANN001 Missing type annotation for function argument `test_keyboard`
   --> tests\models\test_ngram_orchestrator_process_end_of_session.py:215:82
    |
215 | def test_process_end_of_session_summarization_failure(db_with_tables, test_user, test_keyboard):
    |                                                                                  ^^^^^^^^^^^^^
216 |     """Fails at step 4: drop summary table to force summarization SQL to fail after n-grams."""
217 |     from tests.models.conftest import TestSessionMethodsFixtures
    |

D100 Missing docstring in public module
--> tests\models\test_ngram_persist.py:1:1

D100 Missing docstring in public module
--> tests\models\test_practice_session_extensions.py:1:1

D100 Missing docstring in public module
--> tests\models\test_session.py:1:1

D103 Missing docstring in public function
  --> tests\models\test_session.py:13:5
   |
11 | # --- Fixtures ---
12 | @pytest.fixture
13 | def valid_session_dict() -> dict[str, Any]:
   |     ^^^^^^^^^^^^^^^^^^
14 |     now = datetime(2023, 1, 1, 12, 0, 0)
15 |     return {
   |

D103 Missing docstring in public function
  --> tests\models\test_session.py:31:5
   |
30 | # --- Creation and Validation ---
31 | def test_valid_session_creation(valid_session_dict: dict[str, Any]) -> None:
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
32 |     s = Session(**valid_session_dict)
33 |     assert s.session_id == valid_session_dict["session_id"]
   |

D103 Missing docstring in public function
  --> tests\models\test_session.py:60:5
   |
58 |     ],
59 | )
60 | def test_missing_required_fields_raises(
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
61 |     valid_session_dict: dict[str, Any], missing_field: str
62 | ) -> None:
   |

D103 Missing docstring in public function
  --> tests\models\test_session.py:84:5
   |
82 |     ],
83 | )
84 | def test_invalid_field_values_raise(
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
85 |     valid_session_dict: dict[str, Any], field: str, value: Union[str, int]
86 | ) -> None:
   |

D103 Missing docstring in public function
   --> tests\models\test_session.py:104:5
    |
102 |     ],
103 | )
104 | def test_index_business_rules(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^
105 |     valid_session_dict: dict[str, Any], start: int, end: int, expect_error: bool
106 | ) -> None:
    |

D103 Missing docstring in public function
   --> tests\models\test_session.py:119:5
    |
119 | def test_start_time_after_end_time_raises(valid_session_dict: dict[str, Any]) -> None:
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
120 |     data = valid_session_dict.copy()
121 |     data["start_time"] = data["end_time"] + timedelta(seconds=1)  # type: ignore
    |

D103 Missing docstring in public function
   --> tests\models\test_session.py:127:5
    |
126 | # --- Computed Properties ---
127 | def test_computed_properties(valid_session_dict: dict[str, Any]) -> None:
    |     ^^^^^^^^^^^^^^^^^^^^^^^^
128 |     s = Session(**valid_session_dict)
129 |     assert s.expected_chars == 5
    |

D103 Missing docstring in public function
   --> tests\models\test_session.py:148:5
    |
146 |     ],
147 | )
148 | def test_correctness_and_accuracy(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
149 |     valid_session_dict: dict[str, Any],
150 |     actual_chars: int,
    |

D103 Missing docstring in public function
   --> tests\models\test_session.py:170:5
    |
168 |     ],
169 | )
170 | def test_wpm_cpm_zero_and_normal(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
171 |     valid_session_dict: dict[str, Any],
172 |     start_time: datetime,
    |

D103 Missing docstring in public function
   --> tests\models\test_session.py:186:5
    |
185 | # --- Dict/Row Roundtrip ---
186 | def test_to_dict_and_from_dict(valid_session_dict: dict[str, Any]) -> None:
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^
187 |     s = Session(**valid_session_dict)
188 |     d = s.to_dict()
    |

D103 Missing docstring in public function
   --> tests\models\test_session.py:200:5
    |
199 | # --- Extra/Calculated Fields ---
200 | def test_from_dict_ignores_calculated_fields(valid_session_dict: dict[str, Any]) -> None:
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
201 |     d = valid_session_dict.copy()
202 |     d["total_time"] = 123
    |

D103 Missing docstring in public function
   --> tests\models\test_session.py:215:5
    |
215 | def test_from_dict_with_extra_fields_raises(valid_session_dict: dict[str, Any]) -> None:
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
216 |     d = valid_session_dict.copy()
217 |     d["extra_field"] = 123
    |

D103 Missing docstring in public function
   --> tests\models\test_session.py:223:5
    |
222 | # --- Summary ---
223 | def test_get_summary_truncates_content(valid_session_dict: dict[str, Any]) -> None:
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
224 |     s = Session(**valid_session_dict)
225 |     summary = s.get_summary()
    |

D103 Missing docstring in public function
   --> tests\models\test_session.py:232:5
    |
231 | # --- Forbidden extra fields on creation ---
232 | def test_extra_fields_forbidden_on_creation(valid_session_dict: dict[str, Any]) -> None:
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
233 |     d = valid_session_dict.copy()
234 |     d["foo"] = "bar"
    |

D103 Missing docstring in public function
   --> tests\models\test_session.py:240:5
    |
239 | # --- ms_per_keystroke edge case ---
240 | def test_ms_per_keystroke_zero_chars(valid_session_dict: dict[str, Any]) -> None:
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
241 |     d = valid_session_dict.copy()
242 |     d["start_time"] = d["end_time"]  # total_time = 0, expected_chars > 0
    |

D103 Missing docstring in public function
   --> tests\models\test_session.py:248:5
    |
247 | # --- UUID default factory ---
248 | def test_session_id_default_factory(valid_session_dict: dict[str, Any]) -> None:
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
249 |     d = valid_session_dict.copy()
250 |     d.pop("session_id")
    |

D103 Missing docstring in public function
   --> tests\models\test_session.py:256:5
    |
255 | # --- Content required for non-abandoned sessions ---
256 | def test_content_required_if_actual_chars(valid_session_dict: dict[str, Any]) -> None:
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
257 |     d = valid_session_dict.copy()
258 |     d["content"] = ""
    |

D100 Missing docstring in public module
--> tests\models\test_session_manager.py:1:1

D103 Missing docstring in public function
  --> tests\models\test_session_manager.py:17:5
   |
17 | def make_session(snippet_id: str, user_id: str, keyboard_id: str, **overrides: object) -> Session:
   |     ^^^^^^^^^^^^
18 |     now = datetime.datetime(2023, 1, 1, 12, 0, 0)
19 |     data = {
   |

D103 Missing docstring in public function
  --> tests\models\test_session_manager.py:37:5
   |
36 | @pytest.fixture
37 | def category_mgr(db_with_tables: DatabaseManager) -> CategoryManager:
   |     ^^^^^^^^^^^^
38 |     return CategoryManager(db_with_tables)
   |

D103 Missing docstring in public function
  --> tests\models\test_session_manager.py:42:5
   |
41 | @pytest.fixture
42 | def snippet_mgr(db_with_tables: DatabaseManager) -> SnippetManager:
   |     ^^^^^^^^^^^
43 |     return SnippetManager(db_with_tables)
   |

D103 Missing docstring in public function
  --> tests\models\test_session_manager.py:47:5
   |
46 | @pytest.fixture
47 | def session_mgr(db_with_tables: DatabaseManager) -> SessionManager:
   |     ^^^^^^^^^^^
48 |     return SessionManager(db_with_tables)
   |

D103 Missing docstring in public function
  --> tests\models\test_session_manager.py:52:5
   |
51 | @pytest.fixture
52 | def sample_category(category_mgr: CategoryManager) -> Category:
   |     ^^^^^^^^^^^^^^^
53 |     category = Category(category_name="Test Category", description="A category for testing")
54 |     category_mgr.save_category(category)
   |

D103 Missing docstring in public function
  --> tests\models\test_session_manager.py:59:5
   |
58 | @pytest.fixture
59 | def sample_snippet(
   |     ^^^^^^^^^^^^^^
60 |     snippet_mgr: SnippetManager, sample_category: Category, test_user: User
61 | ) -> Snippet:
   |

D103 Missing docstring in public function
  --> tests\models\test_session_manager.py:71:5
   |
71 | def test_save_and_get_session(
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^
72 |     session_mgr: SessionManager,
73 |     sample_snippet: Snippet,
   |

D103 Missing docstring in public function
  --> tests\models\test_session_manager.py:87:5
   |
87 | def test_update_session(
   |     ^^^^^^^^^^^^^^^^^^^
88 |     session_mgr: SessionManager,
89 |     sample_snippet: Snippet,
   |

D103 Missing docstring in public function
   --> tests\models\test_session_manager.py:105:5
    |
105 | def test_list_sessions_for_snippet(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
106 |     session_mgr: SessionManager,
107 |     sample_snippet: Snippet,
    |

D103 Missing docstring in public function
   --> tests\models\test_session_manager.py:128:5
    |
128 | def test_delete_session_by_id(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^
129 |     session_mgr: SessionManager,
130 |     sample_snippet: Snippet,
    |

D103 Missing docstring in public function
   --> tests\models\test_session_manager.py:145:5
    |
145 | def test_delete_all(
    |     ^^^^^^^^^^^^^^^
146 |     session_mgr: SessionManager,
147 |     snippet_mgr: SnippetManager,
    |

D103 Missing docstring in public function
   --> tests\models\test_session_manager.py:184:5
    |
184 | def test_save_session_returns_id(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
185 |     session_mgr: SessionManager,
186 |     sample_snippet: Snippet,
    |

D103 Missing docstring in public function
   --> tests\models\test_session_manager.py:199:5
    |
199 | def test_get_nonexistent_session(session_mgr: SessionManager) -> None:
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
200 |     assert session_mgr.get_session_by_id(str(uuid.uuid4())) is None
    |

D103 Missing docstring in public function
   --> tests\models\test_session_manager.py:203:5
    |
203 | def test_list_sessions_for_snippet_empty(session_mgr: SessionManager) -> None:
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
204 |     assert session_mgr.list_sessions_for_snippet(str(uuid.uuid4())) == []
    |

D205 1 blank line required between summary line and description
 --> tests\models\test_setting.py:1:1
  |
1 | / """
2 | | Unit tests for the Setting Pydantic model in models.setting.
3 | | Focuses on validation logic within the Setting model itself.
4 | | """
  | |___^
5 |
6 |   # Standard library imports
  |
help: Insert single blank line

D212 [*] Multi-line docstring summary should start at the first line
 --> tests\models\test_setting.py:1:1
  |
1 | / """
2 | | Unit tests for the Setting Pydantic model in models.setting.
3 | | Focuses on validation logic within the Setting model itself.
4 | | """
  | |___^
5 |
6 |   # Standard library imports
  |
help: Remove whitespace after opening quotes

D200 One-line docstring should fit on one line
  --> tests\models\test_setting.py:48:9
   |
46 |       )
47 |       def test_setting_type_id_validation(self, setting_type_id: str, expected_error_message_part: str) -> None:
48 | /         """
49 | |         Test objective: Verify Setting model's type_id validation for format, length, and ASCII.
50 | |         """
   | |___________^
51 |           with pytest.raises(ValidationError) as exc_info:
52 |               Setting(
   |
help: Reformat to one line

D212 [*] Multi-line docstring summary should start at the first line
  --> tests\models\test_setting.py:48:9
   |
46 |       )
47 |       def test_setting_type_id_validation(self, setting_type_id: str, expected_error_message_part: str) -> None:
48 | /         """
49 | |         Test objective: Verify Setting model's type_id validation for format, length, and ASCII.
50 | |         """
   | |___________^
51 |           with pytest.raises(ValidationError) as exc_info:
52 |               Setting(
   |
help: Remove whitespace after opening quotes

D205 1 blank line required between summary line and description
 --> tests\models\test_setting_manager.py:1:1
  |
1 | / """
2 | | Unit tests for models.setting_manager.SettingManager.
3 | | Covers CRUD, validation (including DB uniqueness), history tracking, and error handling.
4 | | """
  | |___^
5 |
6 |   import uuid
  |
help: Insert single blank line

D212 [*] Multi-line docstring summary should start at the first line
 --> tests\models\test_setting_manager.py:1:1
  |
1 | / """
2 | | Unit tests for models.setting_manager.SettingManager.
3 | | Covers CRUD, validation (including DB uniqueness), history tracking, and error handling.
4 | | """
  | |___^
5 |
6 |   import uuid
  |
help: Remove whitespace after opening quotes

D200 One-line docstring should fit on one line
  --> tests\models\test_setting_manager.py:18:5
   |
16 |   @pytest.fixture(scope="function")
17 |   def setting_mgr(db_with_tables: DatabaseManager) -> SettingManager:
18 | /     """
19 | |     Fixture: Provides a SettingManager with a fresh, initialized database.
20 | |     """
   | |_______^
21 |       return SettingManager(db_with_tables)
   |
help: Reformat to one line

D212 [*] Multi-line docstring summary should start at the first line
  --> tests\models\test_setting_manager.py:18:5
   |
16 |   @pytest.fixture(scope="function")
17 |   def setting_mgr(db_with_tables: DatabaseManager) -> SettingManager:
18 | /     """
19 | |     Fixture: Provides a SettingManager with a fresh, initialized database.
20 | |     """
   | |_______^
21 |       return SettingManager(db_with_tables)
   |
help: Remove whitespace after opening quotes

D200 One-line docstring should fit on one line
  --> tests\models\test_setting_manager.py:28:9
   |
27 |       def test_create_setting_valid(self, setting_mgr: SettingManager) -> None:
28 | /         """
29 | |         Test objective: Create a setting with valid data and verify persistence.
30 | |         """
   | |___________^
31 |           setting_type_id = "SETTYP"
32 |           related_entity_id = str(uuid.uuid4())
   |
help: Reformat to one line

D212 [*] Multi-line docstring summary should start at the first line
  --> tests\models\test_setting_manager.py:28:9
   |
27 |       def test_create_setting_valid(self, setting_mgr: SettingManager) -> None:
28 | /         """
29 | |         Test objective: Create a setting with valid data and verify persistence.
30 | |         """
   | |___________^
31 |           setting_type_id = "SETTYP"
32 |           related_entity_id = str(uuid.uuid4())
   |
help: Remove whitespace after opening quotes

D200 One-line docstring should fit on one line
  --> tests\models\test_setting_manager.py:64:9
   |
62 |           self, setting_mgr: SettingManager, setting_type_id: str, err_msg_part: str
63 |       ) -> None:
64 | /         """
65 | |         Test objective: Attempt to create a setting with an invalid type_id format.
66 | |         """
   | |___________^
67 |           with pytest.raises((ValueError, SettingValidationError)) as e:
68 |               setting = Setting(
   |
help: Reformat to one line

D212 [*] Multi-line docstring summary should start at the first line
  --> tests\models\test_setting_manager.py:64:9
   |
62 |           self, setting_mgr: SettingManager, setting_type_id: str, err_msg_part: str
63 |       ) -> None:
64 | /         """
65 | |         Test objective: Attempt to create a setting with an invalid type_id format.
66 | |         """
   | |___________^
67 |           with pytest.raises((ValueError, SettingValidationError)) as e:
68 |               setting = Setting(
   |
help: Remove whitespace after opening quotes

D205 1 blank line required between summary line and description
  --> tests\models\test_setting_manager.py:78:9
   |
77 |       def test_update_existing_setting_with_new_value(self, setting_mgr: SettingManager) -> None:
78 | /         """
79 | |         Test objective: Verify that saving a setting with an existing type_id and entity_id updates
80 | |         the setting value and creates a new history entry.
81 | |         """
   | |___________^
82 |           setting_type_id = "UPDSET"
83 |           related_entity_id = str(uuid.uuid4())
   |
help: Insert single blank line

D212 [*] Multi-line docstring summary should start at the first line
  --> tests\models\test_setting_manager.py:78:9
   |
77 |       def test_update_existing_setting_with_new_value(self, setting_mgr: SettingManager) -> None:
78 | /         """
79 | |         Test objective: Verify that saving a setting with an existing type_id and entity_id updates
80 | |         the setting value and creates a new history entry.
81 | |         """
   | |___________^
82 |           setting_type_id = "UPDSET"
83 |           related_entity_id = str(uuid.uuid4())
   |
help: Remove whitespace after opening quotes

D200 One-line docstring should fit on one line
   --> tests\models\test_setting_manager.py:127:9
    |
126 |       def test_get_setting_by_type_and_entity(self, setting_mgr: SettingManager) -> None:
127 | /         """
128 | |         Test objective: Retrieve a setting by its type_id and related_entity_id.
129 | |         """
    | |___________^
130 |           setting_type_id = "GETSET"
131 |           related_entity_id = str(uuid.uuid4())
    |
help: Reformat to one line

D212 [*] Multi-line docstring summary should start at the first line
   --> tests\models\test_setting_manager.py:127:9
    |
126 |       def test_get_setting_by_type_and_entity(self, setting_mgr: SettingManager) -> None:
127 | /         """
128 | |         Test objective: Retrieve a setting by its type_id and related_entity_id.
129 | |         """
    | |___________^
130 |           setting_type_id = "GETSET"
131 |           related_entity_id = str(uuid.uuid4())
    |
help: Remove whitespace after opening quotes

D200 One-line docstring should fit on one line
   --> tests\models\test_setting_manager.py:150:9
    |
149 |       def test_get_setting_with_default(self, setting_mgr: SettingManager) -> None:
150 | /         """
151 | |         Test objective: Test get_setting with a default value when setting doesn't exist.
152 | |         """
    | |___________^
153 |           setting_type_id = "DEFVAL"
154 |           related_entity_id = str(uuid.uuid4())
    |
help: Reformat to one line

D212 [*] Multi-line docstring summary should start at the first line
   --> tests\models\test_setting_manager.py:150:9
    |
149 |       def test_get_setting_with_default(self, setting_mgr: SettingManager) -> None:
150 | /         """
151 | |         Test objective: Test get_setting with a default value when setting doesn't exist.
152 | |         """
    | |___________^
153 |           setting_type_id = "DEFVAL"
154 |           related_entity_id = str(uuid.uuid4())
    |
help: Remove whitespace after opening quotes

D200 One-line docstring should fit on one line
   --> tests\models\test_setting_manager.py:175:9
    |
174 |       def test_get_setting_not_found(self, setting_mgr: SettingManager) -> None:
175 | /         """
176 | |         Test objective: Attempt to retrieve a non-existent setting.
177 | |         """
    | |___________^
178 |           with pytest.raises(SettingNotFound):
179 |               setting_mgr.get_setting("NOTEXS", str(uuid.uuid4()))
    |
help: Reformat to one line

D212 [*] Multi-line docstring summary should start at the first line
   --> tests\models\test_setting_manager.py:175:9
    |
174 |       def test_get_setting_not_found(self, setting_mgr: SettingManager) -> None:
175 | /         """
176 | |         Test objective: Attempt to retrieve a non-existent setting.
177 | |         """
    | |___________^
178 |           with pytest.raises(SettingNotFound):
179 |               setting_mgr.get_setting("NOTEXS", str(uuid.uuid4()))
    |
help: Remove whitespace after opening quotes

D200 One-line docstring should fit on one line
   --> tests\models\test_setting_manager.py:182:9
    |
181 |       def test_list_settings_empty(self, setting_mgr: SettingManager) -> None:
182 | /         """
183 | |         Test objective: List settings for an entity when none exist.
184 | |         """
    | |___________^
185 |           settings = setting_mgr.list_settings(str(uuid.uuid4()))
186 |           assert len(settings) == 0
    |
help: Reformat to one line

D212 [*] Multi-line docstring summary should start at the first line
   --> tests\models\test_setting_manager.py:182:9
    |
181 |       def test_list_settings_empty(self, setting_mgr: SettingManager) -> None:
182 | /         """
183 | |         Test objective: List settings for an entity when none exist.
184 | |         """
    | |___________^
185 |           settings = setting_mgr.list_settings(str(uuid.uuid4()))
186 |           assert len(settings) == 0
    |
help: Remove whitespace after opening quotes

D200 One-line docstring should fit on one line
   --> tests\models\test_setting_manager.py:189:9
    |
188 |       def test_list_settings_populated(self, setting_mgr: SettingManager) -> None:
189 | /         """
190 | |         Test objective: List settings for an entity with multiple settings.
191 | |         """
    | |___________^
192 |           related_entity_id = str(uuid.uuid4())
    |
help: Reformat to one line

D212 [*] Multi-line docstring summary should start at the first line
   --> tests\models\test_setting_manager.py:189:9
    |
188 |       def test_list_settings_populated(self, setting_mgr: SettingManager) -> None:
189 | /         """
190 | |         Test objective: List settings for an entity with multiple settings.
191 | |         """
    | |___________^
192 |           related_entity_id = str(uuid.uuid4())
    |
help: Remove whitespace after opening quotes

D200 One-line docstring should fit on one line
   --> tests\models\test_setting_manager.py:214:9
    |
213 |       def test_update_setting_value(self, setting_mgr: SettingManager) -> None:
214 | /         """
215 | |         Test objective: Update a setting's value using save_setting.
216 | |         """
    | |___________^
217 |           setting_type_id = "UPDATE"
218 |           related_entity_id = str(uuid.uuid4())
    |
help: Reformat to one line

D212 [*] Multi-line docstring summary should start at the first line
   --> tests\models\test_setting_manager.py:214:9
    |
213 |       def test_update_setting_value(self, setting_mgr: SettingManager) -> None:
214 | /         """
215 | |         Test objective: Update a setting's value using save_setting.
216 | |         """
    | |___________^
217 |           setting_type_id = "UPDATE"
218 |           related_entity_id = str(uuid.uuid4())
    |
help: Remove whitespace after opening quotes

D200 One-line docstring should fit on one line
   --> tests\models\test_setting_manager.py:240:9
    |
239 |       def test_history_tracking_on_create(self, setting_mgr: SettingManager) -> None:
240 | /         """
241 | |         Test objective: Verify history record is created when a setting is created.
242 | |         """
    | |___________^
243 |           setting_type_id = "HISCRE"
244 |           related_entity_id = str(uuid.uuid4())
    |
help: Reformat to one line

D212 [*] Multi-line docstring summary should start at the first line
   --> tests\models\test_setting_manager.py:240:9
    |
239 |       def test_history_tracking_on_create(self, setting_mgr: SettingManager) -> None:
240 | /         """
241 | |         Test objective: Verify history record is created when a setting is created.
242 | |         """
    | |___________^
243 |           setting_type_id = "HISCRE"
244 |           related_entity_id = str(uuid.uuid4())
    |
help: Remove whitespace after opening quotes

D200 One-line docstring should fit on one line
   --> tests\models\test_setting_manager.py:270:9
    |
269 |       def test_history_tracking_on_update(self, setting_mgr: SettingManager) -> None:
270 | /         """
271 | |         Test objective: Verify history records are created when a setting is updated.
272 | |         """
    | |___________^
273 |           setting_type_id = "HISUPD"
274 |           related_entity_id = str(uuid.uuid4())
    |
help: Reformat to one line

D212 [*] Multi-line docstring summary should start at the first line
   --> tests\models\test_setting_manager.py:270:9
    |
269 |       def test_history_tracking_on_update(self, setting_mgr: SettingManager) -> None:
270 | /         """
271 | |         Test objective: Verify history records are created when a setting is updated.
272 | |         """
    | |___________^
273 |           setting_type_id = "HISUPD"
274 |           related_entity_id = str(uuid.uuid4())
    |
help: Remove whitespace after opening quotes

D200 One-line docstring should fit on one line
   --> tests\models\test_setting_manager.py:306:9
    |
305 |       def test_history_tracking_on_delete(self, setting_mgr: SettingManager) -> None:
306 | /         """
307 | |         Test objective: Verify history record is created when a setting is deleted.
308 | |         """
    | |___________^
309 |           setting_type_id = "HISDEL"
310 |           related_entity_id = str(uuid.uuid4())
    |
help: Reformat to one line

D212 [*] Multi-line docstring summary should start at the first line
   --> tests\models\test_setting_manager.py:306:9
    |
305 |       def test_history_tracking_on_delete(self, setting_mgr: SettingManager) -> None:
306 | /         """
307 | |         Test objective: Verify history record is created when a setting is deleted.
308 | |         """
    | |___________^
309 |           setting_type_id = "HISDEL"
310 |           related_entity_id = str(uuid.uuid4())
    |
help: Remove whitespace after opening quotes

D200 One-line docstring should fit on one line
   --> tests\models\test_setting_manager.py:336:9
    |
335 |       def test_delete_setting(self, setting_mgr: SettingManager) -> None:
336 | /         """
337 | |         Test objective: Delete an existing setting.
338 | |         """
    | |___________^
339 |           setting_type_id = "DELETE"
340 |           related_entity_id = str(uuid.uuid4())
    |
help: Reformat to one line

D212 [*] Multi-line docstring summary should start at the first line
   --> tests\models\test_setting_manager.py:336:9
    |
335 |       def test_delete_setting(self, setting_mgr: SettingManager) -> None:
336 | /         """
337 | |         Test objective: Delete an existing setting.
338 | |         """
    | |___________^
339 |           setting_type_id = "DELETE"
340 |           related_entity_id = str(uuid.uuid4())
    |
help: Remove whitespace after opening quotes

D200 One-line docstring should fit on one line
   --> tests\models\test_setting_manager.py:359:9
    |
358 |       def test_delete_nonexistent_setting(self, setting_mgr: SettingManager) -> None:
359 | /         """
360 | |         Test objective: Attempt to delete a non-existent setting.
361 | |         """
    | |___________^
362 |           assert setting_mgr.delete_setting("NOEXST", str(uuid.uuid4())) is False
    |
help: Reformat to one line

D212 [*] Multi-line docstring summary should start at the first line
   --> tests\models\test_setting_manager.py:359:9
    |
358 |       def test_delete_nonexistent_setting(self, setting_mgr: SettingManager) -> None:
359 | /         """
360 | |         Test objective: Attempt to delete a non-existent setting.
361 | |         """
    | |___________^
362 |           assert setting_mgr.delete_setting("NOEXST", str(uuid.uuid4())) is False
    |
help: Remove whitespace after opening quotes

D200 One-line docstring should fit on one line
   --> tests\models\test_setting_manager.py:365:9
    |
364 |       def test_delete_all_settings(self, setting_mgr: SettingManager) -> None:
365 | /         """
366 | |         Test objective: Delete all settings for an entity and verify the action.
367 | |         """
    | |___________^
368 |           related_entity_id = str(uuid.uuid4())
    |
help: Reformat to one line

D212 [*] Multi-line docstring summary should start at the first line
   --> tests\models\test_setting_manager.py:365:9
    |
364 |       def test_delete_all_settings(self, setting_mgr: SettingManager) -> None:
365 | /         """
366 | |         Test objective: Delete all settings for an entity and verify the action.
367 | |         """
    | |___________^
368 |           related_entity_id = str(uuid.uuid4())
    |
help: Remove whitespace after opening quotes

D200 One-line docstring should fit on one line
   --> tests\models\test_setting_manager.py:401:9
    |
400 |       def test_history_for_bulk_delete(self, setting_mgr: SettingManager) -> None:
401 | /         """
402 | |         Test objective: Verify history tracking for bulk deletion of settings.
403 | |         """
    | |___________^
404 |           related_entity_id = str(uuid.uuid4())
405 |           setting_types = ["BULK01", "BULK02", "BULK03"]
    |
help: Reformat to one line

D212 [*] Multi-line docstring summary should start at the first line
   --> tests\models\test_setting_manager.py:401:9
    |
400 |       def test_history_for_bulk_delete(self, setting_mgr: SettingManager) -> None:
401 | /         """
402 | |         Test objective: Verify history tracking for bulk deletion of settings.
403 | |         """
    | |___________^
404 |           related_entity_id = str(uuid.uuid4())
405 |           setting_types = ["BULK01", "BULK02", "BULK03"]
    |
help: Remove whitespace after opening quotes

D200 One-line docstring should fit on one line
 --> tests\models\test_simple.py:1:1
  |
1 | / """
2 | | Simple test file to verify pytest discovery.
3 | | """
  | |___^
4 |
5 |   def test_simple():
  |
help: Reformat to one line

D212 [*] Multi-line docstring summary should start at the first line
 --> tests\models\test_simple.py:1:1
  |
1 | / """
2 | | Simple test file to verify pytest discovery.
3 | | """
  | |___^
4 |
5 |   def test_simple():
  |
help: Remove whitespace after opening quotes

ANN201 Missing return type annotation for public function `test_simple`
 --> tests\models\test_simple.py:5:5
  |
3 | """
4 |
5 | def test_simple():
  |     ^^^^^^^^^^^
6 |     """A simple test that should always pass."""
7 |     assert 1 + 1 == 2
  |
help: Add return type annotation: `None`

D205 1 blank line required between summary line and description
 --> tests\models\test_snippet.py:1:1
  |
1 | / """
2 | | Combined unit tests for SnippetModel and SnippetManager.
3 | | Covers all CRUD, validation, edge cases, and error handling.
4 | | """
  | |___^
5 |
6 |   import uuid
  |
help: Insert single blank line

D212 [*] Multi-line docstring summary should start at the first line
 --> tests\models\test_snippet.py:1:1
  |
1 | / """
2 | | Combined unit tests for SnippetModel and SnippetManager.
3 | | Covers all CRUD, validation, edge cases, and error handling.
4 | | """
  | |___^
5 |
6 |   import uuid
  |
help: Remove whitespace after opening quotes

D103 Missing docstring in public function
   --> tests\models\test_snippet.py:127:5
    |
125 |     ],
126 | )
127 | def test_snippet_creation_validation(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
128 |     snippet_category_fixture: str,
129 |     snippet_manager: SnippetManager,
    |

D103 Missing docstring in public function
   --> tests\models\test_snippet.py:157:5
    |
155 |     ],
156 | )
157 | def test_snippet_name_uniqueness(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
158 |     snippet_category_fixture: str,
159 |     snippet_manager: SnippetManager,
    |

D103 Missing docstring in public function
   --> tests\models\test_snippet.py:175:5
    |
175 | def test_snippet_creation_valid(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
176 |     snippet_manager: SnippetManager, valid_snippet_data: Dict[str, Union[str, str]]
177 | ) -> None:
    |

D103 Missing docstring in public function
   --> tests\models\test_snippet.py:193:5
    |
193 | def test_get_nonexistent_snippet(snippet_manager: SnippetManager) -> None:
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
194 |     non_existent_snippet_id = str(uuid.uuid4())
195 |     assert snippet_manager.get_snippet_by_id(non_existent_snippet_id) is None
    |

D103 Missing docstring in public function
   --> tests\models\test_snippet.py:198:5
    |
198 | def test_list_snippets_empty(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^
199 |     snippet_category_fixture: str, snippet_manager: SnippetManager
200 | ) -> None:
    |

D103 Missing docstring in public function
   --> tests\models\test_snippet.py:218:5
    |
218 | def test_list_snippets_populated(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
219 |     snippet_category_fixture: str, snippet_manager: SnippetManager
220 | ) -> None:
    |

D103 Missing docstring in public function
   --> tests\models\test_snippet.py:241:5
    |
241 | def test_snippet_edit(
    |     ^^^^^^^^^^^^^^^^^
242 |     snippet_manager: SnippetManager, valid_snippet_data: Dict[str, Union[str, str]]
243 | ) -> None:
    |

D103 Missing docstring in public function
   --> tests\models\test_snippet.py:260:5
    |
260 | def test_snippet_update(snippet_category_fixture: str, snippet_manager: SnippetManager) -> None:
    |     ^^^^^^^^^^^^^^^^^^^
261 |     from models.snippet import Snippet
    |

D103 Missing docstring in public function
   --> tests\models\test_snippet.py:274:5
    |
274 | def test_snippet_update_name_only(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
275 |     snippet_category_fixture: str, snippet_manager: SnippetManager
276 | ) -> None:
    |

D103 Missing docstring in public function
   --> tests\models\test_snippet.py:291:5
    |
291 | def test_snippet_update_content_only(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
292 |     snippet_category_fixture: str, snippet_manager: SnippetManager
293 | ) -> None:
    |

D103 Missing docstring in public function
   --> tests\models\test_snippet.py:308:5
    |
308 | def test_snippet_delete(snippet_category_fixture: str, snippet_manager: SnippetManager) -> None:
    |     ^^^^^^^^^^^^^^^^^^^
309 |     from models.snippet import Snippet
    |

D103 Missing docstring in public function
   --> tests\models\test_snippet.py:328:5
    |
328 | def test_edit_snippet_change_category(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
329 |     snippet_manager: SnippetManager,
330 |     category_manager: CategoryManager,
    |

D103 Missing docstring in public function
   --> tests\models\test_snippet.py:351:5
    |
351 | def test_edit_snippet_invalid_category(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
352 |     snippet_manager: SnippetManager, snippet_category_fixture: str
353 | ) -> None:
    |

D103 Missing docstring in public function
   --> tests\models\test_snippet.py:366:5
    |
366 | def test_snippet_sql_injection(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^
367 |     snippet_category_fixture: str, snippet_manager: SnippetManager
368 | ) -> None:
    |

D103 Missing docstring in public function
   --> tests\models\test_snippet.py:375:5
    |
375 | def test_snippet_sql_injection_in_content(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
376 |     snippet_category_fixture: str, snippet_manager: SnippetManager
377 | ) -> None:
    |

D103 Missing docstring in public function
   --> tests\models\test_snippet.py:384:5
    |
384 | def test_snippet_long_content(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^
385 |     snippet_category_fixture: str, snippet_manager: SnippetManager
386 | ) -> None:
    |

D103 Missing docstring in public function
   --> tests\models\test_snippet.py:398:5
    |
398 | def test_snippet_content_splitting_boundaries(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
399 |     snippet_category_fixture: str, snippet_manager: SnippetManager
400 | ) -> None:
    |

D103 Missing docstring in public function
   --> tests\models\test_snippet.py:421:5
    |
421 | def test_update_nonexistent_snippet(snippet_manager: SnippetManager) -> None:
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
422 |     non_existent_snippet_id = str(uuid.uuid4())
423 |     with pytest.raises(ForeignKeyError):
    |

D103 Missing docstring in public function
   --> tests\models\test_snippet.py:432:5
    |
432 | def test_snippet_part_number_sequence(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
433 |     snippet_category_fixture: str, snippet_manager: SnippetManager, random_id: str
434 | ) -> None:
    |

D205 1 blank line required between summary line and description
   --> tests\models\test_snippet.py:483:5
    |
482 |   def test_python_code_validation() -> None:
483 | /     """
484 | |     Test that Python code with quotes, equals signs, and other SQL-like patterns
485 | |     passes validation when used as snippet content.
486 | |     """
    | |_______^
487 |       python_code = """import numpy as np
488 |   # Create an array
    |
help: Insert single blank line

D212 [*] Multi-line docstring summary should start at the first line
   --> tests\models\test_snippet.py:483:5
    |
482 |   def test_python_code_validation() -> None:
483 | /     """
484 | |     Test that Python code with quotes, equals signs, and other SQL-like patterns
485 | |     passes validation when used as snippet content.
486 | |     """
    | |_______^
487 |       python_code = """import numpy as np
488 |   # Create an array
    |
help: Remove whitespace after opening quotes

D200 One-line docstring should fit on one line
   --> tests\models\test_snippet.py:523:5
    |
521 |       db_manager: DatabaseManager, snippet_category_fixture: str, random_id: str
522 |   ) -> None:
523 | /     """
524 | |     Test that snippet operations handle errors and success cases appropriately.
525 | |     """
    | |_______^
526 |       # Create snippet manager
527 |       snippet_manager = SnippetManager(db_manager)
    |
help: Reformat to one line

D212 [*] Multi-line docstring summary should start at the first line
   --> tests\models\test_snippet.py:523:5
    |
521 |       db_manager: DatabaseManager, snippet_category_fixture: str, random_id: str
522 |   ) -> None:
523 | /     """
524 | |     Test that snippet operations handle errors and success cases appropriately.
525 | |     """
    | |_______^
526 |       # Create snippet manager
527 |       snippet_manager = SnippetManager(db_manager)
    |
help: Remove whitespace after opening quotes

F811 Redefinition of unused `test_update_nonexistent_snippet` from line 421
   --> tests\models\test_snippet.py:593:5
    |
593 | def test_update_nonexistent_snippet(snippet_manager: SnippetManager) -> None:
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
594 |     """Test updating a snippet that does not exist."""
595 |     non_existent_snippet_id = str(uuid.uuid4())
    |
help: Remove definition: `test_update_nonexistent_snippet`

D103 Missing docstring in public function
   --> tests\models\test_snippet.py:810:5
    |
810 | def test_snippet_sql_injection_content_update(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
811 |     snippet_category_fixture: str, snippet_manager: SnippetManager
812 | ) -> None:
    |

D103 Missing docstring in public function
   --> tests\models\test_snippet.py:824:5
    |
824 | def test_snippet_sql_injection_name_update(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
825 |     snippet_category_fixture: str, snippet_manager: SnippetManager
826 | ) -> None:
    |

D103 Missing docstring in public function
   --> tests\models\test_snippet.py:854:5
    |
854 | def test_snippet_manager_handles_db_errors_gracefully_on_create(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
855 |     snippet_manager: SnippetManager, snippet_category_fixture: str, monkeypatch: MonkeyPatch
856 | ) -> None:
    |

D103 Missing docstring in public function
   --> tests\models\test_snippet.py:871:5
    |
871 | def test_snippet_manager_handles_db_errors_gracefully_on_get(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
872 |     snippet_manager: SnippetManager, monkeypatch: MonkeyPatch
873 | ) -> None:
    |

D103 Missing docstring in public function
   --> tests\models\test_snippet.py:883:5
    |
883 | def test_snippet_manager_handles_db_errors_gracefully_on_update(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
884 |     snippet_manager: SnippetManager, snippet_category_fixture: str, monkeypatch: MonkeyPatch
885 | ) -> None:
    |

D103 Missing docstring in public function
   --> tests\models\test_snippet.py:910:5
    |
910 | def test_snippet_manager_handles_db_errors_gracefully_on_delete(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
911 |     snippet_manager: SnippetManager, snippet_category_fixture: str, monkeypatch: MonkeyPatch
912 | ) -> None:
    |

D103 Missing docstring in public function
   --> tests\models\test_snippet.py:948:5
    |
948 | def test_snippet_manager_handles_db_errors_gracefully_on_list(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
949 |     snippet_manager: SnippetManager, snippet_category_fixture: str, monkeypatch: MonkeyPatch
950 | ) -> None:
    |

D103 Missing docstring in public function
   --> tests\models\test_snippet.py:960:5
    |
960 | def test_snippet_manager_handles_db_errors_gracefully_on_search(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
961 |     snippet_manager: SnippetManager, monkeypatch: MonkeyPatch
962 | ) -> None:
    |

D205 1 blank line required between summary line and description
 --> tests\models\test_snippet_manager.py:1:1
  |
1 | / """
2 | | Unit tests for the SnippetManager class.
3 | | Covers CRUD operations, validation, edge cases, and error handling for snippets.
4 | | """
  | |___^
5 |
6 |   import datetime
  |
help: Insert single blank line

D212 [*] Multi-line docstring summary should start at the first line
 --> tests\models\test_snippet_manager.py:1:1
  |
1 | / """
2 | | Unit tests for the SnippetManager class.
3 | | Covers CRUD operations, validation, edge cases, and error handling for snippets.
4 | | """
  | |___^
5 |
6 |   import datetime
  |
help: Remove whitespace after opening quotes

D102 Missing docstring in public method
  --> tests\models\test_snippet_manager.py:56:9
   |
54 |     """Tests for SnippetManager.save_snippet() method (creation and update)."""
55 |
56 |     def test_create_snippet_happy_path(
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
57 |         self, snippet_mgr: SnippetManager, sample_category: Category
58 |     ) -> None:
   |

D205 1 blank line required between summary line and description
   --> tests\models\test_snippet_manager.py:174:9
    |
172 |           self, snippet_mgr: SnippetManager
173 |       ) -> None:
174 | /         """
175 | |         Test objective: Verify ForeignKeyError for non-existent category ID
176 | |         (foreign key constraint).
177 | |         """
    | |___________^
178 |           non_existent_category_id = str(uuid.uuid4())  # Assuming this ID does not exist
179 |           with pytest.raises(ForeignKeyError):
    |
help: Insert single blank line

D212 [*] Multi-line docstring summary should start at the first line
   --> tests\models\test_snippet_manager.py:174:9
    |
172 |           self, snippet_mgr: SnippetManager
173 |       ) -> None:
174 | /         """
175 | |         Test objective: Verify ForeignKeyError for non-existent category ID
176 | |         (foreign key constraint).
177 | |         """
    | |___________^
178 |           non_existent_category_id = str(uuid.uuid4())  # Assuming this ID does not exist
179 |           with pytest.raises(ForeignKeyError):
    |
help: Remove whitespace after opening quotes

D205 1 blank line required between summary line and description
   --> tests\models\test_snippet_manager.py:226:9
    |
224 |           self, snippet_mgr: SnippetManager, sample_category: Category
225 |       ) -> None:
226 | /         """
227 | |         Test objective: Ensure SnippetManager's internal check for empty content parts is not
228 | |         triggered if Pydantic validation (content min_length=1) is effective.
229 | |         """
    | |___________^
230 |           try:
231 |               # Use minimal valid content
    |
help: Insert single blank line

D212 [*] Multi-line docstring summary should start at the first line
   --> tests\models\test_snippet_manager.py:226:9
    |
224 |           self, snippet_mgr: SnippetManager, sample_category: Category
225 |       ) -> None:
226 | /         """
227 | |         Test objective: Ensure SnippetManager's internal check for empty content parts is not
228 | |         triggered if Pydantic validation (content min_length=1) is effective.
229 | |         """
    | |___________^
230 |           try:
231 |               # Use minimal valid content
    |
help: Remove whitespace after opening quotes

D102 Missing docstring in public method
   --> tests\models\test_snippet_manager.py:254:9
    |
252 |     """Tests for SnippetManager.get_starting_index() method."""
253 |
254 |     def test_get_starting_index_no_sessions(
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
255 |         self, snippet_mgr: SnippetManager, sample_category: Category
256 |     ) -> None:
    |

D102 Missing docstring in public method
   --> tests\models\test_snippet_manager.py:269:9
    |
267 |         assert idx == 0
268 |
269 |     def test_get_starting_index_with_sessions(
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
270 |         self, snippet_mgr: SnippetManager, sample_category: Category
271 |     ) -> None:
    |

D102 Missing docstring in public method
   --> tests\models\test_snippet_manager.py:309:9
    |
307 |         assert idx == 3  # Next should be 'd'
308 |
309 |     def test_get_starting_index_wraps_to_zero(
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
310 |         self, snippet_mgr: SnippetManager, sample_category: Category
311 |     ) -> None:
    |

D102 Missing docstring in public method
   --> tests\models\test_snippet_manager.py:349:9
    |
347 |         assert idx == 0
348 |
349 |     def test_get_starting_index_greater_than_length(
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
350 |         self, snippet_mgr: SnippetManager, sample_category: Category
351 |     ) -> None:
    |

D102 Missing docstring in public method
   --> tests\models\test_snippet_manager.py:389:9
    |
387 |         assert idx == 0
388 |
389 |     def test_get_starting_index_different_user_keyboard(
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
390 |         self, snippet_mgr: SnippetManager, sample_category: Category
391 |     ) -> None:
    |

D205 1 blank line required between summary line and description
 --> tests\models\test_user_manager_fixes.py:1:1
  |
1 | / """
2 | | Tests for UserManager database access pattern fixes.
3 | | Specifically tests the fixes for psycopg2.ProgrammingError: no results to fetch.
4 | | """
  | |___^
5 |
6 |   import uuid
  |
help: Insert single blank line

D212 [*] Multi-line docstring summary should start at the first line
 --> tests\models\test_user_manager_fixes.py:1:1
  |
1 | / """
2 | | Tests for UserManager database access pattern fixes.
3 | | Specifically tests the fixes for psycopg2.ProgrammingError: no results to fetch.
4 | | """
  | |___^
5 |
6 |   import uuid
  |
help: Remove whitespace after opening quotes

F401 [*] `unittest.mock.MagicMock` imported but unused
  --> tests\models\test_user_manager_fixes.py:8:27
   |
 6 | import uuid
 7 | from typing import Any, Dict, List
 8 | from unittest.mock import MagicMock, Mock
   |                           ^^^^^^^^^
 9 |
10 | import pytest
   |
help: Remove unused import: `unittest.mock.MagicMock`

F401 [*] `models.user.User` imported but unused
  --> tests\models\test_user_manager_fixes.py:12:25
   |
10 | import pytest
11 |
12 | from models.user import User
   |                         ^^^^
13 | from models.user_manager import UserManager, UserNotFound, UserValidationError
   |
help: Remove unused import: `models.user.User`

D212 [*] Multi-line docstring summary should start at the first line
 --> text_randomizer.py:2:1
  |
1 |   #!/usr/bin/env python3
2 | / """
3 | | Text Randomizer Program
4 | |
5 | | Takes a long string of text, extracts unique words (split by space),
6 | | and outputs them in random order with each word appearing at most twice.
7 | | """
  | |___^
8 |
9 |   import random
  |
help: Remove whitespace after opening quotes

D415 First line should end with a period, question mark, or exclamation point
 --> text_randomizer.py:2:1
  |
1 |   #!/usr/bin/env python3
2 | / """
3 | | Text Randomizer Program
4 | |
5 | | Takes a long string of text, extracts unique words (split by space),
6 | | and outputs them in random order with each word appearing at most twice.
7 | | """
  | |___^
8 |
9 |   import random
  |
help: Add closing punctuation

D212 [*] Multi-line docstring summary should start at the first line
  --> text_randomizer.py:14:5
   |
13 |   def randomize_text_words(input_text: str) -> str:
14 | /     """
15 | |     Process input text to create a randomized output with unique words appearing at most twice.
16 | |
17 | |     Args:
18 | |         input_text: The input string to process
19 | |
20 | |     Returns:
21 | |         A space-delimited string with words in random order, each appearing at most twice
22 | |     """
   | |_______^
23 |       # Split text into words by spaces and get unique words
24 |       words = input_text.split()
   |
help: Remove whitespace after opening quotes

D100 Missing docstring in public module
--> web_ui\__init_LLM_ngrams__.py:1:1

ANN201 Missing return type annotation for public function `ngram_words_page`
  --> web_ui\__init_LLM_ngrams__.py:9:5
   |
 8 | @web_ui.route("/ngram-words", methods=["GET"])
 9 | def ngram_words_page():
   |     ^^^^^^^^^^^^^^^^
10 |     return render_template("ngram_words.html")
   |
help: Add return type annotation

D103 Missing docstring in public function
  --> web_ui\__init_LLM_ngrams__.py:9:5
   |
 8 | @web_ui.route("/ngram-words", methods=["GET"])
 9 | def ngram_words_page():
   |     ^^^^^^^^^^^^^^^^
10 |     return render_template("ngram_words.html")
   |

ANN201 Missing return type annotation for public function `api_ngram_words`
  --> web_ui\__init_LLM_ngrams__.py:14:5
   |
13 | @web_ui.route("/api/ngram-words", methods=["POST"])
14 | def api_ngram_words():
   |     ^^^^^^^^^^^^^^^
15 |     data = request.get_json()
16 |     snippets = data.get("snippets", [])
   |
help: Add return type annotation

D103 Missing docstring in public function
  --> web_ui\__init_LLM_ngrams__.py:14:5
   |
13 | @web_ui.route("/api/ngram-words", methods=["POST"])
14 | def api_ngram_words():
   |     ^^^^^^^^^^^^^^^
15 |     data = request.get_json()
16 |     snippets = data.get("snippets", [])
   |

F821 Undefined name `os`
  --> web_ui\__init_LLM_ngrams__.py:27:13
   |
25 |     try:
26 |         with open(
27 |             os.path.join(os.path.dirname(__file__), "../Keys/OpenAPI_Key.txt"), "r"
   |             ^^
28 |         ) as f:
29 |             openai.api_key = f.read().strip()
   |

F821 Undefined name `os`
  --> web_ui\__init_LLM_ngrams__.py:27:26
   |
25 |     try:
26 |         with open(
27 |             os.path.join(os.path.dirname(__file__), "../Keys/OpenAPI_Key.txt"), "r"
   |                          ^^
28 |         ) as f:
29 |             openai.api_key = f.read().strip()
   |

E501 Line too long (340 > 120)
  --> web_ui\__init_LLM_ngrams__.py:38:121
   |
36 | 
37 | 
38 | ngrams {ngrams}. Can you please assemble this list in random order into a space delimited string, with a maximum length of {max_length} characters. I'm OK if you repeat certain words, and also if you include the actual ngram.
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
39 | 
   |

F841 Local variable `generated_text` is assigned to but never used
  --> web_ui\__init_LLM_ngrams__.py:51:5
   |
49 |     )
50 |
51 |     generated_text = response.choices[0].text.strip()
   |     ^^^^^^^^^^^^^^
52 |
53 |     # --- Replace this with your OpenAI API key and call if available ---
   |
help: Remove assignment to unused variable `generated_text`

D104 Missing docstring in public package
--> web_ui\__init__.py:1:1

Found 1582 errors.
[*] 361 fixable with the `--fix` option (342 hidden fixes can be enabled with the `--unsafe-fixes` option).
============================= test session starts =============================
platform win32 -- Python 3.13.2, pytest-8.4.1, pluggy-1.6.0 -- D:\SeanDevLocal\AITypingTrainer\.venv\Scripts\python.exe
cachedir: .pytest_cache
PySide6 6.9.1 -- Qt runtime 6.9.1 -- Qt compiled 6.9.1
rootdir: D:\SeanDevLocal\AITypingTrainer
configfile: pytest.ini
plugins: anyio-4.10.0, cov-6.2.1, mock-3.14.1, qt-4.5.0
collecting ... collected 513 items

tests/models/test_category.py::TestCategoryModel::test_category_creation_valid PASSED [  0%]
tests/models/test_category.py::TestCategoryModel::test_category_name_validation[-Category name cannot be blank.] PASSED [  0%]
tests/models/test_category.py::TestCategoryModel::test_category_name_validation[   -Category name cannot be blank.] PASSED [  0%]
tests/models/test_category.py::TestCategoryModel::test_category_name_validation[AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA-Category name must be at most 64 characters.] PASSED [  0%]
tests/models/test_category.py::TestCategoryModel::test_category_name_validation[NonASCII\xd1ame-Category name must be ASCII-only.] PASSED [  0%]
tests/models/test_category.py::TestCategoryModel::test_category_exceptions_instantiable PASSED [  1%]
tests/models/test_category.py::TestCategoryModel::test_category_init_autogenerates_id PASSED [  1%]
tests/models/test_category.py::TestCategoryModel::test_category_from_dict_valid_and_extra_fields PASSED [  1%]
tests/models/test_category.py::TestCategoryModel::test_category_to_dict PASSED [  1%]
tests/models/test_category.py::TestCategoryModel::test_category_field_type_and_value_errors[category_id-123-Input should be a valid string] PASSED [  1%]
tests/models/test_category.py::TestCategoryModel::test_category_field_type_and_value_errors[category_id-not-a-uuid-category_id must be a valid UUID string] PASSED [  2%]
tests/models/test_category.py::TestCategoryModel::test_category_field_type_and_value_errors[category_name-None-Input should be a valid string] PASSED [  2%]
tests/models/test_category.py::TestCategoryModel::test_category_field_type_and_value_errors[category_name--Category name cannot be blank] PASSED [  2%]
tests/models/test_category.py::TestCategoryModel::test_category_field_type_and_value_errors[category_name- -Category name cannot be blank] PASSED [  2%]
tests/models/test_category.py::TestCategoryModel::test_category_field_type_and_value_errors[category_name-AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA-Category name must be at most 64 characters] PASSED [  2%]
tests/models/test_category.py::TestCategoryModel::test_category_field_type_and_value_errors[category_name-NonASCII\xd1ame-Category name must be ASCII-only] PASSED [  3%]
tests/models/test_category.py::TestCategoryModel::test_category_db_rows_fail_validation PASSED [  3%]
tests/models/test_category_manager.py::TestCategoryManager::test_create_category_valid PASSED [  3%]
tests/models/test_category_manager.py::TestCategoryManager::test_create_category_invalid_format[-blank] PASSED [  3%]
tests/models/test_category_manager.py::TestCategoryManager::test_create_category_invalid_format[  -blank] PASSED [  3%]
tests/models/test_category_manager.py::TestCategoryManager::test_create_category_invalid_format[AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA-at most 64 characters] PASSED [  4%]
tests/models/test_category_manager.py::TestCategoryManager::test_create_category_invalid_format[Caf\xe9 NonASCII-ASCII-only] PASSED [  4%]
tests/models/test_category_manager.py::TestCategoryManager::test_create_category_duplicate_name PASSED [  4%]
tests/models/test_category_manager.py::TestCategoryManager::test_get_category_by_id PASSED [  4%]
tests/models/test_category_manager.py::TestCategoryManager::test_get_category_by_id_not_found PASSED [  4%]
tests/models/test_category_manager.py::TestCategoryManager::test_get_category_by_id_invalid_uuid PASSED [  5%]
tests/models/test_category_manager.py::TestCategoryManager::test_get_category_by_name PASSED [  5%]
tests/models/test_category_manager.py::TestCategoryManager::test_get_category_by_name_not_found PASSED [  5%]
tests/models/test_category_manager.py::TestCategoryManager::test_get_category_by_name_case_sensitive PASSED [  5%]
tests/models/test_category_manager.py::TestCategoryManager::test_list_all_categories_empty PASSED [  5%]
tests/models/test_category_manager.py::TestCategoryManager::test_list_all_categories_populated PASSED [  6%]
tests/models/test_category_manager.py::TestCategoryManager::test_update_category_valid_name PASSED [  6%]
tests/models/test_category_manager.py::TestCategoryManager::test_update_category_invalid_format[-blank] PASSED [  6%]
tests/models/test_category_manager.py::TestCategoryManager::test_update_category_invalid_format[AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA-at most 64 characters] PASSED [  6%]
tests/models/test_category_manager.py::TestCategoryManager::test_update_category_invalid_format[Caf\xe9 Again-ASCII-only] PASSED [  6%]
tests/models/test_category_manager.py::TestCategoryManager::test_update_category_to_duplicate_name PASSED [  7%]
tests/models/test_category_manager.py::TestCategoryManager::test_update_category_to_case_variant_duplicate PASSED [  7%]
tests/models/test_category_manager.py::TestCategoryManager::test_update_category_to_same_name PASSED [  7%]
tests/models/test_category_manager.py::TestCategoryManager::test_delete_category_by_id PASSED [  7%]
tests/models/test_category_manager.py::TestCategoryManager::test_delete_category_by_id_invalid_uuid PASSED [  7%]
tests/models/test_category_manager.py::TestCategoryManager::test_delete_nonexistent_category PASSED [  7%]
tests/models/test_category_manager.py::TestCategoryManager::test_delete_all_categories PASSED [  8%]
tests/models/test_category_manager.py::TestCategoryManager::test_category_validation_blank_and_duplicate PASSED [  8%]
tests/models/test_category_manager.py::TestCategoryManager::test_save_category_non_string_name PASSED [  8%]
tests/models/test_category_manager.py::TestCategoryManager::test_delete_category_alias PASSED [  8%]
tests/models/test_category_manager.py::TestCategoryManager::test_save_category_unexpected_db_error PASSED [  8%]
tests/models/test_dynamic_content_service.py::TestDynamicContentServiceInitialization::test_init_with_valid_params PASSED [  9%]
tests/models/test_dynamic_content_service.py::TestDynamicContentServiceInitialization::test_init_with_defaults PASSED [  9%]
tests/models/test_dynamic_content_service.py::TestDynamicContentServiceInitialization::test_invalid_practice_length_too_small PASSED [  9%]
tests/models/test_dynamic_content_service.py::TestDynamicContentServiceInitialization::test_invalid_practice_length_too_large PASSED [  9%]
tests/models/test_dynamic_content_service.py::TestDynamicContentServiceInitialization::test_invalid_practice_length_type PASSED [  9%]
tests/models/test_dynamic_content_service.py::TestDynamicContentServiceInitialization::test_mode_setter_with_string PASSED [ 10%]
tests/models/test_dynamic_content_service.py::TestDynamicContentServiceInitialization::test_mode_setter_with_invalid_string PASSED [ 10%]
tests/models/test_dynamic_content_service.py::TestDynamicContentServiceInitialization::test_mode_setter_with_enum PASSED [ 10%]
tests/models/test_dynamic_content_service.py::TestDynamicContentServiceValidation::test_validate_missing_ngrams PASSED [ 10%]
tests/models/test_dynamic_content_service.py::TestDynamicContentServiceValidation::test_validate_missing_in_scope_keys PASSED [ 10%]
tests/models/test_dynamic_content_service.py::TestDynamicContentServiceValidation::test_validate_missing_llm_service_for_words_mode PASSED [ 11%]
tests/models/test_dynamic_content_service.py::TestDynamicContentServiceValidation::test_validate_missing_llm_service_for_mixed_mode PASSED [ 11%]
tests/models/test_dynamic_content_service.py::TestNGramOnlyMode::test_generate_ngram_content PASSED [ 11%]
tests/models/test_dynamic_content_service.py::TestNGramOnlyMode::test_ngram_content_custom_delimiter PASSED [ 11%]
tests/models/test_dynamic_content_service.py::TestNGramOnlyMode::test_ngram_content_respects_length_limit PASSED [ 11%]
tests/models/test_dynamic_content_service.py::TestNGramOnlyMode::test_ngram_content_filters_out_of_scope_chars FAILED [ 12%]
tests/models/test_dynamic_content_service.py::TestWordsOnlyMode::test_generate_words_content FAILED [ 12%]
tests/models/test_dynamic_content_service.py::TestWordsOnlyMode::test_words_content_filters_out_of_scope_chars FAILED [ 12%]
tests/models/test_dynamic_content_service.py::TestWordsOnlyMode::test_words_content_custom_delimiter FAILED [ 12%]
tests/models/test_dynamic_content_service.py::TestMixedMode::test_generate_mixed_content FAILED [ 12%]
tests/models/test_dynamic_content_service.py::TestMixedMode::test_mixed_content_has_variety FAILED [ 13%]
tests/models/test_keyboard.py::test_keyboard_valid PASSED                [ 13%]
tests/models/test_keyboard.py::test_keyboard_empty_name PASSED           [ 13%]
tests/models/test_keyboard.py::test_keyboard_name_strip PASSED           [ 13%]
tests/models/test_keyboard.py::test_keyboard_default_target_ms PASSED    [ 13%]
tests/models/test_keyboard.py::test_keyboard_custom_target_ms PASSED     [ 14%]
tests/models/test_keyboard.py::test_keyboard_target_ms_too_low PASSED    [ 14%]
tests/models/test_keyboard.py::test_keyboard_target_ms_too_high PASSED   [ 14%]
tests/models/test_keyboard.py::test_keyboard_target_ms_none PASSED       [ 14%]
tests/models/test_keyboard_manager.py::test_create_keyboard PASSED       [ 14%]
tests/models/test_keyboard_manager.py::test_get_keyboard PASSED          [ 15%]
tests/models/test_keyboard_manager.py::test_update_keyboard_name PASSED  [ 15%]
tests/models/test_keyboard_manager.py::test_update_keyboard_target_speed PASSED [ 15%]
tests/models/test_keyboard_manager.py::test_delete_keyboard PASSED       [ 15%]
tests/models/test_keystroke.py::TestKeystrokeCreation::test_keystroke_creation_with_valid_data PASSED [ 15%]
tests/models/test_keystroke.py::TestKeystrokeCreation::test_keystroke_creation_with_defaults PASSED [ 15%]
tests/models/test_keystroke.py::TestKeystrokeCreation::test_keystroke_id_auto_generation PASSED [ 16%]
tests/models/test_keystroke.py::TestKeystrokeCreation::test_keystroke_time_auto_generation PASSED [ 16%]
tests/models/test_keystroke.py::TestKeystrokeCreation::test_keystroke_with_none_session_id PASSED [ 16%]
tests/models/test_keystroke.py::TestKeystrokeCreation::test_keystroke_with_error_true PASSED [ 16%]
tests/models/test_keystroke.py::TestKeystrokeCreation::test_keystroke_with_empty_strings PASSED [ 16%]
tests/models/test_keystroke.py::TestKeystrokeCreation::test_keystroke_with_valid_text_index PASSED [ 17%]
tests/models/test_keystroke.py::TestKeystrokeCreation::test_keystroke_with_negative_text_index_raises_error PASSED [ 17%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_with_valid_data PASSED [ 17%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_with_minimal_data PASSED [ 17%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_datetime_iso_string PASSED [ 17%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_datetime_iso_string_with_z PASSED [ 18%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_invalid_datetime_string PASSED [ 18%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_non_datetime_object PASSED [ 18%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_is_error_string_values[true-True] PASSED [ 18%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_is_error_string_values[True-True] PASSED [ 18%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_is_error_string_values[1-True] PASSED [ 19%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_is_error_string_values[t-True] PASSED [ 19%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_is_error_string_values[y-True] PASSED [ 19%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_is_error_string_values[yes-True] PASSED [ 19%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_is_error_string_values[false-False] PASSED [ 19%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_is_error_string_values[False-False] PASSED [ 20%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_is_error_string_values[0-False] PASSED [ 20%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_is_error_string_values[f-False] PASSED [ 20%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_is_error_string_values[n-False] PASSED [ 20%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_is_error_string_values[no-False] PASSED [ 20%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_is_error_string_values[-False] PASSED [ 21%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_is_error_string_values[other-False] PASSED [ 21%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_is_error_integer_values[0-False] PASSED [ 21%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_is_error_integer_values[1-True] PASSED [ 21%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_is_error_integer_values[-1-True] PASSED [ 21%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_is_error_integer_values[42-True] PASSED [ 22%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_is_error_none_value PASSED [ 22%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_session_id_conversion PASSED [ 22%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_session_id_invalid_conversion PASSED [ 22%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_keystroke_id_conversion PASSED [ 22%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_keystroke_id_invalid_conversion PASSED [ 23%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_empty_dict PASSED [ 23%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_text_index_valid_conversion[0-0_0] PASSED [ 23%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_text_index_valid_conversion[5-5_0] PASSED [ 23%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_text_index_valid_conversion[42-42_0] PASSED [ 23%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_text_index_valid_conversion[999999-999999_0] PASSED [ 23%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_text_index_valid_conversion[0-0_1] PASSED [ 24%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_text_index_valid_conversion[5-5_1] PASSED [ 24%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_text_index_valid_conversion[42-42_1] PASSED [ 24%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_text_index_valid_conversion[999999-999999_1] PASSED [ 24%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_text_index_invalid_conversion[invalid] PASSED [ 24%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_text_index_invalid_conversion[not-a-number] PASSED [ 25%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_text_index_invalid_conversion[text_index_value2] PASSED [ 25%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_text_index_invalid_conversion[text_index_value3] PASSED [ 25%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_text_index_invalid_conversion[None] PASSED [ 25%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_text_index_invalid_conversion[-1_0] PASSED [ 25%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_text_index_invalid_conversion[-100_0] PASSED [ 26%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_text_index_invalid_conversion[-1_1] PASSED [ 26%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_text_index_invalid_conversion[-100_1] PASSED [ 26%]
tests/models/test_keystroke.py::TestKeystrokeToDict::test_to_dict_complete_data PASSED [ 26%]
tests/models/test_keystroke.py::TestKeystrokeToDict::test_to_dict_datetime_serialization PASSED [ 26%]
tests/models/test_keystroke.py::TestKeystrokeToDict::test_to_dict_with_none_values PASSED [ 27%]
tests/models/test_keystroke.py::TestKeystrokeToDict::test_to_dict_roundtrip PASSED [ 27%]
tests/models/test_keystroke.py::TestKeystrokeClassMethods::test_get_for_session_success PASSED [ 27%]
tests/models/test_keystroke.py::TestKeystrokeClassMethods::test_get_for_session_empty_result PASSED [ 27%]
tests/models/test_keystroke.py::TestKeystrokeClassMethods::test_get_for_session_none_result PASSED [ 27%]
tests/models/test_keystroke.py::TestKeystrokeClassMethods::test_get_errors_for_session_success PASSED [ 28%]
tests/models/test_keystroke.py::TestKeystrokeClassMethods::test_get_errors_for_session_empty_result PASSED [ 28%]
tests/models/test_keystroke.py::TestKeystrokeClassMethods::test_delete_all_keystrokes_success PASSED [ 28%]
tests/models/test_keystroke.py::TestKeystrokeClassMethods::test_delete_all_keystrokes_exception PASSED [ 28%]
tests/models/test_keystroke.py::TestKeystrokeEdgeCases::test_keystroke_with_unicode_characters PASSED [ 28%]
tests/models/test_keystroke.py::TestKeystrokeEdgeCases::test_keystroke_with_special_characters PASSED [ 29%]
tests/models/test_keystroke.py::TestKeystrokeEdgeCases::test_keystroke_with_very_long_strings PASSED [ 29%]
tests/models/test_keystroke.py::TestKeystrokeEdgeCases::test_keystroke_with_negative_time_since_previous PASSED [ 29%]
tests/models/test_keystroke.py::TestKeystrokeEdgeCases::test_keystroke_with_zero_time_since_previous PASSED [ 29%]
tests/models/test_keystroke.py::TestKeystrokeEdgeCases::test_keystroke_with_very_large_time_since_previous PASSED [ 29%]
tests/models/test_keystroke.py::TestKeystrokeEdgeCases::test_from_dict_with_extra_fields PASSED [ 30%]
tests/models/test_keystroke.py::TestKeystrokeIntegration::test_full_workflow_create_save_retrieve PASSED [ 30%]
tests/models/test_keystroke.py::TestKeystrokeIntegration::test_model_consistency_with_specification PASSED [ 30%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerInitialization::test_init_default_database_manager PASSED [ 30%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerInitialization::test_init_custom_database_manager PASSED [ 30%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerInitialization::test_init_none_database_manager PASSED [ 30%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerAddKeystroke::test_add_single_keystroke PASSED [ 31%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerAddKeystroke::test_add_multiple_keystrokes PASSED [ 31%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerAddKeystroke::test_add_keystroke_with_error PASSED [ 31%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerGetKeystrokesForSession::test_get_keystrokes_for_session_success PASSED [ 31%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerGetKeystrokesForSession::test_get_keystrokes_for_session_empty PASSED [ 31%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerGetKeystrokesForSession::test_get_keystrokes_replaces_existing_list PASSED [ 32%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerGetKeystrokesForSession::test_get_keystrokes_with_uuid_session_id PASSED [ 32%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerSaveKeystrokes::test_save_keystrokes_success FAILED [ 32%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerSaveKeystrokes::test_save_keystrokes_empty_list PASSED [ 32%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerSaveKeystrokes::test_save_keystrokes_database_error FAILED [ 32%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerSaveKeystrokes::test_save_keystrokes_with_special_characters FAILED [ 33%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerSaveKeystrokes::test_save_keystrokes_boolean_conversion FAILED [ 33%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerDeleteKeystrokes::test_delete_keystrokes_by_session_success PASSED [ 33%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerDeleteKeystrokes::test_delete_keystrokes_by_session_database_error PASSED [ 33%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerDeleteKeystrokes::test_delete_keystrokes_by_session_uuid PASSED [ 33%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerDeleteKeystrokes::test_delete_all_keystrokes_success PASSED [ 34%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerDeleteKeystrokes::test_delete_all_keystrokes_database_error PASSED [ 34%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerDeleteKeystrokes::test_delete_keystrokes_empty_session_id PASSED [ 34%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerCountKeystrokes::test_count_keystrokes_dict_result PASSED [ 34%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerCountKeystrokes::test_count_keystrokes_tuple_result PASSED [ 34%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerCountKeystrokes::test_count_keystrokes_zero_result PASSED [ 35%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerCountKeystrokes::test_count_keystrokes_none_result PASSED [ 35%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerCountKeystrokes::test_count_keystrokes_none_count_value PASSED [ 35%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerCountKeystrokes::test_count_keystrokes_database_error PASSED [ 35%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerCountKeystrokes::test_count_keystrokes_result_conversion_error PASSED [ 35%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerCountKeystrokes::test_count_keystrokes_uuid_session_id PASSED [ 36%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerIntegration::test_full_keystroke_workflow FAILED [ 36%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerIntegration::test_concurrent_session_handling PASSED [ 36%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerEdgeCases::test_extreme_session_id_values PASSED [ 36%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerEdgeCases::test_extreme_keystroke_values PASSED [ 36%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerEdgeCases::test_unicode_and_special_characters FAILED [ 37%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerEdgeCases::test_memory_management_large_list PASSED [ 37%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerErrorHandling::test_database_connection_failure FAILED [ 37%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerErrorHandling::test_invalid_keystroke_data PASSED [ 37%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerErrorHandling::test_partial_save_failure FAILED [ 37%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerErrorHandling::test_network_timeout_simulation FAILED [ 38%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerCompatibility::test_different_datetime_formats PASSED [ 38%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerCompatibility::test_boolean_variations PASSED [ 38%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerCompatibility::test_numeric_edge_cases PASSED [ 38%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerCompatibility::test_string_encoding_variants PASSED [ 38%]
tests/models/test_llm_ngram_service.py::test_missing_api_key PASSED      [ 38%]
tests/models/test_llm_ngram_service.py::test_invalid_ngrams PASSED       [ 39%]
tests/models/test_llm_ngram_service.py::test_llm_success PASSED          [ 39%]
tests/models/test_llm_ngram_service.py::test_llm_trims_to_max_length PASSED [ 39%]
tests/models/test_llm_ngram_service.py::test_get_words_with_ngrams_word_counts[ngrams0-the-1-1] PASSED [ 39%]
tests/models/test_llm_ngram_service.py::test_get_words_with_ngrams_word_counts[ngrams1-thecat-2-2] PASSED [ 39%]
tests/models/test_llm_ngram_service.py::test_get_words_with_ngrams_word_counts[ngrams2-abcdefghijklmnopqrstuvwxyz-5-5] PASSED [ 40%]
tests/models/test_llm_ngram_service.py::test_llm_simple_prompt_returns_10_words PASSED [ 40%]
tests/models/test_next_session_position.py::test_get_next_position_no_previous_session PASSED [ 40%]
tests/models/test_next_session_position.py::test_get_next_position_continue_from_previous PASSED [ 40%]
tests/models/test_next_session_position.py::test_get_next_position_wrap_around PASSED [ 40%]
tests/models/test_next_session_position.py::test_get_next_position_beyond_length PASSED [ 41%]
tests/models/test_next_session_position.py::test_get_next_position_multiple_sessions PASSED [ 41%]
tests/models/test_ngram.py::TestKeystroke::test_keystroke_basic PASSED   [ 41%]
tests/models/test_ngram.py::TestKeystroke::test_keystroke_nfc_single_char FAILED [ 41%]
tests/models/test_ngram.py::TestNGramTextRules::test_has_sequence_separators PASSED [ 41%]
tests/models/test_ngram.py::TestNGramTextRules::test_is_valid_ngram_text PASSED [ 42%]
tests/models/test_ngram.py::TestSpeedNGram::test_speed_ngram_computes_ms_per_keystroke PASSED [ 42%]
tests/models/test_ngram.py::TestSpeedNGram::test_speed_ngram_rejects_separators PASSED [ 42%]
tests/models/test_ngram.py::TestSpeedNGram::test_speed_ngram_invalid_size PASSED [ 42%]
tests/models/test_ngram.py::TestSpeedNGram::test_speed_ngram_at_max_size PASSED [ 42%]
tests/models/test_ngram.py::TestSpeedNGram::test_speed_ngram_rejects_over_max PASSED [ 43%]
tests/models/test_ngram.py::TestErrorNGram::test_error_ngram_pattern_last_char_only PASSED [ 43%]
tests/models/test_ngram.py::TestErrorNGram::test_error_ngram_pattern_invalid_first_char PASSED [ 43%]
tests/models/test_ngram.py::TestErrorNGram::test_error_ngram_rejects_separators PASSED [ 43%]
tests/models/test_ngram.py::TestErrorNGram::test_error_ngram_at_max_size PASSED [ 43%]
tests/models/test_ngram.py::TestErrorNGram::test_error_ngram_rejects_over_max PASSED [ 44%]
tests/models/test_ngram_analytics_service.py::TestDecayingAverageCalculator::test_calculate_decaying_average_basic PASSED [ 44%]
tests/models/test_ngram_analytics_service.py::TestDecayingAverageCalculator::test_calculate_decaying_average_single_value PASSED [ 44%]
tests/models/test_ngram_analytics_service.py::TestDecayingAverageCalculator::test_calculate_decaying_average_empty_values PASSED [ 44%]
tests/models/test_ngram_analytics_service.py::TestDecayingAverageCalculator::test_calculate_decaying_average_max_samples PASSED [ 44%]
tests/models/test_ngram_analytics_service.py::TestNGramAnalyticsService::test_init_with_valid_dependencies PASSED [ 45%]
tests/models/test_ngram_analytics_service.py::TestNGramAnalyticsService::test_init_with_none_dependencies PASSED [ 45%]
tests/models/test_ngram_analytics_service.py::TestNGramAnalyticsService::test_refresh_speed_summaries_basic ERROR [ 45%]
tests/models/test_ngram_analytics_service.py::TestNGramAnalyticsService::test_get_speed_heatmap_data_basic SKIPPED [ 45%]
tests/models/test_ngram_analytics_service.py::TestNGramAnalyticsService::test_get_performance_trends_basic SKIPPED [ 45%]
tests/models/test_ngram_analytics_service.py::TestNGramAnalyticsService::test_slowest_n_moved_from_ngram_manager SKIPPED [ 46%]
tests/models/test_ngram_analytics_service.py::TestNGramAnalyticsService::test_error_n_moved_from_ngram_manager SKIPPED [ 46%]
tests/models/test_ngram_analytics_service.py::TestNGramAnalyticsService::test_dual_insert_creates_records_in_both_tables FAILED [ 46%]
tests/models/test_ngram_analytics_service.py::TestNGramAnalyticsService::test_history_table_accumulates_all_records FAILED [ 46%]
tests/models/test_ngram_analytics_service.py::TestNGramAnalyticsService::test_get_ngram_history_retrieval FAILED [ 46%]
tests/models/test_ngram_analytics_service.py::TestNGramAnalyticsService::test_history_table_schema_compatibility FAILED [ 46%]
tests/models/test_ngram_analytics_service.py::TestNGramPerformanceData::test_valid_performance_data PASSED [ 47%]
tests/models/test_ngram_analytics_service.py::TestNGramPerformanceData::test_invalid_performance_data PASSED [ 47%]
tests/models/test_ngram_analytics_service.py::TestNGramHeatmapData::test_valid_heatmap_data PASSED [ 47%]
tests/models/test_ngram_analytics_service_session_methods.py::TestSummarizeSessionNgrams::test_summarize_with_ngram_speed_only[1-1] ERROR [ 47%]
tests/models/test_ngram_analytics_service_session_methods.py::TestSummarizeSessionNgrams::test_summarize_with_ngram_speed_only[3-3] ERROR [ 47%]
tests/models/test_ngram_analytics_service_session_methods.py::TestSummarizeSessionNgrams::test_summarize_with_ngram_errors_only[1-1] ERROR [ 48%]
tests/models/test_ngram_analytics_service_session_methods.py::TestSummarizeSessionNgrams::test_summarize_with_ngram_errors_only[2-2] ERROR [ 48%]
tests/models/test_ngram_analytics_service_session_methods.py::TestSummarizeSessionNgrams::test_summarize_with_speed_and_errors ERROR [ 48%]
tests/models/test_ngram_analytics_service_session_methods.py::TestSummarizeSessionNgrams::test_summarize_with_keystrokes[1-1] ERROR [ 48%]
tests/models/test_ngram_analytics_service_session_methods.py::TestSummarizeSessionNgrams::test_summarize_with_keystrokes[3-3] ERROR [ 48%]
tests/models/test_ngram_analytics_service_session_methods.py::TestSummarizeSessionNgrams::test_no_sessions_missing ERROR [ 49%]
tests/models/test_ngram_analytics_service_session_methods.py::TestSummarizeSessionNgrams::test_sessions_missing_no_data ERROR [ 49%]
tests/models/test_ngram_analytics_service_session_methods.py::TestAddSpeedSummaryForSession::test_single_session_processing ERROR [ 49%]
tests/models/test_ngram_analytics_service_session_methods.py::TestAddSpeedSummaryForSession::test_nonexistent_session FAILED [ 49%]
tests/models/test_ngram_analytics_service_session_methods.py::TestAddSpeedSummaryForSession::test_multiple_ngrams_processing ERROR [ 49%]
tests/models/test_ngram_analytics_service_session_methods.py::TestCatchupSpeedSummary::test_empty_database_catchup FAILED [ 50%]
tests/models/test_ngram_analytics_service_session_methods.py::TestCatchupSpeedSummary::test_single_session_catchup ERROR [ 50%]
tests/models/test_ngram_analytics_service_session_methods.py::TestCatchupSpeedSummary::test_multiple_sessions_catchup ERROR [ 50%]
tests/models/test_ngram_analytics_service_session_methods.py::TestCatchupSpeedSummary::test_catchup_with_session_errors ERROR [ 50%]
tests/models/test_ngram_analytics_service_session_methods.py::TestIntegrationScenarios::test_full_workflow_integration ERROR [ 50%]
tests/models/test_ngram_manager.py::TestAnalyzeBasic::test_clean_windows_and_gross_up PASSED [ 51%]
tests/models/test_ngram_manager.py::TestAnalyzeBasic::test_ignored_zero_duration PASSED [ 51%]
tests/models/test_ngram_manager.py::TestAnalyzeBasic::test_separators_split_runs PASSED [ 51%]
tests/models/test_ngram_manager.py::TestErrorClassification::test_error_last_only PASSED [ 51%]
tests/models/test_ngram_manager.py::TestErrorClassification::test_error_not_last_is_ignored PASSED [ 51%]
tests/models/test_ngram_orchestrator_process_end_of_session.py::test_process_end_of_session_success_path FAILED [ 52%]
tests/models/test_ngram_orchestrator_process_end_of_session.py::test_process_end_of_session_session_save_failure FAILED [ 52%]
tests/models/test_ngram_orchestrator_process_end_of_session.py::test_process_end_of_session_keystrokes_save_failure FAILED [ 52%]
tests/models/test_ngram_orchestrator_process_end_of_session.py::test_process_end_of_session_summarization_failure FAILED [ 52%]
tests/models/test_session.py::test_valid_session_creation PASSED         [ 52%]
tests/models/test_session.py::test_missing_required_fields_raises[snippet_id] PASSED [ 53%]
tests/models/test_session.py::test_missing_required_fields_raises[user_id] PASSED [ 53%]
tests/models/test_session.py::test_missing_required_fields_raises[keyboard_id] PASSED [ 53%]
tests/models/test_session.py::test_missing_required_fields_raises[snippet_index_start] PASSED [ 53%]
tests/models/test_session.py::test_missing_required_fields_raises[snippet_index_end] PASSED [ 53%]
tests/models/test_session.py::test_missing_required_fields_raises[content] PASSED [ 53%]
tests/models/test_session.py::test_missing_required_fields_raises[start_time] PASSED [ 54%]
tests/models/test_session.py::test_missing_required_fields_raises[end_time] PASSED [ 54%]
tests/models/test_session.py::test_missing_required_fields_raises[actual_chars] PASSED [ 54%]
tests/models/test_session.py::test_missing_required_fields_raises[errors] PASSED [ 54%]
tests/models/test_session.py::test_invalid_field_values_raise[session_id-not-a-uuid] PASSED [ 54%]
tests/models/test_session.py::test_invalid_field_values_raise[snippet_id-not-a-uuid] PASSED [ 55%]
tests/models/test_session.py::test_invalid_field_values_raise[user_id-not-a-uuid] PASSED [ 55%]
tests/models/test_session.py::test_invalid_field_values_raise[keyboard_id-not-a-uuid] PASSED [ 55%]
tests/models/test_session.py::test_invalid_field_values_raise[snippet_index_start--1] PASSED [ 55%]
tests/models/test_session.py::test_invalid_field_values_raise[snippet_index_end-0] PASSED [ 55%]
tests/models/test_session.py::test_invalid_field_values_raise[start_time-not-a-date] PASSED [ 56%]
tests/models/test_session.py::test_invalid_field_values_raise[end_time-12345] PASSED [ 56%]
tests/models/test_session.py::test_invalid_field_values_raise[actual_chars-not-an-int] PASSED [ 56%]
tests/models/test_session.py::test_invalid_field_values_raise[errors-not-an-int] PASSED [ 56%]
tests/models/test_session.py::test_index_business_rules[0-0-True] PASSED [ 56%]
tests/models/test_session.py::test_index_business_rules[5-5-True] PASSED [ 57%]
tests/models/test_session.py::test_index_business_rules[10-5-True] PASSED [ 57%]
tests/models/test_session.py::test_index_business_rules[-1-5-True] PASSED [ 57%]
tests/models/test_session.py::test_index_business_rules[0-1-False] PASSED [ 57%]
tests/models/test_session.py::test_index_business_rules[2-5-False] PASSED [ 57%]
tests/models/test_session.py::test_start_time_after_end_time_raises PASSED [ 58%]
tests/models/test_session.py::test_computed_properties PASSED            [ 58%]
tests/models/test_session.py::test_correctness_and_accuracy[5-0-1.0-1.0] PASSED [ 58%]
tests/models/test_session.py::test_correctness_and_accuracy[5-5-0.0-0.0] PASSED [ 58%]
tests/models/test_session.py::test_correctness_and_accuracy[0-0-0.0-0.0] PASSED [ 58%]
tests/models/test_session.py::test_wpm_cpm_zero_and_normal[start_time0-end_time0-0.0-0.0] PASSED [ 59%]
tests/models/test_session.py::test_wpm_cpm_zero_and_normal[start_time1-end_time1-1.0-5.0] PASSED [ 59%]
tests/models/test_session.py::test_to_dict_and_from_dict PASSED          [ 59%]
tests/models/test_session.py::test_from_dict_ignores_calculated_fields PASSED [ 59%]
tests/models/test_session.py::test_from_dict_with_extra_fields_raises PASSED [ 59%]
tests/models/test_session.py::test_get_summary_truncates_content PASSED  [ 60%]
tests/models/test_session.py::test_extra_fields_forbidden_on_creation PASSED [ 60%]
tests/models/test_session.py::test_ms_per_keystroke_zero_chars PASSED    [ 60%]
tests/models/test_session.py::test_session_id_default_factory PASSED     [ 60%]
tests/models/test_session.py::test_content_required_if_actual_chars PASSED [ 60%]
tests/models/test_session_manager.py::test_save_and_get_session PASSED   [ 61%]
tests/models/test_session_manager.py::test_update_session PASSED         [ 61%]
tests/models/test_session_manager.py::test_list_sessions_for_snippet PASSED [ 61%]
tests/models/test_session_manager.py::test_delete_session_by_id PASSED   [ 61%]
tests/models/test_session_manager.py::test_delete_all PASSED             [ 61%]
tests/models/test_session_manager.py::test_save_session_returns_id PASSED [ 61%]
tests/models/test_session_manager.py::test_get_nonexistent_session PASSED [ 62%]
tests/models/test_session_manager.py::test_list_sessions_for_snippet_empty PASSED [ 62%]
tests/models/test_setting.py::TestSettingModel::test_setting_creation_valid PASSED [ 62%]
tests/models/test_setting.py::TestSettingModel::test_setting_type_id_validation[-setting_type_id must be exactly 6 characters] PASSED [ 62%]
tests/models/test_setting.py::TestSettingModel::test_setting_type_id_validation[ABC-setting_type_id must be exactly 6 characters] PASSED [ 62%]
tests/models/test_setting.py::TestSettingModel::test_setting_type_id_validation[ABCDEFG-setting_type_id must be exactly 6 characters] PASSED [ 63%]
tests/models/test_setting.py::TestSettingModel::test_setting_type_id_validation[ABCD\u20ac\u03a9-setting_type_id must be ASCII-only] PASSED [ 63%]
tests/models/test_setting.py::TestSettingModel::test_setting_exceptions_instantiable PASSED [ 63%]
tests/models/test_setting.py::TestSettingModel::test_setting_init_autogenerates_id PASSED [ 63%]
tests/models/test_setting.py::TestSettingModel::test_setting_from_dict_valid_and_extra_fields PASSED [ 63%]
tests/models/test_setting.py::TestSettingModel::test_setting_to_dict PASSED [ 64%]
tests/models/test_setting.py::TestSettingModel::test_setting_field_type_and_value_errors[setting_id-123-Input should be a valid string] PASSED [ 64%]
tests/models/test_setting.py::TestSettingModel::test_setting_field_type_and_value_errors[setting_id-not-a-uuid-setting_id must be a valid UUID string] PASSED [ 64%]
tests/models/test_setting.py::TestSettingModel::test_setting_field_type_and_value_errors[setting_type_id-None-Input should be a valid string] PASSED [ 64%]
tests/models/test_setting.py::TestSettingModel::test_setting_field_type_and_value_errors[setting_type_id--setting_type_id must be exactly 6 characters] PASSED [ 64%]
tests/models/test_setting.py::TestSettingModel::test_setting_field_type_and_value_errors[setting_type_id-ABC-setting_type_id must be exactly 6 characters] PASSED [ 65%]
tests/models/test_setting.py::TestSettingModel::test_setting_field_type_and_value_errors[related_entity_id-None-Input should be a valid string] PASSED [ 65%]
tests/models/test_setting.py::TestSettingModel::test_setting_field_type_and_value_errors[related_entity_id-not-a-uuid-related_entity_id must be a valid UUID string] PASSED [ 65%]
tests/models/test_setting.py::TestSettingModel::test_setting_field_type_and_value_errors[updated_at-None-Input should be a valid string] PASSED [ 65%]
tests/models/test_setting.py::TestSettingModel::test_setting_field_type_and_value_errors[updated_at-not-iso-format-updated_at must be a valid ISO datetime string] PASSED [ 65%]
tests/models/test_setting_manager.py::TestSettingManager::test_create_setting_valid PASSED [ 66%]
tests/models/test_setting_manager.py::TestSettingManager::test_create_setting_invalid_format[-must be exactly 6 characters] PASSED [ 66%]
tests/models/test_setting_manager.py::TestSettingManager::test_create_setting_invalid_format[ABC-must be exactly 6 characters] PASSED [ 66%]
tests/models/test_setting_manager.py::TestSettingManager::test_create_setting_invalid_format[ABCDEFG-must be exactly 6 characters] PASSED [ 66%]
tests/models/test_setting_manager.py::TestSettingManager::test_create_setting_invalid_format[ABCD\u20ac\u03a9-must be ASCII-only] PASSED [ 66%]
tests/models/test_setting_manager.py::TestSettingManager::test_update_existing_setting_with_new_value PASSED [ 67%]
tests/models/test_setting_manager.py::TestSettingManager::test_get_setting_by_type_and_entity PASSED [ 67%]
tests/models/test_setting_manager.py::TestSettingManager::test_get_setting_with_default PASSED [ 67%]
tests/models/test_setting_manager.py::TestSettingManager::test_get_setting_not_found PASSED [ 67%]
tests/models/test_setting_manager.py::TestSettingManager::test_list_settings_empty PASSED [ 67%]
tests/models/test_setting_manager.py::TestSettingManager::test_list_settings_populated PASSED [ 68%]
tests/models/test_setting_manager.py::TestSettingManager::test_update_setting_value PASSED [ 68%]
tests/models/test_setting_manager.py::TestSettingManager::test_history_tracking_on_create PASSED [ 68%]
tests/models/test_setting_manager.py::TestSettingManager::test_history_tracking_on_update PASSED [ 68%]
tests/models/test_setting_manager.py::TestSettingManager::test_history_tracking_on_delete PASSED [ 68%]
tests/models/test_setting_manager.py::TestSettingManager::test_delete_setting PASSED [ 69%]
tests/models/test_setting_manager.py::TestSettingManager::test_delete_nonexistent_setting PASSED [ 69%]
tests/models/test_setting_manager.py::TestSettingManager::test_delete_all_settings PASSED [ 69%]
tests/models/test_setting_manager.py::TestSettingManager::test_history_for_bulk_delete PASSED [ 69%]
tests/models/test_simple.py::test_simple PASSED                          [ 69%]
tests/models/test_snippet.py::test_snippet_model_validation_valid PASSED [ 69%]
tests/models/test_snippet.py::test_snippet_model_validation_invalid_name_empty PASSED [ 70%]
tests/models/test_snippet.py::test_snippet_model_validation_invalid_name_non_ascii PASSED [ 70%]
tests/models/test_snippet.py::test_snippet_ascii_name ERROR              [ 70%]
tests/models/test_snippet.py::test_snippet_model_validation_invalid_name_too_long PASSED [ 70%]
tests/models/test_snippet.py::test_snippet_name_length ERROR             [ 70%]
tests/models/test_snippet.py::test_snippet_model_validation_invalid_content_empty PASSED [ 71%]
tests/models/test_snippet.py::test_snippet_model_validation_invalid_category_id PASSED [ 71%]
tests/models/test_snippet.py::test_snippet_creation_validation[Alpha-Some content-True] ERROR [ 71%]
tests/models/test_snippet.py::test_snippet_creation_validation[-Some content-False] ERROR [ 71%]
tests/models/test_snippet.py::test_snippet_creation_validation[AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA-Content-False] ERROR [ 71%]
tests/models/test_snippet.py::test_snippet_creation_validation[NonAscii\xe9-Content-False] ERROR [ 72%]
tests/models/test_snippet.py::test_snippet_creation_validation[Alpha--False] ERROR [ 72%]
tests/models/test_snippet.py::test_snippet_name_uniqueness[Unique1-Unique2-True] ERROR [ 72%]
tests/models/test_snippet.py::test_snippet_name_uniqueness[DupName-DupName-False] ERROR [ 72%]
tests/models/test_snippet.py::test_snippet_creation_valid ERROR          [ 72%]
tests/models/test_snippet.py::test_get_nonexistent_snippet ERROR         [ 73%]
tests/models/test_snippet.py::test_list_snippets_empty ERROR             [ 73%]
tests/models/test_snippet.py::test_list_snippets_populated ERROR         [ 73%]
tests/models/test_snippet.py::test_snippet_edit ERROR                    [ 73%]
tests/models/test_snippet.py::test_snippet_update ERROR                  [ 73%]
tests/models/test_snippet.py::test_snippet_update_name_only ERROR        [ 74%]
tests/models/test_snippet.py::test_snippet_update_content_only ERROR     [ 74%]
tests/models/test_snippet.py::test_snippet_delete ERROR                  [ 74%]
tests/models/test_snippet.py::test_delete_nonexistent_snippet ERROR      [ 74%]
tests/models/test_snippet.py::test_edit_snippet_change_category ERROR    [ 74%]
tests/models/test_snippet.py::test_edit_snippet_invalid_category ERROR   [ 75%]
tests/models/test_snippet.py::test_snippet_sql_injection ERROR           [ 75%]
tests/models/test_snippet.py::test_snippet_sql_injection_in_content ERROR [ 75%]
tests/models/test_snippet.py::test_snippet_long_content ERROR            [ 75%]
tests/models/test_snippet.py::test_snippet_content_splitting_boundaries ERROR [ 75%]
tests/models/test_snippet.py::test_update_nonexistent_snippet ERROR      [ 76%]
tests/models/test_snippet.py::test_snippet_part_number_sequence ERROR    [ 76%]
tests/models/test_snippet.py::test_python_code_validation PASSED         [ 76%]
tests/models/test_snippet.py::test_snippet_operation_handling ERROR      [ 76%]
tests/models/test_snippet.py::test_delete_snippet ERROR                  [ 76%]
tests/models/test_snippet.py::test_create_snippet_with_nonexistent_category ERROR [ 76%]
tests/models/test_snippet.py::test_update_snippet_partial ERROR          [ 77%]
tests/models/test_snippet.py::test_update_snippet_no_changes ERROR       [ 77%]
tests/models/test_snippet.py::test_get_snippet_by_name ERROR             [ 77%]
tests/models/test_snippet.py::test_get_snippet_by_name_nonexistent ERROR [ 77%]
tests/models/test_snippet.py::test_get_snippet_by_name_multiple_categories ERROR [ 77%]
tests/models/test_snippet.py::test_search_snippets ERROR                 [ 78%]
tests/models/test_snippet.py::test_search_snippets_no_results ERROR      [ 78%]
tests/models/test_snippet.py::test_snippet_sql_injection_name_create ERROR [ 78%]
tests/models/test_snippet.py::test_snippet_sql_injection_content_create ERROR [ 78%]
tests/models/test_snippet.py::test_snippet_sql_injection_name_create_with_specific_error ERROR [ 78%]
tests/models/test_snippet.py::test_snippet_sql_injection_content_update ERROR [ 79%]
tests/models/test_snippet.py::test_snippet_sql_injection_name_update ERROR [ 79%]
tests/models/test_snippet.py::test_snippet_deletion_idempotency ERROR    [ 79%]
tests/models/test_snippet.py::test_snippet_manager_handles_db_errors_gracefully_on_create ERROR [ 79%]
tests/models/test_snippet.py::test_snippet_manager_handles_db_errors_gracefully_on_get ERROR [ 79%]
tests/models/test_snippet.py::test_snippet_manager_handles_db_errors_gracefully_on_update ERROR [ 80%]
tests/models/test_snippet.py::test_snippet_manager_handles_db_errors_gracefully_on_delete ERROR [ 80%]
tests/models/test_snippet.py::test_snippet_manager_handles_db_errors_gracefully_on_list ERROR [ 80%]
tests/models/test_snippet.py::test_snippet_manager_handles_db_errors_gracefully_on_search ERROR [ 80%]
tests/models/test_snippet.py::test_create_snippet_pydantic_validation_errors ERROR [ 80%]
tests/models/test_snippet_manager.py::TestCreateSnippet::test_create_snippet_happy_path PASSED [ 81%]
tests/models/test_snippet_manager.py::TestCreateSnippet::test_create_snippet_content_splitting PASSED [ 81%]
tests/models/test_snippet_manager.py::TestCreateSnippet::test_create_snippet_duplicate_name_in_category PASSED [ 81%]
tests/models/test_snippet_manager.py::TestCreateSnippet::test_create_snippet_duplicate_name_different_category PASSED [ 81%]
tests/models/test_snippet_manager.py::TestCreateSnippet::test_create_snippet_invalid_category_id_foreign_key PASSED [ 81%]
tests/models/test_snippet_manager.py::TestCreateSnippet::test_create_snippet_pydantic_validation_errors[-Valid Content-ValueError] PASSED [ 82%]
tests/models/test_snippet_manager.py::TestCreateSnippet::test_create_snippet_pydantic_validation_errors[ -Valid Content-ValueError] PASSED [ 82%]
tests/models/test_snippet_manager.py::TestCreateSnippet::test_create_snippet_pydantic_validation_errors[NNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN-Valid Content-ValueError] PASSED [ 82%]
tests/models/test_snippet_manager.py::TestCreateSnippet::test_create_snippet_pydantic_validation_errors[Invalid\xd1ame-Valid Content-ValueError] PASSED [ 82%]
tests/models/test_snippet_manager.py::TestCreateSnippet::test_create_snippet_pydantic_validation_errors[ValidName--ValueError] PASSED [ 82%]
tests/models/test_snippet_manager.py::TestCreateSnippet::test_create_snippet_pydantic_validation_errors[ValidName- -ValueError] PASSED [ 83%]
tests/models/test_snippet_manager.py::TestCreateSnippet::test_create_snippet_pydantic_validation_errors[ValidName-Invalid\xc7ontent-ValueError] PASSED [ 83%]
tests/models/test_snippet_manager.py::TestCreateSnippet::test_create_snippet_pydantic_validation_errors[DROP TABLE Users;-Content-ValueError] PASSED [ 83%]
tests/models/test_snippet_manager.py::TestCreateSnippet::test_create_snippet_pydantic_validation_errors[ValidName-SELECT * FROM Users; -- comment-ValueError] PASSED [ 83%]
tests/models/test_snippet_manager.py::TestCreateSnippet::test_create_snippet_internal_empty_content_check_unreachable_with_valid_pydantic_input PASSED [ 83%]
tests/models/test_snippet_manager.py::TestGetStartingIndex::test_get_starting_index_no_sessions PASSED [ 84%]
tests/models/test_snippet_manager.py::TestGetStartingIndex::test_get_starting_index_with_sessions PASSED [ 84%]
tests/models/test_snippet_manager.py::TestGetStartingIndex::test_get_starting_index_wraps_to_zero PASSED [ 84%]
tests/models/test_snippet_manager.py::TestGetStartingIndex::test_get_starting_index_greater_than_length PASSED [ 84%]
tests/models/test_snippet_manager.py::TestGetStartingIndex::test_get_starting_index_different_user_keyboard PASSED [ 84%]
tests/models/test_user.py::TestUserModel::test_create_user_with_minimal_fields PASSED [ 84%]
tests/models/test_user.py::TestUserModel::test_create_user_with_existing_id PASSED [ 85%]
tests/models/test_user.py::TestUserModel::test_valid_email_formats[test@example.com] PASSED [ 85%]
tests/models/test_user.py::TestUserModel::test_valid_email_formats[test.user@example.com] PASSED [ 85%]
tests/models/test_user.py::TestUserModel::test_valid_email_formats[test+user@example.com] PASSED [ 85%]
tests/models/test_user.py::TestUserModel::test_valid_email_formats[test.user+tag@example.co.uk] PASSED [ 85%]
tests/models/test_user.py::TestUserModel::test_valid_email_formats[test@subdomain.example.com] PASSED [ 86%]
tests/models/test_user.py::TestUserModel::test_valid_email_formats[test@123.123.123.123] PASSED [ 86%]
tests/models/test_user.py::TestUserModel::test_valid_email_formats[test@[123.123.123.123]] PASSED [ 86%]
tests/models/test_user.py::TestUserModel::test_invalid_email_formats[plainaddress] PASSED [ 86%]
tests/models/test_user.py::TestUserModel::test_invalid_email_formats[@missingusername.com] PASSED [ 86%]
tests/models/test_user.py::TestUserModel::test_invalid_email_formats[username@.com] PASSED [ 87%]
tests/models/test_user.py::TestUserModel::test_invalid_email_formats[.username@example.com] PASSED [ 87%]
tests/models/test_user.py::TestUserModel::test_invalid_email_formats[username@example..com] PASSED [ 87%]
tests/models/test_user.py::TestUserModel::test_invalid_email_formats[username@example.com.] PASSED [ 87%]
tests/models/test_user.py::TestUserModel::test_invalid_email_formats[username@.example.com] PASSED [ 87%]
tests/models/test_user.py::TestUserModel::test_invalid_email_formats[username@-example.com] PASSED [ 88%]
tests/models/test_user.py::TestUserModel::test_invalid_email_formats[username@example-.com] PASSED [ 88%]
tests/models/test_user.py::TestUserModel::test_invalid_email_formats[username@example.com-] PASSED [ 88%]
tests/models/test_user.py::TestUserModel::test_invalid_email_formats[username@example.c] PASSED [ 88%]
tests/models/test_user.py::TestUserModel::test_invalid_email_formats[username@example.com.1a] PASSED [ 88%]
tests/models/test_user.py::TestUserModel::test_invalid_email_formats[username@example.com.a] PASSED [ 89%]
tests/models/test_user.py::TestUserModel::test_invalid_email_formats[username@example.com.1] PASSED [ 89%]
tests/models/test_user.py::TestUserModel::test_invalid_email_formats[username@example.com.a1-] PASSED [ 89%]
tests/models/test_user.py::TestUserModel::test_invalid_email_formats[username@example.com.-a] PASSED [ 89%]
tests/models/test_user.py::TestUserModel::test_valid_name_formats[John] PASSED [ 89%]
tests/models/test_user.py::TestUserModel::test_valid_name_formats[Mary-Jane] PASSED [ 90%]
tests/models/test_user.py::TestUserModel::test_valid_name_formats[O'Reilly] PASSED [ 90%]
tests/models/test_user.py::TestUserModel::test_valid_name_formats[De La Cruz] PASSED [ 90%]
tests/models/test_user.py::TestUserModel::test_valid_name_formats[X] PASSED [ 90%]
tests/models/test_user.py::TestUserModel::test_valid_name_formats[AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA] PASSED [ 90%]
tests/models/test_user.py::TestUserModel::test_invalid_name_formats[] PASSED [ 91%]
tests/models/test_user.py::TestUserModel::test_invalid_name_formats[ ] PASSED [ 91%]
tests/models/test_user.py::TestUserModel::test_invalid_name_formats[\t] PASSED [ 91%]
tests/models/test_user.py::TestUserModel::test_invalid_name_formats[\n] PASSED [ 91%]
tests/models/test_user.py::TestUserModel::test_invalid_name_formats[AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA] PASSED [ 91%]
tests/models/test_user.py::TestUserModel::test_invalid_name_formats[John@Doe] PASSED [ 92%]
tests/models/test_user.py::TestUserModel::test_invalid_name_formats[John\nDoe] PASSED [ 92%]
tests/models/test_user.py::TestUserModel::test_invalid_name_formats[John\tDoe] PASSED [ 92%]
tests/models/test_user.py::TestUserModel::test_invalid_name_formats[John\rDoe] PASSED [ 92%]
tests/models/test_user.py::TestUserModel::test_invalid_name_formats[John\x0cDoe] PASSED [ 92%]
tests/models/test_user.py::TestUserModel::test_invalid_name_formats[John\x0bDoe] PASSED [ 92%]
tests/models/test_user.py::TestUserModel::test_whitespace_stripping PASSED [ 93%]
tests/models/test_user.py::TestUserModel::test_case_insensitive_email PASSED [ 93%]
tests/models/test_user.py::TestUserModel::test_to_dict PASSED            [ 93%]
tests/models/test_user.py::TestUserModel::test_from_dict PASSED          [ 93%]
tests/models/test_user.py::TestUserModel::test_from_dict_with_extra_fields PASSED [ 93%]
tests/models/test_user.py::TestUserModel::test_validate_user_id_empty PASSED [ 94%]
tests/models/test_user.py::TestUserModel::test_validate_user_id_invalid PASSED [ 94%]
tests/models/test_user.py::TestUserModel::test_ip_address_domain_variants PASSED [ 94%]
tests/models/test_user.py::TestUserModel::test_special_domain_validation PASSED [ 94%]
tests/models/test_user.py::TestUserModel::test_domain_edge_cases PASSED  [ 94%]
tests/models/test_user_manager.py::TestUserManager::test_create_and_retrieve_user PASSED [ 95%]
tests/models/test_user_manager.py::TestUserManager::test_update_user PASSED [ 95%]
tests/models/test_user_manager.py::TestUserManager::test_delete_user PASSED [ 95%]
tests/models/test_user_manager.py::TestUserManager::test_list_all_users PASSED [ 95%]
tests/models/test_user_manager.py::TestUserManager::test_email_uniqueness PASSED [ 95%]
tests/models/test_user_manager.py::TestUserManager::test_update_user_with_same_email PASSED [ 96%]
tests/models/test_user_manager.py::TestUserManager::test_nonexistent_user_retrieval PASSED [ 96%]
tests/models/test_user_manager.py::TestUserManager::test_case_insensitive_email_retrieval PASSED [ 96%]
tests/models/test_user_manager.py::TestUserManager::test_empty_database_operations PASSED [ 96%]
tests/models/test_user_manager_fixes.py::TestUserManagerDatabaseAccessFixes::test_list_all_users_with_results PASSED [ 96%]
tests/models/test_user_manager_fixes.py::TestUserManagerDatabaseAccessFixes::test_list_all_users_empty_database PASSED [ 97%]
tests/models/test_user_manager_fixes.py::TestUserManagerDatabaseAccessFixes::test_get_user_by_id_found PASSED [ 97%]
tests/models/test_user_manager_fixes.py::TestUserManagerDatabaseAccessFixes::test_get_user_by_id_not_found PASSED [ 97%]
tests/models/test_user_manager_fixes.py::TestUserManagerDatabaseAccessFixes::test_get_user_by_email_found PASSED [ 97%]
tests/models/test_user_manager_fixes.py::TestUserManagerDatabaseAccessFixes::test_get_user_by_email_not_found PASSED [ 97%]
tests/models/test_user_manager_fixes.py::TestUserManagerDatabaseAccessFixes::test_user_exists_true PASSED [ 98%]
tests/models/test_user_manager_fixes.py::TestUserManagerDatabaseAccessFixes::test_user_exists_false PASSED [ 98%]
tests/models/test_user_manager_fixes.py::TestUserManagerDatabaseAccessFixes::test_delete_user_by_id_exists PASSED [ 98%]
tests/models/test_user_manager_fixes.py::TestUserManagerDatabaseAccessFixes::test_delete_user_by_id_not_exists PASSED [ 98%]
tests/models/test_user_manager_fixes.py::TestUserManagerDatabaseAccessFixes::test_delete_all_users_with_users_dict_result PASSED [ 98%]
tests/models/test_user_manager_fixes.py::TestUserManagerDatabaseAccessFixes::test_delete_all_users_with_users_non_dict_result PASSED [ 99%]
tests/models/test_user_manager_fixes.py::TestUserManagerDatabaseAccessFixes::test_delete_all_users_no_users_dict_result PASSED [ 99%]
tests/models/test_user_manager_fixes.py::TestUserManagerDatabaseAccessFixes::test_delete_all_users_no_users_empty_result PASSED [ 99%]
tests/models/test_user_manager_fixes.py::TestUserManagerDatabaseAccessFixes::test_validate_email_uniqueness_unique PASSED [ 99%]
tests/models/test_user_manager_fixes.py::TestUserManagerDatabaseAccessFixes::test_validate_email_uniqueness_duplicate PASSED [ 99%]
tests/models/test_user_manager_fixes.py::TestUserManagerDatabaseAccessFixes::test_validate_email_uniqueness_update_same_user PASSED [100%]

=================================== ERRORS ====================================
_ ERROR at setup of TestNGramAnalyticsService.test_refresh_speed_summaries_basic _

self = <db.database_manager.DatabaseManager object at 0x0000021B35183070>
query = 'INSERT INTO snippets (snippet_id, category_id, title, content, difficulty_level) VALUES (?, ?, ?, ?, ?)'
params = ('snippet_1', 'cat_1', 'Snippet', 'content', 1)

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table snippets has no column named title

db\database_manager.py:524: OperationalError

The above exception was the direct cause of the following exception:

item = <Function test_refresh_speed_summaries_basic>

    @pytest.hookimpl(wrapper=True, tryfirst=True)
    def pytest_runtest_setup(item):
        """
        Hook called after before test setup starts, to start capturing exceptions
        as early as possible.
        """
        capture_enabled = _is_exception_capture_enabled(item)
        if capture_enabled:
            item.qt_exception_capture_manager = _QtExceptionCaptureManager()
            item.qt_exception_capture_manager.start()
>       result = yield
                 ^^^^^

.venv\Lib\site-packages\pytestqt\plugin.py:178: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:321: in ngram_speed_test_data
    db_with_tables.execute(
db\database_manager.py:539: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x0000021B35183070>
e = OperationalError('table snippets has no column named title')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table snippets has no column named title

db\database_manager.py:449: DatabaseError
---------------------------- Captured stdout setup ----------------------------
Exception during query: table snippets has no column named title. Rolling back transaction.
---------------------------- Captured stderr setup ----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 524, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table snippets has no column named title
_ ERROR at setup of TestSummarizeSessionNgrams.test_summarize_with_ngram_speed_only[1-1] _

self = <db.database_manager.DatabaseManager object at 0x0000021B351171C0>
query = '\n            INSERT INTO categories (category_id, category_name, description)\n            VALUES (?, ?, ?)\n            '
params = ('2ac75a1d-f8a2-48e1-9e9f-038b4e0e012d', 'Test Category', 'Test category for testing')

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table categories has no column named description

db\database_manager.py:524: OperationalError

The above exception was the direct cause of the following exception:

db_with_tables = <db.database_manager.DatabaseManager object at 0x0000021B351171C0>
test_user = User(user_id='3307debe-ebbe-4ce5-a9fa-b73bb7670a6a', first_name='Test', surname='User', email_address='test.user.0baf2a90-acad-4fb2-b3df-38aa02378ffc@example.com')
test_keyboard = Keyboard(keyboard_id='9613eb43-6e55-4f54-9ecc-d0825e5203e1', user_id='3307debe-ebbe-4ce5-a9fa-b73bb7670a6a', keyboard_name='Test Keyboard', target_ms_per_keystroke=600)

    @pytest.fixture
    def test_data_setup(db_with_tables: DatabaseManager, test_user: User, test_keyboard: Keyboard) -> Dict[str, Any]:
        """Set up comprehensive test data for session analytics tests."""
        db = db_with_tables
    
        # Create category and snippet
>       category_id = TestSessionMethodsFixtures.create_category(db)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_ngram_analytics_service_session_methods.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:239: in create_category
    db.execute(
db\database_manager.py:539: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x0000021B351171C0>
e = OperationalError('table categories has no column named description')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table categories has no column named description

db\database_manager.py:449: DatabaseError
---------------------------- Captured stdout setup ----------------------------
Exception during query: table categories has no column named description. Rolling back transaction.
---------------------------- Captured stderr setup ----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 524, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table categories has no column named description
_ ERROR at setup of TestSummarizeSessionNgrams.test_summarize_with_ngram_speed_only[3-3] _

self = <db.database_manager.DatabaseManager object at 0x0000021B35AF19B0>
query = '\n            INSERT INTO categories (category_id, category_name, description)\n            VALUES (?, ?, ?)\n            '
params = ('89a73922-2fc5-43c4-8b24-a4fcc6a66a50', 'Test Category', 'Test category for testing')

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table categories has no column named description

db\database_manager.py:524: OperationalError

The above exception was the direct cause of the following exception:

db_with_tables = <db.database_manager.DatabaseManager object at 0x0000021B35AF19B0>
test_user = User(user_id='29eeb219-b88e-4e1a-a1db-3b52a4355fac', first_name='Test', surname='User', email_address='test.user.6ecb4f47-fada-42ef-ad81-e6d1e5e17471@example.com')
test_keyboard = Keyboard(keyboard_id='2359f11c-7bc7-409d-bcbf-0088d62b7723', user_id='29eeb219-b88e-4e1a-a1db-3b52a4355fac', keyboard_name='Test Keyboard', target_ms_per_keystroke=600)

    @pytest.fixture
    def test_data_setup(db_with_tables: DatabaseManager, test_user: User, test_keyboard: Keyboard) -> Dict[str, Any]:
        """Set up comprehensive test data for session analytics tests."""
        db = db_with_tables
    
        # Create category and snippet
>       category_id = TestSessionMethodsFixtures.create_category(db)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_ngram_analytics_service_session_methods.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:239: in create_category
    db.execute(
db\database_manager.py:539: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x0000021B35AF19B0>
e = OperationalError('table categories has no column named description')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table categories has no column named description

db\database_manager.py:449: DatabaseError
---------------------------- Captured stdout setup ----------------------------
Exception during query: table categories has no column named description. Rolling back transaction.
---------------------------- Captured stderr setup ----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 524, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table categories has no column named description
_ ERROR at setup of TestSummarizeSessionNgrams.test_summarize_with_ngram_errors_only[1-1] _

self = <db.database_manager.DatabaseManager object at 0x0000021B35AF1A90>
query = '\n            INSERT INTO categories (category_id, category_name, description)\n            VALUES (?, ?, ?)\n            '
params = ('5d538443-de69-4f7a-a0d7-ccc4b3a19fd9', 'Test Category', 'Test category for testing')

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table categories has no column named description

db\database_manager.py:524: OperationalError

The above exception was the direct cause of the following exception:

db_with_tables = <db.database_manager.DatabaseManager object at 0x0000021B35AF1A90>
test_user = User(user_id='58bebca8-05e1-4e4d-be55-4c0e23793689', first_name='Test', surname='User', email_address='test.user.db227a98-1a16-4535-bf7a-e11f55857af2@example.com')
test_keyboard = Keyboard(keyboard_id='fd115d78-19d2-4686-a250-7d9b7f96c833', user_id='58bebca8-05e1-4e4d-be55-4c0e23793689', keyboard_name='Test Keyboard', target_ms_per_keystroke=600)

    @pytest.fixture
    def test_data_setup(db_with_tables: DatabaseManager, test_user: User, test_keyboard: Keyboard) -> Dict[str, Any]:
        """Set up comprehensive test data for session analytics tests."""
        db = db_with_tables
    
        # Create category and snippet
>       category_id = TestSessionMethodsFixtures.create_category(db)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_ngram_analytics_service_session_methods.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:239: in create_category
    db.execute(
db\database_manager.py:539: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x0000021B35AF1A90>
e = OperationalError('table categories has no column named description')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table categories has no column named description

db\database_manager.py:449: DatabaseError
---------------------------- Captured stdout setup ----------------------------
Exception during query: table categories has no column named description. Rolling back transaction.
---------------------------- Captured stderr setup ----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 524, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table categories has no column named description
_ ERROR at setup of TestSummarizeSessionNgrams.test_summarize_with_ngram_errors_only[2-2] _

self = <db.database_manager.DatabaseManager object at 0x0000021B35AF1F60>
query = '\n            INSERT INTO categories (category_id, category_name, description)\n            VALUES (?, ?, ?)\n            '
params = ('49f00ce4-5b8c-4020-9279-9686a8e34072', 'Test Category', 'Test category for testing')

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table categories has no column named description

db\database_manager.py:524: OperationalError

The above exception was the direct cause of the following exception:

db_with_tables = <db.database_manager.DatabaseManager object at 0x0000021B35AF1F60>
test_user = User(user_id='fc6517c4-3115-46b2-b58c-b2e15819294a', first_name='Test', surname='User', email_address='test.user.502572a8-9590-44f2-bf81-f8d7d943f8e6@example.com')
test_keyboard = Keyboard(keyboard_id='ff44d948-eb03-4795-ad60-0693c8aeabd2', user_id='fc6517c4-3115-46b2-b58c-b2e15819294a', keyboard_name='Test Keyboard', target_ms_per_keystroke=600)

    @pytest.fixture
    def test_data_setup(db_with_tables: DatabaseManager, test_user: User, test_keyboard: Keyboard) -> Dict[str, Any]:
        """Set up comprehensive test data for session analytics tests."""
        db = db_with_tables
    
        # Create category and snippet
>       category_id = TestSessionMethodsFixtures.create_category(db)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_ngram_analytics_service_session_methods.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:239: in create_category
    db.execute(
db\database_manager.py:539: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x0000021B35AF1F60>
e = OperationalError('table categories has no column named description')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table categories has no column named description

db\database_manager.py:449: DatabaseError
---------------------------- Captured stdout setup ----------------------------
Exception during query: table categories has no column named description. Rolling back transaction.
---------------------------- Captured stderr setup ----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 524, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table categories has no column named description
_ ERROR at setup of TestSummarizeSessionNgrams.test_summarize_with_speed_and_errors _

self = <db.database_manager.DatabaseManager object at 0x0000021B35182430>
query = '\n            INSERT INTO categories (category_id, category_name, description)\n            VALUES (?, ?, ?)\n            '
params = ('a83a0ea7-01db-43d2-a6c4-1717e853a748', 'Test Category', 'Test category for testing')

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table categories has no column named description

db\database_manager.py:524: OperationalError

The above exception was the direct cause of the following exception:

db_with_tables = <db.database_manager.DatabaseManager object at 0x0000021B35182430>
test_user = User(user_id='e17579b8-3109-41ba-9afc-4d2800f66dfb', first_name='Test', surname='User', email_address='test.user.9ad790ae-cae5-4e59-bfe4-c8f82c2c219e@example.com')
test_keyboard = Keyboard(keyboard_id='d4d68032-5470-44ce-9483-a3b0afd5082b', user_id='e17579b8-3109-41ba-9afc-4d2800f66dfb', keyboard_name='Test Keyboard', target_ms_per_keystroke=600)

    @pytest.fixture
    def test_data_setup(db_with_tables: DatabaseManager, test_user: User, test_keyboard: Keyboard) -> Dict[str, Any]:
        """Set up comprehensive test data for session analytics tests."""
        db = db_with_tables
    
        # Create category and snippet
>       category_id = TestSessionMethodsFixtures.create_category(db)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_ngram_analytics_service_session_methods.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:239: in create_category
    db.execute(
db\database_manager.py:539: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x0000021B35182430>
e = OperationalError('table categories has no column named description')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table categories has no column named description

db\database_manager.py:449: DatabaseError
---------------------------- Captured stdout setup ----------------------------
Exception during query: table categories has no column named description. Rolling back transaction.
---------------------------- Captured stderr setup ----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 524, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table categories has no column named description
_ ERROR at setup of TestSummarizeSessionNgrams.test_summarize_with_keystrokes[1-1] _

self = <db.database_manager.DatabaseManager object at 0x0000021B35AF1240>
query = '\n            INSERT INTO categories (category_id, category_name, description)\n            VALUES (?, ?, ?)\n            '
params = ('ad0dff1f-ad21-4761-b711-c295e69398b5', 'Test Category', 'Test category for testing')

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table categories has no column named description

db\database_manager.py:524: OperationalError

The above exception was the direct cause of the following exception:

db_with_tables = <db.database_manager.DatabaseManager object at 0x0000021B35AF1240>
test_user = User(user_id='bcbdb793-045a-477b-ae88-68807f79229a', first_name='Test', surname='User', email_address='test.user.ca91aedc-2ebc-45e6-abf9-f0bbcdee5ffb@example.com')
test_keyboard = Keyboard(keyboard_id='c12d90b0-d69f-4ed8-a1dd-e75a6ecf37af', user_id='bcbdb793-045a-477b-ae88-68807f79229a', keyboard_name='Test Keyboard', target_ms_per_keystroke=600)

    @pytest.fixture
    def test_data_setup(db_with_tables: DatabaseManager, test_user: User, test_keyboard: Keyboard) -> Dict[str, Any]:
        """Set up comprehensive test data for session analytics tests."""
        db = db_with_tables
    
        # Create category and snippet
>       category_id = TestSessionMethodsFixtures.create_category(db)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_ngram_analytics_service_session_methods.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:239: in create_category
    db.execute(
db\database_manager.py:539: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x0000021B35AF1240>
e = OperationalError('table categories has no column named description')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table categories has no column named description

db\database_manager.py:449: DatabaseError
---------------------------- Captured stdout setup ----------------------------
Exception during query: table categories has no column named description. Rolling back transaction.
---------------------------- Captured stderr setup ----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 524, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table categories has no column named description
_ ERROR at setup of TestSummarizeSessionNgrams.test_summarize_with_keystrokes[3-3] _

self = <db.database_manager.DatabaseManager object at 0x0000021B35AF0FA0>
query = '\n            INSERT INTO categories (category_id, category_name, description)\n            VALUES (?, ?, ?)\n            '
params = ('84dcc2be-a8ea-459a-9d9b-aa26f539f25b', 'Test Category', 'Test category for testing')

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table categories has no column named description

db\database_manager.py:524: OperationalError

The above exception was the direct cause of the following exception:

db_with_tables = <db.database_manager.DatabaseManager object at 0x0000021B35AF0FA0>
test_user = User(user_id='41d630fe-28d2-49ec-a623-004496f661c8', first_name='Test', surname='User', email_address='test.user.f5bb1a10-c04d-454d-93c1-af08b5db052d@example.com')
test_keyboard = Keyboard(keyboard_id='b1dfc9c0-d285-4b73-9907-87d5981a88a1', user_id='41d630fe-28d2-49ec-a623-004496f661c8', keyboard_name='Test Keyboard', target_ms_per_keystroke=600)

    @pytest.fixture
    def test_data_setup(db_with_tables: DatabaseManager, test_user: User, test_keyboard: Keyboard) -> Dict[str, Any]:
        """Set up comprehensive test data for session analytics tests."""
        db = db_with_tables
    
        # Create category and snippet
>       category_id = TestSessionMethodsFixtures.create_category(db)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_ngram_analytics_service_session_methods.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:239: in create_category
    db.execute(
db\database_manager.py:539: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x0000021B35AF0FA0>
e = OperationalError('table categories has no column named description')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table categories has no column named description

db\database_manager.py:449: DatabaseError
---------------------------- Captured stdout setup ----------------------------
Exception during query: table categories has no column named description. Rolling back transaction.
---------------------------- Captured stderr setup ----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 524, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table categories has no column named description
____ ERROR at setup of TestSummarizeSessionNgrams.test_no_sessions_missing ____

self = <db.database_manager.DatabaseManager object at 0x0000021B35ADD2B0>
query = '\n            INSERT INTO categories (category_id, category_name, description)\n            VALUES (?, ?, ?)\n            '
params = ('ec5c9213-a1dd-47d9-bb88-00baebe842f3', 'Test Category', 'Test category for testing')

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table categories has no column named description

db\database_manager.py:524: OperationalError

The above exception was the direct cause of the following exception:

db_with_tables = <db.database_manager.DatabaseManager object at 0x0000021B35ADD2B0>
test_user = User(user_id='79e64ead-1123-4bbc-8c2b-bcc18101db09', first_name='Test', surname='User', email_address='test.user.24838516-26fa-435d-8bd5-e5abf2222f54@example.com')
test_keyboard = Keyboard(keyboard_id='0b6e7341-ef92-40a5-9de8-26e87e3b5e1e', user_id='79e64ead-1123-4bbc-8c2b-bcc18101db09', keyboard_name='Test Keyboard', target_ms_per_keystroke=600)

    @pytest.fixture
    def test_data_setup(db_with_tables: DatabaseManager, test_user: User, test_keyboard: Keyboard) -> Dict[str, Any]:
        """Set up comprehensive test data for session analytics tests."""
        db = db_with_tables
    
        # Create category and snippet
>       category_id = TestSessionMethodsFixtures.create_category(db)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_ngram_analytics_service_session_methods.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:239: in create_category
    db.execute(
db\database_manager.py:539: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x0000021B35ADD2B0>
e = OperationalError('table categories has no column named description')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table categories has no column named description

db\database_manager.py:449: DatabaseError
---------------------------- Captured stdout setup ----------------------------
Exception during query: table categories has no column named description. Rolling back transaction.
---------------------------- Captured stderr setup ----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 524, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table categories has no column named description
_ ERROR at setup of TestSummarizeSessionNgrams.test_sessions_missing_no_data __

self = <db.database_manager.DatabaseManager object at 0x0000021B35ADD390>
query = '\n            INSERT INTO categories (category_id, category_name, description)\n            VALUES (?, ?, ?)\n            '
params = ('bc18546c-8508-46e1-be8b-15d88ef4c5f1', 'Test Category', 'Test category for testing')

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table categories has no column named description

db\database_manager.py:524: OperationalError

The above exception was the direct cause of the following exception:

db_with_tables = <db.database_manager.DatabaseManager object at 0x0000021B35ADD390>
test_user = User(user_id='7d6a996b-5a18-4b25-bb7b-aea1a41ef56a', first_name='Test', surname='User', email_address='test.user.a93c0c16-acec-4a9f-8926-3772ab78d4e3@example.com')
test_keyboard = Keyboard(keyboard_id='cb9cfab2-58cf-4adf-ba3b-185870e47cf6', user_id='7d6a996b-5a18-4b25-bb7b-aea1a41ef56a', keyboard_name='Test Keyboard', target_ms_per_keystroke=600)

    @pytest.fixture
    def test_data_setup(db_with_tables: DatabaseManager, test_user: User, test_keyboard: Keyboard) -> Dict[str, Any]:
        """Set up comprehensive test data for session analytics tests."""
        db = db_with_tables
    
        # Create category and snippet
>       category_id = TestSessionMethodsFixtures.create_category(db)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_ngram_analytics_service_session_methods.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:239: in create_category
    db.execute(
db\database_manager.py:539: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x0000021B35ADD390>
e = OperationalError('table categories has no column named description')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table categories has no column named description

db\database_manager.py:449: DatabaseError
---------------------------- Captured stdout setup ----------------------------
Exception during query: table categories has no column named description. Rolling back transaction.
---------------------------- Captured stderr setup ----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 524, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table categories has no column named description
_ ERROR at setup of TestAddSpeedSummaryForSession.test_single_session_processing _

self = <db.database_manager.DatabaseManager object at 0x0000021B35ADD780>
query = '\n            INSERT INTO categories (category_id, category_name, description)\n            VALUES (?, ?, ?)\n            '
params = ('d2b7dc26-38f8-4657-98ca-60d442431652', 'Test Category', 'Test category for testing')

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table categories has no column named description

db\database_manager.py:524: OperationalError

The above exception was the direct cause of the following exception:

db_with_tables = <db.database_manager.DatabaseManager object at 0x0000021B35ADD780>
test_user = User(user_id='7bd409ad-4ea5-4807-bc39-fa775e5a2d32', first_name='Test', surname='User', email_address='test.user.8bb43e8b-1dc7-46f7-b2da-645e11d02a47@example.com')
test_keyboard = Keyboard(keyboard_id='296ce94b-7b99-4544-a390-809e70a5dc88', user_id='7bd409ad-4ea5-4807-bc39-fa775e5a2d32', keyboard_name='Test Keyboard', target_ms_per_keystroke=600)

    @pytest.fixture
    def test_data_setup(db_with_tables: DatabaseManager, test_user: User, test_keyboard: Keyboard) -> Dict[str, Any]:
        """Set up comprehensive test data for session analytics tests."""
        db = db_with_tables
    
        # Create category and snippet
>       category_id = TestSessionMethodsFixtures.create_category(db)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_ngram_analytics_service_session_methods.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:239: in create_category
    db.execute(
db\database_manager.py:539: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x0000021B35ADD780>
e = OperationalError('table categories has no column named description')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table categories has no column named description

db\database_manager.py:449: DatabaseError
---------------------------- Captured stdout setup ----------------------------
Exception during query: table categories has no column named description. Rolling back transaction.
---------------------------- Captured stderr setup ----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 524, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table categories has no column named description
_ ERROR at setup of TestAddSpeedSummaryForSession.test_multiple_ngrams_processing _

self = <db.database_manager.DatabaseManager object at 0x0000021B35ADE350>
query = '\n            INSERT INTO categories (category_id, category_name, description)\n            VALUES (?, ?, ?)\n            '
params = ('15cc6c9a-79ca-4619-bd01-cd13df178041', 'Test Category', 'Test category for testing')

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table categories has no column named description

db\database_manager.py:524: OperationalError

The above exception was the direct cause of the following exception:

db_with_tables = <db.database_manager.DatabaseManager object at 0x0000021B35ADE350>
test_user = User(user_id='8aefe07c-7604-45a5-a6ee-0caac1e91955', first_name='Test', surname='User', email_address='test.user.bb11d74b-7142-4ea3-950a-486b26d5196e@example.com')
test_keyboard = Keyboard(keyboard_id='54917493-d999-42d2-824d-959478f02060', user_id='8aefe07c-7604-45a5-a6ee-0caac1e91955', keyboard_name='Test Keyboard', target_ms_per_keystroke=600)

    @pytest.fixture
    def test_data_setup(db_with_tables: DatabaseManager, test_user: User, test_keyboard: Keyboard) -> Dict[str, Any]:
        """Set up comprehensive test data for session analytics tests."""
        db = db_with_tables
    
        # Create category and snippet
>       category_id = TestSessionMethodsFixtures.create_category(db)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_ngram_analytics_service_session_methods.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:239: in create_category
    db.execute(
db\database_manager.py:539: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x0000021B35ADE350>
e = OperationalError('table categories has no column named description')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table categories has no column named description

db\database_manager.py:449: DatabaseError
---------------------------- Captured stdout setup ----------------------------
Exception during query: table categories has no column named description. Rolling back transaction.
---------------------------- Captured stderr setup ----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 524, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table categories has no column named description
____ ERROR at setup of TestCatchupSpeedSummary.test_single_session_catchup ____

self = <db.database_manager.DatabaseManager object at 0x0000021B35ADF850>
query = '\n            INSERT INTO categories (category_id, category_name, description)\n            VALUES (?, ?, ?)\n            '
params = ('8537643d-feda-478a-959e-f95c2e90ddad', 'Test Category', 'Test category for testing')

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table categories has no column named description

db\database_manager.py:524: OperationalError

The above exception was the direct cause of the following exception:

db_with_tables = <db.database_manager.DatabaseManager object at 0x0000021B35ADF850>
test_user = User(user_id='52a052cc-bf75-4021-a811-4cfd107fa93b', first_name='Test', surname='User', email_address='test.user.83ea28b2-5199-4016-a9ef-53f26fe5eca4@example.com')
test_keyboard = Keyboard(keyboard_id='aaa15059-4ec9-4105-bbfd-6c45cfe2a945', user_id='52a052cc-bf75-4021-a811-4cfd107fa93b', keyboard_name='Test Keyboard', target_ms_per_keystroke=600)

    @pytest.fixture
    def test_data_setup(db_with_tables: DatabaseManager, test_user: User, test_keyboard: Keyboard) -> Dict[str, Any]:
        """Set up comprehensive test data for session analytics tests."""
        db = db_with_tables
    
        # Create category and snippet
>       category_id = TestSessionMethodsFixtures.create_category(db)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_ngram_analytics_service_session_methods.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:239: in create_category
    db.execute(
db\database_manager.py:539: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x0000021B35ADF850>
e = OperationalError('table categories has no column named description')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table categories has no column named description

db\database_manager.py:449: DatabaseError
---------------------------- Captured stdout setup ----------------------------
Exception during query: table categories has no column named description. Rolling back transaction.
---------------------------- Captured stderr setup ----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 524, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table categories has no column named description
__ ERROR at setup of TestCatchupSpeedSummary.test_multiple_sessions_catchup ___

self = <db.database_manager.DatabaseManager object at 0x0000021B35ADE430>
query = '\n            INSERT INTO categories (category_id, category_name, description)\n            VALUES (?, ?, ?)\n            '
params = ('91976e49-ee5a-4fa0-b263-a8309062540c', 'Test Category', 'Test category for testing')

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table categories has no column named description

db\database_manager.py:524: OperationalError

The above exception was the direct cause of the following exception:

db_with_tables = <db.database_manager.DatabaseManager object at 0x0000021B35ADE430>
test_user = User(user_id='6d5d8600-add0-4955-85b9-49aeff8eca5f', first_name='Test', surname='User', email_address='test.user.2637edaf-5562-445a-969d-b6a581f5a681@example.com')
test_keyboard = Keyboard(keyboard_id='13111cc0-086c-440a-8780-3dbbe4fdd3e2', user_id='6d5d8600-add0-4955-85b9-49aeff8eca5f', keyboard_name='Test Keyboard', target_ms_per_keystroke=600)

    @pytest.fixture
    def test_data_setup(db_with_tables: DatabaseManager, test_user: User, test_keyboard: Keyboard) -> Dict[str, Any]:
        """Set up comprehensive test data for session analytics tests."""
        db = db_with_tables
    
        # Create category and snippet
>       category_id = TestSessionMethodsFixtures.create_category(db)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_ngram_analytics_service_session_methods.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:239: in create_category
    db.execute(
db\database_manager.py:539: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x0000021B35ADE430>
e = OperationalError('table categories has no column named description')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table categories has no column named description

db\database_manager.py:449: DatabaseError
---------------------------- Captured stdout setup ----------------------------
Exception during query: table categories has no column named description. Rolling back transaction.
---------------------------- Captured stderr setup ----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 524, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table categories has no column named description
_ ERROR at setup of TestCatchupSpeedSummary.test_catchup_with_session_errors __

self = <db.database_manager.DatabaseManager object at 0x0000021B35AF12B0>
query = '\n            INSERT INTO categories (category_id, category_name, description)\n            VALUES (?, ?, ?)\n            '
params = ('670dc0da-8791-4e25-bbed-145fcd1436de', 'Test Category', 'Test category for testing')

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table categories has no column named description

db\database_manager.py:524: OperationalError

The above exception was the direct cause of the following exception:

db_with_tables = <db.database_manager.DatabaseManager object at 0x0000021B35AF12B0>
test_user = User(user_id='6c466a94-33c6-4a6f-bf47-60c4bdb50749', first_name='Test', surname='User', email_address='test.user.39649bef-f174-47d8-8348-087a431e43d6@example.com')
test_keyboard = Keyboard(keyboard_id='3bd08aba-21b4-4712-9930-9937325b6f0d', user_id='6c466a94-33c6-4a6f-bf47-60c4bdb50749', keyboard_name='Test Keyboard', target_ms_per_keystroke=600)

    @pytest.fixture
    def test_data_setup(db_with_tables: DatabaseManager, test_user: User, test_keyboard: Keyboard) -> Dict[str, Any]:
        """Set up comprehensive test data for session analytics tests."""
        db = db_with_tables
    
        # Create category and snippet
>       category_id = TestSessionMethodsFixtures.create_category(db)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_ngram_analytics_service_session_methods.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:239: in create_category
    db.execute(
db\database_manager.py:539: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x0000021B35AF12B0>
e = OperationalError('table categories has no column named description')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table categories has no column named description

db\database_manager.py:449: DatabaseError
---------------------------- Captured stdout setup ----------------------------
Exception during query: table categories has no column named description. Rolling back transaction.
---------------------------- Captured stderr setup ----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 524, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table categories has no column named description
__ ERROR at setup of TestIntegrationScenarios.test_full_workflow_integration __

self = <db.database_manager.DatabaseManager object at 0x0000021B35ADD5C0>
query = '\n            INSERT INTO categories (category_id, category_name, description)\n            VALUES (?, ?, ?)\n            '
params = ('2c5da107-a86f-4ad3-a2ba-3fa1cdb1ae55', 'Test Category', 'Test category for testing')

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table categories has no column named description

db\database_manager.py:524: OperationalError

The above exception was the direct cause of the following exception:

db_with_tables = <db.database_manager.DatabaseManager object at 0x0000021B35ADD5C0>
test_user = User(user_id='4c85b00a-3c5c-49fd-b268-5041cf7c8ea0', first_name='Test', surname='User', email_address='test.user.c88a3a32-ae7d-480c-ab1d-11935f6cba88@example.com')
test_keyboard = Keyboard(keyboard_id='dd2787f4-854a-4e34-b8b7-583c7bb25e52', user_id='4c85b00a-3c5c-49fd-b268-5041cf7c8ea0', keyboard_name='Test Keyboard', target_ms_per_keystroke=600)

    @pytest.fixture
    def test_data_setup(db_with_tables: DatabaseManager, test_user: User, test_keyboard: Keyboard) -> Dict[str, Any]:
        """Set up comprehensive test data for session analytics tests."""
        db = db_with_tables
    
        # Create category and snippet
>       category_id = TestSessionMethodsFixtures.create_category(db)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_ngram_analytics_service_session_methods.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:239: in create_category
    db.execute(
db\database_manager.py:539: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x0000021B35ADD5C0>
e = OperationalError('table categories has no column named description')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table categories has no column named description

db\database_manager.py:449: DatabaseError
---------------------------- Captured stdout setup ----------------------------
Exception during query: table categories has no column named description. Rolling back transaction.
---------------------------- Captured stderr setup ----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 524, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table categories has no column named description
__________________ ERROR at setup of test_snippet_ascii_name __________________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 64
  def test_snippet_ascii_name(valid_snippet_data: Dict[str, str]) -> None:
E       fixture 'valid_snippet_data' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:64
_________________ ERROR at setup of test_snippet_name_length __________________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 86
  def test_snippet_name_length(valid_snippet_data: Dict[str, Union[str, str]]) -> None:
E       fixture 'valid_snippet_data' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:86
_ ERROR at setup of test_snippet_creation_validation[Alpha-Some content-True] _
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 117
  @pytest.mark.parametrize(
      "name,content,expect_success",
      [
          ("Alpha", "Some content", True),
          ("", "Some content", False),  # Validation for name
          ("A" * 129, "Content", False),  # Validation for name length
          ("NonAscii", "Content", False),  # Validation for name ASCII
          ("Alpha", "", False),  # Validation for content
      ],
  )
  def test_snippet_creation_validation(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:117
___ ERROR at setup of test_snippet_creation_validation[-Some content-False] ___
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 117
  @pytest.mark.parametrize(
      "name,content,expect_success",
      [
          ("Alpha", "Some content", True),
          ("", "Some content", False),  # Validation for name
          ("A" * 129, "Content", False),  # Validation for name length
          ("NonAscii", "Content", False),  # Validation for name ASCII
          ("Alpha", "", False),  # Validation for content
      ],
  )
  def test_snippet_creation_validation(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:117
_ ERROR at setup of test_snippet_creation_validation[AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA-Content-False] _
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 117
  @pytest.mark.parametrize(
      "name,content,expect_success",
      [
          ("Alpha", "Some content", True),
          ("", "Some content", False),  # Validation for name
          ("A" * 129, "Content", False),  # Validation for name length
          ("NonAscii", "Content", False),  # Validation for name ASCII
          ("Alpha", "", False),  # Validation for content
      ],
  )
  def test_snippet_creation_validation(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:117
_ ERROR at setup of test_snippet_creation_validation[NonAscii\xe9-Content-False] _
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 117
  @pytest.mark.parametrize(
      "name,content,expect_success",
      [
          ("Alpha", "Some content", True),
          ("", "Some content", False),  # Validation for name
          ("A" * 129, "Content", False),  # Validation for name length
          ("NonAscii", "Content", False),  # Validation for name ASCII
          ("Alpha", "", False),  # Validation for content
      ],
  )
  def test_snippet_creation_validation(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:117
______ ERROR at setup of test_snippet_creation_validation[Alpha--False] _______
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 117
  @pytest.mark.parametrize(
      "name,content,expect_success",
      [
          ("Alpha", "Some content", True),
          ("", "Some content", False),  # Validation for name
          ("A" * 129, "Content", False),  # Validation for name length
          ("NonAscii", "Content", False),  # Validation for name ASCII
          ("Alpha", "", False),  # Validation for content
      ],
  )
  def test_snippet_creation_validation(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:117
____ ERROR at setup of test_snippet_name_uniqueness[Unique1-Unique2-True] _____
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 150
  @pytest.mark.parametrize(
      "name1,name2,should_succeed",
      [
          ("Unique1", "Unique2", True),
          ("DupName", "DupName", False),
      ],
  )
  def test_snippet_name_uniqueness(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:150
____ ERROR at setup of test_snippet_name_uniqueness[DupName-DupName-False] ____
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 150
  @pytest.mark.parametrize(
      "name1,name2,should_succeed",
      [
          ("Unique1", "Unique2", True),
          ("DupName", "DupName", False),
      ],
  )
  def test_snippet_name_uniqueness(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:150
________________ ERROR at setup of test_snippet_creation_valid ________________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 175
  def test_snippet_creation_valid(
E       fixture 'snippet_manager' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:175
_______________ ERROR at setup of test_get_nonexistent_snippet ________________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 193
  def test_get_nonexistent_snippet(snippet_manager: SnippetManager) -> None:
E       fixture 'snippet_manager' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:193
_________________ ERROR at setup of test_list_snippets_empty __________________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 198
  def test_list_snippets_empty(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:198
_______________ ERROR at setup of test_list_snippets_populated ________________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 218
  def test_list_snippets_populated(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:218
_____________________ ERROR at setup of test_snippet_edit _____________________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 241
  def test_snippet_edit(
E       fixture 'snippet_manager' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:241
____________________ ERROR at setup of test_snippet_update ____________________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 260
  def test_snippet_update(snippet_category_fixture: str, snippet_manager: SnippetManager) -> None:
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:260
_______________ ERROR at setup of test_snippet_update_name_only _______________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 274
  def test_snippet_update_name_only(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:274
_____________ ERROR at setup of test_snippet_update_content_only ______________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 291
  def test_snippet_update_content_only(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:291
____________________ ERROR at setup of test_snippet_delete ____________________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 308
  def test_snippet_delete(snippet_category_fixture: str, snippet_manager: SnippetManager) -> None:
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:308
______________ ERROR at setup of test_delete_nonexistent_snippet ______________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 317
  def test_delete_nonexistent_snippet(snippet_manager: SnippetManager) -> None:
E       fixture 'snippet_manager' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:317
_____________ ERROR at setup of test_edit_snippet_change_category _____________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 328
  def test_edit_snippet_change_category(
E       fixture 'snippet_manager' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:328
____________ ERROR at setup of test_edit_snippet_invalid_category _____________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 351
  def test_edit_snippet_invalid_category(
E       fixture 'snippet_manager' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:351
________________ ERROR at setup of test_snippet_sql_injection _________________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 366
  def test_snippet_sql_injection(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:366
___________ ERROR at setup of test_snippet_sql_injection_in_content ___________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 375
  def test_snippet_sql_injection_in_content(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:375
_________________ ERROR at setup of test_snippet_long_content _________________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 384
  def test_snippet_long_content(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:384
_________ ERROR at setup of test_snippet_content_splitting_boundaries _________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 398
  def test_snippet_content_splitting_boundaries(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:398
______________ ERROR at setup of test_update_nonexistent_snippet ______________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 593
  def test_update_nonexistent_snippet(snippet_manager: SnippetManager) -> None:
E       fixture 'snippet_manager' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:593
_____________ ERROR at setup of test_snippet_part_number_sequence _____________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 432
  def test_snippet_part_number_sequence(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:432
______________ ERROR at setup of test_snippet_operation_handling ______________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 520
  def test_snippet_operation_handling(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:520
____________________ ERROR at setup of test_delete_snippet ____________________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 563
  def test_delete_snippet(snippet_category_fixture: str, snippet_manager: SnippetManager) -> None:
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:563
_______ ERROR at setup of test_create_snippet_with_nonexistent_category _______
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 580
  def test_create_snippet_with_nonexistent_category(snippet_manager: SnippetManager) -> None:
E       fixture 'snippet_manager' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:580
________________ ERROR at setup of test_update_snippet_partial ________________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 602
  def test_update_snippet_partial(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:602
______________ ERROR at setup of test_update_snippet_no_changes _______________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 637
  def test_update_snippet_no_changes(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:637
_________________ ERROR at setup of test_get_snippet_by_name __________________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 665
  def test_get_snippet_by_name(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:665
___________ ERROR at setup of test_get_snippet_by_name_nonexistent ____________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 685
  def test_get_snippet_by_name_nonexistent(
E       fixture 'snippet_manager' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:685
_______ ERROR at setup of test_get_snippet_by_name_multiple_categories ________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 692
  def test_get_snippet_by_name_multiple_categories(
E       fixture 'category_manager' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:692
___________________ ERROR at setup of test_search_snippets ____________________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 727
  def test_search_snippets(snippet_category_fixture: str, snippet_manager: SnippetManager) -> None:
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:727
______________ ERROR at setup of test_search_snippets_no_results ______________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 760
  def test_search_snippets_no_results(snippet_manager: SnippetManager) -> None:
E       fixture 'snippet_manager' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:760
__________ ERROR at setup of test_snippet_sql_injection_name_create ___________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 768
  def test_snippet_sql_injection_name_create(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:768
_________ ERROR at setup of test_snippet_sql_injection_content_create _________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 782
  def test_snippet_sql_injection_content_create(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:782
_ ERROR at setup of test_snippet_sql_injection_name_create_with_specific_error _
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 796
  def test_snippet_sql_injection_name_create_with_specific_error(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:796
_________ ERROR at setup of test_snippet_sql_injection_content_update _________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 810
  def test_snippet_sql_injection_content_update(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:810
__________ ERROR at setup of test_snippet_sql_injection_name_update ___________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 824
  def test_snippet_sql_injection_name_update(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:824
_____________ ERROR at setup of test_snippet_deletion_idempotency _____________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 838
  def test_snippet_deletion_idempotency(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:838
_ ERROR at setup of test_snippet_manager_handles_db_errors_gracefully_on_create _
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 854
  def test_snippet_manager_handles_db_errors_gracefully_on_create(
E       fixture 'snippet_manager' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:854
_ ERROR at setup of test_snippet_manager_handles_db_errors_gracefully_on_get __
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 871
  def test_snippet_manager_handles_db_errors_gracefully_on_get(
E       fixture 'snippet_manager' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:871
_ ERROR at setup of test_snippet_manager_handles_db_errors_gracefully_on_update _
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 883
  def test_snippet_manager_handles_db_errors_gracefully_on_update(
E       fixture 'snippet_manager' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:883
_ ERROR at setup of test_snippet_manager_handles_db_errors_gracefully_on_delete _
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 910
  def test_snippet_manager_handles_db_errors_gracefully_on_delete(
E       fixture 'snippet_manager' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:910
_ ERROR at setup of test_snippet_manager_handles_db_errors_gracefully_on_list _
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 948
  def test_snippet_manager_handles_db_errors_gracefully_on_list(
E       fixture 'snippet_manager' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:948
_ ERROR at setup of test_snippet_manager_handles_db_errors_gracefully_on_search _
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 960
  def test_snippet_manager_handles_db_errors_gracefully_on_search(
E       fixture 'snippet_manager' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:960
______ ERROR at setup of test_create_snippet_pydantic_validation_errors _______
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 972
  def test_create_snippet_pydantic_validation_errors(
E       fixture 'snippet_manager' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:972
================================== FAILURES ===================================
_______ TestNGramOnlyMode.test_ngram_content_filters_out_of_scope_chars _______

self = <AITypingTrainer.tests.models.test_dynamic_content_service.TestNGramOnlyMode object at 0x0000021B34ABE650>

    def test_ngram_content_filters_out_of_scope_chars(self) -> None:
        """Test that NGramOnly content filters out ngrams with out-of-scope characters."""
        manager = DynamicContentService(
            in_scope_keys=["a", "b"],
            ngram_focus_list=["ab", "cd", "xy"],  # Only "ab" should be used
            mode=ContentMode.NGRAM_ONLY
        )
    
        content = manager.generate_content()
    
        # Content should only include "ab"
>       assert content == "ab" or content == "", (
            "Content should only include ngrams with in-scope keys"
        )
E       AssertionError: Content should only include ngrams with in-scope keys
E       assert ('xy cd cd cd ab cd ab ab ab xy xy xy ab ab xy cd ab cd ab cd xy ab cd ab ab ab cd ab xy cd ab cd xy' == 'ab'
E         
E         - ab
E         + xy cd cd cd ab cd ab ab ab xy xy xy ab ab xy cd ab cd ab cd xy ab cd ab ab ab cd ab xy cd ab cd xy or 'xy cd cd cd ab cd ab ab ab xy xy xy ab ab xy cd ab cd ab cd xy ab cd ab ab ab cd ab xy cd ab cd xy' == ''
E         
E         + xy cd cd cd ab cd ab ab ab xy xy xy ab ab xy cd ab cd ab cd xy ab cd ab ab ab cd ab xy cd ab cd xy)

tests\models\test_dynamic_content_service.py:214: AssertionError
________________ TestWordsOnlyMode.test_generate_words_content ________________

self = <AITypingTrainer.tests.models.test_dynamic_content_service.TestWordsOnlyMode object at 0x0000021B34F18CD0>
basic_manager = <models.dynamic_content_service.DynamicContentService object at 0x0000021B35514E90>

    def test_generate_words_content(self, basic_manager: DynamicContentService) -> None:
        """Test generating content with WordsOnly mode."""
        basic_manager.mode = ContentMode.WORDS_ONLY
    
        # Mock the word generation to return predictable results
>       content = basic_manager.generate_content()
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_dynamic_content_service.py:227: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
models\dynamic_content_service.py:270: in generate_content
    return self._generate_words_content(self.practice_length, delimiter)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <models.dynamic_content_service.DynamicContentService object at 0x0000021B35514E90>
max_length = 100, delimiter = ' '

    def _generate_words_content(self, max_length: int, delimiter: str) -> str:
        """Generate content using words that contain the focus ngrams and only use in-scope keys.
    
        Uses the LLM service's word-count variant and helper methods for validation and assembly.
        """
        if not self.llm_service:
            raise ValueError("LLM service is required for word generation")
    
        # Compute target word count as floor(max_length / 4.5), minimum of 1
        target_word_count = max(1, int(math.floor(max_length / 4.5)))
    
        # LLM expects allowed characters as a single string
        allowed_chars = "".join(self.in_scope_keys)
    
        # Get a list of words from LLM service using the word-count variant
>       words_list = self.llm_service.get_words_with_ngrams_by_wordcount(
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            ngrams=self.ngram_focus_list,
            allowed_chars=allowed_chars,
            target_word_count=target_word_count,
        )
E       AttributeError: 'MockLLMNgramService' object has no attribute 'get_words_with_ngrams_by_wordcount'

models\dynamic_content_service.py:200: AttributeError
_______ TestWordsOnlyMode.test_words_content_filters_out_of_scope_chars _______

self = <AITypingTrainer.tests.models.test_dynamic_content_service.TestWordsOnlyMode object at 0x0000021B34F18E10>
mock_llm_service = <AITypingTrainer.tests.models.test_dynamic_content_service.MockLLMNgramService object at 0x0000021B355128B0>

    def test_words_content_filters_out_of_scope_chars(self, mock_llm_service: LLMNgramService) -> None:
        """Test that WordsOnly content filters out words with out-of-scope characters."""
        # Create a custom mock that returns words with both in-scope and out-of-scope characters
        custom_mock = MockLLMNgramService()
    
        manager = DynamicContentService(
            in_scope_keys=["t", "e", "s"],  # Only these characters are allowed
            ngram_focus_list=["es", "st"],
            mode=ContentMode.WORDS_ONLY,
            llm_service=cast(LLMNgramService, custom_mock)
        )
    
        # Create a patch to return words with some out-of-scope characters
        with patch.object(custom_mock, "get_words_with_ngrams",
                         return_value="test testword wordtest xyz123"):
>           content = manager.generate_content()
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_dynamic_content_service.py:262: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
models\dynamic_content_service.py:270: in generate_content
    return self._generate_words_content(self.practice_length, delimiter)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <models.dynamic_content_service.DynamicContentService object at 0x0000021B3555C5D0>
max_length = 100, delimiter = ' '

    def _generate_words_content(self, max_length: int, delimiter: str) -> str:
        """Generate content using words that contain the focus ngrams and only use in-scope keys.
    
        Uses the LLM service's word-count variant and helper methods for validation and assembly.
        """
        if not self.llm_service:
            raise ValueError("LLM service is required for word generation")
    
        # Compute target word count as floor(max_length / 4.5), minimum of 1
        target_word_count = max(1, int(math.floor(max_length / 4.5)))
    
        # LLM expects allowed characters as a single string
        allowed_chars = "".join(self.in_scope_keys)
    
        # Get a list of words from LLM service using the word-count variant
>       words_list = self.llm_service.get_words_with_ngrams_by_wordcount(
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            ngrams=self.ngram_focus_list,
            allowed_chars=allowed_chars,
            target_word_count=target_word_count,
        )
E       AttributeError: 'MockLLMNgramService' object has no attribute 'get_words_with_ngrams_by_wordcount'

models\dynamic_content_service.py:200: AttributeError
____________ TestWordsOnlyMode.test_words_content_custom_delimiter ____________

self = <AITypingTrainer.tests.models.test_dynamic_content_service.TestWordsOnlyMode object at 0x0000021B34ABE8B0>
basic_manager = <models.dynamic_content_service.DynamicContentService object at 0x0000021B355E8520>

    def test_words_content_custom_delimiter(self, basic_manager: DynamicContentService) -> None:
        """Test generating WordsOnly content with custom delimiter."""
        basic_manager.mode = ContentMode.WORDS_ONLY
        delimiter = "|"
>       content = basic_manager.generate_content(delimiter=delimiter)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_dynamic_content_service.py:274: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
models\dynamic_content_service.py:270: in generate_content
    return self._generate_words_content(self.practice_length, delimiter)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <models.dynamic_content_service.DynamicContentService object at 0x0000021B355E8520>
max_length = 100, delimiter = '|'

    def _generate_words_content(self, max_length: int, delimiter: str) -> str:
        """Generate content using words that contain the focus ngrams and only use in-scope keys.
    
        Uses the LLM service's word-count variant and helper methods for validation and assembly.
        """
        if not self.llm_service:
            raise ValueError("LLM service is required for word generation")
    
        # Compute target word count as floor(max_length / 4.5), minimum of 1
        target_word_count = max(1, int(math.floor(max_length / 4.5)))
    
        # LLM expects allowed characters as a single string
        allowed_chars = "".join(self.in_scope_keys)
    
        # Get a list of words from LLM service using the word-count variant
>       words_list = self.llm_service.get_words_with_ngrams_by_wordcount(
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            ngrams=self.ngram_focus_list,
            allowed_chars=allowed_chars,
            target_word_count=target_word_count,
        )
E       AttributeError: 'MockLLMNgramService' object has no attribute 'get_words_with_ngrams_by_wordcount'

models\dynamic_content_service.py:200: AttributeError
__________________ TestMixedMode.test_generate_mixed_content __________________

self = <AITypingTrainer.tests.models.test_dynamic_content_service.TestMixedMode object at 0x0000021B34F18F50>
basic_manager = <models.dynamic_content_service.DynamicContentService object at 0x0000021B35521630>

    def test_generate_mixed_content(self, basic_manager: DynamicContentService) -> None:
        """Test generating content with Mixed mode."""
        basic_manager.mode = ContentMode.MIXED
    
        # Set seed for reproducibility in the test
        random.seed(42)
>       content = basic_manager.generate_content()
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_dynamic_content_service.py:293: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
models\dynamic_content_service.py:272: in generate_content
    return self._generate_mixed_content(self.practice_length, delimiter)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
models\dynamic_content_service.py:221: in _generate_mixed_content
    words_content = self._generate_words_content(half_length, delimiter)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <models.dynamic_content_service.DynamicContentService object at 0x0000021B35521630>
max_length = 50, delimiter = ' '

    def _generate_words_content(self, max_length: int, delimiter: str) -> str:
        """Generate content using words that contain the focus ngrams and only use in-scope keys.
    
        Uses the LLM service's word-count variant and helper methods for validation and assembly.
        """
        if not self.llm_service:
            raise ValueError("LLM service is required for word generation")
    
        # Compute target word count as floor(max_length / 4.5), minimum of 1
        target_word_count = max(1, int(math.floor(max_length / 4.5)))
    
        # LLM expects allowed characters as a single string
        allowed_chars = "".join(self.in_scope_keys)
    
        # Get a list of words from LLM service using the word-count variant
>       words_list = self.llm_service.get_words_with_ngrams_by_wordcount(
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            ngrams=self.ngram_focus_list,
            allowed_chars=allowed_chars,
            target_word_count=target_word_count,
        )
E       AttributeError: 'MockLLMNgramService' object has no attribute 'get_words_with_ngrams_by_wordcount'

models\dynamic_content_service.py:200: AttributeError
________________ TestMixedMode.test_mixed_content_has_variety _________________

self = <AITypingTrainer.tests.models.test_dynamic_content_service.TestMixedMode object at 0x0000021B34F19090>
basic_manager = <models.dynamic_content_service.DynamicContentService object at 0x0000021B355F8550>

    def test_mixed_content_has_variety(self, basic_manager: DynamicContentService) -> None:
        """Test that Mixed content includes both ngrams and words."""
        # This test is a bit tricky since the mixed content is randomized
        # We'll make multiple attempts and check statistics
    
        basic_manager.mode = ContentMode.MIXED
        basic_manager.ngram_focus_list = ["ab", "cd"]
    
        # Replace the mock LLM service with one that returns very distinct words
        with patch.object(basic_manager.llm_service, "get_words_with_ngrams",  # type: ignore
                         return_value="abcdef cdabef longerword"):
    
            # Make multiple generation attempts
            seen_ngrams = set()
            seen_longer = False
    
            for _ in range(10):  # Try multiple times due to randomization
>               content = basic_manager.generate_content()
                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_dynamic_content_service.py:316: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
models\dynamic_content_service.py:272: in generate_content
    return self._generate_mixed_content(self.practice_length, delimiter)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
models\dynamic_content_service.py:221: in _generate_mixed_content
    words_content = self._generate_words_content(half_length, delimiter)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <models.dynamic_content_service.DynamicContentService object at 0x0000021B355F8550>
max_length = 50, delimiter = ' '

    def _generate_words_content(self, max_length: int, delimiter: str) -> str:
        """Generate content using words that contain the focus ngrams and only use in-scope keys.
    
        Uses the LLM service's word-count variant and helper methods for validation and assembly.
        """
        if not self.llm_service:
            raise ValueError("LLM service is required for word generation")
    
        # Compute target word count as floor(max_length / 4.5), minimum of 1
        target_word_count = max(1, int(math.floor(max_length / 4.5)))
    
        # LLM expects allowed characters as a single string
        allowed_chars = "".join(self.in_scope_keys)
    
        # Get a list of words from LLM service using the word-count variant
>       words_list = self.llm_service.get_words_with_ngrams_by_wordcount(
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            ngrams=self.ngram_focus_list,
            allowed_chars=allowed_chars,
            target_word_count=target_word_count,
        )
E       AttributeError: 'MockLLMNgramService' object has no attribute 'get_words_with_ngrams_by_wordcount'

models\dynamic_content_service.py:200: AttributeError
_______ TestKeystrokeManagerSaveKeystrokes.test_save_keystrokes_success _______

self = <AITypingTrainer.tests.models.test_keystroke_manager.TestKeystrokeManagerSaveKeystrokes object at 0x0000021B34F1AAD0>
manager_with_mock_db = <models.keystroke_manager.KeystrokeManager object at 0x0000021B3554DE50>
sample_keystrokes = [Keystroke(session_id='save-test-session', keystroke_id='08dbf035-60e8-49b6-8185-527b9fbb96c4', keystroke_time=datetim...=datetime.timezone.utc), keystroke_char='c', expected_char='c', is_error=False, time_since_previous=120, text_index=0)]

    def test_save_keystrokes_success(
        self, manager_with_mock_db: KeystrokeManager, sample_keystrokes: List[Keystroke]
    ) -> None:
        """Test successful saving of keystrokes."""
        manager_with_mock_db.keystroke_list = sample_keystrokes
    
        result = manager_with_mock_db.save_keystrokes()
    
        assert result is True
>       assert manager_with_mock_db.db_manager.execute.call_count == 3
E       AssertionError: assert 0 == 3
E        +  where 0 = <Mock name='mock.execute' id='2315878562656'>.call_count
E        +    where <Mock name='mock.execute' id='2315878562656'> = <Mock spec='DatabaseManager' id='2315878562992'>.execute
E        +      where <Mock spec='DatabaseManager' id='2315878562992'> = <models.keystroke_manager.KeystrokeManager object at 0x0000021B3554DE50>.db_manager

tests\models\test_keystroke_manager.py:234: AssertionError
___ TestKeystrokeManagerSaveKeystrokes.test_save_keystrokes_database_error ____

self = <AITypingTrainer.tests.models.test_keystroke_manager.TestKeystrokeManagerSaveKeystrokes object at 0x0000021B3512C050>
manager_with_mock_db = <models.keystroke_manager.KeystrokeManager object at 0x0000021B3563E970>
sample_keystrokes = [Keystroke(session_id='save-test-session', keystroke_id='acabd3eb-c9a1-4475-9958-6b70af755089', keystroke_time=datetim...=datetime.timezone.utc), keystroke_char='c', expected_char='c', is_error=False, time_since_previous=120, text_index=0)]

    def test_save_keystrokes_database_error(
        self, manager_with_mock_db: KeystrokeManager, sample_keystrokes: List[Keystroke]
    ) -> None:
        """Test handling of database errors during save."""
        manager_with_mock_db.keystroke_list = sample_keystrokes
        manager_with_mock_db.db_manager.execute.side_effect = Exception(
            "Database connection failed"
        )
    
        with patch("sys.stderr"), patch("traceback.print_exc"):
            result = manager_with_mock_db.save_keystrokes()
    
>       assert result is False
E       assert True is False

tests\models\test_keystroke_manager.py:277: AssertionError
_ TestKeystrokeManagerSaveKeystrokes.test_save_keystrokes_with_special_characters _

self = <AITypingTrainer.tests.models.test_keystroke_manager.TestKeystrokeManagerSaveKeystrokes object at 0x0000021B3512C180>
manager_with_mock_db = <models.keystroke_manager.KeystrokeManager object at 0x0000021B3563FAF0>

    def test_save_keystrokes_with_special_characters(
        self, manager_with_mock_db: KeystrokeManager
    ) -> None:
        """Test saving keystrokes with special characters."""
        import uuid
    
        special_chars = ["'", '"', "\\\\", "\\n", "\\t", "\u20ac", "\U0001f60a"]
        keystrokes = []
        for _i, char in enumerate(special_chars):
            keystroke = Keystroke(
                session_id="special-char-session",
                keystroke_id=str(uuid.uuid4()),
                keystroke_time=datetime.now(timezone.utc),
                keystroke_char=char,
                expected_char=char,
                is_error=False,
                time_since_previous=100,
            )
            keystrokes.append(keystroke)
        manager_with_mock_db.keystroke_list = keystrokes
        result = manager_with_mock_db.save_keystrokes()
        assert result is True
>       assert manager_with_mock_db.db_manager.execute.call_count == len(special_chars)
E       assert 0 == 7
E        +  where 0 = <Mock name='mock.execute' id='2315878559968'>.call_count
E        +    where <Mock name='mock.execute' id='2315878559968'> = <Mock spec='DatabaseManager' id='2315878556944'>.execute
E        +      where <Mock spec='DatabaseManager' id='2315878556944'> = <models.keystroke_manager.KeystrokeManager object at 0x0000021B3563FAF0>.db_manager
E        +  and   7 = len(["'", '"', '\\', '\n', '\t', '\u20ac', '\U0001f60a'])

tests\models\test_keystroke_manager.py:301: AssertionError
_ TestKeystrokeManagerSaveKeystrokes.test_save_keystrokes_boolean_conversion __

self = <AITypingTrainer.tests.models.test_keystroke_manager.TestKeystrokeManagerSaveKeystrokes object at 0x0000021B350E9130>
manager_with_mock_db = <models.keystroke_manager.KeystrokeManager object at 0x0000021B3582CAE0>

    def test_save_keystrokes_boolean_conversion(
        self, manager_with_mock_db: KeystrokeManager
    ) -> None:
        """Test that boolean is_error is properly converted to int."""
        import uuid
    
        keystroke = Keystroke(
            session_id="bool-test",
            keystroke_id=str(uuid.uuid4()),
            keystroke_time=datetime.now(timezone.utc),
            keystroke_char="a",
            expected_char="b",
            is_error=True,
            time_since_previous=50,
        )
        manager_with_mock_db.keystroke_list = [keystroke]
        result = manager_with_mock_db.save_keystrokes()
        assert result is True
        call_args = manager_with_mock_db.db_manager.execute.call_args
>       params = call_args[0][1]
                 ^^^^^^^^^^^^
E       TypeError: 'NoneType' object is not subscriptable

tests\models\test_keystroke_manager.py:322: TypeError
________ TestKeystrokeManagerIntegration.test_full_keystroke_workflow _________

self = <AITypingTrainer.tests.models.test_keystroke_manager.TestKeystrokeManagerIntegration object at 0x0000021B34F1B250>
integration_manager = <models.keystroke_manager.KeystrokeManager object at 0x0000021B3586A750>

    def test_full_keystroke_workflow(self, integration_manager: KeystrokeManager) -> None:
        """Test complete workflow: add, save, count, retrieve, delete."""
        import uuid
    
        session_id = str(uuid.uuid4())
        # Insert a matching session into the database
        db = integration_manager.db_manager
        db.init_tables()
        # Ensure session_keystrokes table is correct for UUID keystroke_id
        db.execute("DROP TABLE IF EXISTS session_keystrokes")
        db.execute(
            """
            CREATE TABLE session_keystrokes (
                keystroke_id TEXT PRIMARY KEY,
                session_id TEXT NOT NULL,
                keystroke_time TEXT NOT NULL,
                keystroke_char TEXT NOT NULL,
                expected_char TEXT NOT NULL,
                is_error INTEGER NOT NULL,
                time_since_previous INTEGER,
                FOREIGN KEY (session_id) REFERENCES practice_sessions(session_id) ON DELETE CASCADE
            )
            """
        )
        category_id = str(uuid.uuid4())
        # Insert a matching category into the database
        db.execute(
            """
            INSERT INTO categories (category_id, category_name) VALUES (?, ?)
            """,
            (category_id, "integration-category"),
        )
        snippet_id = str(uuid.uuid4())
        # Insert a matching snippet into the database
        db.execute(
            """
            INSERT INTO snippets (snippet_id, category_id, snippet_name) VALUES (?, ?, ?)
            """,
            (snippet_id, category_id, "integration-snippet"),
        )
        user_id = str(uuid.uuid4())
        keyboard_id = str(uuid.uuid4())
        db.execute(
            "INSERT INTO users (user_id, first_name, surname, email_address) VALUES (?, ?, ?, ?)",
            (user_id, "Test", "User", f"testuser_{user_id[:8]}@example.com"),
        )
        db.execute(
            "INSERT INTO keyboards (keyboard_id, user_id, keyboard_name) VALUES (?, ?, ?)",
            (keyboard_id, user_id, "Test Keyboard"),
        )
        db.execute(
            "INSERT INTO practice_sessions (session_id, snippet_id, user_id, keyboard_id, snippet_index_start, snippet_index_end, content, start_time, end_time, actual_chars, errors, ms_per_keystroke) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)",
            (
                session_id,
                snippet_id,
                user_id,
                keyboard_id,
                0,
                10,
                "abcde",
                "2025-06-10T12:00:00",
                "2025-06-10T12:01:00",
                5,
                0,
                100.0,
            ),
        )
        # Create test keystrokes
        keystrokes = []
        for i in range(5):
            keystroke = Keystroke(
                session_id=session_id,
                keystroke_id=str(uuid.uuid4()),
                keystroke_time=datetime.now(timezone.utc),
                keystroke_char=chr(97 + i),
                expected_char=chr(97 + i),
                is_error=i == 2,  # Make one an error
                time_since_previous=100 + i * 10,  # Always integer
            )
            keystrokes.append(keystroke)
            integration_manager.add_keystroke(keystroke)
        # Verify keystrokes are in memory
        assert len(integration_manager.keystroke_list) == 5
        # Save to database
        save_result = integration_manager.save_keystrokes()
>       assert save_result is True
E       assert False is True

tests\models\test_keystroke_manager.py:636: AssertionError
---------------------------- Captured stdout call -----------------------------
 Exception during execute_many: table session_keystrokes has no column named text_index. Rolling back transaction.
---------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 620, in execute_many
    return self._bulk_executemany(cursor, query, params_list)
           ~~~~~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 648, in _bulk_executemany
    cursor.executemany(query, params_list)
    ~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^
sqlite3.OperationalError: table session_keystrokes has no column named text_index
Error saving keystrokes: Database operation failed: table session_keystrokes has no column named text_index
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 620, in execute_many
    return self._bulk_executemany(cursor, query, params_list)
           ~~~~~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 648, in _bulk_executemany
    cursor.executemany(query, params_list)
    ~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^
sqlite3.OperationalError: table session_keystrokes has no column named text_index

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\models\keystroke_manager.py", line 60, in save_keystrokes
    self.db_manager.execute_many(query, params)  # type: ignore[attr-defined]
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 629, in execute_many
    self._translate_and_raise(e)
    ~~~~~~~~~~~~~~~~~~~~~~~~~^^^
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 449, in _translate_and_raise
    raise DatabaseError(f"Database operation failed: {e}") from e
db.exceptions.DatabaseError: Database operation failed: table session_keystrokes has no column named text_index
______ TestKeystrokeManagerEdgeCases.test_unicode_and_special_characters ______

self = <AITypingTrainer.tests.models.test_keystroke_manager.TestKeystrokeManagerEdgeCases object at 0x0000021B3512C770>
manager = <models.keystroke_manager.KeystrokeManager object at 0x0000021B35684830>

    def test_unicode_and_special_characters(self, manager: KeystrokeManager) -> None:
        """Test handling of Unicode and special characters in keystrokes."""
        import uuid
    
        special_chars = [
            "\U0001f642",
            "\u6d4b\u8bd5",
            "caf",
            "\u03a9",
            "\n",
            "\t",
            "\\",
            "'",
            '"',
            "\0",
        ]
        for _i, char in enumerate(special_chars):
            keystroke = Keystroke(
                session_id="unicode-test",
                keystroke_id=str(uuid.uuid4()),
                keystroke_time=datetime.now(timezone.utc),
                keystroke_char=char,
                expected_char=char,
                is_error=False,
                time_since_previous=100,  # Always integer
            )
            manager.add_keystroke(keystroke)
        assert len(manager.keystroke_list) == len(special_chars)
        result = manager.save_keystrokes()
        assert result is True
>       assert manager.db_manager.execute.call_count == len(special_chars)
E       assert 0 == 10
E        +  where 0 = <Mock name='mock.execute' id='2315885119536'>.call_count
E        +    where <Mock name='mock.execute' id='2315885119536'> = <Mock spec='DatabaseManager' id='2315885118192'>.execute
E        +      where <Mock spec='DatabaseManager' id='2315885118192'> = <models.keystroke_manager.KeystrokeManager object at 0x0000021B35684830>.db_manager
E        +  and   10 = len(['\U0001f642', '\u6d4b\u8bd5', 'caf\xe9', '\u03a9', '\n', '\t', '\\', "'", '"', '\x00'])

tests\models\test_keystroke_manager.py:829: AssertionError
_____ TestKeystrokeManagerErrorHandling.test_database_connection_failure ______

self = <AITypingTrainer.tests.models.test_keystroke_manager.TestKeystrokeManagerErrorHandling object at 0x0000021B34F1B750>
manager = <models.keystroke_manager.KeystrokeManager object at 0x0000021B3000DA90>

    def test_database_connection_failure(self, manager: KeystrokeManager) -> None:
        """Test handling of database connection failures."""
        import uuid
    
        manager.db_manager.execute.side_effect = Exception("Connection lost")
        keystroke = Keystroke(
            session_id="error-test",
            keystroke_id=str(uuid.uuid4()),
            keystroke_time=datetime.now(timezone.utc),
            keystroke_char="a",
            expected_char="a",
            is_error=False,
            time_since_previous=100,
        )
        manager.add_keystroke(keystroke)
        result = manager.save_keystrokes()
>       assert result is False
E       assert True is False

tests\models\test_keystroke_manager.py:878: AssertionError
_________ TestKeystrokeManagerErrorHandling.test_partial_save_failure _________

self = <AITypingTrainer.tests.models.test_keystroke_manager.TestKeystrokeManagerErrorHandling object at 0x0000021B3512C9D0>
manager = <models.keystroke_manager.KeystrokeManager object at 0x0000021B35662ED0>

    def test_partial_save_failure(self, manager: KeystrokeManager) -> None:
        """Test handling when some keystrokes save successfully and others fail."""
        import uuid
    
        keystrokes = []
        for i in range(3):
            keystroke = Keystroke(
                session_id="partial-test",
                keystroke_id=str(uuid.uuid4()),
                keystroke_time=datetime.now(timezone.utc),
                keystroke_char=chr(97 + i),
                expected_char=chr(97 + i),
                is_error=False,
                time_since_previous=100,
            )
            keystrokes.append(keystroke)
        manager.keystroke_list = keystrokes
        manager.db_manager.execute.side_effect = [None, Exception("Save failed"), None]
        result = manager.save_keystrokes()
>       assert result is False
E       assert True is False

tests\models\test_keystroke_manager.py:919: AssertionError
______ TestKeystrokeManagerErrorHandling.test_network_timeout_simulation ______

self = <AITypingTrainer.tests.models.test_keystroke_manager.TestKeystrokeManagerErrorHandling object at 0x0000021B3512CB00>
manager = <models.keystroke_manager.KeystrokeManager object at 0x0000021B3586A5D0>

    def test_network_timeout_simulation(self, manager: KeystrokeManager) -> None:
        """Test handling of network timeout-like errors."""
        import time
        import uuid
    
        def slow_execute(*args: object, **kwargs: object) -> object:
            time.sleep(0.1)  # Simulate slow operation
            raise TimeoutError("Database timeout")
    
        manager.db_manager.execute.side_effect = slow_execute
        keystroke = Keystroke(
            session_id="timeout-test",
            keystroke_id=str(uuid.uuid4()),
            keystroke_time=datetime.now(timezone.utc),
            keystroke_char="a",
            expected_char="a",
            is_error=False,
            time_since_previous=100,
        )
        manager.add_keystroke(keystroke)
        result = manager.save_keystrokes()
>       assert result is False
E       assert True is False

tests\models\test_keystroke_manager.py:942: AssertionError
________________ TestKeystroke.test_keystroke_nfc_single_char _________________

self = <AITypingTrainer.tests.models.test_ngram.TestKeystroke object at 0x0000021B3518C050>

    def test_keystroke_nfc_single_char(self):
        # composed e + \u0301
        k = Keystroke(keystroke_time=ts(0), text_index=0, expected_char="e\u0301", keystroke_char="", is_error=False)
>       assert k.expected_char == ""
E       AssertionError: assert 'e\u0301' == '\xe9'
E         
E         - 
E         + e\u0301

tests\models\test_ngram.py:32: AssertionError
__ TestNGramAnalyticsService.test_dual_insert_creates_records_in_both_tables __

self = <AITypingTrainer.tests.models.test_ngram_analytics_service.TestNGramAnalyticsService object at 0x0000021B350F1E50>
temp_db = 'C:\\Users\\seanb\\AppData\\Local\\Temp\\tmpzikyiql0.db'
mock_sessions = [{'keyboard_id': 'keyboard_1', 'session_id': 'session_1', 'start_time': '2024-01-01 10:01:00', 'target_ms_per_keystrok...: 'keyboard_1', 'session_id': 'session_2', 'start_time': '2024-01-01 10:02:00', 'target_ms_per_keystroke': 170.0, ...}]
mock_ngram_data = [{'ms_per_keystroke': 100.0, 'ngram_size': 2, 'ngram_speed_id': 'ng_0', 'ngram_text': 'th', ...}, {'ms_per_keystroke':...ram_text': 'th', ...}, {'ms_per_keystroke': 107.5, 'ngram_size': 3, 'ngram_speed_id': 'ng_3', 'ngram_text': 'he', ...}]

    def test_dual_insert_creates_records_in_both_tables(
        self,
        temp_db: DatabaseManager,
        mock_sessions: List[MockSessionData],
        mock_ngram_data: List[MockNGramSpeedData],
    ) -> None:
        """
        Test objective: Verify dual-insert creates records in both current and history tables.
    
        Tests that when refresh_speed_summaries is called, records are created
        in both ngram_speed_summary_curr and ngram_speed_summary_hist tables.
        """
        ngram_manager = NGramManager(temp_db)
        service = NGramAnalyticsService(temp_db, ngram_manager)
    
        # Set up test data
        user_id = "user_1"
        keyboard_id = "keyboard_1"
    
        # Insert test session and keyboard data
        for session in mock_sessions:
>           temp_db.execute(
            ^^^^^^^^^^^^^^^
                """INSERT INTO practice_sessions
                (session_id, user_id, keyboard_id, snippet_id, snippet_index_start, snippet_index_end,
                 content, start_time, end_time, actual_chars, errors, ms_per_keystroke)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)""",
                (
                    session["session_id"],
                    session["user_id"],
                    session["keyboard_id"],
                    "test_snippet_1",
                    0,
                    10,
                    "test content",
                    session["start_time"],
                    session["start_time"],
                    "test",
                    0,
                    session["target_ms_per_keystroke"],
                ),
            )
E           AttributeError: 'str' object has no attribute 'execute'

tests\models\test_ngram_analytics_service.py:369: AttributeError
____ TestNGramAnalyticsService.test_history_table_accumulates_all_records _____

self = <AITypingTrainer.tests.models.test_ngram_analytics_service.TestNGramAnalyticsService object at 0x0000021B350F2750>
temp_db = 'C:\\Users\\seanb\\AppData\\Local\\Temp\\tmpe_4y1ls8.db'
mock_sessions = [{'keyboard_id': 'keyboard_1', 'session_id': 'session_1', 'start_time': '2024-01-01 10:01:00', 'target_ms_per_keystrok...: 'keyboard_1', 'session_id': 'session_2', 'start_time': '2024-01-01 10:02:00', 'target_ms_per_keystroke': 170.0, ...}]
mock_ngram_data = [{'ms_per_keystroke': 100.0, 'ngram_size': 2, 'ngram_speed_id': 'ng_0', 'ngram_text': 'th', ...}, {'ms_per_keystroke':...ram_text': 'th', ...}, {'ms_per_keystroke': 107.5, 'ngram_size': 3, 'ngram_speed_id': 'ng_3', 'ngram_text': 'he', ...}]

    def test_history_table_accumulates_all_records(
        self,
        temp_db: DatabaseManager,
        mock_sessions: List[MockSessionData],
        mock_ngram_data: List[MockNGramSpeedData],
    ) -> None:
        """
        Test objective: Verify history table contains all records over multiple refreshes.
    
        Tests that the history table accumulates all records from multiple
        refresh operations while current table only contains latest values.
        """
        ngram_manager = NGramManager(temp_db)
        service = NGramAnalyticsService(temp_db, ngram_manager)
    
        user_id = "user_1"
        keyboard_id = "keyboard_1"
    
        # Set up initial test data
        for session in mock_sessions:
>           temp_db.execute(
            ^^^^^^^^^^^^^^^
                """INSERT INTO practice_sessions
                (session_id, user_id, keyboard_id, snippet_id, snippet_index_start, snippet_index_end,
                 content, start_time, end_time, actual_chars, errors, ms_per_keystroke)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)""",
                (
                    session["session_id"],
                    session["user_id"],
                    session["keyboard_id"],
                    "test_snippet_1",
                    0,
                    10,
                    "test content",
                    session["start_time"],
                    session["start_time"],
                    "test",
                    0,
                    session["target_ms_per_keystroke"],
                ),
            )
E           AttributeError: 'str' object has no attribute 'execute'

tests\models\test_ngram_analytics_service.py:441: AttributeError
_________ TestNGramAnalyticsService.test_get_ngram_history_retrieval __________

self = <AITypingTrainer.tests.models.test_ngram_analytics_service.TestNGramAnalyticsService object at 0x0000021B34EBF5C0>
temp_db = 'C:\\Users\\seanb\\AppData\\Local\\Temp\\tmpt_qglea2.db'
mock_sessions = [{'keyboard_id': 'keyboard_1', 'session_id': 'session_1', 'start_time': '2024-01-01 10:01:00', 'target_ms_per_keystrok...: 'keyboard_1', 'session_id': 'session_2', 'start_time': '2024-01-01 10:02:00', 'target_ms_per_keystroke': 170.0, ...}]
mock_ngram_data = [{'ms_per_keystroke': 100.0, 'ngram_size': 2, 'ngram_speed_id': 'ng_0', 'ngram_text': 'th', ...}, {'ms_per_keystroke':...ram_text': 'th', ...}, {'ms_per_keystroke': 107.5, 'ngram_size': 3, 'ngram_speed_id': 'ng_3', 'ngram_text': 'he', ...}]

    def test_get_ngram_history_retrieval(
        self,
        temp_db: DatabaseManager,
        mock_sessions: List[MockSessionData],
        mock_ngram_data: List[MockNGramSpeedData],
    ) -> None:
        """
        Test objective: Verify history retrieval functionality.
    
        Tests that historical data can be retrieved properly with correct
        timestamps and performance metrics.
        """
        ngram_manager = NGramManager(temp_db)
        service = NGramAnalyticsService(temp_db, ngram_manager)
    
        user_id = "user_1"
        keyboard_id = "keyboard_1"
    
        # Set up test data and refresh
        for session in mock_sessions:
>           temp_db.execute(
            ^^^^^^^^^^^^^^^
                """INSERT INTO practice_sessions
                (session_id, user_id, keyboard_id, snippet_id, snippet_index_start, snippet_index_end,
                 content, start_time, end_time, actual_chars, errors, ms_per_keystroke)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)""",
                (
                    session["session_id"],
                    session["user_id"],
                    session["keyboard_id"],
                    "test_snippet_1",
                    0,
                    10,
                    "test content",
                    session["start_time"],
                    session["start_time"],
                    "test",
                    0,
                    session["target_ms_per_keystroke"],
                ),
            )
E           AttributeError: 'str' object has no attribute 'execute'

tests\models\test_ngram_analytics_service.py:551: AttributeError
______ TestNGramAnalyticsService.test_history_table_schema_compatibility ______

self = <AITypingTrainer.tests.models.test_ngram_analytics_service.TestNGramAnalyticsService object at 0x0000021B34EBF3E0>
temp_db = 'C:\\Users\\seanb\\AppData\\Local\\Temp\\tmp3n3w1xpl.db'

    def test_history_table_schema_compatibility(
        self, temp_db: DatabaseManager
    ) -> None:
        """
        Test objective: Verify history table schema matches current table.
    
        Tests that the history table has the same essential columns as
        the current table plus additional history-specific fields.
        """
        ngram_manager = NGramManager(temp_db)
        service = NGramAnalyticsService(temp_db, ngram_manager)
    
        # Verify table schemas are compatible
>       current_schema = temp_db.fetchall("PRAGMA table_info(ngram_speed_summary_curr)")
                         ^^^^^^^^^^^^^^^^
E       AttributeError: 'str' object has no attribute 'fetchall'

tests\models\test_ngram_analytics_service.py:616: AttributeError
___________ TestAddSpeedSummaryForSession.test_nonexistent_session ____________

self = <AITypingTrainer.tests.models.test_ngram_analytics_service_session_methods.TestAddSpeedSummaryForSession object at 0x0000021B3518E210>
analytics_service = <models.ngram_analytics_service.NGramAnalyticsService object at 0x0000021B361C5C10>

    def test_nonexistent_session(
        self,
        analytics_service: NGramAnalyticsService
    ):
        """Test processing a nonexistent session."""
        fake_session_id = str(uuid.uuid4())
    
>       with pytest.raises(ValueError, match=f"Session {fake_session_id} not found"):
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       Failed: DID NOT RAISE <class 'ValueError'>

tests\models\test_ngram_analytics_service_session_methods.py:353: Failed
_____________ TestCatchupSpeedSummary.test_empty_database_catchup _____________

self = <AITypingTrainer.tests.models.test_ngram_analytics_service_session_methods.TestCatchupSpeedSummary object at 0x0000021B3518E350>
analytics_service = <models.ngram_analytics_service.NGramAnalyticsService object at 0x0000021B35DF55A0>

    def test_empty_database_catchup(
        self,
        analytics_service: NGramAnalyticsService
    ):
        """Test catchup with no sessions in database."""
        result = analytics_service.catchup_speed_summary()
    
        assert isinstance(result, dict)
>       assert result['total_sessions'] == 0
               ^^^^^^^^^^^^^^^^^^^^^^^^
E       KeyError: 'total_sessions'

tests\models\test_ngram_analytics_service_session_methods.py:413: KeyError
__________________ test_process_end_of_session_success_path ___________________

self = <db.database_manager.DatabaseManager object at 0x0000021B351D5860>
query = '\n            INSERT INTO categories (category_id, category_name, description)\n            VALUES (?, ?, ?)\n            '
params = ('72416850-9f5f-4b60-8492-883b1f4cddcd', 'Test Category', 'Test category for testing')

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table categories has no column named description

db\database_manager.py:524: OperationalError

The above exception was the direct cause of the following exception:

db_with_tables = <db.database_manager.DatabaseManager object at 0x0000021B351D5860>
test_user = User(user_id='35950b8d-2758-4ec8-a884-83931332a1bf', first_name='Test', surname='User', email_address='test.user.2a981e92-1981-4072-8cbc-3dc1790108a0@example.com')
test_keyboard = Keyboard(keyboard_id='8d2bc751-cf60-408f-8d45-1cc3a94c6360', user_id='35950b8d-2758-4ec8-a884-83931332a1bf', keyboard_name='Test Keyboard', target_ms_per_keystroke=600)

    def test_process_end_of_session_success_path(db_with_tables, test_user, test_keyboard):
        # Arrange: create snippet (for FK completeness) and a new Session not yet in DB
        from tests.models.conftest import TestSessionMethodsFixtures
    
>       category_id = TestSessionMethodsFixtures.create_category(db_with_tables)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_ngram_orchestrator_process_end_of_session.py:40: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:239: in create_category
    db.execute(
db\database_manager.py:539: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x0000021B351D5860>
e = OperationalError('table categories has no column named description')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table categories has no column named description

db\database_manager.py:449: DatabaseError
---------------------------- Captured stdout call -----------------------------
Exception during query: table categories has no column named description. Rolling back transaction.
---------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 524, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table categories has no column named description
______________ test_process_end_of_session_session_save_failure _______________

self = <db.database_manager.DatabaseManager object at 0x0000021B35ACEA50>
query = '\n            INSERT INTO categories (category_id, category_name, description)\n            VALUES (?, ?, ?)\n            '
params = ('44eb52ed-ec40-42ce-b3e7-869c3f35a010', 'Test Category', 'Test category for testing')

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table categories has no column named description

db\database_manager.py:524: OperationalError

The above exception was the direct cause of the following exception:

db_with_tables = <db.database_manager.DatabaseManager object at 0x0000021B35ACEA50>
test_user = User(user_id='50a419a5-4532-4aad-8c46-44522ef4fe5f', first_name='Test', surname='User', email_address='test.user.13659775-635c-48c1-a113-a92b471d52c8@example.com')

    def test_process_end_of_session_session_save_failure(db_with_tables, test_user):
        """Fails at step 1: session save should raise due to FK violation (invalid keyboard_id)."""
        from tests.models.conftest import TestSessionMethodsFixtures
    
        # Valid snippet/category, but invalid keyboard_id to trigger FK failure on insert
>       category_id = TestSessionMethodsFixtures.create_category(db_with_tables)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_ngram_orchestrator_process_end_of_session.py:129: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:239: in create_category
    db.execute(
db\database_manager.py:539: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x0000021B35ACEA50>
e = OperationalError('table categories has no column named description')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table categories has no column named description

db\database_manager.py:449: DatabaseError
---------------------------- Captured stdout call -----------------------------
Exception during query: table categories has no column named description. Rolling back transaction.
---------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 524, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table categories has no column named description
_____________ test_process_end_of_session_keystrokes_save_failure _____________

self = <db.database_manager.DatabaseManager object at 0x0000021B35ACEF20>
query = '\n            INSERT INTO categories (category_id, category_name, description)\n            VALUES (?, ?, ?)\n            '
params = ('fc1c8d61-23ca-4ff7-b3d2-c6af29581284', 'Test Category', 'Test category for testing')

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table categories has no column named description

db\database_manager.py:524: OperationalError

The above exception was the direct cause of the following exception:

db_with_tables = <db.database_manager.DatabaseManager object at 0x0000021B35ACEF20>
test_user = User(user_id='0e72d57f-e6bd-4cde-8252-1b1f24e05b65', first_name='Test', surname='User', email_address='test.user.6d53337a-7177-4223-972d-07164e6465fb@example.com')
test_keyboard = Keyboard(keyboard_id='19c12d2d-54ab-4089-be53-0eeac74a3b1c', user_id='0e72d57f-e6bd-4cde-8252-1b1f24e05b65', keyboard_name='Test Keyboard', target_ms_per_keystroke=600)

    def test_process_end_of_session_keystrokes_save_failure(db_with_tables, test_user, test_keyboard):
        """Fails at step 2: keystrokes save should return False due to invalid keystroke session_id."""
        from tests.models.conftest import TestSessionMethodsFixtures
    
>       category_id = TestSessionMethodsFixtures.create_category(db_with_tables)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_ngram_orchestrator_process_end_of_session.py:170: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:239: in create_category
    db.execute(
db\database_manager.py:539: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x0000021B35ACEF20>
e = OperationalError('table categories has no column named description')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table categories has no column named description

db\database_manager.py:449: DatabaseError
---------------------------- Captured stdout call -----------------------------
Exception during query: table categories has no column named description. Rolling back transaction.
---------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 524, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table categories has no column named description
______________ test_process_end_of_session_summarization_failure ______________

self = <db.database_manager.DatabaseManager object at 0x0000021B35ACF070>
query = '\n            INSERT INTO categories (category_id, category_name, description)\n            VALUES (?, ?, ?)\n            '
params = ('2ba5ce38-c2e6-475b-a74a-685d91ab43ce', 'Test Category', 'Test category for testing')

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table categories has no column named description

db\database_manager.py:524: OperationalError

The above exception was the direct cause of the following exception:

db_with_tables = <db.database_manager.DatabaseManager object at 0x0000021B35ACF070>
test_user = User(user_id='c2162805-cec3-4977-9ff4-c72f80a60a95', first_name='Test', surname='User', email_address='test.user.4245d4a0-6096-4080-b6d1-3ed6ef9e77b7@example.com')
test_keyboard = Keyboard(keyboard_id='e2cae0f6-683a-4955-9021-8e25890181b2', user_id='c2162805-cec3-4977-9ff4-c72f80a60a95', keyboard_name='Test Keyboard', target_ms_per_keystroke=600)

    def test_process_end_of_session_summarization_failure(db_with_tables, test_user, test_keyboard):
        """Fails at step 4: drop summary table to force summarization SQL to fail after n-grams."""
        from tests.models.conftest import TestSessionMethodsFixtures
    
>       category_id = TestSessionMethodsFixtures.create_category(db_with_tables)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_ngram_orchestrator_process_end_of_session.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:239: in create_category
    db.execute(
db\database_manager.py:539: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x0000021B35ACF070>
e = OperationalError('table categories has no column named description')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table categories has no column named description

db\database_manager.py:449: DatabaseError
---------------------------- Captured stdout call -----------------------------
Exception during query: table categories has no column named description. Rolling back transaction.
---------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 524, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table categories has no column named description
=========================== short test summary info ===========================
FAILED tests/models/test_dynamic_content_service.py::TestNGramOnlyMode::test_ngram_content_filters_out_of_scope_chars - AssertionError: Content should only include ngrams with in-scope keys
assert ('xy cd cd cd ab cd ab ab ab xy xy xy ab ab xy cd ab cd ab cd xy ab cd ab ab ab cd ab xy cd ab cd xy' == 'ab'
  
  - ab
  + xy cd cd cd ab cd ab ab ab xy xy xy ab ab xy cd ab cd ab cd xy ab cd ab ab ab cd ab xy cd ab cd xy or 'xy cd cd cd ab cd ab ab ab xy xy xy ab ab xy cd ab cd ab cd xy ab cd ab ab ab cd ab xy cd ab cd xy' == ''
  
  + xy cd cd cd ab cd ab ab ab xy xy xy ab ab xy cd ab cd ab cd xy ab cd ab ab ab cd ab xy cd ab cd xy)
FAILED tests/models/test_dynamic_content_service.py::TestWordsOnlyMode::test_generate_words_content - AttributeError: 'MockLLMNgramService' object has no attribute 'get_words_with_ngrams_by_wordcount'
FAILED tests/models/test_dynamic_content_service.py::TestWordsOnlyMode::test_words_content_filters_out_of_scope_chars - AttributeError: 'MockLLMNgramService' object has no attribute 'get_words_with_ngrams_by_wordcount'
FAILED tests/models/test_dynamic_content_service.py::TestWordsOnlyMode::test_words_content_custom_delimiter - AttributeError: 'MockLLMNgramService' object has no attribute 'get_words_with_ngrams_by_wordcount'
FAILED tests/models/test_dynamic_content_service.py::TestMixedMode::test_generate_mixed_content - AttributeError: 'MockLLMNgramService' object has no attribute 'get_words_with_ngrams_by_wordcount'
FAILED tests/models/test_dynamic_content_service.py::TestMixedMode::test_mixed_content_has_variety - AttributeError: 'MockLLMNgramService' object has no attribute 'get_words_with_ngrams_by_wordcount'
FAILED tests/models/test_keystroke_manager.py::TestKeystrokeManagerSaveKeystrokes::test_save_keystrokes_success - AssertionError: assert 0 == 3
 +  where 0 = <Mock name='mock.execute' id='2315878562656'>.call_count
 +    where <Mock name='mock.execute' id='2315878562656'> = <Mock spec='DatabaseManager' id='2315878562992'>.execute
 +      where <Mock spec='DatabaseManager' id='2315878562992'> = <models.keystroke_manager.KeystrokeManager object at 0x0000021B3554DE50>.db_manager
FAILED tests/models/test_keystroke_manager.py::TestKeystrokeManagerSaveKeystrokes::test_save_keystrokes_database_error - assert True is False
FAILED tests/models/test_keystroke_manager.py::TestKeystrokeManagerSaveKeystrokes::test_save_keystrokes_with_special_characters - assert 0 == 7
 +  where 0 = <Mock name='mock.execute' id='2315878559968'>.call_count
 +    where <Mock name='mock.execute' id='2315878559968'> = <Mock spec='DatabaseManager' id='2315878556944'>.execute
 +      where <Mock spec='DatabaseManager' id='2315878556944'> = <models.keystroke_manager.KeystrokeManager object at 0x0000021B3563FAF0>.db_manager
 +  and   7 = len(["'", '"', '\\', '\n', '\t', '\u20ac', '\U0001f60a'])
FAILED tests/models/test_keystroke_manager.py::TestKeystrokeManagerSaveKeystrokes::test_save_keystrokes_boolean_conversion - TypeError: 'NoneType' object is not subscriptable
FAILED tests/models/test_keystroke_manager.py::TestKeystrokeManagerIntegration::test_full_keystroke_workflow - assert False is True
FAILED tests/models/test_keystroke_manager.py::TestKeystrokeManagerEdgeCases::test_unicode_and_special_characters - assert 0 == 10
 +  where 0 = <Mock name='mock.execute' id='2315885119536'>.call_count
 +    where <Mock name='mock.execute' id='2315885119536'> = <Mock spec='DatabaseManager' id='2315885118192'>.execute
 +      where <Mock spec='DatabaseManager' id='2315885118192'> = <models.keystroke_manager.KeystrokeManager object at 0x0000021B35684830>.db_manager
 +  and   10 = len(['\U0001f642', '\u6d4b\u8bd5', 'caf\xe9', '\u03a9', '\n', '\t', '\\', "'", '"', '\x00'])
FAILED tests/models/test_keystroke_manager.py::TestKeystrokeManagerErrorHandling::test_database_connection_failure - assert True is False
FAILED tests/models/test_keystroke_manager.py::TestKeystrokeManagerErrorHandling::test_partial_save_failure - assert True is False
FAILED tests/models/test_keystroke_manager.py::TestKeystrokeManagerErrorHandling::test_network_timeout_simulation - assert True is False
FAILED tests/models/test_ngram.py::TestKeystroke::test_keystroke_nfc_single_char - AssertionError: assert 'e\\u0301' == '\\xe9'\n  \n  - \xe9\n  + e\u0301
FAILED tests/models/test_ngram_analytics_service.py::TestNGramAnalyticsService::test_dual_insert_creates_records_in_both_tables - AttributeError: 'str' object has no attribute 'execute'
FAILED tests/models/test_ngram_analytics_service.py::TestNGramAnalyticsService::test_history_table_accumulates_all_records - AttributeError: 'str' object has no attribute 'execute'
FAILED tests/models/test_ngram_analytics_service.py::TestNGramAnalyticsService::test_get_ngram_history_retrieval - AttributeError: 'str' object has no attribute 'execute'
FAILED tests/models/test_ngram_analytics_service.py::TestNGramAnalyticsService::test_history_table_schema_compatibility - AttributeError: 'str' object has no attribute 'fetchall'
FAILED tests/models/test_ngram_analytics_service_session_methods.py::TestAddSpeedSummaryForSession::test_nonexistent_session - Failed: DID NOT RAISE <class 'ValueError'>
FAILED tests/models/test_ngram_analytics_service_session_methods.py::TestCatchupSpeedSummary::test_empty_database_catchup - KeyError: 'total_sessions'
FAILED tests/models/test_ngram_orchestrator_process_end_of_session.py::test_process_end_of_session_success_path - db.exceptions.DatabaseError: Database operation failed: table categories has no column named description
FAILED tests/models/test_ngram_orchestrator_process_end_of_session.py::test_process_end_of_session_session_save_failure - db.exceptions.DatabaseError: Database operation failed: table categories has no column named description
FAILED tests/models/test_ngram_orchestrator_process_end_of_session.py::test_process_end_of_session_keystrokes_save_failure - db.exceptions.DatabaseError: Database operation failed: table categories has no column named description
FAILED tests/models/test_ngram_orchestrator_process_end_of_session.py::test_process_end_of_session_summarization_failure - db.exceptions.DatabaseError: Database operation failed: table categories has no column named description
ERROR tests/models/test_ngram_analytics_service.py::TestNGramAnalyticsService::test_refresh_speed_summaries_basic - db.exceptions.DatabaseError: Database operation failed: table snippets has no column named title
ERROR tests/models/test_ngram_analytics_service_session_methods.py::TestSummarizeSessionNgrams::test_summarize_with_ngram_speed_only[1-1] - db.exceptions.DatabaseError: Database operation failed: table categories has no column named description
ERROR tests/models/test_ngram_analytics_service_session_methods.py::TestSummarizeSessionNgrams::test_summarize_with_ngram_speed_only[3-3] - db.exceptions.DatabaseError: Database operation failed: table categories has no column named description
ERROR tests/models/test_ngram_analytics_service_session_methods.py::TestSummarizeSessionNgrams::test_summarize_with_ngram_errors_only[1-1] - db.exceptions.DatabaseError: Database operation failed: table categories has no column named description
ERROR tests/models/test_ngram_analytics_service_session_methods.py::TestSummarizeSessionNgrams::test_summarize_with_ngram_errors_only[2-2] - db.exceptions.DatabaseError: Database operation failed: table categories has no column named description
ERROR tests/models/test_ngram_analytics_service_session_methods.py::TestSummarizeSessionNgrams::test_summarize_with_speed_and_errors - db.exceptions.DatabaseError: Database operation failed: table categories has no column named description
ERROR tests/models/test_ngram_analytics_service_session_methods.py::TestSummarizeSessionNgrams::test_summarize_with_keystrokes[1-1] - db.exceptions.DatabaseError: Database operation failed: table categories has no column named description
ERROR tests/models/test_ngram_analytics_service_session_methods.py::TestSummarizeSessionNgrams::test_summarize_with_keystrokes[3-3] - db.exceptions.DatabaseError: Database operation failed: table categories has no column named description
ERROR tests/models/test_ngram_analytics_service_session_methods.py::TestSummarizeSessionNgrams::test_no_sessions_missing - db.exceptions.DatabaseError: Database operation failed: table categories has no column named description
ERROR tests/models/test_ngram_analytics_service_session_methods.py::TestSummarizeSessionNgrams::test_sessions_missing_no_data - db.exceptions.DatabaseError: Database operation failed: table categories has no column named description
ERROR tests/models/test_ngram_analytics_service_session_methods.py::TestAddSpeedSummaryForSession::test_single_session_processing - db.exceptions.DatabaseError: Database operation failed: table categories has no column named description
ERROR tests/models/test_ngram_analytics_service_session_methods.py::TestAddSpeedSummaryForSession::test_multiple_ngrams_processing - db.exceptions.DatabaseError: Database operation failed: table categories has no column named description
ERROR tests/models/test_ngram_analytics_service_session_methods.py::TestCatchupSpeedSummary::test_single_session_catchup - db.exceptions.DatabaseError: Database operation failed: table categories has no column named description
ERROR tests/models/test_ngram_analytics_service_session_methods.py::TestCatchupSpeedSummary::test_multiple_sessions_catchup - db.exceptions.DatabaseError: Database operation failed: table categories has no column named description
ERROR tests/models/test_ngram_analytics_service_session_methods.py::TestCatchupSpeedSummary::test_catchup_with_session_errors - db.exceptions.DatabaseError: Database operation failed: table categories has no column named description
ERROR tests/models/test_ngram_analytics_service_session_methods.py::TestIntegrationScenarios::test_full_workflow_integration - db.exceptions.DatabaseError: Database operation failed: table categories has no column named description
ERROR tests/models/test_snippet.py::test_snippet_ascii_name
ERROR tests/models/test_snippet.py::test_snippet_name_length
ERROR tests/models/test_snippet.py::test_snippet_creation_validation[Alpha-Some content-True]
ERROR tests/models/test_snippet.py::test_snippet_creation_validation[-Some content-False]
ERROR tests/models/test_snippet.py::test_snippet_creation_validation[AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA-Content-False]
ERROR tests/models/test_snippet.py::test_snippet_creation_validation[NonAscii\xe9-Content-False]
ERROR tests/models/test_snippet.py::test_snippet_creation_validation[Alpha--False]
ERROR tests/models/test_snippet.py::test_snippet_name_uniqueness[Unique1-Unique2-True]
ERROR tests/models/test_snippet.py::test_snippet_name_uniqueness[DupName-DupName-False]
ERROR tests/models/test_snippet.py::test_snippet_creation_valid
ERROR tests/models/test_snippet.py::test_get_nonexistent_snippet
ERROR tests/models/test_snippet.py::test_list_snippets_empty
ERROR tests/models/test_snippet.py::test_list_snippets_populated
ERROR tests/models/test_snippet.py::test_snippet_edit
ERROR tests/models/test_snippet.py::test_snippet_update
ERROR tests/models/test_snippet.py::test_snippet_update_name_only
ERROR tests/models/test_snippet.py::test_snippet_update_content_only
ERROR tests/models/test_snippet.py::test_snippet_delete
ERROR tests/models/test_snippet.py::test_delete_nonexistent_snippet
ERROR tests/models/test_snippet.py::test_edit_snippet_change_category
ERROR tests/models/test_snippet.py::test_edit_snippet_invalid_category
ERROR tests/models/test_snippet.py::test_snippet_sql_injection
ERROR tests/models/test_snippet.py::test_snippet_sql_injection_in_content
ERROR tests/models/test_snippet.py::test_snippet_long_content
ERROR tests/models/test_snippet.py::test_snippet_content_splitting_boundaries
ERROR tests/models/test_snippet.py::test_update_nonexistent_snippet
ERROR tests/models/test_snippet.py::test_snippet_part_number_sequence
ERROR tests/models/test_snippet.py::test_snippet_operation_handling
ERROR tests/models/test_snippet.py::test_delete_snippet
ERROR tests/models/test_snippet.py::test_create_snippet_with_nonexistent_category
ERROR tests/models/test_snippet.py::test_update_snippet_partial
ERROR tests/models/test_snippet.py::test_update_snippet_no_changes
ERROR tests/models/test_snippet.py::test_get_snippet_by_name
ERROR tests/models/test_snippet.py::test_get_snippet_by_name_nonexistent
ERROR tests/models/test_snippet.py::test_get_snippet_by_name_multiple_categories
ERROR tests/models/test_snippet.py::test_search_snippets
ERROR tests/models/test_snippet.py::test_search_snippets_no_results
ERROR tests/models/test_snippet.py::test_snippet_sql_injection_name_create
ERROR tests/models/test_snippet.py::test_snippet_sql_injection_content_create
ERROR tests/models/test_snippet.py::test_snippet_sql_injection_name_create_with_specific_error
ERROR tests/models/test_snippet.py::test_snippet_sql_injection_content_update
ERROR tests/models/test_snippet.py::test_snippet_sql_injection_name_update
ERROR tests/models/test_snippet.py::test_snippet_deletion_idempotency
ERROR tests/models/test_snippet.py::test_snippet_manager_handles_db_errors_gracefully_on_create
ERROR tests/models/test_snippet.py::test_snippet_manager_handles_db_errors_gracefully_on_get
ERROR tests/models/test_snippet.py::test_snippet_manager_handles_db_errors_gracefully_on_update
ERROR tests/models/test_snippet.py::test_snippet_manager_handles_db_errors_gracefully_on_delete
ERROR tests/models/test_snippet.py::test_snippet_manager_handles_db_errors_gracefully_on_list
ERROR tests/models/test_snippet.py::test_snippet_manager_handles_db_errors_gracefully_on_search
ERROR tests/models/test_snippet.py::test_create_snippet_pydantic_validation_errors
============ 26 failed, 417 passed, 4 skipped, 66 errors in 40.53s ============
============================= test session starts =============================
platform win32 -- Python 3.13.2, pytest-8.4.1, pluggy-1.6.0
PySide6 6.9.1 -- Qt runtime 6.9.1 -- Qt compiled 6.9.1
rootdir: D:\SeanDevLocal\AITypingTrainer
configfile: pytest.ini
plugins: anyio-4.10.0, cov-6.2.1, mock-3.14.1, qt-4.5.0
collected 513 items

tests\models\test_category.py .................                          [  3%]
tests\models\test_category_manager.py .............................      [  8%]
tests\models\test_dynamic_content_service.py ...............FFFFFF       [ 13%]
tests\models\test_keyboard.py ........                                   [ 14%]
tests\models\test_keyboard_manager.py .....                              [ 15%]
tests\models\test_keystroke.py ......................................... [ 23%]
...................................                                      [ 30%]
tests\models\test_keystroke_manager.py ..........F.FFF..............F... [ 36%]
F.F.FF....                                                               [ 38%]
tests\models\test_llm_ngram_service.py .......F                          [ 40%]
tests\models\test_next_session_position.py .....                         [ 41%]
tests\models\test_ngram.py .F............                                [ 44%]
tests\models\test_ngram_analytics_service.py ......EssssFFFF...          [ 47%]
tests\models\test_ngram_analytics_service_session_methods.py EEEEEEEEEEF [ 49%]
EFEEEE                                                                   [ 50%]
tests\models\test_ngram_manager.py .....                                 [ 51%]
tests\models\test_ngram_orchestrator_process_end_of_session.py FFFF      [ 52%]
tests\models\test_session.py ..........................................  [ 60%]
tests\models\test_session_manager.py ........                            [ 62%]
tests\models\test_setting.py ..................                          [ 65%]
tests\models\test_setting_manager.py ...................                 [ 69%]
tests\models\test_simple.py .                                            [ 69%]
tests\models\test_snippet.py ...E.E..EEEEEEEEEEEEEEEEEEEEEEEEE.EEEEEEEEE [ 78%]
EEEEEEEEEEEEEE                                                           [ 80%]
tests\models\test_snippet_manager.py ....................                [ 84%]
tests\models\test_user.py .............................................. [ 93%]
......                                                                   [ 94%]
tests\models\test_user_manager.py .........                              [ 96%]
tests\models\test_user_manager_fixes.py .................                [100%]

=================================== ERRORS ====================================
_ ERROR at setup of TestNGramAnalyticsService.test_refresh_speed_summaries_basic _

self = <db.database_manager.DatabaseManager object at 0x000002184C46DE10>
query = 'INSERT INTO snippets (snippet_id, category_id, title, content, difficulty_level) VALUES (?, ?, ?, ?, ?)'
params = ('snippet_1', 'cat_1', 'Snippet', 'content', 1)

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table snippets has no column named title

db\database_manager.py:524: OperationalError

The above exception was the direct cause of the following exception:

item = <Function test_refresh_speed_summaries_basic>

    @pytest.hookimpl(wrapper=True, tryfirst=True)
    def pytest_runtest_setup(item):
        """
        Hook called after before test setup starts, to start capturing exceptions
        as early as possible.
        """
        capture_enabled = _is_exception_capture_enabled(item)
        if capture_enabled:
            item.qt_exception_capture_manager = _QtExceptionCaptureManager()
            item.qt_exception_capture_manager.start()
>       result = yield
                 ^^^^^

.venv\Lib\site-packages\pytestqt\plugin.py:178: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:321: in ngram_speed_test_data
    db_with_tables.execute(
db\database_manager.py:539: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x000002184C46DE10>
e = OperationalError('table snippets has no column named title')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table snippets has no column named title

db\database_manager.py:449: DatabaseError
---------------------------- Captured stdout setup ----------------------------
Exception during query: table snippets has no column named title. Rolling back transaction.
---------------------------- Captured stderr setup ----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 524, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table snippets has no column named title
_ ERROR at setup of TestSummarizeSessionNgrams.test_summarize_with_ngram_speed_only[1-1] _

self = <db.database_manager.DatabaseManager object at 0x000002184DD33150>
query = '\n            INSERT INTO categories (category_id, category_name, description)\n            VALUES (?, ?, ?)\n            '
params = ('3a577a62-389e-4f02-9f5c-9f5f847c4511', 'Test Category', 'Test category for testing')

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table categories has no column named description

db\database_manager.py:524: OperationalError

The above exception was the direct cause of the following exception:

db_with_tables = <db.database_manager.DatabaseManager object at 0x000002184DD33150>
test_user = User(user_id='1d6889e2-dd04-4c27-819e-f92edd47b0a5', first_name='Test', surname='User', email_address='test.user.4c4cde50-7313-4964-8243-8bff7b6056fb@example.com')
test_keyboard = Keyboard(keyboard_id='56b484b2-f35d-4959-b313-7c9611108c7e', user_id='1d6889e2-dd04-4c27-819e-f92edd47b0a5', keyboard_name='Test Keyboard', target_ms_per_keystroke=600)

    @pytest.fixture
    def test_data_setup(db_with_tables: DatabaseManager, test_user: User, test_keyboard: Keyboard) -> Dict[str, Any]:
        """Set up comprehensive test data for session analytics tests."""
        db = db_with_tables
    
        # Create category and snippet
>       category_id = TestSessionMethodsFixtures.create_category(db)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_ngram_analytics_service_session_methods.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:239: in create_category
    db.execute(
db\database_manager.py:539: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x000002184DD33150>
e = OperationalError('table categories has no column named description')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table categories has no column named description

db\database_manager.py:449: DatabaseError
---------------------------- Captured stdout setup ----------------------------
Exception during query: table categories has no column named description. Rolling back transaction.
---------------------------- Captured stderr setup ----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 524, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table categories has no column named description
_ ERROR at setup of TestSummarizeSessionNgrams.test_summarize_with_ngram_speed_only[3-3] _

self = <db.database_manager.DatabaseManager object at 0x000002184DD33000>
query = '\n            INSERT INTO categories (category_id, category_name, description)\n            VALUES (?, ?, ?)\n            '
params = ('78ee2379-d488-41e3-a800-b457ef6aab2f', 'Test Category', 'Test category for testing')

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table categories has no column named description

db\database_manager.py:524: OperationalError

The above exception was the direct cause of the following exception:

db_with_tables = <db.database_manager.DatabaseManager object at 0x000002184DD33000>
test_user = User(user_id='bcfa13d2-543c-4dde-8a2a-d81539d51918', first_name='Test', surname='User', email_address='test.user.cfbf369a-2452-404e-a690-95dd4dd7012d@example.com')
test_keyboard = Keyboard(keyboard_id='98a52003-d2bd-4100-adac-38ae0a2ec1da', user_id='bcfa13d2-543c-4dde-8a2a-d81539d51918', keyboard_name='Test Keyboard', target_ms_per_keystroke=600)

    @pytest.fixture
    def test_data_setup(db_with_tables: DatabaseManager, test_user: User, test_keyboard: Keyboard) -> Dict[str, Any]:
        """Set up comprehensive test data for session analytics tests."""
        db = db_with_tables
    
        # Create category and snippet
>       category_id = TestSessionMethodsFixtures.create_category(db)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_ngram_analytics_service_session_methods.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:239: in create_category
    db.execute(
db\database_manager.py:539: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x000002184DD33000>
e = OperationalError('table categories has no column named description')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table categories has no column named description

db\database_manager.py:449: DatabaseError
---------------------------- Captured stdout setup ----------------------------
Exception during query: table categories has no column named description. Rolling back transaction.
---------------------------- Captured stderr setup ----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 524, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table categories has no column named description
_ ERROR at setup of TestSummarizeSessionNgrams.test_summarize_with_ngram_errors_only[1-1] _

self = <db.database_manager.DatabaseManager object at 0x000002184C494670>
query = '\n            INSERT INTO categories (category_id, category_name, description)\n            VALUES (?, ?, ?)\n            '
params = ('1d2f5232-632f-4aa8-845f-cbec3d29a0d1', 'Test Category', 'Test category for testing')

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table categories has no column named description

db\database_manager.py:524: OperationalError

The above exception was the direct cause of the following exception:

db_with_tables = <db.database_manager.DatabaseManager object at 0x000002184C494670>
test_user = User(user_id='75872a53-aa55-45b3-b697-cb5ede335237', first_name='Test', surname='User', email_address='test.user.349fb426-84f0-41c1-b902-109b9fd14278@example.com')
test_keyboard = Keyboard(keyboard_id='06dc872e-465c-4eeb-a00b-917db070cef4', user_id='75872a53-aa55-45b3-b697-cb5ede335237', keyboard_name='Test Keyboard', target_ms_per_keystroke=600)

    @pytest.fixture
    def test_data_setup(db_with_tables: DatabaseManager, test_user: User, test_keyboard: Keyboard) -> Dict[str, Any]:
        """Set up comprehensive test data for session analytics tests."""
        db = db_with_tables
    
        # Create category and snippet
>       category_id = TestSessionMethodsFixtures.create_category(db)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_ngram_analytics_service_session_methods.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:239: in create_category
    db.execute(
db\database_manager.py:539: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x000002184C494670>
e = OperationalError('table categories has no column named description')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table categories has no column named description

db\database_manager.py:449: DatabaseError
---------------------------- Captured stdout setup ----------------------------
Exception during query: table categories has no column named description. Rolling back transaction.
---------------------------- Captured stderr setup ----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 524, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table categories has no column named description
_ ERROR at setup of TestSummarizeSessionNgrams.test_summarize_with_ngram_errors_only[2-2] _

self = <db.database_manager.DatabaseManager object at 0x000002184DE08210>
query = '\n            INSERT INTO categories (category_id, category_name, description)\n            VALUES (?, ?, ?)\n            '
params = ('8c5ce4b8-8c17-4124-9539-8d9f2595dbef', 'Test Category', 'Test category for testing')

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table categories has no column named description

db\database_manager.py:524: OperationalError

The above exception was the direct cause of the following exception:

db_with_tables = <db.database_manager.DatabaseManager object at 0x000002184DE08210>
test_user = User(user_id='4ab4f2e5-7952-45a8-a10b-54faab673153', first_name='Test', surname='User', email_address='test.user.ed1a43bf-d765-4ae8-af86-8295eda0e132@example.com')
test_keyboard = Keyboard(keyboard_id='88474e2d-36c4-4fda-a5fe-2409ef1d39d2', user_id='4ab4f2e5-7952-45a8-a10b-54faab673153', keyboard_name='Test Keyboard', target_ms_per_keystroke=600)

    @pytest.fixture
    def test_data_setup(db_with_tables: DatabaseManager, test_user: User, test_keyboard: Keyboard) -> Dict[str, Any]:
        """Set up comprehensive test data for session analytics tests."""
        db = db_with_tables
    
        # Create category and snippet
>       category_id = TestSessionMethodsFixtures.create_category(db)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_ngram_analytics_service_session_methods.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:239: in create_category
    db.execute(
db\database_manager.py:539: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x000002184DE08210>
e = OperationalError('table categories has no column named description')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table categories has no column named description

db\database_manager.py:449: DatabaseError
---------------------------- Captured stdout setup ----------------------------
Exception during query: table categories has no column named description. Rolling back transaction.
---------------------------- Captured stderr setup ----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 524, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table categories has no column named description
_ ERROR at setup of TestSummarizeSessionNgrams.test_summarize_with_speed_and_errors _

self = <db.database_manager.DatabaseManager object at 0x000002184DE08980>
query = '\n            INSERT INTO categories (category_id, category_name, description)\n            VALUES (?, ?, ?)\n            '
params = ('b9bc0208-973a-4988-955b-a57d481b532c', 'Test Category', 'Test category for testing')

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table categories has no column named description

db\database_manager.py:524: OperationalError

The above exception was the direct cause of the following exception:

db_with_tables = <db.database_manager.DatabaseManager object at 0x000002184DE08980>
test_user = User(user_id='9c1609a2-b3af-47f7-99e5-bdc3f86eeb11', first_name='Test', surname='User', email_address='test.user.5426a58e-07af-4af0-b1b4-72f7cd306797@example.com')
test_keyboard = Keyboard(keyboard_id='e61b88e1-4fe4-4f82-b3ab-b48ced9e0a09', user_id='9c1609a2-b3af-47f7-99e5-bdc3f86eeb11', keyboard_name='Test Keyboard', target_ms_per_keystroke=600)

    @pytest.fixture
    def test_data_setup(db_with_tables: DatabaseManager, test_user: User, test_keyboard: Keyboard) -> Dict[str, Any]:
        """Set up comprehensive test data for session analytics tests."""
        db = db_with_tables
    
        # Create category and snippet
>       category_id = TestSessionMethodsFixtures.create_category(db)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_ngram_analytics_service_session_methods.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:239: in create_category
    db.execute(
db\database_manager.py:539: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x000002184DE08980>
e = OperationalError('table categories has no column named description')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table categories has no column named description

db\database_manager.py:449: DatabaseError
---------------------------- Captured stdout setup ----------------------------
Exception during query: table categories has no column named description. Rolling back transaction.
---------------------------- Captured stderr setup ----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 524, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table categories has no column named description
_ ERROR at setup of TestSummarizeSessionNgrams.test_summarize_with_keystrokes[1-1] _

self = <db.database_manager.DatabaseManager object at 0x000002184DE08F30>
query = '\n            INSERT INTO categories (category_id, category_name, description)\n            VALUES (?, ?, ?)\n            '
params = ('54609414-0dfe-4e2e-951a-8966f48e0106', 'Test Category', 'Test category for testing')

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table categories has no column named description

db\database_manager.py:524: OperationalError

The above exception was the direct cause of the following exception:

db_with_tables = <db.database_manager.DatabaseManager object at 0x000002184DE08F30>
test_user = User(user_id='8af0f8b7-20f3-49b2-9f07-b24273824cea', first_name='Test', surname='User', email_address='test.user.5ff25989-b2a2-4069-9f52-78b2015ab7d7@example.com')
test_keyboard = Keyboard(keyboard_id='27897ce2-1fd0-443f-991d-0ca2b4540a53', user_id='8af0f8b7-20f3-49b2-9f07-b24273824cea', keyboard_name='Test Keyboard', target_ms_per_keystroke=600)

    @pytest.fixture
    def test_data_setup(db_with_tables: DatabaseManager, test_user: User, test_keyboard: Keyboard) -> Dict[str, Any]:
        """Set up comprehensive test data for session analytics tests."""
        db = db_with_tables
    
        # Create category and snippet
>       category_id = TestSessionMethodsFixtures.create_category(db)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_ngram_analytics_service_session_methods.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:239: in create_category
    db.execute(
db\database_manager.py:539: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x000002184DE08F30>
e = OperationalError('table categories has no column named description')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table categories has no column named description

db\database_manager.py:449: DatabaseError
---------------------------- Captured stdout setup ----------------------------
Exception during query: table categories has no column named description. Rolling back transaction.
---------------------------- Captured stderr setup ----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 524, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table categories has no column named description
_ ERROR at setup of TestSummarizeSessionNgrams.test_summarize_with_keystrokes[3-3] _

self = <db.database_manager.DatabaseManager object at 0x000002184DE0B700>
query = '\n            INSERT INTO categories (category_id, category_name, description)\n            VALUES (?, ?, ?)\n            '
params = ('c06d781b-36b8-4355-abf2-b083267da4d6', 'Test Category', 'Test category for testing')

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table categories has no column named description

db\database_manager.py:524: OperationalError

The above exception was the direct cause of the following exception:

db_with_tables = <db.database_manager.DatabaseManager object at 0x000002184DE0B700>
test_user = User(user_id='cb4d5c48-b95b-492e-9cf8-766b319b661c', first_name='Test', surname='User', email_address='test.user.7e3a0d3d-c352-4287-ac6d-20ec501a4597@example.com')
test_keyboard = Keyboard(keyboard_id='d7b1e232-686f-4cd9-999c-9a9f870c6a28', user_id='cb4d5c48-b95b-492e-9cf8-766b319b661c', keyboard_name='Test Keyboard', target_ms_per_keystroke=600)

    @pytest.fixture
    def test_data_setup(db_with_tables: DatabaseManager, test_user: User, test_keyboard: Keyboard) -> Dict[str, Any]:
        """Set up comprehensive test data for session analytics tests."""
        db = db_with_tables
    
        # Create category and snippet
>       category_id = TestSessionMethodsFixtures.create_category(db)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_ngram_analytics_service_session_methods.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:239: in create_category
    db.execute(
db\database_manager.py:539: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x000002184DE0B700>
e = OperationalError('table categories has no column named description')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table categories has no column named description

db\database_manager.py:449: DatabaseError
---------------------------- Captured stdout setup ----------------------------
Exception during query: table categories has no column named description. Rolling back transaction.
---------------------------- Captured stderr setup ----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 524, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table categories has no column named description
____ ERROR at setup of TestSummarizeSessionNgrams.test_no_sessions_missing ____

self = <db.database_manager.DatabaseManager object at 0x000002184DE0B930>
query = '\n            INSERT INTO categories (category_id, category_name, description)\n            VALUES (?, ?, ?)\n            '
params = ('b196c899-dd75-4f79-a064-cd5bda7ac18c', 'Test Category', 'Test category for testing')

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table categories has no column named description

db\database_manager.py:524: OperationalError

The above exception was the direct cause of the following exception:

db_with_tables = <db.database_manager.DatabaseManager object at 0x000002184DE0B930>
test_user = User(user_id='14711c89-5529-4e6d-aec4-e3bf94c2f1ba', first_name='Test', surname='User', email_address='test.user.8e484fa0-9063-4f1a-8166-05d993bd3b7d@example.com')
test_keyboard = Keyboard(keyboard_id='4f14f08d-a527-4d88-9a62-0bae5e5bbaf3', user_id='14711c89-5529-4e6d-aec4-e3bf94c2f1ba', keyboard_name='Test Keyboard', target_ms_per_keystroke=600)

    @pytest.fixture
    def test_data_setup(db_with_tables: DatabaseManager, test_user: User, test_keyboard: Keyboard) -> Dict[str, Any]:
        """Set up comprehensive test data for session analytics tests."""
        db = db_with_tables
    
        # Create category and snippet
>       category_id = TestSessionMethodsFixtures.create_category(db)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_ngram_analytics_service_session_methods.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:239: in create_category
    db.execute(
db\database_manager.py:539: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x000002184DE0B930>
e = OperationalError('table categories has no column named description')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table categories has no column named description

db\database_manager.py:449: DatabaseError
---------------------------- Captured stdout setup ----------------------------
Exception during query: table categories has no column named description. Rolling back transaction.
---------------------------- Captured stderr setup ----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 524, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table categories has no column named description
_ ERROR at setup of TestSummarizeSessionNgrams.test_sessions_missing_no_data __

self = <db.database_manager.DatabaseManager object at 0x000002184DE08980>
query = '\n            INSERT INTO categories (category_id, category_name, description)\n            VALUES (?, ?, ?)\n            '
params = ('5f417654-f1ef-402f-a5f3-6d4f31df1ffe', 'Test Category', 'Test category for testing')

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table categories has no column named description

db\database_manager.py:524: OperationalError

The above exception was the direct cause of the following exception:

db_with_tables = <db.database_manager.DatabaseManager object at 0x000002184DE08980>
test_user = User(user_id='a0b0fb2d-90e2-4bd3-8dc1-24aaf4a6a969', first_name='Test', surname='User', email_address='test.user.a5eb4fac-13ed-4d83-b052-1f087db8fa2f@example.com')
test_keyboard = Keyboard(keyboard_id='69066ece-dc00-4a58-bb07-c87f6e95b055', user_id='a0b0fb2d-90e2-4bd3-8dc1-24aaf4a6a969', keyboard_name='Test Keyboard', target_ms_per_keystroke=600)

    @pytest.fixture
    def test_data_setup(db_with_tables: DatabaseManager, test_user: User, test_keyboard: Keyboard) -> Dict[str, Any]:
        """Set up comprehensive test data for session analytics tests."""
        db = db_with_tables
    
        # Create category and snippet
>       category_id = TestSessionMethodsFixtures.create_category(db)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_ngram_analytics_service_session_methods.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:239: in create_category
    db.execute(
db\database_manager.py:539: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x000002184DE08980>
e = OperationalError('table categories has no column named description')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table categories has no column named description

db\database_manager.py:449: DatabaseError
---------------------------- Captured stdout setup ----------------------------
Exception during query: table categories has no column named description. Rolling back transaction.
---------------------------- Captured stderr setup ----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 524, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table categories has no column named description
_ ERROR at setup of TestAddSpeedSummaryForSession.test_single_session_processing _

self = <db.database_manager.DatabaseManager object at 0x000002184DDFD010>
query = '\n            INSERT INTO categories (category_id, category_name, description)\n            VALUES (?, ?, ?)\n            '
params = ('85439f97-dd4b-423d-b312-de9e308aa854', 'Test Category', 'Test category for testing')

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table categories has no column named description

db\database_manager.py:524: OperationalError

The above exception was the direct cause of the following exception:

db_with_tables = <db.database_manager.DatabaseManager object at 0x000002184DDFD010>
test_user = User(user_id='9ef9dad1-35b7-4c66-a1db-e6f929a389d3', first_name='Test', surname='User', email_address='test.user.bef040f2-09a9-420a-96a0-6d2e7f44369e@example.com')
test_keyboard = Keyboard(keyboard_id='60b61734-724a-41eb-8350-8e323890c239', user_id='9ef9dad1-35b7-4c66-a1db-e6f929a389d3', keyboard_name='Test Keyboard', target_ms_per_keystroke=600)

    @pytest.fixture
    def test_data_setup(db_with_tables: DatabaseManager, test_user: User, test_keyboard: Keyboard) -> Dict[str, Any]:
        """Set up comprehensive test data for session analytics tests."""
        db = db_with_tables
    
        # Create category and snippet
>       category_id = TestSessionMethodsFixtures.create_category(db)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_ngram_analytics_service_session_methods.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:239: in create_category
    db.execute(
db\database_manager.py:539: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x000002184DDFD010>
e = OperationalError('table categories has no column named description')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table categories has no column named description

db\database_manager.py:449: DatabaseError
---------------------------- Captured stdout setup ----------------------------
Exception during query: table categories has no column named description. Rolling back transaction.
---------------------------- Captured stderr setup ----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 524, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table categories has no column named description
_ ERROR at setup of TestAddSpeedSummaryForSession.test_multiple_ngrams_processing _

self = <db.database_manager.DatabaseManager object at 0x000002184DDFF0E0>
query = '\n            INSERT INTO categories (category_id, category_name, description)\n            VALUES (?, ?, ?)\n            '
params = ('f99189e4-d23d-476a-b673-031c820f04d1', 'Test Category', 'Test category for testing')

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table categories has no column named description

db\database_manager.py:524: OperationalError

The above exception was the direct cause of the following exception:

db_with_tables = <db.database_manager.DatabaseManager object at 0x000002184DDFF0E0>
test_user = User(user_id='67c5eb3a-72d0-4efc-97de-7893f0f2c915', first_name='Test', surname='User', email_address='test.user.efdf49bb-9c95-48c9-9ff0-03935cca7384@example.com')
test_keyboard = Keyboard(keyboard_id='3fe6b67d-afd3-46f4-b2df-f9753140fdc8', user_id='67c5eb3a-72d0-4efc-97de-7893f0f2c915', keyboard_name='Test Keyboard', target_ms_per_keystroke=600)

    @pytest.fixture
    def test_data_setup(db_with_tables: DatabaseManager, test_user: User, test_keyboard: Keyboard) -> Dict[str, Any]:
        """Set up comprehensive test data for session analytics tests."""
        db = db_with_tables
    
        # Create category and snippet
>       category_id = TestSessionMethodsFixtures.create_category(db)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_ngram_analytics_service_session_methods.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:239: in create_category
    db.execute(
db\database_manager.py:539: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x000002184DDFF0E0>
e = OperationalError('table categories has no column named description')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table categories has no column named description

db\database_manager.py:449: DatabaseError
---------------------------- Captured stdout setup ----------------------------
Exception during query: table categories has no column named description. Rolling back transaction.
---------------------------- Captured stderr setup ----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 524, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table categories has no column named description
____ ERROR at setup of TestCatchupSpeedSummary.test_single_session_catchup ____

self = <db.database_manager.DatabaseManager object at 0x000002184DDFFE70>
query = '\n            INSERT INTO categories (category_id, category_name, description)\n            VALUES (?, ?, ?)\n            '
params = ('d4991122-640e-4a1f-b27f-c2e1abeb604b', 'Test Category', 'Test category for testing')

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table categories has no column named description

db\database_manager.py:524: OperationalError

The above exception was the direct cause of the following exception:

db_with_tables = <db.database_manager.DatabaseManager object at 0x000002184DDFFE70>
test_user = User(user_id='72c9cba7-0fde-472b-9427-83499ae863b2', first_name='Test', surname='User', email_address='test.user.3b395679-2037-413e-9040-eaf2d7d33ecb@example.com')
test_keyboard = Keyboard(keyboard_id='398117b7-3125-479c-a680-0639343d475e', user_id='72c9cba7-0fde-472b-9427-83499ae863b2', keyboard_name='Test Keyboard', target_ms_per_keystroke=600)

    @pytest.fixture
    def test_data_setup(db_with_tables: DatabaseManager, test_user: User, test_keyboard: Keyboard) -> Dict[str, Any]:
        """Set up comprehensive test data for session analytics tests."""
        db = db_with_tables
    
        # Create category and snippet
>       category_id = TestSessionMethodsFixtures.create_category(db)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_ngram_analytics_service_session_methods.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:239: in create_category
    db.execute(
db\database_manager.py:539: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x000002184DDFFE70>
e = OperationalError('table categories has no column named description')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table categories has no column named description

db\database_manager.py:449: DatabaseError
---------------------------- Captured stdout setup ----------------------------
Exception during query: table categories has no column named description. Rolling back transaction.
---------------------------- Captured stderr setup ----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 524, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table categories has no column named description
__ ERROR at setup of TestCatchupSpeedSummary.test_multiple_sessions_catchup ___

self = <db.database_manager.DatabaseManager object at 0x000002184DDFD9B0>
query = '\n            INSERT INTO categories (category_id, category_name, description)\n            VALUES (?, ?, ?)\n            '
params = ('8ca8ee9e-fa7c-4fd5-8e17-b47c34468356', 'Test Category', 'Test category for testing')

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table categories has no column named description

db\database_manager.py:524: OperationalError

The above exception was the direct cause of the following exception:

db_with_tables = <db.database_manager.DatabaseManager object at 0x000002184DDFD9B0>
test_user = User(user_id='734d4071-e270-4743-a302-ad68392440bb', first_name='Test', surname='User', email_address='test.user.436270dd-c0ca-4c43-98ad-4e688b494c5d@example.com')
test_keyboard = Keyboard(keyboard_id='24a93627-50f7-4527-b384-ebf39db0a7bb', user_id='734d4071-e270-4743-a302-ad68392440bb', keyboard_name='Test Keyboard', target_ms_per_keystroke=600)

    @pytest.fixture
    def test_data_setup(db_with_tables: DatabaseManager, test_user: User, test_keyboard: Keyboard) -> Dict[str, Any]:
        """Set up comprehensive test data for session analytics tests."""
        db = db_with_tables
    
        # Create category and snippet
>       category_id = TestSessionMethodsFixtures.create_category(db)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_ngram_analytics_service_session_methods.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:239: in create_category
    db.execute(
db\database_manager.py:539: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x000002184DDFD9B0>
e = OperationalError('table categories has no column named description')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table categories has no column named description

db\database_manager.py:449: DatabaseError
---------------------------- Captured stdout setup ----------------------------
Exception during query: table categories has no column named description. Rolling back transaction.
---------------------------- Captured stderr setup ----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 524, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table categories has no column named description
_ ERROR at setup of TestCatchupSpeedSummary.test_catchup_with_session_errors __

self = <db.database_manager.DatabaseManager object at 0x000002184DDFC4B0>
query = '\n            INSERT INTO categories (category_id, category_name, description)\n            VALUES (?, ?, ?)\n            '
params = ('7b758bbf-7590-4ded-9374-04a983e73dd8', 'Test Category', 'Test category for testing')

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table categories has no column named description

db\database_manager.py:524: OperationalError

The above exception was the direct cause of the following exception:

db_with_tables = <db.database_manager.DatabaseManager object at 0x000002184DDFC4B0>
test_user = User(user_id='2e942758-63b5-4d83-8281-4503a7b51beb', first_name='Test', surname='User', email_address='test.user.48b0690c-9c22-411a-822c-bdbea2278b65@example.com')
test_keyboard = Keyboard(keyboard_id='2ee990c2-1e73-47d5-b7f1-101ab899270f', user_id='2e942758-63b5-4d83-8281-4503a7b51beb', keyboard_name='Test Keyboard', target_ms_per_keystroke=600)

    @pytest.fixture
    def test_data_setup(db_with_tables: DatabaseManager, test_user: User, test_keyboard: Keyboard) -> Dict[str, Any]:
        """Set up comprehensive test data for session analytics tests."""
        db = db_with_tables
    
        # Create category and snippet
>       category_id = TestSessionMethodsFixtures.create_category(db)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_ngram_analytics_service_session_methods.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:239: in create_category
    db.execute(
db\database_manager.py:539: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x000002184DDFC4B0>
e = OperationalError('table categories has no column named description')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table categories has no column named description

db\database_manager.py:449: DatabaseError
---------------------------- Captured stdout setup ----------------------------
Exception during query: table categories has no column named description. Rolling back transaction.
---------------------------- Captured stderr setup ----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 524, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table categories has no column named description
__ ERROR at setup of TestIntegrationScenarios.test_full_workflow_integration __

self = <db.database_manager.DatabaseManager object at 0x000002184C4958D0>
query = '\n            INSERT INTO categories (category_id, category_name, description)\n            VALUES (?, ?, ?)\n            '
params = ('a5ade637-c28c-4d7f-84eb-17d526668717', 'Test Category', 'Test category for testing')

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table categories has no column named description

db\database_manager.py:524: OperationalError

The above exception was the direct cause of the following exception:

db_with_tables = <db.database_manager.DatabaseManager object at 0x000002184C4958D0>
test_user = User(user_id='12512264-cf59-47b6-82c8-0ce2ac3f2998', first_name='Test', surname='User', email_address='test.user.f51eec75-a7c4-47f7-9a3e-88a55f8a24c1@example.com')
test_keyboard = Keyboard(keyboard_id='d03b30cc-cf9d-4a98-a256-1f761a407acf', user_id='12512264-cf59-47b6-82c8-0ce2ac3f2998', keyboard_name='Test Keyboard', target_ms_per_keystroke=600)

    @pytest.fixture
    def test_data_setup(db_with_tables: DatabaseManager, test_user: User, test_keyboard: Keyboard) -> Dict[str, Any]:
        """Set up comprehensive test data for session analytics tests."""
        db = db_with_tables
    
        # Create category and snippet
>       category_id = TestSessionMethodsFixtures.create_category(db)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_ngram_analytics_service_session_methods.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:239: in create_category
    db.execute(
db\database_manager.py:539: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x000002184C4958D0>
e = OperationalError('table categories has no column named description')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table categories has no column named description

db\database_manager.py:449: DatabaseError
---------------------------- Captured stdout setup ----------------------------
Exception during query: table categories has no column named description. Rolling back transaction.
---------------------------- Captured stderr setup ----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 524, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table categories has no column named description
__________________ ERROR at setup of test_snippet_ascii_name __________________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 64
  def test_snippet_ascii_name(valid_snippet_data: Dict[str, str]) -> None:
E       fixture 'valid_snippet_data' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:64
_________________ ERROR at setup of test_snippet_name_length __________________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 86
  def test_snippet_name_length(valid_snippet_data: Dict[str, Union[str, str]]) -> None:
E       fixture 'valid_snippet_data' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:86
_ ERROR at setup of test_snippet_creation_validation[Alpha-Some content-True] _
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 117
  @pytest.mark.parametrize(
      "name,content,expect_success",
      [
          ("Alpha", "Some content", True),
          ("", "Some content", False),  # Validation for name
          ("A" * 129, "Content", False),  # Validation for name length
          ("NonAscii", "Content", False),  # Validation for name ASCII
          ("Alpha", "", False),  # Validation for content
      ],
  )
  def test_snippet_creation_validation(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:117
___ ERROR at setup of test_snippet_creation_validation[-Some content-False] ___
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 117
  @pytest.mark.parametrize(
      "name,content,expect_success",
      [
          ("Alpha", "Some content", True),
          ("", "Some content", False),  # Validation for name
          ("A" * 129, "Content", False),  # Validation for name length
          ("NonAscii", "Content", False),  # Validation for name ASCII
          ("Alpha", "", False),  # Validation for content
      ],
  )
  def test_snippet_creation_validation(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:117
_ ERROR at setup of test_snippet_creation_validation[AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA-Content-False] _
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 117
  @pytest.mark.parametrize(
      "name,content,expect_success",
      [
          ("Alpha", "Some content", True),
          ("", "Some content", False),  # Validation for name
          ("A" * 129, "Content", False),  # Validation for name length
          ("NonAscii", "Content", False),  # Validation for name ASCII
          ("Alpha", "", False),  # Validation for content
      ],
  )
  def test_snippet_creation_validation(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:117
_ ERROR at setup of test_snippet_creation_validation[NonAscii\xe9-Content-False] _
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 117
  @pytest.mark.parametrize(
      "name,content,expect_success",
      [
          ("Alpha", "Some content", True),
          ("", "Some content", False),  # Validation for name
          ("A" * 129, "Content", False),  # Validation for name length
          ("NonAscii", "Content", False),  # Validation for name ASCII
          ("Alpha", "", False),  # Validation for content
      ],
  )
  def test_snippet_creation_validation(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:117
______ ERROR at setup of test_snippet_creation_validation[Alpha--False] _______
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 117
  @pytest.mark.parametrize(
      "name,content,expect_success",
      [
          ("Alpha", "Some content", True),
          ("", "Some content", False),  # Validation for name
          ("A" * 129, "Content", False),  # Validation for name length
          ("NonAscii", "Content", False),  # Validation for name ASCII
          ("Alpha", "", False),  # Validation for content
      ],
  )
  def test_snippet_creation_validation(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:117
____ ERROR at setup of test_snippet_name_uniqueness[Unique1-Unique2-True] _____
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 150
  @pytest.mark.parametrize(
      "name1,name2,should_succeed",
      [
          ("Unique1", "Unique2", True),
          ("DupName", "DupName", False),
      ],
  )
  def test_snippet_name_uniqueness(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:150
____ ERROR at setup of test_snippet_name_uniqueness[DupName-DupName-False] ____
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 150
  @pytest.mark.parametrize(
      "name1,name2,should_succeed",
      [
          ("Unique1", "Unique2", True),
          ("DupName", "DupName", False),
      ],
  )
  def test_snippet_name_uniqueness(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:150
________________ ERROR at setup of test_snippet_creation_valid ________________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 175
  def test_snippet_creation_valid(
E       fixture 'snippet_manager' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:175
_______________ ERROR at setup of test_get_nonexistent_snippet ________________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 193
  def test_get_nonexistent_snippet(snippet_manager: SnippetManager) -> None:
E       fixture 'snippet_manager' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:193
_________________ ERROR at setup of test_list_snippets_empty __________________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 198
  def test_list_snippets_empty(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:198
_______________ ERROR at setup of test_list_snippets_populated ________________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 218
  def test_list_snippets_populated(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:218
_____________________ ERROR at setup of test_snippet_edit _____________________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 241
  def test_snippet_edit(
E       fixture 'snippet_manager' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:241
____________________ ERROR at setup of test_snippet_update ____________________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 260
  def test_snippet_update(snippet_category_fixture: str, snippet_manager: SnippetManager) -> None:
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:260
_______________ ERROR at setup of test_snippet_update_name_only _______________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 274
  def test_snippet_update_name_only(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:274
_____________ ERROR at setup of test_snippet_update_content_only ______________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 291
  def test_snippet_update_content_only(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:291
____________________ ERROR at setup of test_snippet_delete ____________________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 308
  def test_snippet_delete(snippet_category_fixture: str, snippet_manager: SnippetManager) -> None:
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:308
______________ ERROR at setup of test_delete_nonexistent_snippet ______________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 317
  def test_delete_nonexistent_snippet(snippet_manager: SnippetManager) -> None:
E       fixture 'snippet_manager' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:317
_____________ ERROR at setup of test_edit_snippet_change_category _____________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 328
  def test_edit_snippet_change_category(
E       fixture 'snippet_manager' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:328
____________ ERROR at setup of test_edit_snippet_invalid_category _____________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 351
  def test_edit_snippet_invalid_category(
E       fixture 'snippet_manager' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:351
________________ ERROR at setup of test_snippet_sql_injection _________________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 366
  def test_snippet_sql_injection(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:366
___________ ERROR at setup of test_snippet_sql_injection_in_content ___________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 375
  def test_snippet_sql_injection_in_content(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:375
_________________ ERROR at setup of test_snippet_long_content _________________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 384
  def test_snippet_long_content(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:384
_________ ERROR at setup of test_snippet_content_splitting_boundaries _________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 398
  def test_snippet_content_splitting_boundaries(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:398
______________ ERROR at setup of test_update_nonexistent_snippet ______________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 593
  def test_update_nonexistent_snippet(snippet_manager: SnippetManager) -> None:
E       fixture 'snippet_manager' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:593
_____________ ERROR at setup of test_snippet_part_number_sequence _____________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 432
  def test_snippet_part_number_sequence(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:432
______________ ERROR at setup of test_snippet_operation_handling ______________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 520
  def test_snippet_operation_handling(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:520
____________________ ERROR at setup of test_delete_snippet ____________________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 563
  def test_delete_snippet(snippet_category_fixture: str, snippet_manager: SnippetManager) -> None:
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:563
_______ ERROR at setup of test_create_snippet_with_nonexistent_category _______
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 580
  def test_create_snippet_with_nonexistent_category(snippet_manager: SnippetManager) -> None:
E       fixture 'snippet_manager' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:580
________________ ERROR at setup of test_update_snippet_partial ________________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 602
  def test_update_snippet_partial(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:602
______________ ERROR at setup of test_update_snippet_no_changes _______________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 637
  def test_update_snippet_no_changes(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:637
_________________ ERROR at setup of test_get_snippet_by_name __________________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 665
  def test_get_snippet_by_name(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:665
___________ ERROR at setup of test_get_snippet_by_name_nonexistent ____________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 685
  def test_get_snippet_by_name_nonexistent(
E       fixture 'snippet_manager' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:685
_______ ERROR at setup of test_get_snippet_by_name_multiple_categories ________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 692
  def test_get_snippet_by_name_multiple_categories(
E       fixture 'category_manager' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:692
___________________ ERROR at setup of test_search_snippets ____________________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 727
  def test_search_snippets(snippet_category_fixture: str, snippet_manager: SnippetManager) -> None:
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:727
______________ ERROR at setup of test_search_snippets_no_results ______________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 760
  def test_search_snippets_no_results(snippet_manager: SnippetManager) -> None:
E       fixture 'snippet_manager' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:760
__________ ERROR at setup of test_snippet_sql_injection_name_create ___________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 768
  def test_snippet_sql_injection_name_create(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:768
_________ ERROR at setup of test_snippet_sql_injection_content_create _________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 782
  def test_snippet_sql_injection_content_create(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:782
_ ERROR at setup of test_snippet_sql_injection_name_create_with_specific_error _
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 796
  def test_snippet_sql_injection_name_create_with_specific_error(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:796
_________ ERROR at setup of test_snippet_sql_injection_content_update _________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 810
  def test_snippet_sql_injection_content_update(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:810
__________ ERROR at setup of test_snippet_sql_injection_name_update ___________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 824
  def test_snippet_sql_injection_name_update(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:824
_____________ ERROR at setup of test_snippet_deletion_idempotency _____________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 838
  def test_snippet_deletion_idempotency(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:838
_ ERROR at setup of test_snippet_manager_handles_db_errors_gracefully_on_create _
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 854
  def test_snippet_manager_handles_db_errors_gracefully_on_create(
E       fixture 'snippet_manager' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:854
_ ERROR at setup of test_snippet_manager_handles_db_errors_gracefully_on_get __
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 871
  def test_snippet_manager_handles_db_errors_gracefully_on_get(
E       fixture 'snippet_manager' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:871
_ ERROR at setup of test_snippet_manager_handles_db_errors_gracefully_on_update _
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 883
  def test_snippet_manager_handles_db_errors_gracefully_on_update(
E       fixture 'snippet_manager' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:883
_ ERROR at setup of test_snippet_manager_handles_db_errors_gracefully_on_delete _
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 910
  def test_snippet_manager_handles_db_errors_gracefully_on_delete(
E       fixture 'snippet_manager' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:910
_ ERROR at setup of test_snippet_manager_handles_db_errors_gracefully_on_list _
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 948
  def test_snippet_manager_handles_db_errors_gracefully_on_list(
E       fixture 'snippet_manager' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:948
_ ERROR at setup of test_snippet_manager_handles_db_errors_gracefully_on_search _
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 960
  def test_snippet_manager_handles_db_errors_gracefully_on_search(
E       fixture 'snippet_manager' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:960
______ ERROR at setup of test_create_snippet_pydantic_validation_errors _______
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 972
  def test_create_snippet_pydantic_validation_errors(
E       fixture 'snippet_manager' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:972
================================== FAILURES ===================================
_______ TestNGramOnlyMode.test_ngram_content_filters_out_of_scope_chars _______

self = <AITypingTrainer.tests.models.test_dynamic_content_service.TestNGramOnlyMode object at 0x000002184BD3EEA0>

    def test_ngram_content_filters_out_of_scope_chars(self) -> None:
        """Test that NGramOnly content filters out ngrams with out-of-scope characters."""
        manager = DynamicContentService(
            in_scope_keys=["a", "b"],
            ngram_focus_list=["ab", "cd", "xy"],  # Only "ab" should be used
            mode=ContentMode.NGRAM_ONLY
        )
    
        content = manager.generate_content()
    
        # Content should only include "ab"
>       assert content == "ab" or content == "", (
            "Content should only include ngrams with in-scope keys"
        )
E       AssertionError: Content should only include ngrams with in-scope keys
E       assert ('ab cd xy cd ...y cd xy ab xy' == 'ab'
E         
E         - ab
E         + ab cd xy cd xy ab ab xy xy cd cd ab xy ab ab xy xy cd xy cd cd xy cd xy ab ab ab xy xy cd xy ab xy or 'ab cd xy cd ...y cd xy ab xy' == ''
E         
E         + ab cd xy cd xy ab ab xy xy cd cd ab xy ab ab xy xy cd xy cd cd xy cd xy ab ab ab xy xy cd xy ab xy)

tests\models\test_dynamic_content_service.py:214: AssertionError
________________ TestWordsOnlyMode.test_generate_words_content ________________

self = <AITypingTrainer.tests.models.test_dynamic_content_service.TestWordsOnlyMode object at 0x000002184BD46FD0>
basic_manager = <models.dynamic_content_service.DynamicContentService object at 0x000002184C864710>

    def test_generate_words_content(self, basic_manager: DynamicContentService) -> None:
        """Test generating content with WordsOnly mode."""
        basic_manager.mode = ContentMode.WORDS_ONLY
    
        # Mock the word generation to return predictable results
>       content = basic_manager.generate_content()
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_dynamic_content_service.py:227: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
models\dynamic_content_service.py:270: in generate_content
    return self._generate_words_content(self.practice_length, delimiter)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <models.dynamic_content_service.DynamicContentService object at 0x000002184C864710>
max_length = 100, delimiter = ' '

    def _generate_words_content(self, max_length: int, delimiter: str) -> str:
        """Generate content using words that contain the focus ngrams and only use in-scope keys.
    
        Uses the LLM service's word-count variant and helper methods for validation and assembly.
        """
        if not self.llm_service:
            raise ValueError("LLM service is required for word generation")
    
        # Compute target word count as floor(max_length / 4.5), minimum of 1
        target_word_count = max(1, int(math.floor(max_length / 4.5)))
    
        # LLM expects allowed characters as a single string
        allowed_chars = "".join(self.in_scope_keys)
    
        # Get a list of words from LLM service using the word-count variant
>       words_list = self.llm_service.get_words_with_ngrams_by_wordcount(
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            ngrams=self.ngram_focus_list,
            allowed_chars=allowed_chars,
            target_word_count=target_word_count,
        )
E       AttributeError: 'MockLLMNgramService' object has no attribute 'get_words_with_ngrams_by_wordcount'

models\dynamic_content_service.py:200: AttributeError
_______ TestWordsOnlyMode.test_words_content_filters_out_of_scope_chars _______

self = <AITypingTrainer.tests.models.test_dynamic_content_service.TestWordsOnlyMode object at 0x000002184BD47110>
mock_llm_service = <AITypingTrainer.tests.models.test_dynamic_content_service.MockLLMNgramService object at 0x000002184C802580>

    def test_words_content_filters_out_of_scope_chars(self, mock_llm_service: LLMNgramService) -> None:
        """Test that WordsOnly content filters out words with out-of-scope characters."""
        # Create a custom mock that returns words with both in-scope and out-of-scope characters
        custom_mock = MockLLMNgramService()
    
        manager = DynamicContentService(
            in_scope_keys=["t", "e", "s"],  # Only these characters are allowed
            ngram_focus_list=["es", "st"],
            mode=ContentMode.WORDS_ONLY,
            llm_service=cast(LLMNgramService, custom_mock)
        )
    
        # Create a patch to return words with some out-of-scope characters
        with patch.object(custom_mock, "get_words_with_ngrams",
                         return_value="test testword wordtest xyz123"):
>           content = manager.generate_content()
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_dynamic_content_service.py:262: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
models\dynamic_content_service.py:270: in generate_content
    return self._generate_words_content(self.practice_length, delimiter)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <models.dynamic_content_service.DynamicContentService object at 0x000002184D8EFA10>
max_length = 100, delimiter = ' '

    def _generate_words_content(self, max_length: int, delimiter: str) -> str:
        """Generate content using words that contain the focus ngrams and only use in-scope keys.
    
        Uses the LLM service's word-count variant and helper methods for validation and assembly.
        """
        if not self.llm_service:
            raise ValueError("LLM service is required for word generation")
    
        # Compute target word count as floor(max_length / 4.5), minimum of 1
        target_word_count = max(1, int(math.floor(max_length / 4.5)))
    
        # LLM expects allowed characters as a single string
        allowed_chars = "".join(self.in_scope_keys)
    
        # Get a list of words from LLM service using the word-count variant
>       words_list = self.llm_service.get_words_with_ngrams_by_wordcount(
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            ngrams=self.ngram_focus_list,
            allowed_chars=allowed_chars,
            target_word_count=target_word_count,
        )
E       AttributeError: 'MockLLMNgramService' object has no attribute 'get_words_with_ngrams_by_wordcount'

models\dynamic_content_service.py:200: AttributeError
____________ TestWordsOnlyMode.test_words_content_custom_delimiter ____________

self = <AITypingTrainer.tests.models.test_dynamic_content_service.TestWordsOnlyMode object at 0x000002184BD3EFD0>
basic_manager = <models.dynamic_content_service.DynamicContentService object at 0x000002184D94C050>

    def test_words_content_custom_delimiter(self, basic_manager: DynamicContentService) -> None:
        """Test generating WordsOnly content with custom delimiter."""
        basic_manager.mode = ContentMode.WORDS_ONLY
        delimiter = "|"
>       content = basic_manager.generate_content(delimiter=delimiter)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_dynamic_content_service.py:274: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
models\dynamic_content_service.py:270: in generate_content
    return self._generate_words_content(self.practice_length, delimiter)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <models.dynamic_content_service.DynamicContentService object at 0x000002184D94C050>
max_length = 100, delimiter = '|'

    def _generate_words_content(self, max_length: int, delimiter: str) -> str:
        """Generate content using words that contain the focus ngrams and only use in-scope keys.
    
        Uses the LLM service's word-count variant and helper methods for validation and assembly.
        """
        if not self.llm_service:
            raise ValueError("LLM service is required for word generation")
    
        # Compute target word count as floor(max_length / 4.5), minimum of 1
        target_word_count = max(1, int(math.floor(max_length / 4.5)))
    
        # LLM expects allowed characters as a single string
        allowed_chars = "".join(self.in_scope_keys)
    
        # Get a list of words from LLM service using the word-count variant
>       words_list = self.llm_service.get_words_with_ngrams_by_wordcount(
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            ngrams=self.ngram_focus_list,
            allowed_chars=allowed_chars,
            target_word_count=target_word_count,
        )
E       AttributeError: 'MockLLMNgramService' object has no attribute 'get_words_with_ngrams_by_wordcount'

models\dynamic_content_service.py:200: AttributeError
__________________ TestMixedMode.test_generate_mixed_content __________________

self = <AITypingTrainer.tests.models.test_dynamic_content_service.TestMixedMode object at 0x000002184BD47250>
basic_manager = <models.dynamic_content_service.DynamicContentService object at 0x000002184D906530>

    def test_generate_mixed_content(self, basic_manager: DynamicContentService) -> None:
        """Test generating content with Mixed mode."""
        basic_manager.mode = ContentMode.MIXED
    
        # Set seed for reproducibility in the test
        random.seed(42)
>       content = basic_manager.generate_content()
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_dynamic_content_service.py:293: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
models\dynamic_content_service.py:272: in generate_content
    return self._generate_mixed_content(self.practice_length, delimiter)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
models\dynamic_content_service.py:221: in _generate_mixed_content
    words_content = self._generate_words_content(half_length, delimiter)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <models.dynamic_content_service.DynamicContentService object at 0x000002184D906530>
max_length = 50, delimiter = ' '

    def _generate_words_content(self, max_length: int, delimiter: str) -> str:
        """Generate content using words that contain the focus ngrams and only use in-scope keys.
    
        Uses the LLM service's word-count variant and helper methods for validation and assembly.
        """
        if not self.llm_service:
            raise ValueError("LLM service is required for word generation")
    
        # Compute target word count as floor(max_length / 4.5), minimum of 1
        target_word_count = max(1, int(math.floor(max_length / 4.5)))
    
        # LLM expects allowed characters as a single string
        allowed_chars = "".join(self.in_scope_keys)
    
        # Get a list of words from LLM service using the word-count variant
>       words_list = self.llm_service.get_words_with_ngrams_by_wordcount(
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            ngrams=self.ngram_focus_list,
            allowed_chars=allowed_chars,
            target_word_count=target_word_count,
        )
E       AttributeError: 'MockLLMNgramService' object has no attribute 'get_words_with_ngrams_by_wordcount'

models\dynamic_content_service.py:200: AttributeError
________________ TestMixedMode.test_mixed_content_has_variety _________________

self = <AITypingTrainer.tests.models.test_dynamic_content_service.TestMixedMode object at 0x000002184BD47390>
basic_manager = <models.dynamic_content_service.DynamicContentService object at 0x000002184D906E90>

    def test_mixed_content_has_variety(self, basic_manager: DynamicContentService) -> None:
        """Test that Mixed content includes both ngrams and words."""
        # This test is a bit tricky since the mixed content is randomized
        # We'll make multiple attempts and check statistics
    
        basic_manager.mode = ContentMode.MIXED
        basic_manager.ngram_focus_list = ["ab", "cd"]
    
        # Replace the mock LLM service with one that returns very distinct words
        with patch.object(basic_manager.llm_service, "get_words_with_ngrams",  # type: ignore
                         return_value="abcdef cdabef longerword"):
    
            # Make multiple generation attempts
            seen_ngrams = set()
            seen_longer = False
    
            for _ in range(10):  # Try multiple times due to randomization
>               content = basic_manager.generate_content()
                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_dynamic_content_service.py:316: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
models\dynamic_content_service.py:272: in generate_content
    return self._generate_mixed_content(self.practice_length, delimiter)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
models\dynamic_content_service.py:221: in _generate_mixed_content
    words_content = self._generate_words_content(half_length, delimiter)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <models.dynamic_content_service.DynamicContentService object at 0x000002184D906E90>
max_length = 50, delimiter = ' '

    def _generate_words_content(self, max_length: int, delimiter: str) -> str:
        """Generate content using words that contain the focus ngrams and only use in-scope keys.
    
        Uses the LLM service's word-count variant and helper methods for validation and assembly.
        """
        if not self.llm_service:
            raise ValueError("LLM service is required for word generation")
    
        # Compute target word count as floor(max_length / 4.5), minimum of 1
        target_word_count = max(1, int(math.floor(max_length / 4.5)))
    
        # LLM expects allowed characters as a single string
        allowed_chars = "".join(self.in_scope_keys)
    
        # Get a list of words from LLM service using the word-count variant
>       words_list = self.llm_service.get_words_with_ngrams_by_wordcount(
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            ngrams=self.ngram_focus_list,
            allowed_chars=allowed_chars,
            target_word_count=target_word_count,
        )
E       AttributeError: 'MockLLMNgramService' object has no attribute 'get_words_with_ngrams_by_wordcount'

models\dynamic_content_service.py:200: AttributeError
_______ TestKeystrokeManagerSaveKeystrokes.test_save_keystrokes_success _______

self = <AITypingTrainer.tests.models.test_keystroke_manager.TestKeystrokeManagerSaveKeystrokes object at 0x000002184C3A8E10>
manager_with_mock_db = <models.keystroke_manager.KeystrokeManager object at 0x000002184D935D60>
sample_keystrokes = [Keystroke(session_id='save-test-session', keystroke_id='39e58c91-e081-4233-9a80-fafee0457b23', keystroke_time=datetim...=datetime.timezone.utc), keystroke_char='c', expected_char='c', is_error=False, time_since_previous=120, text_index=0)]

    def test_save_keystrokes_success(
        self, manager_with_mock_db: KeystrokeManager, sample_keystrokes: List[Keystroke]
    ) -> None:
        """Test successful saving of keystrokes."""
        manager_with_mock_db.keystroke_list = sample_keystrokes
    
        result = manager_with_mock_db.save_keystrokes()
    
        assert result is True
>       assert manager_with_mock_db.db_manager.execute.call_count == 3
E       AssertionError: assert 0 == 3
E        +  where 0 = <Mock name='mock.execute' id='2303385807776'>.call_count
E        +    where <Mock name='mock.execute' id='2303385807776'> = <Mock spec='DatabaseManager' id='2303385809456'>.execute
E        +      where <Mock spec='DatabaseManager' id='2303385809456'> = <models.keystroke_manager.KeystrokeManager object at 0x000002184D935D60>.db_manager

tests\models\test_keystroke_manager.py:234: AssertionError
___ TestKeystrokeManagerSaveKeystrokes.test_save_keystrokes_database_error ____

self = <AITypingTrainer.tests.models.test_keystroke_manager.TestKeystrokeManagerSaveKeystrokes object at 0x000002184C3E0770>
manager_with_mock_db = <models.keystroke_manager.KeystrokeManager object at 0x000002184D950F30>
sample_keystrokes = [Keystroke(session_id='save-test-session', keystroke_id='fa3324aa-7675-44e2-9120-cc2fe9f0a6c1', keystroke_time=datetim...=datetime.timezone.utc), keystroke_char='c', expected_char='c', is_error=False, time_since_previous=120, text_index=0)]

    def test_save_keystrokes_database_error(
        self, manager_with_mock_db: KeystrokeManager, sample_keystrokes: List[Keystroke]
    ) -> None:
        """Test handling of database errors during save."""
        manager_with_mock_db.keystroke_list = sample_keystrokes
        manager_with_mock_db.db_manager.execute.side_effect = Exception(
            "Database connection failed"
        )
    
        with patch("sys.stderr"), patch("traceback.print_exc"):
            result = manager_with_mock_db.save_keystrokes()
    
>       assert result is False
E       assert True is False

tests\models\test_keystroke_manager.py:277: AssertionError
_ TestKeystrokeManagerSaveKeystrokes.test_save_keystrokes_with_special_characters _

self = <AITypingTrainer.tests.models.test_keystroke_manager.TestKeystrokeManagerSaveKeystrokes object at 0x000002184C3E08A0>
manager_with_mock_db = <models.keystroke_manager.KeystrokeManager object at 0x000002184D93A5F0>

    def test_save_keystrokes_with_special_characters(
        self, manager_with_mock_db: KeystrokeManager
    ) -> None:
        """Test saving keystrokes with special characters."""
        import uuid
    
        special_chars = ["'", '"', "\\\\", "\\n", "\\t", "\u20ac", "\U0001f60a"]
        keystrokes = []
        for _i, char in enumerate(special_chars):
            keystroke = Keystroke(
                session_id="special-char-session",
                keystroke_id=str(uuid.uuid4()),
                keystroke_time=datetime.now(timezone.utc),
                keystroke_char=char,
                expected_char=char,
                is_error=False,
                time_since_previous=100,
            )
            keystrokes.append(keystroke)
        manager_with_mock_db.keystroke_list = keystrokes
        result = manager_with_mock_db.save_keystrokes()
        assert result is True
>       assert manager_with_mock_db.db_manager.execute.call_count == len(special_chars)
E       assert 0 == 7
E        +  where 0 = <Mock name='mock.execute' id='2303385809456'>.call_count
E        +    where <Mock name='mock.execute' id='2303385809456'> = <Mock spec='DatabaseManager' id='2303385810464'>.execute
E        +      where <Mock spec='DatabaseManager' id='2303385810464'> = <models.keystroke_manager.KeystrokeManager object at 0x000002184D93A5F0>.db_manager
E        +  and   7 = len(["'", '"', '\\', '\n', '\t', '', ...])

tests\models\test_keystroke_manager.py:301: AssertionError
_ TestKeystrokeManagerSaveKeystrokes.test_save_keystrokes_boolean_conversion __

self = <AITypingTrainer.tests.models.test_keystroke_manager.TestKeystrokeManagerSaveKeystrokes object at 0x000002184C3EDFD0>
manager_with_mock_db = <models.keystroke_manager.KeystrokeManager object at 0x000002184D9D3E10>

    def test_save_keystrokes_boolean_conversion(
        self, manager_with_mock_db: KeystrokeManager
    ) -> None:
        """Test that boolean is_error is properly converted to int."""
        import uuid
    
        keystroke = Keystroke(
            session_id="bool-test",
            keystroke_id=str(uuid.uuid4()),
            keystroke_time=datetime.now(timezone.utc),
            keystroke_char="a",
            expected_char="b",
            is_error=True,
            time_since_previous=50,
        )
        manager_with_mock_db.keystroke_list = [keystroke]
        result = manager_with_mock_db.save_keystrokes()
        assert result is True
        call_args = manager_with_mock_db.db_manager.execute.call_args
>       params = call_args[0][1]
                 ^^^^^^^^^^^^
E       TypeError: 'NoneType' object is not subscriptable

tests\models\test_keystroke_manager.py:322: TypeError
________ TestKeystrokeManagerIntegration.test_full_keystroke_workflow _________

self = <AITypingTrainer.tests.models.test_keystroke_manager.TestKeystrokeManagerIntegration object at 0x000002184C3A9590>
integration_manager = <models.keystroke_manager.KeystrokeManager object at 0x000002184DA27FB0>

    def test_full_keystroke_workflow(self, integration_manager: KeystrokeManager) -> None:
        """Test complete workflow: add, save, count, retrieve, delete."""
        import uuid
    
        session_id = str(uuid.uuid4())
        # Insert a matching session into the database
        db = integration_manager.db_manager
        db.init_tables()
        # Ensure session_keystrokes table is correct for UUID keystroke_id
        db.execute("DROP TABLE IF EXISTS session_keystrokes")
        db.execute(
            """
            CREATE TABLE session_keystrokes (
                keystroke_id TEXT PRIMARY KEY,
                session_id TEXT NOT NULL,
                keystroke_time TEXT NOT NULL,
                keystroke_char TEXT NOT NULL,
                expected_char TEXT NOT NULL,
                is_error INTEGER NOT NULL,
                time_since_previous INTEGER,
                FOREIGN KEY (session_id) REFERENCES practice_sessions(session_id) ON DELETE CASCADE
            )
            """
        )
        category_id = str(uuid.uuid4())
        # Insert a matching category into the database
        db.execute(
            """
            INSERT INTO categories (category_id, category_name) VALUES (?, ?)
            """,
            (category_id, "integration-category"),
        )
        snippet_id = str(uuid.uuid4())
        # Insert a matching snippet into the database
        db.execute(
            """
            INSERT INTO snippets (snippet_id, category_id, snippet_name) VALUES (?, ?, ?)
            """,
            (snippet_id, category_id, "integration-snippet"),
        )
        user_id = str(uuid.uuid4())
        keyboard_id = str(uuid.uuid4())
        db.execute(
            "INSERT INTO users (user_id, first_name, surname, email_address) VALUES (?, ?, ?, ?)",
            (user_id, "Test", "User", f"testuser_{user_id[:8]}@example.com"),
        )
        db.execute(
            "INSERT INTO keyboards (keyboard_id, user_id, keyboard_name) VALUES (?, ?, ?)",
            (keyboard_id, user_id, "Test Keyboard"),
        )
        db.execute(
            "INSERT INTO practice_sessions (session_id, snippet_id, user_id, keyboard_id, snippet_index_start, snippet_index_end, content, start_time, end_time, actual_chars, errors, ms_per_keystroke) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)",
            (
                session_id,
                snippet_id,
                user_id,
                keyboard_id,
                0,
                10,
                "abcde",
                "2025-06-10T12:00:00",
                "2025-06-10T12:01:00",
                5,
                0,
                100.0,
            ),
        )
        # Create test keystrokes
        keystrokes = []
        for i in range(5):
            keystroke = Keystroke(
                session_id=session_id,
                keystroke_id=str(uuid.uuid4()),
                keystroke_time=datetime.now(timezone.utc),
                keystroke_char=chr(97 + i),
                expected_char=chr(97 + i),
                is_error=i == 2,  # Make one an error
                time_since_previous=100 + i * 10,  # Always integer
            )
            keystrokes.append(keystroke)
            integration_manager.add_keystroke(keystroke)
        # Verify keystrokes are in memory
        assert len(integration_manager.keystroke_list) == 5
        # Save to database
        save_result = integration_manager.save_keystrokes()
>       assert save_result is True
E       assert False is True

tests\models\test_keystroke_manager.py:636: AssertionError
---------------------------- Captured stdout call -----------------------------
 Exception during execute_many: table session_keystrokes has no column named text_index. Rolling back transaction.
---------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 620, in execute_many
    return self._bulk_executemany(cursor, query, params_list)
           ~~~~~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 648, in _bulk_executemany
    cursor.executemany(query, params_list)
    ~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^
sqlite3.OperationalError: table session_keystrokes has no column named text_index
Error saving keystrokes: Database operation failed: table session_keystrokes has no column named text_index
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 620, in execute_many
    return self._bulk_executemany(cursor, query, params_list)
           ~~~~~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 648, in _bulk_executemany
    cursor.executemany(query, params_list)
    ~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^
sqlite3.OperationalError: table session_keystrokes has no column named text_index

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\models\keystroke_manager.py", line 60, in save_keystrokes
    self.db_manager.execute_many(query, params)  # type: ignore[attr-defined]
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 629, in execute_many
    self._translate_and_raise(e)
    ~~~~~~~~~~~~~~~~~~~~~~~~~^^^
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 449, in _translate_and_raise
    raise DatabaseError(f"Database operation failed: {e}") from e
db.exceptions.DatabaseError: Database operation failed: table session_keystrokes has no column named text_index
______ TestKeystrokeManagerEdgeCases.test_unicode_and_special_characters ______

self = <AITypingTrainer.tests.models.test_keystroke_manager.TestKeystrokeManagerEdgeCases object at 0x000002184C3E0E90>
manager = <models.keystroke_manager.KeystrokeManager object at 0x000002184D9A14F0>

    def test_unicode_and_special_characters(self, manager: KeystrokeManager) -> None:
        """Test handling of Unicode and special characters in keystrokes."""
        import uuid
    
        special_chars = [
            "\U0001f642",
            "\u6d4b\u8bd5",
            "caf",
            "\u03a9",
            "\n",
            "\t",
            "\\",
            "'",
            '"',
            "\0",
        ]
        for _i, char in enumerate(special_chars):
            keystroke = Keystroke(
                session_id="unicode-test",
                keystroke_id=str(uuid.uuid4()),
                keystroke_time=datetime.now(timezone.utc),
                keystroke_char=char,
                expected_char=char,
                is_error=False,
                time_since_previous=100,  # Always integer
            )
            manager.add_keystroke(keystroke)
        assert len(manager.keystroke_list) == len(special_chars)
        result = manager.save_keystrokes()
        assert result is True
>       assert manager.db_manager.execute.call_count == len(special_chars)
E       AssertionError: assert 0 == 10
E        +  where 0 = <Mock name='mock.execute' id='2303405223152'>.call_count
E        +    where <Mock name='mock.execute' id='2303405223152'> = <Mock spec='DatabaseManager' id='2303405225168'>.execute
E        +      where <Mock spec='DatabaseManager' id='2303405225168'> = <models.keystroke_manager.KeystrokeManager object at 0x000002184D9A14F0>.db_manager
E        +  and   10 = len(['\U0001f642', '\u6d4b\u8bd5', 'caf\xe9', '\u03a9', '\\n', '\\t', ...])

tests\models\test_keystroke_manager.py:829: AssertionError
_____ TestKeystrokeManagerErrorHandling.test_database_connection_failure ______

self = <AITypingTrainer.tests.models.test_keystroke_manager.TestKeystrokeManagerErrorHandling object at 0x000002184C3A9A90>
manager = <models.keystroke_manager.KeystrokeManager object at 0x000002184B8C8CB0>

    def test_database_connection_failure(self, manager: KeystrokeManager) -> None:
        """Test handling of database connection failures."""
        import uuid
    
        manager.db_manager.execute.side_effect = Exception("Connection lost")
        keystroke = Keystroke(
            session_id="error-test",
            keystroke_id=str(uuid.uuid4()),
            keystroke_time=datetime.now(timezone.utc),
            keystroke_char="a",
            expected_char="a",
            is_error=False,
            time_since_previous=100,
        )
        manager.add_keystroke(keystroke)
        result = manager.save_keystrokes()
>       assert result is False
E       assert True is False

tests\models\test_keystroke_manager.py:878: AssertionError
_________ TestKeystrokeManagerErrorHandling.test_partial_save_failure _________

self = <AITypingTrainer.tests.models.test_keystroke_manager.TestKeystrokeManagerErrorHandling object at 0x000002184C3E10F0>
manager = <models.keystroke_manager.KeystrokeManager object at 0x000002184D9E7770>

    def test_partial_save_failure(self, manager: KeystrokeManager) -> None:
        """Test handling when some keystrokes save successfully and others fail."""
        import uuid
    
        keystrokes = []
        for i in range(3):
            keystroke = Keystroke(
                session_id="partial-test",
                keystroke_id=str(uuid.uuid4()),
                keystroke_time=datetime.now(timezone.utc),
                keystroke_char=chr(97 + i),
                expected_char=chr(97 + i),
                is_error=False,
                time_since_previous=100,
            )
            keystrokes.append(keystroke)
        manager.keystroke_list = keystrokes
        manager.db_manager.execute.side_effect = [None, Exception("Save failed"), None]
        result = manager.save_keystrokes()
>       assert result is False
E       assert True is False

tests\models\test_keystroke_manager.py:919: AssertionError
______ TestKeystrokeManagerErrorHandling.test_network_timeout_simulation ______

self = <AITypingTrainer.tests.models.test_keystroke_manager.TestKeystrokeManagerErrorHandling object at 0x000002184C3E1220>
manager = <models.keystroke_manager.KeystrokeManager object at 0x000002184D9F8410>

    def test_network_timeout_simulation(self, manager: KeystrokeManager) -> None:
        """Test handling of network timeout-like errors."""
        import time
        import uuid
    
        def slow_execute(*args: object, **kwargs: object) -> object:
            time.sleep(0.1)  # Simulate slow operation
            raise TimeoutError("Database timeout")
    
        manager.db_manager.execute.side_effect = slow_execute
        keystroke = Keystroke(
            session_id="timeout-test",
            keystroke_id=str(uuid.uuid4()),
            keystroke_time=datetime.now(timezone.utc),
            keystroke_char="a",
            expected_char="a",
            is_error=False,
            time_since_previous=100,
        )
        manager.add_keystroke(keystroke)
        result = manager.save_keystrokes()
>       assert result is False
E       assert True is False

tests\models\test_keystroke_manager.py:942: AssertionError
___________________ test_llm_simple_prompt_returns_10_words ___________________

    @pytest.mark.slow
    def test_llm_simple_prompt_returns_10_words() -> None:
        """Integration-style test: requires OPENAI_API_KEY in env; otherwise skipped.
    
        Validates that GPT-5-mini returns at least 10 words for a simple prompt.
        """
        api_key = os.getenv("OPENAI_API_KEY") or os.getenv("OpenAPI_Key") or os.getenv(
            "OPENAI_API_TOKEN"
        )
        if not api_key:
            pytest.skip("OPENAI_API_KEY not set; skipping live API test")
    
        svc = LLMNgramService(api_key=api_key)
        prompt = (
            "Please list 10 words that I can use for typing practice. "
            "Return only the words, separated by spaces."
        )
>       text = svc._call_gpt5_with_robust_error_handling(prompt)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_llm_ngram_service.py:88: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <models.llm_ngram_service.LLMNgramService object at 0x000002184C802F10>
prompt = 'Please list 10 words that I can use for typing practice. Return only the words, separated by spaces.'

    def _call_gpt5_with_robust_error_handling(self, prompt: str) -> str:
        """Call GPT-5-mini once with clear errors and extract plain text.
    
        Simplified: no retries/backoff; direct Chat Completions call with valid params.
        """
        if self.client is None:
            raise RuntimeError("OpenAI client is not available.")
    
        system_prompt = (
            "You are an expert in English lexicography and touch typing instruction. "
            "Return plain text only, not JSON. Do not call tools. "
            "Be extremely concise and do not explain your reasoning."
        )
    
        try:
            # Optimized low-temperature and bounded tokens.
            # Seed omitted for broad compatibility with client versions.
            resp = self.client.chat.completions.create(
                model="gpt-5-mini",
                messages=[
                    {"role": "system", "content": system_prompt},
                    {"role": "user", "content": prompt},
                ],
                max_completion_tokens=450,
                n=1,
            )
            text = self._extract_text_from_response(resp)
            if not text:
                diag = self._collect_diagnostics(resp)
                self._logger.error("Empty text from GPT-5-mini. Diagnostics: %s", diag)
>               raise RuntimeError("Model returned empty text.")
E               RuntimeError: Model returned empty text.

models\llm_ngram_service.py:334: RuntimeError
---------------------------- Captured stderr call -----------------------------
2025-08-19 22:41:28 [ERROR] LLMNgramService: Empty text from GPT-5-mini. Diagnostics: {
  "usage": {
    "completion_tokens": 450,
    "prompt_tokens": 69,
    "total_tokens": 519,
    "completion_tokens_details": {
      "accepted_prediction_tokens": 0,
      "audio_tokens": 0,
      "reasoning_tokens": 450,
      "rejected_prediction_tokens": 0
    },
    "prompt_tokens_details": {
      "audio_tokens": 0,
      "cached_tokens": 0
    }
  },
  "id": "chatcmpl-C6T3NVy1O2mMgSCLL5DDCOEp7GeN8",
  "outputs_summary": [],
  "raw_excerpt": "[]"
}
------------------------------ Captured log call ------------------------------
ERROR    LLMNgramService:llm_ngram_service.py:333 Empty text from GPT-5-mini. Diagnostics: {
  "usage": {
    "completion_tokens": 450,
    "prompt_tokens": 69,
    "total_tokens": 519,
    "completion_tokens_details": {
      "accepted_prediction_tokens": 0,
      "audio_tokens": 0,
      "reasoning_tokens": 450,
      "rejected_prediction_tokens": 0
    },
    "prompt_tokens_details": {
      "audio_tokens": 0,
      "cached_tokens": 0
    }
  },
  "id": "chatcmpl-C6T3NVy1O2mMgSCLL5DDCOEp7GeN8",
  "outputs_summary": [],
  "raw_excerpt": "[]"
}
________________ TestKeystroke.test_keystroke_nfc_single_char _________________

self = <AITypingTrainer.tests.models.test_ngram.TestKeystroke object at 0x000002184C3AA350>

    def test_keystroke_nfc_single_char(self):
        # composed e + \u0301
        k = Keystroke(keystroke_time=ts(0), text_index=0, expected_char="e\u0301", keystroke_char="", is_error=False)
>       assert k.expected_char == ""
E       AssertionError: assert 'e\u0301' == '\xe9'
E         
E         - 
E         + e\u0301

tests\models\test_ngram.py:32: AssertionError
__ TestNGramAnalyticsService.test_dual_insert_creates_records_in_both_tables __

self = <AITypingTrainer.tests.models.test_ngram_analytics_service.TestNGramAnalyticsService object at 0x000002184C3B6050>
temp_db = 'C:\\Users\\seanb\\AppData\\Local\\Temp\\tmpq19wjefi.db'
mock_sessions = [{'keyboard_id': 'keyboard_1', 'session_id': 'session_1', 'start_time': '2024-01-01 10:01:00', 'target_ms_per_keystrok...: 'keyboard_1', 'session_id': 'session_2', 'start_time': '2024-01-01 10:02:00', 'target_ms_per_keystroke': 170.0, ...}]
mock_ngram_data = [{'ms_per_keystroke': 100.0, 'ngram_size': 2, 'ngram_speed_id': 'ng_0', 'ngram_text': 'th', ...}, {'ms_per_keystroke':...ram_text': 'th', ...}, {'ms_per_keystroke': 107.5, 'ngram_size': 3, 'ngram_speed_id': 'ng_3', 'ngram_text': 'he', ...}]

    def test_dual_insert_creates_records_in_both_tables(
        self,
        temp_db: DatabaseManager,
        mock_sessions: List[MockSessionData],
        mock_ngram_data: List[MockNGramSpeedData],
    ) -> None:
        """
        Test objective: Verify dual-insert creates records in both current and history tables.
    
        Tests that when refresh_speed_summaries is called, records are created
        in both ngram_speed_summary_curr and ngram_speed_summary_hist tables.
        """
        ngram_manager = NGramManager(temp_db)
        service = NGramAnalyticsService(temp_db, ngram_manager)
    
        # Set up test data
        user_id = "user_1"
        keyboard_id = "keyboard_1"
    
        # Insert test session and keyboard data
        for session in mock_sessions:
>           temp_db.execute(
            ^^^^^^^^^^^^^^^
                """INSERT INTO practice_sessions
                (session_id, user_id, keyboard_id, snippet_id, snippet_index_start, snippet_index_end,
                 content, start_time, end_time, actual_chars, errors, ms_per_keystroke)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)""",
                (
                    session["session_id"],
                    session["user_id"],
                    session["keyboard_id"],
                    "test_snippet_1",
                    0,
                    10,
                    "test content",
                    session["start_time"],
                    session["start_time"],
                    "test",
                    0,
                    session["target_ms_per_keystroke"],
                ),
            )
E           AttributeError: 'str' object has no attribute 'execute'

tests\models\test_ngram_analytics_service.py:369: AttributeError
____ TestNGramAnalyticsService.test_history_table_accumulates_all_records _____

self = <AITypingTrainer.tests.models.test_ngram_analytics_service.TestNGramAnalyticsService object at 0x000002184C3B6250>
temp_db = 'C:\\Users\\seanb\\AppData\\Local\\Temp\\tmpzzvstytr.db'
mock_sessions = [{'keyboard_id': 'keyboard_1', 'session_id': 'session_1', 'start_time': '2024-01-01 10:01:00', 'target_ms_per_keystrok...: 'keyboard_1', 'session_id': 'session_2', 'start_time': '2024-01-01 10:02:00', 'target_ms_per_keystroke': 170.0, ...}]
mock_ngram_data = [{'ms_per_keystroke': 100.0, 'ngram_size': 2, 'ngram_speed_id': 'ng_0', 'ngram_text': 'th', ...}, {'ms_per_keystroke':...ram_text': 'th', ...}, {'ms_per_keystroke': 107.5, 'ngram_size': 3, 'ngram_speed_id': 'ng_3', 'ngram_text': 'he', ...}]

    def test_history_table_accumulates_all_records(
        self,
        temp_db: DatabaseManager,
        mock_sessions: List[MockSessionData],
        mock_ngram_data: List[MockNGramSpeedData],
    ) -> None:
        """
        Test objective: Verify history table contains all records over multiple refreshes.
    
        Tests that the history table accumulates all records from multiple
        refresh operations while current table only contains latest values.
        """
        ngram_manager = NGramManager(temp_db)
        service = NGramAnalyticsService(temp_db, ngram_manager)
    
        user_id = "user_1"
        keyboard_id = "keyboard_1"
    
        # Set up initial test data
        for session in mock_sessions:
>           temp_db.execute(
            ^^^^^^^^^^^^^^^
                """INSERT INTO practice_sessions
                (session_id, user_id, keyboard_id, snippet_id, snippet_index_start, snippet_index_end,
                 content, start_time, end_time, actual_chars, errors, ms_per_keystroke)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)""",
                (
                    session["session_id"],
                    session["user_id"],
                    session["keyboard_id"],
                    "test_snippet_1",
                    0,
                    10,
                    "test content",
                    session["start_time"],
                    session["start_time"],
                    "test",
                    0,
                    session["target_ms_per_keystroke"],
                ),
            )
E           AttributeError: 'str' object has no attribute 'execute'

tests\models\test_ngram_analytics_service.py:441: AttributeError
_________ TestNGramAnalyticsService.test_get_ngram_history_retrieval __________

self = <AITypingTrainer.tests.models.test_ngram_analytics_service.TestNGramAnalyticsService object at 0x000002184C45C230>
temp_db = 'C:\\Users\\seanb\\AppData\\Local\\Temp\\tmprl51me3b.db'
mock_sessions = [{'keyboard_id': 'keyboard_1', 'session_id': 'session_1', 'start_time': '2024-01-01 10:01:00', 'target_ms_per_keystrok...: 'keyboard_1', 'session_id': 'session_2', 'start_time': '2024-01-01 10:02:00', 'target_ms_per_keystroke': 170.0, ...}]
mock_ngram_data = [{'ms_per_keystroke': 100.0, 'ngram_size': 2, 'ngram_speed_id': 'ng_0', 'ngram_text': 'th', ...}, {'ms_per_keystroke':...ram_text': 'th', ...}, {'ms_per_keystroke': 107.5, 'ngram_size': 3, 'ngram_speed_id': 'ng_3', 'ngram_text': 'he', ...}]

    def test_get_ngram_history_retrieval(
        self,
        temp_db: DatabaseManager,
        mock_sessions: List[MockSessionData],
        mock_ngram_data: List[MockNGramSpeedData],
    ) -> None:
        """
        Test objective: Verify history retrieval functionality.
    
        Tests that historical data can be retrieved properly with correct
        timestamps and performance metrics.
        """
        ngram_manager = NGramManager(temp_db)
        service = NGramAnalyticsService(temp_db, ngram_manager)
    
        user_id = "user_1"
        keyboard_id = "keyboard_1"
    
        # Set up test data and refresh
        for session in mock_sessions:
>           temp_db.execute(
            ^^^^^^^^^^^^^^^
                """INSERT INTO practice_sessions
                (session_id, user_id, keyboard_id, snippet_id, snippet_index_start, snippet_index_end,
                 content, start_time, end_time, actual_chars, errors, ms_per_keystroke)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)""",
                (
                    session["session_id"],
                    session["user_id"],
                    session["keyboard_id"],
                    "test_snippet_1",
                    0,
                    10,
                    "test content",
                    session["start_time"],
                    session["start_time"],
                    "test",
                    0,
                    session["target_ms_per_keystroke"],
                ),
            )
E           AttributeError: 'str' object has no attribute 'execute'

tests\models\test_ngram_analytics_service.py:551: AttributeError
______ TestNGramAnalyticsService.test_history_table_schema_compatibility ______

self = <AITypingTrainer.tests.models.test_ngram_analytics_service.TestNGramAnalyticsService object at 0x000002184C45C410>
temp_db = 'C:\\Users\\seanb\\AppData\\Local\\Temp\\tmpz1k8df98.db'

    def test_history_table_schema_compatibility(
        self, temp_db: DatabaseManager
    ) -> None:
        """
        Test objective: Verify history table schema matches current table.
    
        Tests that the history table has the same essential columns as
        the current table plus additional history-specific fields.
        """
        ngram_manager = NGramManager(temp_db)
        service = NGramAnalyticsService(temp_db, ngram_manager)
    
        # Verify table schemas are compatible
>       current_schema = temp_db.fetchall("PRAGMA table_info(ngram_speed_summary_curr)")
                         ^^^^^^^^^^^^^^^^
E       AttributeError: 'str' object has no attribute 'fetchall'

tests\models\test_ngram_analytics_service.py:616: AttributeError
___________ TestAddSpeedSummaryForSession.test_nonexistent_session ____________

self = <AITypingTrainer.tests.models.test_ngram_analytics_service_session_methods.TestAddSpeedSummaryForSession object at 0x000002184C498550>
analytics_service = <models.ngram_analytics_service.NGramAnalyticsService object at 0x000002184DD60290>

    def test_nonexistent_session(
        self,
        analytics_service: NGramAnalyticsService
    ):
        """Test processing a nonexistent session."""
        fake_session_id = str(uuid.uuid4())
    
>       with pytest.raises(ValueError, match=f"Session {fake_session_id} not found"):
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       Failed: DID NOT RAISE <class 'ValueError'>

tests\models\test_ngram_analytics_service_session_methods.py:353: Failed
_____________ TestCatchupSpeedSummary.test_empty_database_catchup _____________

self = <AITypingTrainer.tests.models.test_ngram_analytics_service_session_methods.TestCatchupSpeedSummary object at 0x000002184C498690>
analytics_service = <models.ngram_analytics_service.NGramAnalyticsService object at 0x000002184DD6E570>

    def test_empty_database_catchup(
        self,
        analytics_service: NGramAnalyticsService
    ):
        """Test catchup with no sessions in database."""
        result = analytics_service.catchup_speed_summary()
    
        assert isinstance(result, dict)
>       assert result['total_sessions'] == 0
               ^^^^^^^^^^^^^^^^^^^^^^^^
E       KeyError: 'total_sessions'

tests\models\test_ngram_analytics_service_session_methods.py:413: KeyError
__________________ test_process_end_of_session_success_path ___________________

self = <db.database_manager.DatabaseManager object at 0x000002184C495470>
query = '\n            INSERT INTO categories (category_id, category_name, description)\n            VALUES (?, ?, ?)\n            '
params = ('6bbb8ec5-a7ff-43ce-9aad-9c59570143c9', 'Test Category', 'Test category for testing')

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table categories has no column named description

db\database_manager.py:524: OperationalError

The above exception was the direct cause of the following exception:

db_with_tables = <db.database_manager.DatabaseManager object at 0x000002184C495470>
test_user = User(user_id='921aacf3-3d69-4bf9-8170-4f117f99faba', first_name='Test', surname='User', email_address='test.user.35e1c3e7-d0c5-4648-841c-cfc12b4371c6@example.com')
test_keyboard = Keyboard(keyboard_id='2d810ab8-fd28-488d-a95b-9f0acc493738', user_id='921aacf3-3d69-4bf9-8170-4f117f99faba', keyboard_name='Test Keyboard', target_ms_per_keystroke=600)

    def test_process_end_of_session_success_path(db_with_tables, test_user, test_keyboard):
        # Arrange: create snippet (for FK completeness) and a new Session not yet in DB
        from tests.models.conftest import TestSessionMethodsFixtures
    
>       category_id = TestSessionMethodsFixtures.create_category(db_with_tables)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_ngram_orchestrator_process_end_of_session.py:40: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:239: in create_category
    db.execute(
db\database_manager.py:539: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x000002184C495470>
e = OperationalError('table categories has no column named description')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table categories has no column named description

db\database_manager.py:449: DatabaseError
---------------------------- Captured stdout call -----------------------------
Exception during query: table categories has no column named description. Rolling back transaction.
---------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 524, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table categories has no column named description
______________ test_process_end_of_session_session_save_failure _______________

self = <db.database_manager.DatabaseManager object at 0x000002184DE1DF60>
query = '\n            INSERT INTO categories (category_id, category_name, description)\n            VALUES (?, ?, ?)\n            '
params = ('b9e13b7c-67ef-4ebf-873f-8aef7c93711c', 'Test Category', 'Test category for testing')

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table categories has no column named description

db\database_manager.py:524: OperationalError

The above exception was the direct cause of the following exception:

db_with_tables = <db.database_manager.DatabaseManager object at 0x000002184DE1DF60>
test_user = User(user_id='2c3d444f-cf9a-45ac-a148-0c666c2ae7e6', first_name='Test', surname='User', email_address='test.user.a90a2ae2-148d-429f-82a0-d6692ab2677b@example.com')

    def test_process_end_of_session_session_save_failure(db_with_tables, test_user):
        """Fails at step 1: session save should raise due to FK violation (invalid keyboard_id)."""
        from tests.models.conftest import TestSessionMethodsFixtures
    
        # Valid snippet/category, but invalid keyboard_id to trigger FK failure on insert
>       category_id = TestSessionMethodsFixtures.create_category(db_with_tables)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_ngram_orchestrator_process_end_of_session.py:129: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:239: in create_category
    db.execute(
db\database_manager.py:539: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x000002184DE1DF60>
e = OperationalError('table categories has no column named description')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table categories has no column named description

db\database_manager.py:449: DatabaseError
---------------------------- Captured stdout call -----------------------------
Exception during query: table categories has no column named description. Rolling back transaction.
---------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 524, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table categories has no column named description
_____________ test_process_end_of_session_keystrokes_save_failure _____________

self = <db.database_manager.DatabaseManager object at 0x000002184DE1E430>
query = '\n            INSERT INTO categories (category_id, category_name, description)\n            VALUES (?, ?, ?)\n            '
params = ('68aca899-eb51-4f61-bc29-b8254fa60152', 'Test Category', 'Test category for testing')

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table categories has no column named description

db\database_manager.py:524: OperationalError

The above exception was the direct cause of the following exception:

db_with_tables = <db.database_manager.DatabaseManager object at 0x000002184DE1E430>
test_user = User(user_id='1fbe0d17-5816-4ca5-a139-c2182e215b09', first_name='Test', surname='User', email_address='test.user.5c96f9f9-e76d-46f8-8114-d870a6b2c74e@example.com')
test_keyboard = Keyboard(keyboard_id='dfce34d5-fe37-4fa3-a2a5-bd6033b17b2b', user_id='1fbe0d17-5816-4ca5-a139-c2182e215b09', keyboard_name='Test Keyboard', target_ms_per_keystroke=600)

    def test_process_end_of_session_keystrokes_save_failure(db_with_tables, test_user, test_keyboard):
        """Fails at step 2: keystrokes save should return False due to invalid keystroke session_id."""
        from tests.models.conftest import TestSessionMethodsFixtures
    
>       category_id = TestSessionMethodsFixtures.create_category(db_with_tables)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_ngram_orchestrator_process_end_of_session.py:170: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:239: in create_category
    db.execute(
db\database_manager.py:539: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x000002184DE1E430>
e = OperationalError('table categories has no column named description')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table categories has no column named description

db\database_manager.py:449: DatabaseError
---------------------------- Captured stdout call -----------------------------
Exception during query: table categories has no column named description. Rolling back transaction.
---------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 524, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table categories has no column named description
______________ test_process_end_of_session_summarization_failure ______________

self = <db.database_manager.DatabaseManager object at 0x000002184DE1ED60>
query = '\n            INSERT INTO categories (category_id, category_name, description)\n            VALUES (?, ?, ?)\n            '
params = ('5f3a24f3-09ff-488f-b41d-9d0ec866d42e', 'Test Category', 'Test category for testing')

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table categories has no column named description

db\database_manager.py:524: OperationalError

The above exception was the direct cause of the following exception:

db_with_tables = <db.database_manager.DatabaseManager object at 0x000002184DE1ED60>
test_user = User(user_id='0344ffd7-cdb5-49e1-841f-301e11cc0d23', first_name='Test', surname='User', email_address='test.user.be26b22f-c835-46e5-8abf-63d91ac47835@example.com')
test_keyboard = Keyboard(keyboard_id='d17794b4-1b5e-4c60-9897-45d7e7ce7de1', user_id='0344ffd7-cdb5-49e1-841f-301e11cc0d23', keyboard_name='Test Keyboard', target_ms_per_keystroke=600)

    def test_process_end_of_session_summarization_failure(db_with_tables, test_user, test_keyboard):
        """Fails at step 4: drop summary table to force summarization SQL to fail after n-grams."""
        from tests.models.conftest import TestSessionMethodsFixtures
    
>       category_id = TestSessionMethodsFixtures.create_category(db_with_tables)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_ngram_orchestrator_process_end_of_session.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:239: in create_category
    db.execute(
db\database_manager.py:539: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x000002184DE1ED60>
e = OperationalError('table categories has no column named description')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table categories has no column named description

db\database_manager.py:449: DatabaseError
---------------------------- Captured stdout call -----------------------------
Exception during query: table categories has no column named description. Rolling back transaction.
---------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 524, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table categories has no column named description
============================== warnings summary ===============================
tests/models/test_category_manager.py::TestCategoryManager::test_list_all_categories_populated
  D:\SeanDevLocal\AITypingTrainer\db\database_manager.py:388: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002184C7E7970>
    cursor = self._conn.cursor()
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_category_manager.py::TestCategoryManager::test_list_all_categories_populated
  D:\SeanDevLocal\AITypingTrainer\db\database_manager.py:388: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002184C819120>
    cursor = self._conn.cursor()
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_category_manager.py::TestCategoryManager::test_list_all_categories_populated
  D:\SeanDevLocal\AITypingTrainer\db\database_manager.py:388: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002184C8196C0>
    cursor = self._conn.cursor()
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_category_manager.py::TestCategoryManager::test_list_all_categories_populated
  D:\SeanDevLocal\AITypingTrainer\db\database_manager.py:388: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002184C8197B0>
    cursor = self._conn.cursor()
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_category_manager.py::TestCategoryManager::test_list_all_categories_populated
  D:\SeanDevLocal\AITypingTrainer\db\database_manager.py:388: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002184C819A80>
    cursor = self._conn.cursor()
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_category_manager.py::TestCategoryManager::test_list_all_categories_populated
  D:\SeanDevLocal\AITypingTrainer\db\database_manager.py:388: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002184C8198A0>
    cursor = self._conn.cursor()
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_category_manager.py::TestCategoryManager::test_list_all_categories_populated
  D:\SeanDevLocal\AITypingTrainer\db\database_manager.py:388: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002184C8194E0>
    cursor = self._conn.cursor()
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_category_manager.py::TestCategoryManager::test_list_all_categories_populated
  D:\SeanDevLocal\AITypingTrainer\db\database_manager.py:388: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002184C819300>
    cursor = self._conn.cursor()
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_category_manager.py::TestCategoryManager::test_list_all_categories_populated
  D:\SeanDevLocal\AITypingTrainer\db\database_manager.py:388: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002184C819990>
    cursor = self._conn.cursor()
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_dynamic_content_service.py::TestDynamicContentServiceInitialization::test_invalid_practice_length_too_small
  C:\Python\Python313\Lib\re\_parser.py:230: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002184C819C60>
    def __init__(self, string):
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_dynamic_content_service.py::TestDynamicContentServiceInitialization::test_invalid_practice_length_too_small
  C:\Python\Python313\Lib\re\_parser.py:230: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002184C81AC50>
    def __init__(self, string):
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_dynamic_content_service.py::TestDynamicContentServiceInitialization::test_invalid_practice_length_too_small
  C:\Python\Python313\Lib\re\_parser.py:230: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002184C81B1F0>
    def __init__(self, string):
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_dynamic_content_service.py::TestDynamicContentServiceInitialization::test_invalid_practice_length_too_small
  C:\Python\Python313\Lib\re\_parser.py:230: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002184C81B2E0>
    def __init__(self, string):
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_dynamic_content_service.py::TestDynamicContentServiceInitialization::test_invalid_practice_length_too_small
  C:\Python\Python313\Lib\re\_parser.py:230: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002184C81B3D0>
    def __init__(self, string):
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_dynamic_content_service.py::TestDynamicContentServiceInitialization::test_invalid_practice_length_too_small
  C:\Python\Python313\Lib\re\_parser.py:230: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002184C81B4C0>
    def __init__(self, string):
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_dynamic_content_service.py::TestDynamicContentServiceInitialization::test_invalid_practice_length_too_small
  C:\Python\Python313\Lib\re\_parser.py:230: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002184C81B5B0>
    def __init__(self, string):
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_dynamic_content_service.py::TestDynamicContentServiceInitialization::test_invalid_practice_length_too_small
  C:\Python\Python313\Lib\re\_parser.py:230: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002184C81B6A0>
    def __init__(self, string):
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_dynamic_content_service.py::TestDynamicContentServiceInitialization::test_invalid_practice_length_too_small
  C:\Python\Python313\Lib\re\_parser.py:230: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002184C81B790>
    def __init__(self, string):
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_dynamic_content_service.py::TestDynamicContentServiceInitialization::test_invalid_practice_length_too_small
  C:\Python\Python313\Lib\re\_parser.py:230: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002184C81B880>
    def __init__(self, string):
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_dynamic_content_service.py::TestDynamicContentServiceInitialization::test_invalid_practice_length_too_small
  C:\Python\Python313\Lib\re\_parser.py:230: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002184C81B970>
    def __init__(self, string):
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_dynamic_content_service.py::TestDynamicContentServiceInitialization::test_invalid_practice_length_too_small
  C:\Python\Python313\Lib\re\_parser.py:230: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002184C81BA60>
    def __init__(self, string):
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_keystroke.py::TestKeystrokeClassMethods::test_get_for_session_empty_result
  C:\Python\Python313\Lib\unittest\mock.py:2245: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002184D936C50>
    def __init__(self, name, parent):
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_keystroke.py::TestKeystrokeClassMethods::test_get_for_session_empty_result
  C:\Python\Python313\Lib\unittest\mock.py:2245: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002184D936F20>
    def __init__(self, name, parent):
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_keystroke.py::TestKeystrokeClassMethods::test_get_for_session_empty_result
  C:\Python\Python313\Lib\unittest\mock.py:2245: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002184D937010>
    def __init__(self, name, parent):
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_keystroke.py::TestKeystrokeClassMethods::test_get_for_session_empty_result
  C:\Python\Python313\Lib\unittest\mock.py:2245: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002184D937100>
    def __init__(self, name, parent):
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_keystroke.py::TestKeystrokeClassMethods::test_get_for_session_empty_result
  C:\Python\Python313\Lib\unittest\mock.py:2245: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002184D9371F0>
    def __init__(self, name, parent):
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_keystroke_manager.py::TestKeystrokeManagerGetKeystrokesForSession::test_get_keystrokes_with_uuid_session_id
  <frozen importlib._bootstrap>:162: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002184D9375B0>
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_keystroke_manager.py::TestKeystrokeManagerGetKeystrokesForSession::test_get_keystrokes_with_uuid_session_id
  <frozen importlib._bootstrap>:162: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002184D9376A0>
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_keystroke_manager.py::TestKeystrokeManagerEdgeCases::test_memory_management_large_list
  C:\Python\Python313\Lib\uuid.py:174: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002184DA88310>
    if [hex, bytes, bytes_le, fields, int].count(None) != 4:
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_ngram_orchestrator_process_end_of_session.py::test_process_end_of_session_summarization_failure
  D:\SeanDevLocal\AITypingTrainer\.venv\Lib\site-packages\pydantic\_internal\_repr.py:63: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002184DD898A0>
    return join_str.join(repr(v) if a is None else f'{a}={v!r}' for a, v in self.__repr_args__())
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_ngram_orchestrator_process_end_of_session.py::test_process_end_of_session_summarization_failure
  D:\SeanDevLocal\AITypingTrainer\.venv\Lib\site-packages\pydantic\_internal\_repr.py:63: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002184DD89F30>
    return join_str.join(repr(v) if a is None else f'{a}={v!r}' for a, v in self.__repr_args__())
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_ngram_orchestrator_process_end_of_session.py::test_process_end_of_session_summarization_failure
  D:\SeanDevLocal\AITypingTrainer\.venv\Lib\site-packages\pydantic\_internal\_repr.py:63: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002184C81A2F0>
    return join_str.join(repr(v) if a is None else f'{a}={v!r}' for a, v in self.__repr_args__())
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_ngram_orchestrator_process_end_of_session.py::test_process_end_of_session_summarization_failure
  D:\SeanDevLocal\AITypingTrainer\.venv\Lib\site-packages\pydantic\_internal\_repr.py:63: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002184E5E3100>
    return join_str.join(repr(v) if a is None else f'{a}={v!r}' for a, v in self.__repr_args__())
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_ngram_orchestrator_process_end_of_session.py::test_process_end_of_session_summarization_failure
  D:\SeanDevLocal\AITypingTrainer\.venv\Lib\site-packages\pydantic\_internal\_repr.py:63: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002184E5E3B50>
    return join_str.join(repr(v) if a is None else f'{a}={v!r}' for a, v in self.__repr_args__())
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_ngram_orchestrator_process_end_of_session.py::test_process_end_of_session_summarization_failure
  D:\SeanDevLocal\AITypingTrainer\.venv\Lib\site-packages\pydantic\_internal\_repr.py:63: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002184E5E2C50>
    return join_str.join(repr(v) if a is None else f'{a}={v!r}' for a, v in self.__repr_args__())
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_ngram_orchestrator_process_end_of_session.py::test_process_end_of_session_summarization_failure
  D:\SeanDevLocal\AITypingTrainer\.venv\Lib\site-packages\pydantic\_internal\_repr.py:63: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002184D9373D0>
    return join_str.join(repr(v) if a is None else f'{a}={v!r}' for a, v in self.__repr_args__())
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_setting.py::TestSettingModel::test_setting_field_type_and_value_errors[setting_id-123-Input should be a valid string]
  D:\SeanDevLocal\AITypingTrainer\.venv\Lib\site-packages\pluggy\_callers.py:95: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002184DD89E40>
    args = [caller_kwargs[argname] for argname in hook_impl.argnames]
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_setting.py::TestSettingModel::test_setting_field_type_and_value_errors[setting_id-123-Input should be a valid string]
  D:\SeanDevLocal\AITypingTrainer\.venv\Lib\site-packages\pluggy\_callers.py:95: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002184DD8A3E0>
    args = [caller_kwargs[argname] for argname in hook_impl.argnames]
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_setting.py::TestSettingModel::test_setting_field_type_and_value_errors[setting_id-123-Input should be a valid string]
  D:\SeanDevLocal\AITypingTrainer\.venv\Lib\site-packages\pluggy\_callers.py:95: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002184DD89D50>
    args = [caller_kwargs[argname] for argname in hook_impl.argnames]
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_setting.py::TestSettingModel::test_setting_field_type_and_value_errors[setting_id-123-Input should be a valid string]
  D:\SeanDevLocal\AITypingTrainer\.venv\Lib\site-packages\pluggy\_callers.py:95: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002184DD8BC40>
    args = [caller_kwargs[argname] for argname in hook_impl.argnames]
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_setting.py::TestSettingModel::test_setting_field_type_and_value_errors[setting_id-123-Input should be a valid string]
  D:\SeanDevLocal\AITypingTrainer\.venv\Lib\site-packages\pluggy\_callers.py:95: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002184DD89C60>
    args = [caller_kwargs[argname] for argname in hook_impl.argnames]
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_setting.py::TestSettingModel::test_setting_field_type_and_value_errors[setting_id-123-Input should be a valid string]
  D:\SeanDevLocal\AITypingTrainer\.venv\Lib\site-packages\pluggy\_callers.py:95: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002184DD8B010>
    args = [caller_kwargs[argname] for argname in hook_impl.argnames]
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_setting.py::TestSettingModel::test_setting_field_type_and_value_errors[setting_id-123-Input should be a valid string]
  D:\SeanDevLocal\AITypingTrainer\.venv\Lib\site-packages\pluggy\_callers.py:95: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002184DD8A890>
    args = [caller_kwargs[argname] for argname in hook_impl.argnames]
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_setting.py::TestSettingModel::test_setting_field_type_and_value_errors[setting_id-123-Input should be a valid string]
  D:\SeanDevLocal\AITypingTrainer\.venv\Lib\site-packages\pluggy\_callers.py:95: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002184DD8A110>
    args = [caller_kwargs[argname] for argname in hook_impl.argnames]
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_setting_manager.py::TestSettingManager::test_list_settings_populated
  D:\SeanDevLocal\AITypingTrainer\db\database_manager.py:375: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002184DDAB970>
    return cast(CursorProtocol, self._conn.cursor())
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_setting_manager.py::TestSettingManager::test_list_settings_populated
  D:\SeanDevLocal\AITypingTrainer\db\database_manager.py:375: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002184DF5D210>
    return cast(CursorProtocol, self._conn.cursor())
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_setting_manager.py::TestSettingManager::test_list_settings_populated
  D:\SeanDevLocal\AITypingTrainer\db\database_manager.py:375: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002184DF5D3F0>
    return cast(CursorProtocol, self._conn.cursor())
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_setting_manager.py::TestSettingManager::test_list_settings_populated
  D:\SeanDevLocal\AITypingTrainer\db\database_manager.py:375: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002184DF5D4E0>
    return cast(CursorProtocol, self._conn.cursor())
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_setting_manager.py::TestSettingManager::test_list_settings_populated
  D:\SeanDevLocal\AITypingTrainer\db\database_manager.py:375: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002184DF5D5D0>
    return cast(CursorProtocol, self._conn.cursor())
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_setting_manager.py::TestSettingManager::test_list_settings_populated
  D:\SeanDevLocal\AITypingTrainer\db\database_manager.py:375: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002184DF5D7B0>
    return cast(CursorProtocol, self._conn.cursor())
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_snippet.py::test_list_snippets_empty
  C:\Python\Python313\Lib\pathlib\_local.py:128: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002184DDA89A0>
    path = os.fspath(arg)
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_snippet.py::test_list_snippets_empty
  C:\Python\Python313\Lib\pathlib\_local.py:128: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002184DDA9990>
    path = os.fspath(arg)
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_snippet.py::test_list_snippets_empty
  C:\Python\Python313\Lib\pathlib\_local.py:128: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002184DDA9210>
    path = os.fspath(arg)
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_snippet.py::test_list_snippets_empty
  C:\Python\Python313\Lib\pathlib\_local.py:128: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002184DDA8C70>
    path = os.fspath(arg)
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_snippet.py::test_list_snippets_empty
  C:\Python\Python313\Lib\pathlib\_local.py:128: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002184DDA9300>
    path = os.fspath(arg)
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_snippet.py::test_list_snippets_empty
  C:\Python\Python313\Lib\pathlib\_local.py:128: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002184DDA85E0>
    path = os.fspath(arg)
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_snippet.py::test_list_snippets_empty
  C:\Python\Python313\Lib\pathlib\_local.py:128: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002184DDA9030>
    path = os.fspath(arg)
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_snippet.py::test_list_snippets_empty
  C:\Python\Python313\Lib\pathlib\_local.py:128: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002184DDA9120>
    path = os.fspath(arg)
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_snippet.py::test_update_snippet_no_changes
  D:\SeanDevLocal\AITypingTrainer\.venv\Lib\site-packages\_pytest\reports.py:346: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002184DF96D40>
    keywords = {x: 1 for x in item.keywords}
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_snippet_manager.py::TestCreateSnippet::test_create_snippet_duplicate_name_in_category
  C:\Python\Python313\Lib\functools.py:53: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002184DEA8400>
    value = getattr(wrapped, attr)
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_snippet_manager.py::TestCreateSnippet::test_create_snippet_duplicate_name_in_category
  C:\Python\Python313\Lib\functools.py:53: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002184DEA8310>
    value = getattr(wrapped, attr)
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_user.py::TestUserModel::test_invalid_email_formats[username@example.com-]
  D:\SeanDevLocal\AITypingTrainer\.venv\Lib\site-packages\_pytest\raises.py:348: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002184DF5F5B0>
    if not isinstance(
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_user.py::TestUserModel::test_invalid_email_formats[username@example.com-]
  D:\SeanDevLocal\AITypingTrainer\.venv\Lib\site-packages\_pytest\raises.py:348: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002184DF5EF20>
    if not isinstance(
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_user.py::TestUserModel::test_invalid_email_formats[username@example.com-]
  D:\SeanDevLocal\AITypingTrainer\.venv\Lib\site-packages\_pytest\raises.py:348: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002184DF5E6B0>
    if not isinstance(
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_user.py::TestUserModel::test_invalid_email_formats[username@example.com-]
  D:\SeanDevLocal\AITypingTrainer\.venv\Lib\site-packages\_pytest\raises.py:348: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002184DF5E7A0>
    if not isinstance(
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_user.py::TestUserModel::test_invalid_email_formats[username@example.com-]
  D:\SeanDevLocal\AITypingTrainer\.venv\Lib\site-packages\_pytest\raises.py:348: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002184DF5F3D0>
    if not isinstance(
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_user.py::TestUserModel::test_invalid_email_formats[username@example.com-]
  D:\SeanDevLocal\AITypingTrainer\.venv\Lib\site-packages\_pytest\raises.py:348: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002184DF5F010>
    if not isinstance(
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_user.py::TestUserModel::test_invalid_email_formats[username@example.com-]
  D:\SeanDevLocal\AITypingTrainer\.venv\Lib\site-packages\_pytest\raises.py:348: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002184DF5E980>
    if not isinstance(
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_user.py::TestUserModel::test_invalid_email_formats[username@example.com-]
  D:\SeanDevLocal\AITypingTrainer\.venv\Lib\site-packages\_pytest\raises.py:348: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002184DF5E110>
    if not isinstance(
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_user.py::TestUserModel::test_invalid_email_formats[username@example.com-]
  D:\SeanDevLocal\AITypingTrainer\.venv\Lib\site-packages\_pytest\raises.py:348: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002184DF5EB60>
    if not isinstance(
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_user.py::TestUserModel::test_invalid_email_formats[username@example.com-]
  D:\SeanDevLocal\AITypingTrainer\.venv\Lib\site-packages\_pytest\raises.py:348: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002184DF5E200>
    if not isinstance(
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_user.py::TestUserModel::test_invalid_email_formats[username@example.com-]
  D:\SeanDevLocal\AITypingTrainer\.venv\Lib\site-packages\_pytest\raises.py:348: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002184DF5EE30>
    if not isinstance(
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_user.py::TestUserModel::test_invalid_email_formats[username@example.com-]
  D:\SeanDevLocal\AITypingTrainer\.venv\Lib\site-packages\_pytest\raises.py:348: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002184DF5EA70>
    if not isinstance(
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_user.py::TestUserModel::test_invalid_email_formats[username@example.com-]
  D:\SeanDevLocal\AITypingTrainer\.venv\Lib\site-packages\_pytest\raises.py:348: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002184DF5E3E0>
    if not isinstance(
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_user.py::TestUserModel::test_invalid_email_formats[username@example.com-]
  D:\SeanDevLocal\AITypingTrainer\.venv\Lib\site-packages\_pytest\raises.py:348: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002184DF5DB70>
    if not isinstance(
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_user.py::TestUserModel::test_invalid_email_formats[username@example.com-]
  D:\SeanDevLocal\AITypingTrainer\.venv\Lib\site-packages\_pytest\raises.py:348: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002184DF5E5C0>
    if not isinstance(
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_user.py::TestUserModel::test_invalid_email_formats[username@example.com-]
  D:\SeanDevLocal\AITypingTrainer\.venv\Lib\site-packages\_pytest\raises.py:348: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002184DF5DC60>
    if not isinstance(
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_user.py::TestUserModel::test_invalid_email_formats[username@example.com-]
  D:\SeanDevLocal\AITypingTrainer\.venv\Lib\site-packages\_pytest\raises.py:348: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002184DF5E890>
    if not isinstance(
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_user_manager_fixes.py::TestUserManagerDatabaseAccessFixes::test_get_user_by_id_not_found
  C:\Python\Python313\Lib\re\_parser.py:239: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002184DF5C220>
    def __next(self):
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_user_manager_fixes.py::TestUserManagerDatabaseAccessFixes::test_get_user_by_id_not_found
  C:\Python\Python313\Lib\re\_parser.py:239: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002184DF5D120>
    def __next(self):
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_user_manager_fixes.py::TestUserManagerDatabaseAccessFixes::test_get_user_by_id_not_found
  C:\Python\Python313\Lib\re\_parser.py:239: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002184DF5C8B0>
    def __next(self):
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_user_manager_fixes.py::TestUserManagerDatabaseAccessFixes::test_get_user_by_id_not_found
  C:\Python\Python313\Lib\re\_parser.py:239: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002184DF5D990>
    def __next(self):
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_user_manager_fixes.py::TestUserManagerDatabaseAccessFixes::test_get_user_by_id_not_found
  C:\Python\Python313\Lib\re\_parser.py:239: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002184DF5C9A0>
    def __next(self):
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_user_manager_fixes.py::TestUserManagerDatabaseAccessFixes::test_get_user_by_id_not_found
  C:\Python\Python313\Lib\re\_parser.py:239: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002184DDA8B80>
    def __next(self):
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_user_manager_fixes.py::TestUserManagerDatabaseAccessFixes::test_get_user_by_id_not_found
  C:\Python\Python313\Lib\re\_parser.py:239: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002184DDAA890>
    def __next(self):
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_user_manager_fixes.py::TestUserManagerDatabaseAccessFixes::test_get_user_by_id_not_found
  C:\Python\Python313\Lib\re\_parser.py:239: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002184DF94A90>
    def __next(self):
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_user_manager_fixes.py::TestUserManagerDatabaseAccessFixes::test_get_user_by_id_not_found
  C:\Python\Python313\Lib\re\_parser.py:239: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002184DF94310>
    def __next(self):
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=============================== tests coverage ================================
_______________ coverage: platform win32, python 3.13.2-final-0 _______________

Name                                Stmts   Miss  Cover   Missing
-----------------------------------------------------------------
models\__init__.py                      1      0   100%
models\category.py                     45      1    98%   68
models\category_manager.py             76     14    82%   220-238
models\dynamic_content_service.py     148     58    61%   84, 100-109, 113-139, 144, 191, 207-213, 224-251, 297-312
models\keyboard.py                     66     16    76%   43, 45, 56, 58, 78, 81-82, 90, 93-94, 99, 114-118
models\keyboard_manager.py             57      7    88%   71-80, 101, 146, 159-161
models\keystroke.py                    95      9    91%   36, 68-69, 79-80, 132-139
models\keystroke_manager.py            62      4    94%   62-63, 137-138
models\library.py                      72     72     0%   7-170
models\llm_ngram_service.py           206     72    65%   104-109, 153-154, 176-177, 181-194, 206-208, 213, 218-223, 226, 233-242, 248-251, 253-254, 260-268, 278-294, 310, 335, 337-340, 349, 365-366, 379-380
models\ngram.py                        83      0   100%
models\ngram_analytics_service.py     339    211    38%   64, 70, 244-342, 359-368, 383-443, 467-544, 548-575, 593-701, 734-737, 765-766, 780-790, 809-812, 815-817, 830-831, 834-836, 848-867, 875-887
models\ngram_manager.py               126     41    67%   67, 75, 83, 95-96, 172, 192, 243-274, 285-303, 307, 336-343
models\session.py                      88      2    98%   79, 93
models\session_manager.py             122     69    43%   43-45, 67-80, 90-92, 118-124, 131-135, 149-153, 230-243, 246, 252, 255, 259-262, 268-341
models\setting.py                      74      3    96%   89, 109, 121
models\setting_manager.py              68     10    85%   39-46, 174-177, 286
models\snippet.py                      85     16    81%   82-92, 129, 141, 154, 159, 164, 169
models\snippet_manager.py             183    121    34%   43, 45, 74-78, 86, 117, 134-137, 141-150, 167-193, 210-247, 264-300, 306-318, 338-376, 388
models\user.py                        101     11    89%   61, 67, 79, 84, 93, 99, 102, 122-123, 141, 154
models\user_manager.py                 68      0   100%
-----------------------------------------------------------------
TOTAL                                2165    737    66%
=========================== short test summary info ===========================
FAILED tests/models/test_dynamic_content_service.py::TestNGramOnlyMode::test_ngram_content_filters_out_of_scope_chars
FAILED tests/models/test_dynamic_content_service.py::TestWordsOnlyMode::test_generate_words_content
FAILED tests/models/test_dynamic_content_service.py::TestWordsOnlyMode::test_words_content_filters_out_of_scope_chars
FAILED tests/models/test_dynamic_content_service.py::TestWordsOnlyMode::test_words_content_custom_delimiter
FAILED tests/models/test_dynamic_content_service.py::TestMixedMode::test_generate_mixed_content
FAILED tests/models/test_dynamic_content_service.py::TestMixedMode::test_mixed_content_has_variety
FAILED tests/models/test_keystroke_manager.py::TestKeystrokeManagerSaveKeystrokes::test_save_keystrokes_success
FAILED tests/models/test_keystroke_manager.py::TestKeystrokeManagerSaveKeystrokes::test_save_keystrokes_database_error
FAILED tests/models/test_keystroke_manager.py::TestKeystrokeManagerSaveKeystrokes::test_save_keystrokes_with_special_characters
FAILED tests/models/test_keystroke_manager.py::TestKeystrokeManagerSaveKeystrokes::test_save_keystrokes_boolean_conversion
FAILED tests/models/test_keystroke_manager.py::TestKeystrokeManagerIntegration::test_full_keystroke_workflow
FAILED tests/models/test_keystroke_manager.py::TestKeystrokeManagerEdgeCases::test_unicode_and_special_characters
FAILED tests/models/test_keystroke_manager.py::TestKeystrokeManagerErrorHandling::test_database_connection_failure
FAILED tests/models/test_keystroke_manager.py::TestKeystrokeManagerErrorHandling::test_partial_save_failure
FAILED tests/models/test_keystroke_manager.py::TestKeystrokeManagerErrorHandling::test_network_timeout_simulation
FAILED tests/models/test_llm_ngram_service.py::test_llm_simple_prompt_returns_10_words
FAILED tests/models/test_ngram.py::TestKeystroke::test_keystroke_nfc_single_char
FAILED tests/models/test_ngram_analytics_service.py::TestNGramAnalyticsService::test_dual_insert_creates_records_in_both_tables
FAILED tests/models/test_ngram_analytics_service.py::TestNGramAnalyticsService::test_history_table_accumulates_all_records
FAILED tests/models/test_ngram_analytics_service.py::TestNGramAnalyticsService::test_get_ngram_history_retrieval
FAILED tests/models/test_ngram_analytics_service.py::TestNGramAnalyticsService::test_history_table_schema_compatibility
FAILED tests/models/test_ngram_analytics_service_session_methods.py::TestAddSpeedSummaryForSession::test_nonexistent_session
FAILED tests/models/test_ngram_analytics_service_session_methods.py::TestCatchupSpeedSummary::test_empty_database_catchup
FAILED tests/models/test_ngram_orchestrator_process_end_of_session.py::test_process_end_of_session_success_path
FAILED tests/models/test_ngram_orchestrator_process_end_of_session.py::test_process_end_of_session_session_save_failure
FAILED tests/models/test_ngram_orchestrator_process_end_of_session.py::test_process_end_of_session_keystrokes_save_failure
FAILED tests/models/test_ngram_orchestrator_process_end_of_session.py::test_process_end_of_session_summarization_failure
ERROR tests/models/test_ngram_analytics_service.py::TestNGramAnalyticsService::test_refresh_speed_summaries_basic
ERROR tests/models/test_ngram_analytics_service_session_methods.py::TestSummarizeSessionNgrams::test_summarize_with_ngram_speed_only[1-1]
ERROR tests/models/test_ngram_analytics_service_session_methods.py::TestSummarizeSessionNgrams::test_summarize_with_ngram_speed_only[3-3]
ERROR tests/models/test_ngram_analytics_service_session_methods.py::TestSummarizeSessionNgrams::test_summarize_with_ngram_errors_only[1-1]
ERROR tests/models/test_ngram_analytics_service_session_methods.py::TestSummarizeSessionNgrams::test_summarize_with_ngram_errors_only[2-2]
ERROR tests/models/test_ngram_analytics_service_session_methods.py::TestSummarizeSessionNgrams::test_summarize_with_speed_and_errors
ERROR tests/models/test_ngram_analytics_service_session_methods.py::TestSummarizeSessionNgrams::test_summarize_with_keystrokes[1-1]
ERROR tests/models/test_ngram_analytics_service_session_methods.py::TestSummarizeSessionNgrams::test_summarize_with_keystrokes[3-3]
ERROR tests/models/test_ngram_analytics_service_session_methods.py::TestSummarizeSessionNgrams::test_no_sessions_missing
ERROR tests/models/test_ngram_analytics_service_session_methods.py::TestSummarizeSessionNgrams::test_sessions_missing_no_data
ERROR tests/models/test_ngram_analytics_service_session_methods.py::TestAddSpeedSummaryForSession::test_single_session_processing
ERROR tests/models/test_ngram_analytics_service_session_methods.py::TestAddSpeedSummaryForSession::test_multiple_ngrams_processing
ERROR tests/models/test_ngram_analytics_service_session_methods.py::TestCatchupSpeedSummary::test_single_session_catchup
ERROR tests/models/test_ngram_analytics_service_session_methods.py::TestCatchupSpeedSummary::test_multiple_sessions_catchup
ERROR tests/models/test_ngram_analytics_service_session_methods.py::TestCatchupSpeedSummary::test_catchup_with_session_errors
ERROR tests/models/test_ngram_analytics_service_session_methods.py::TestIntegrationScenarios::test_full_workflow_integration
ERROR tests/models/test_snippet.py::test_snippet_ascii_name
ERROR tests/models/test_snippet.py::test_snippet_name_length
ERROR tests/models/test_snippet.py::test_snippet_creation_validation[Alpha-Some content-True]
ERROR tests/models/test_snippet.py::test_snippet_creation_validation[-Some content-False]
ERROR tests/models/test_snippet.py::test_snippet_creation_validation[AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA-Content-False]
ERROR tests/models/test_snippet.py::test_snippet_creation_validation[NonAscii\xe9-Content-False]
ERROR tests/models/test_snippet.py::test_snippet_creation_validation[Alpha--False]
ERROR tests/models/test_snippet.py::test_snippet_name_uniqueness[Unique1-Unique2-True]
ERROR tests/models/test_snippet.py::test_snippet_name_uniqueness[DupName-DupName-False]
ERROR tests/models/test_snippet.py::test_snippet_creation_valid
ERROR tests/models/test_snippet.py::test_get_nonexistent_snippet
ERROR tests/models/test_snippet.py::test_list_snippets_empty
ERROR tests/models/test_snippet.py::test_list_snippets_populated
ERROR tests/models/test_snippet.py::test_snippet_edit
ERROR tests/models/test_snippet.py::test_snippet_update
ERROR tests/models/test_snippet.py::test_snippet_update_name_only
ERROR tests/models/test_snippet.py::test_snippet_update_content_only
ERROR tests/models/test_snippet.py::test_snippet_delete
ERROR tests/models/test_snippet.py::test_delete_nonexistent_snippet
ERROR tests/models/test_snippet.py::test_edit_snippet_change_category
ERROR tests/models/test_snippet.py::test_edit_snippet_invalid_category
ERROR tests/models/test_snippet.py::test_snippet_sql_injection
ERROR tests/models/test_snippet.py::test_snippet_sql_injection_in_content
ERROR tests/models/test_snippet.py::test_snippet_long_content
ERROR tests/models/test_snippet.py::test_snippet_content_splitting_boundaries
ERROR tests/models/test_snippet.py::test_update_nonexistent_snippet
ERROR tests/models/test_snippet.py::test_snippet_part_number_sequence
ERROR tests/models/test_snippet.py::test_snippet_operation_handling
ERROR tests/models/test_snippet.py::test_delete_snippet
ERROR tests/models/test_snippet.py::test_create_snippet_with_nonexistent_category
ERROR tests/models/test_snippet.py::test_update_snippet_partial
ERROR tests/models/test_snippet.py::test_update_snippet_no_changes
ERROR tests/models/test_snippet.py::test_get_snippet_by_name
ERROR tests/models/test_snippet.py::test_get_snippet_by_name_nonexistent
ERROR tests/models/test_snippet.py::test_get_snippet_by_name_multiple_categories
ERROR tests/models/test_snippet.py::test_search_snippets
ERROR tests/models/test_snippet.py::test_search_snippets_no_results
ERROR tests/models/test_snippet.py::test_snippet_sql_injection_name_create
ERROR tests/models/test_snippet.py::test_snippet_sql_injection_content_create
ERROR tests/models/test_snippet.py::test_snippet_sql_injection_name_create_with_specific_error
ERROR tests/models/test_snippet.py::test_snippet_sql_injection_content_update
ERROR tests/models/test_snippet.py::test_snippet_sql_injection_name_update
ERROR tests/models/test_snippet.py::test_snippet_deletion_idempotency
ERROR tests/models/test_snippet.py::test_snippet_manager_handles_db_errors_gracefully_on_create
ERROR tests/models/test_snippet.py::test_snippet_manager_handles_db_errors_gracefully_on_get
ERROR tests/models/test_snippet.py::test_snippet_manager_handles_db_errors_gracefully_on_update
ERROR tests/models/test_snippet.py::test_snippet_manager_handles_db_errors_gracefully_on_delete
ERROR tests/models/test_snippet.py::test_snippet_manager_handles_db_errors_gracefully_on_list
ERROR tests/models/test_snippet.py::test_snippet_manager_handles_db_errors_gracefully_on_search
ERROR tests/models/test_snippet.py::test_create_snippet_pydantic_validation_errors
===== 27 failed, 416 passed, 4 skipped, 87 warnings, 66 errors in 46.56s ======
