models\category.py: error: Source file found twice under different module names: "AITypingTrainer.models.category" and "models.category"
models\category.py: note: See https://mypy.readthedocs.io/en/stable/running_mypy.html#mapping-file-paths-to-modules for more info
models\category.py: note: Common resolutions include: a) adding `__init__.py` somewhere, b) using `--explicit-package-bases` or adjusting MYPYPATH
Found 1 error in 1 file (errors prevented further checking)
E501 Line too long (90 > 88)
   --> models\category_manager.py:226:89
    |
224 |             new_category = Category(
225 |                 category_name=category_name,
226 |                 description="Category for custom text snippets and user-generated content"
    |                                                                                         ^^
227 |             )
228 |             self.save_category(new_category)
    |

E501 Line too long (97 > 88)
  --> models\dynamic_content_manager.py:91:89
   |
89 |             raise ValueError("Ngram focus list cannot be empty")
90 |
91 |         if self.mode in (ContentMode.WORDS_ONLY, ContentMode.MIXED) and self.llm_service is None:
   |                                                                                         ^^^^^^^^^
92 |             raise ValueError("LLM service is required for WordsOnly and Mixed modes")
   |

I001 [*] Import block is un-sorted or un-formatted
  --> models\dynamic_content_service.py:7:1
   |
 5 |   """
 6 |
 7 | / import random
 8 | | from enum import Enum
 9 | | from typing import List, Optional
10 | |
11 | | from models.llm_ngram_service import LLMNgramService
12 | | from models.category_manager import CategoryManager
13 | | from models.snippet_manager import SnippetManager
   | |_________________________________________________^
   |
help: Organize imports

E501 Line too long (97 > 88)
  --> models\dynamic_content_service.py:93:89
   |
91 |             raise ValueError("Ngram focus list cannot be empty")
92 |
93 |         if self.mode in (ContentMode.WORDS_ONLY, ContentMode.MIXED) and self.llm_service is None:
   |                                                                                         ^^^^^^^^^
94 |             raise ValueError("LLM service is required for WordsOnly and Mixed modes")
   |

E501 Line too long (96 > 88)
   --> models\dynamic_content_service.py:110:89
    |
108 |         weighted_ngrams = []
109 |         for ngram in self.ngram_focus_list:
110 |             # Add each ngram multiple times based on its length (shorter ngrams get more weight)
    |                                                                                         ^^^^^^^^
111 |             weight = max(1, 6 - len(ngram))  # 3-char gets weight 3, 4-char gets weight 2, etc.
112 |             weighted_ngrams.extend([ngram] * weight)
    |

E501 Line too long (95 > 88)
   --> models\dynamic_content_service.py:111:89
    |
109 |         for ngram in self.ngram_focus_list:
110 |             # Add each ngram multiple times based on its length (shorter ngrams get more weight)
111 |             weight = max(1, 6 - len(ngram))  # 3-char gets weight 3, 4-char gets weight 2, etc.
    |                                                                                         ^^^^^^^
112 |             weighted_ngrams.extend([ngram] * weight)
    |

E501 Line too long (115 > 88)
   --> models\dynamic_content_service.py:270:89
    |
268 |             return self._generate_mixed_content(self.practice_length, delimiter)
269 |
270 |     def ensure_dynamic_snippet_id(self, category_manager: CategoryManager, snippet_manager: SnippetManager) -> str:
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^
271 |         """
272 |         Ensure a valid dynamic snippet_id exists by coordinating with CategoryManager and SnippetManager.
    |

E501 Line too long (105 > 88)
   --> models\dynamic_content_service.py:272:89
    |
270 |     def ensure_dynamic_snippet_id(self, category_manager: CategoryManager, snippet_manager: SnippetManager) -> str:
271 |         """
272 |         Ensure a valid dynamic snippet_id exists by coordinating with CategoryManager and SnippetManager.
    |                                                                                         ^^^^^^^^^^^^^^^^^
273 |         
274 |         This method:
    |

E501 Line too long (98 > 88)
   --> models\dynamic_content_service.py:275:89
    |
274 |         This method:
275 |         1. Uses CategoryManager.create_dynamic_category() to get the "Custom Snippets" category_id
    |                                                                                         ^^^^^^^^^^
276 |         2. Uses SnippetManager.create_dynamic_snippet() to get or create a dynamic snippet
277 |         3. Returns the snippet_id for use in typing drills
    |

E501 Line too long (90 > 88)
   --> models\dynamic_content_service.py:276:89
    |
274 |         This method:
275 |         1. Uses CategoryManager.create_dynamic_category() to get the "Custom Snippets" category_id
276 |         2. Uses SnippetManager.create_dynamic_snippet() to get or create a dynamic snippet
    |                                                                                         ^^
277 |         3. Returns the snippet_id for use in typing drills
    |

E501 Line too long (91 > 88)
   --> models\dynamic_content_service.py:301:89
    |
299 |         except Exception as e:
300 |             # Log the error and re-raise for proper error handling
301 |             raise Exception(f"Failed to ensure dynamic snippet_id exists: {str(e)}") from e
    |                                                                                         ^^^
    |

E501 Line too long (92 > 88)
  --> models\keystroke_manager.py:41:89
   |
39 |                 "INSERT INTO session_keystrokes "
40 |                 "(session_id, keystroke_id, keystroke_time, "
41 |                 "keystroke_char, expected_char, is_error, time_since_previous, text_index) "
   |                                                                                         ^^^^
42 |                 "VALUES (?, ?, ?, ?, ?, ?, ?, ?)"
43 |             )
   |

E501 Line too long (92 > 88)
  --> models\keystroke_manager.py:60:89
   |
58 |             ]
59 |
60 |             # Use execute_many when supported; fall back to per-row execute to satisfy tests
   |                                                                                         ^^^^
61 |             if getattr(self.db_manager, "execute_many_supported", False):
62 |                 # Some backends optimize bulk inserts
   |

E501 Line too long (93 > 88)
  --> models\llm_ngram_service.py:23:89
   |
22 |     Updates:
23 |     - API key argument now optional; if omitted and allow_env=True, resolves from environment
   |                                                                                         ^^^^^
24 |       variables in priority order: OPENAI_API_KEY, OpenAPI_Key, OPENAI_API_TOKEN.
25 |     - Reuses a single OpenAI client instance (instead of recreating in get_words_with_ngrams_2).
   |

E501 Line too long (96 > 88)
  --> models\llm_ngram_service.py:25:89
   |
23 |     - API key argument now optional; if omitted and allow_env=True, resolves from environment
24 |       variables in priority order: OPENAI_API_KEY, OpenAPI_Key, OPENAI_API_TOKEN.
25 |     - Reuses a single OpenAI client instance (instead of recreating in get_words_with_ngrams_2).
   |                                                                                         ^^^^^^^^
26 |     - Optional validation (list models) can be enabled via validate=True.
27 |     """
   |

E501 Line too long (90 > 88)
  --> models\llm_ngram_service.py:44:89
   |
42 |         if not api_key:
43 |             raise LLMMissingAPIKeyError(
44 |                 "OpenAI API key must be provided explicitly or via environment variables."
   |                                                                                         ^^
45 |             )
46 |         self.api_key: str = api_key
   |

E501 Line too long (98 > 88)
  --> models\llm_ngram_service.py:51:89
   |
49 |                 self.client = OpenAI(api_key=self.api_key)
50 |                 if validate:
51 |                     # Lightweight validation; ignore errors to avoid hard-fail in some deployments
   |                                                                                         ^^^^^^^^^^
52 |                     try:  # pragma: no cover (network dependent)
53 |                         _ = self.client.models.list()
   |

E501 Line too long (98 > 88)
  --> models\llm_ngram_service.py:78:89
   |
76 |             raise ValueError("No ngrams provided or ngrams is not a list.")
77 |
78 |     def _format_prompt_parameters(self, ngrams: List[str], allowed_chars: str) -> tuple[str, str]:
   |                                                                                         ^^^^^^^^^^
79 |         """Format ngrams and allowed_chars for prompt template."""
80 |         return repr(ngrams), repr(allowed_chars)
   |

E501 Line too long (91 > 88)
  --> models\llm_ngram_service.py:89:89
   |
87 |         target_word_count: int = int(max_length / 5)
88 |         prompt_path = os.path.join(
89 |             os.path.dirname(os.path.dirname(__file__)), "Prompts", "ngram_words_prompt.txt"
   |                                                                                         ^^^
90 |         )
91 |         try:
   |

E501 Line too long (90 > 88)
   --> models\llm_ngram_service.py:136:89
    |
134 |                             chunks.append(part["text"])
135 |                         for ann in part.get("annotations", []) or []:
136 |                             if isinstance(ann, dict) and isinstance(ann.get("text"), str):
    |                                                                                         ^^
137 |                                 chunks.append(ann["text"])
138 |             return "\n".join(s for s in chunks if s).strip()
    |

E501 Line too long (91 > 88)
   --> models\llm_ngram_service.py:155:89
    |
154 |         candidates = {}
155 |         for key in ("status", "usage", "id", "created_at", "finish_reason", "stop_reason"):
    |                                                                                         ^^^
156 |             if key in data:
157 |                 candidates[key] = data[key]
    |

E501 Line too long (93 > 88)
   --> models\llm_ngram_service.py:168:89
    |
166 |             parts = out.get("content", [])
167 |             if parts:
168 |                 kinds = [p.get("type") for p in parts if isinstance(p, dict) and "type" in p]
    |                                                                                         ^^^^^
169 |                 entry["content_types"] = kinds
170 |                 entry["has_tool_calls"] = any(
    |

E501 Line too long (98 > 88)
   --> models\llm_ngram_service.py:173:89
    |
171 |                     "tool_calls" in p for p in parts if isinstance(p, dict)
172 |                 )
173 |                 entry["has_refusal"] = any(p.get("refusal") for p in parts if isinstance(p, dict))
    |                                                                                         ^^^^^^^^^^
174 |                 if any("content_filter_results" in p for p in parts if isinstance(p, dict)):
175 |                     entry["has_content_filter_results"] = True
    |

E501 Line too long (92 > 88)
   --> models\llm_ngram_service.py:174:89
    |
172 |                 )
173 |                 entry["has_refusal"] = any(p.get("refusal") for p in parts if isinstance(p, dict))
174 |                 if any("content_filter_results" in p for p in parts if isinstance(p, dict)):
    |                                                                                         ^^^^
175 |                     entry["has_content_filter_results"] = True
176 |             info_list.append(entry)
    |

E501 Line too long (91 > 88)
   --> models\llm_ngram_service.py:221:89
    |
219 |         return text
220 |
221 |     def _process_response_to_fit_length(self, generated_text: str, max_length: int) -> str:
    |                                                                                         ^^^
222 |         """Process GPT response to fit within max_length constraint."""
223 |         words = generated_text.split()
    |

E501 Line too long (99 > 88)
   --> models\llm_ngram_service.py:238:89
    |
236 |             raise RuntimeError("Failed to generate words with ngrams.")
237 |
238 |     def get_words_with_ngrams(self, ngrams: List[str], allowed_chars: str, max_length: int) -> str:
    |                                                                                         ^^^^^^^^^^^
239 |         """Generate words that include each of the provided ngrams at least somewhere.
    |

E501 Line too long (90 > 88)
   --> models\llm_ngram_service.py:241:89
    |
239 |         """Generate words that include each of the provided ngrams at least somewhere.
240 |
241 |         This method follows single responsibility principle with extracted helper methods.
    |                                                                                         ^^
242 |         """
243 |         # Step 1: Validate input
    |

E501 Line too long (92 > 88)
   --> models\llm_ngram_service.py:247:89
    |
246 |         # Step 2: Format parameters for prompt
247 |         ngram_str, allowed_chars_str = self._format_prompt_parameters(ngrams, allowed_chars)
    |                                                                                         ^^^^
248 |
249 |         # Step 3: Load and format prompt template
    |

E501 Line too long (96 > 88)
   --> models\llm_ngram_service.py:250:89
    |
249 |         # Step 3: Load and format prompt template
250 |         prompt = self._load_and_format_prompt_template(ngram_str, allowed_chars_str, max_length)
    |                                                                                         ^^^^^^^^
251 |
252 |         # Step 4: Call GPT-5 with robust error handling
    |

I001 [*] Import block is un-sorted or un-formatted
  --> models\ngram_analytics_service.py:11:1
   |
 9 |   """
10 |
11 | / import logging
12 | | import traceback
13 | | from dataclasses import dataclass
14 | | from datetime import datetime
15 | | from math import log
16 | | from typing import Dict, List, Optional, Union, TYPE_CHECKING
17 | |
18 | | from pydantic import BaseModel, Field
19 | |
20 | | from db.database_manager import DatabaseManager
21 | | from helpers.debug_util import DebugUtil
22 | | from models.ngram_manager import NGramManager
   | |_____________________________________________^
23 |
24 |   if TYPE_CHECKING:  # Only for type hints to avoid circular imports at runtime
   |
help: Organize imports

I001 [*] Import block is un-sorted or un-formatted
  --> models\ngram_analytics_service.py:25:5
   |
24 |   if TYPE_CHECKING:  # Only for type hints to avoid circular imports at runtime
25 | /     from models.session import Session
26 | |     from models.keystroke import Keystroke
   | |__________________________________________^
27 |
28 |   logger = logging.getLogger(__name__)
   |
help: Organize imports

E501 Line too long (99 > 88)
  --> models\ngram_analytics_service.py:51:89
   |
49 |         self.max_samples = max_samples
50 |
51 |     def calculate_decaying_average(self, values: List[float], timestamps: List[datetime]) -> float:
   |                                                                                         ^^^^^^^^^^^
52 |         """
53 |         Calculate decaying average with exponential weighting.
   |

E501 Line too long (100 > 88)
  --> models\ngram_analytics_service.py:72:89
   |
71 |         # Sort by timestamp descending and take only the most recent max_samples
72 |         recent_data = sorted(zip(timestamps, values, strict=True), reverse=True)[: self.max_samples]
   |                                                                                         ^^^^^^^^^^^^
73 |
74 |         if not recent_data:
   |

I001 [*] Import block is un-sorted or un-formatted
   --> models\ngram_analytics_service.py:215:9
    |
213 |               Exception: If any step fails, the exception is propagated
214 |           """
215 | /         from models.session_manager import SessionManager  # local import to avoid cycles
216 | |         from models.keystroke import Keystroke
217 | |         from models.keystroke_manager import KeystrokeManager
    | |_____________________________________________________________^
218 |
219 |           if self.db is None:
    |
help: Organize imports

E501 Line too long (89 > 88)
   --> models\ngram_analytics_service.py:215:89
    |
213 |             Exception: If any step fails, the exception is propagated
214 |         """
215 |         from models.session_manager import SessionManager  # local import to avoid cycles
    |                                                                                         ^
216 |         from models.keystroke import Keystroke
217 |         from models.keystroke_manager import KeystrokeManager
    |

E501 Line too long (107 > 88)
   --> models\ngram_analytics_service.py:249:89
    |
247 |             else:
248 |                 kdict = dict(item)
249 |                 # Skip explicit backspace records; they are corrections, not keystrokes for n-gram analysis
    |                                                                                         ^^^^^^^^^^^^^^^^^^^
250 |                 if kdict.get("is_backspace"):
251 |                     continue
    |

E501 Line too long (91 > 88)
   --> models\ngram_analytics_service.py:311:89
    |
309 |         try:
310 |             inserted = self.summarize_session_ngrams()
311 |             # Optionally also run catch-up for speed summaries; not strictly required here.
    |                                                                                         ^^^
312 |             return inserted
313 |         except Exception as e:
    |

E501 Line too long (95 > 88)
   --> models\ngram_analytics_service.py:386:89
    |
384 |                 )
385 |
386 |             logger.info(f"Retrieved {len(history_data)} historical records for user {user_id}")
    |                                                                                         ^^^^^^^
387 |             return history_data
    |

E501 Line too long (90 > 88)
   --> models\ngram_analytics_service.py:499:89
    |
497 |             return []
498 |
499 |     def _parse_datetime(self, dt_value: Union[str, datetime, None]) -> Optional[datetime]:
    |                                                                                         ^^
500 |         """Parse datetime from various possible formats."""
501 |         if dt_value is None:
    |

E501 Line too long (99 > 88)
   --> models\ngram_analytics_service.py:595:89
    |
593 | ΓÇª                     SUM(
594 | ΓÇª                         nd.ngram_time_ms * 
595 | ΓÇª                         POWER(0.9, JULIANDAY(ts.date_val) - JULIANDAY(nd.session_date))
    |                                                                               ^^^^^^^^^^^
596 | ΓÇª                     ) / SUM(
597 | ΓÇª                         POWER(0.9, JULIANDAY(ts.date_val) - JULIANDAY(nd.session_date))
    |

E501 Line too long (99 > 88)
   --> models\ngram_analytics_service.py:597:89
    |
595 | ΓÇª                             POWER(0.9, JULIANDAY(ts.date_val) - JULIANDAY(nd.session_date))
596 | ΓÇª                         ) / SUM(
597 | ΓÇª                             POWER(0.9, JULIANDAY(ts.date_val) - JULIANDAY(nd.session_date))
    |                                                                                   ^^^^^^^^^^^
598 | ΓÇª                         )
599 | ΓÇª                     ELSE 0
    |

E501 Line too long (90 > 88)
   --> models\ngram_analytics_service.py:603:89
    |
601 |                     FROM time_series ts
602 |                     LEFT JOIN ngram_data nd ON nd.session_date <= ts.date_val
603 |                         AND nd.recency_rank <= 20  -- Only consider most recent 20 samples
    |                                                                                         ^^
604 |                     GROUP BY ts.date_val, nd.ngram_text, nd.ngram_size
605 |                     HAVING COUNT(nd.ngram_time_ms) > 0  -- Only include dates with data
    |

E501 Line too long (99 > 88)
   --> models\ngram_analytics_service.py:749:89
    |
747 |             allowed_chars = set(included_keys)
748 |             return_val = [
749 |                 stats for stats in return_val if all(char in allowed_chars for char in stats.ngram)
    |                                                                                         ^^^^^^^^^^^
750 |             ]
    |

E501 Line too long (97 > 88)
   --> models\ngram_analytics_service.py:831:89
    |
829 |                 avg_speed=0,  # Not applicable for error count
830 |                 total_occurrences=row["error_count"],
831 |                 last_used=datetime.fromisoformat(row["last_used"]) if row["last_used"] else None,
    |                                                                                         ^^^^^^^^^
832 |                 ngram_score=0,
833 |             )
    |

E501 Line too long (99 > 88)
   --> models\ngram_analytics_service.py:841:89
    |
839 |             allowed_chars = set(included_keys)
840 |             return_val = [
841 |                 stats for stats in return_val if all(char in allowed_chars for char in stats.ngram)
    |                                                                                         ^^^^^^^^^^^
842 |             ]
    |

E501 Line too long (94 > 88)
   --> models\ngram_analytics_service.py:848:89
    |
846 |     def summarize_session_ngrams(self) -> int:
847 |         """
848 |         Summarize session ngram performance for all sessions not yet in session_ngram_summary.
    |                                                                                         ^^^^^^
849 |
850 |         Uses complex CTEs to aggregate data from session_ngram_speed, session_ngram_errors,
    |

E501 Line too long (91 > 88)
   --> models\ngram_analytics_service.py:850:89
    |
848 |         Summarize session ngram performance for all sessions not yet in session_ngram_summary.
849 |
850 |         Uses complex CTEs to aggregate data from session_ngram_speed, session_ngram_errors,
    |                                                                                         ^^^
851 |         and session_keystrokes tables, then inserts the results into session_ngram_summary.
    |

E501 Line too long (91 > 88)
   --> models\ngram_analytics_service.py:851:89
    |
850 |         Uses complex CTEs to aggregate data from session_ngram_speed, session_ngram_errors,
851 |         and session_keystrokes tables, then inserts the results into session_ngram_summary.
    |                                                                                         ^^^
852 |
853 |         Returns:
    |

E501 Line too long (90 > 88)
   --> models\ngram_analytics_service.py:976:89
    |
974 |         INSERT INTO session_ngram_summary (
975 |             session_id, ngram_text, user_id, keyboard_id, ngram_size,
976 |             avg_ms_per_keystroke, target_speed_ms, instance_count, error_count, updated_dt
    |                                                                                         ^^
977 |         )
978 |         SELECT 
    |

E501 Line too long (90 > 88)
   --> models\ngram_analytics_service.py:980:89
    |
978 |         SELECT 
979 |             session_id, ngram_text, user_id, keyboard_id, ngram_size,
980 |             avg_ms_per_keystroke, target_speed_ms, instance_count, error_count, updated_dt
    |                                                                                         ^^
981 |         FROM ReadyToInsert;
982 |         """
    |

E501 Line too long (100 > 88)
   --> models\ngram_analytics_service.py:989:89
    |
987 |             rows_affected = cursor.rowcount if cursor.rowcount is not None else 0
988 |
989 |             logger.info(f"Successfully inserted {rows_affected} records into session_ngram_summary")
    |                                                                                         ^^^^^^^^^^^^
990 |
991 |             # Log summary statistics
    |

E501 Line too long (95 > 88)
    --> models\ngram_analytics_service.py:1001:89
     |
 999 |             if summary_stats:
1000 |                 logger.info(
1001 |                     f"Total records in session_ngram_summary: {summary_stats['total_records']}"
     |                                                                                         ^^^^^^^
1002 |                 )
1003 |                 logger.info(
     |

E501 Line too long (100 > 88)
    --> models\ngram_analytics_service.py:1004:89
     |
1002 |                 )
1003 |                 logger.info(
1004 |                     f"Unique sessions in session_ngram_summary: {summary_stats['unique_sessions']}")
     |                                                                                         ^^^^^^^^^^^^
1005 |
1006 |             return rows_affected
     |

E501 Line too long (93 > 88)
    --> models\ngram_analytics_service.py:1016:89
     |
1014 |     def add_speed_summary_for_session(self, session_id: str) -> dict:
1015 |         """
1016 |         Update performance summary for a specific session using decaying average calculation.
     |                                                                                         ^^^^^
1017 |
1018 |         Uses the last 20 sessions (including the given session) to calculate decaying averages
     |

E501 Line too long (94 > 88)
    --> models\ngram_analytics_service.py:1018:89
     |
1016 |         Update performance summary for a specific session using decaying average calculation.
1017 |
1018 |         Uses the last 20 sessions (including the given session) to calculate decaying averages
     |                                                                                         ^^^^^^
1019 |         and updates both ngram_speed_summary_curr (merge) and ngram_speed_summary_hist (insert).
     |

E501 Line too long (96 > 88)
    --> models\ngram_analytics_service.py:1019:89
     |
1018 |         Uses the last 20 sessions (including the given session) to calculate decaying averages
1019 |         and updates both ngram_speed_summary_curr (merge) and ngram_speed_summary_hist (insert).
     |                                                                                         ^^^^^^^^
1020 |
1021 |         Args:
     |

E501 Line too long (98 > 88)
    --> models\ngram_analytics_service.py:1034:89
     |
1032 |         # Get session info for logging
1033 |         session_info = self.db.fetchone(
1034 |             "SELECT start_time, user_id, keyboard_id FROM practice_sessions WHERE session_id = ?",
     |                                                                                         ^^^^^^^^^^
1035 |             (session_id,),
1036 |         )
     |

E501 Line too long (89 > 88)
    --> models\ngram_analytics_service.py:1042:89
     |
1040 |             raise ValueError(f"Session {session_id} not found")
1041 |
1042 |         logger.info(f"Processing session {session_id} from {session_info['start_time']}")
     |                                                                                         ^
1043 |
1044 |         # Insert into history table first
     |

E501 Line too long (91 > 88)
    --> models\ngram_analytics_service.py:1075:89
     |
1073 |                     CASE
1074 |                         WHEN sc.start_time >= sns.updated_dt
1075 |                         THEN EXTRACT(EPOCH FROM (sc.start_time - sns.updated_dt)) / 86400.0
     |                                                                                         ^^^
1076 |                         ELSE 0
1077 |                     END AS days_ago,
     |

E501 Line too long (117 > 88)
    --> models\ngram_analytics_service.py:1078:89
     |
1076 |                         ELSE 0
1077 |                     END AS days_ago,
1078 |                     ROW_NUMBER() OVER (PARTITION BY sns.ngram_text ORDER BY sns.updated_dt DESC) AS key_instance_rank
     |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
1079 |                 FROM
1080 |                     SessionContext sc
     |

E501 Line too long (90 > 88)
    --> models\ngram_analytics_service.py:1098:89
     |
1096 |                     target_speed_ms,
1097 |                     SUM(avg_ms_per_keystroke * instance_count * POWER(0.9, days_ago)) / 
1098 |                         SUM(instance_count * POWER(0.9, days_ago)) AS decaying_average_ms,
     |                                                                                         ^^
1099 |                     SUM(instance_count) AS total_sample_count,
1100 |                     MAX(start_time) AS last_measured
     |

E501 Line too long (93 > 88)
    --> models\ngram_analytics_service.py:1106:89
     |
1104 |                     key_instance_rank <= 20
1105 |                 GROUP BY 
1106 |                     user_id, keyboard_id, session_id, ngram_text, ngram_size, target_speed_ms
     |                                                                                         ^^^^^
1107 |             )
1108 |             SELECT 
     |

E501 Line too long (91 > 88)
    --> models\ngram_analytics_service.py:1221:89
     |
1219 |             logger.info("Inserting into ngram_speed_summary_hist")
1220 |             hist_cursor = self.db.execute(history_insert_query, (session_id,))
1221 |             hist_inserted = hist_cursor.rowcount if hist_cursor.rowcount is not None else 0
     |                                                                                         ^^^
1222 |
1223 |             # Execute current table merge
     |

E501 Line too long (90 > 88)
    --> models\ngram_analytics_service.py:1226:89
     |
1224 |             logger.info("Updating ngram_speed_summary_curr")
1225 |             curr_cursor = self.db.execute(merge_query, (session_id,))
1226 |             curr_updated = curr_cursor.rowcount if curr_cursor.rowcount is not None else 0
     |                                                                                         ^^
1227 |
1228 |             result = {
     |

E501 Line too long (100 > 88)
    --> models\ngram_analytics_service.py:1235:89
     |
1234 |             logger.info(
1235 |                 f"Session {session_id}: {tmp_inserted} records inserted into temp, {hist_inserted} "
     |                                                                                         ^^^^^^^^^^^^
1236 |                 f"records inserted into hist, {curr_updated} records updated in curr"
1237 |             )
     |

E501 Line too long (98 > 88)
    --> models\ngram_analytics_service.py:1245:89
     |
1244 |         except Exception as e:
1245 |             logger.error(f"Error in AddSpeedSummaryForSession for session {session_id}: {str(e)}")
     |                                                                                         ^^^^^^^^^^
1246 |             raise
     |

E501 Line too long (91 > 88)
    --> models\ngram_analytics_service.py:1280:89
     |
1278 |         if not sessions:
1279 |             logger.info("No sessions found to process")
1280 |             return {"total_sessions": 0, "total_hist_inserted": 0, "total_curr_updated": 0}
     |                                                                                         ^^^
1281 |
1282 |         logger.info(f"Found {len(sessions)} sessions to process")
     |

E501 Line too long (100 > 88)
    --> models\ngram_analytics_service.py:1312:89
     |
1310 |                 # Indented debug message with record counts
1311 |                 print(
1312 |                     f"    Records: {curr_updated} updated in curr, {hist_inserted} inserted in hist"
     |                                                                                         ^^^^^^^^^^^^
1313 |                 )
1314 |                 logger.info(
     |

E501 Line too long (100 > 88)
    --> models\ngram_analytics_service.py:1315:89
     |
1313 |                 )
1314 |                 logger.info(
1315 |                     f"    Records: {curr_updated} updated in curr, {hist_inserted} inserted in hist"
     |                                                                                         ^^^^^^^^^^^^
1316 |                 )
     |

E501 Line too long (96 > 88)
    --> models\ngram_analytics_service.py:1338:89
     |
1336 |             f"CatchupSpeedSummary completed: {processed_sessions}/{len(sessions)} "
1337 |             f"sessions processed, "
1338 |             f"{total_curr_updated} total curr updates, {total_hist_inserted} total hist inserts"
     |                                                                                         ^^^^^^^^
1339 |         )
     |

E501 Line too long (94 > 88)
    --> models\ngram_analytics_service.py:1341:89
     |
1339 |         )
1340 |
1341 |         print(f"\nCatchup completed: {processed_sessions}/{len(sessions)} sessions processed")
     |                                                                                         ^^^^^^
1342 |         print(f"Total records updated in curr: {total_curr_updated}")
1343 |         print(f"Total records inserted in hist: {total_hist_inserted}")
     |

E501 Line too long (90 > 88)
    --> models\ngram_analytics_service.py:1386:89
     |
1384 |         try:
1385 |             if self.db is None:
1386 |                 logger.warning("Cannot delete session summaries - no database connection")
     |                                                                                         ^^
1387 |                 return False
     |

E501 Line too long (90 > 88)
    --> models\ngram_analytics_service.py:1396:89
     |
1395 |         except Exception as e:
1396 |             logger.error("Error deleting session summary data: %s", str(e), exc_info=True)
     |                                                                                         ^^
1397 |             return False
     |

E501 Line too long (100 > 88)
   --> models\ngram_manager.py:122:89
    |
120 |                         )
121 |                     elif classification == "error_last":
122 |                         # Error n-grams always based on RAW according to spec; speed_mode not stored
    |                                                                                         ^^^^^^^^^^^^
123 |                         exp = expected_text[start_index : start_index + n]
124 |                         act = "".join(k.keystroke_char for k in ks_window)
    |

E501 Line too long (91 > 88)
   --> models\ngram_manager.py:142:89
    |
140 |         return speed, errors
141 |
142 |     def _compact_keystrokes_net(self, keystrokes: List[Keystroke]) -> dict[int, Keystroke]:
    |                                                                                         ^^^
143 |         """Compact keystrokes to the last occurrence per text_index (NET mode).
    |

E501 Line too long (89 > 88)
   --> models\ngram_manager.py:240:89
    |
238 |             ms_per_keystroke
239 |
240 |         NOTE: Older code/Prompts mention additional columns (speed_mode, created_at). The
    |                                                                                         ^
241 |         current schema intentionally omits them; this method therefore only inserts the six
242 |         allowed columns and ignores any extra attributes present on SpeedNGram objects.
    |

E501 Line too long (91 > 88)
   --> models\ngram_manager.py:241:89
    |
240 |         NOTE: Older code/Prompts mention additional columns (speed_mode, created_at). The
241 |         current schema intentionally omits them; this method therefore only inserts the six
    |                                                                                         ^^^
242 |         allowed columns and ignores any extra attributes present on SpeedNGram objects.
243 |         """
    |

E501 Line too long (98 > 88)
   --> models\ngram_manager.py:249:89
    |
247 |         for s in items:
248 |             ms_per_key = (
249 |                 s.ms_per_keystroke if s.ms_per_keystroke is not None else (s.duration_ms / s.size)
    |                                                                                         ^^^^^^^^^^
250 |             )
251 |             params.append(
    |

E501 Line too long (97 > 88)
   --> models\ngram_manager.py:264:89
    |
262 |         query = (
263 |             "INSERT INTO session_ngram_speed ("
264 |             "ngram_speed_id, session_id, ngram_size, ngram_text, ngram_time_ms, ms_per_keystroke"
    |                                                                                         ^^^^^^^^^
265 |             ") VALUES (?, ?, ?, ?, ?, ?)"
266 |         )
    |

E501 Line too long (96 > 88)
   --> models\ngram_manager.py:306:89
    |
304 |             return written
305 |
306 |     def persist_all(self, speed: List[SpeedNGram], errors: List[ErrorNGram]) -> Tuple[int, int]:
    |                                                                                         ^^^^^^^^
307 |         """Persist both speed and error n-grams; returns (speed_count, error_count)."""
308 |         return self.persist_speed_ngrams(speed), self.persist_error_ngrams(errors)
    |

E501 Line too long (91 > 88)
   --> models\session.py:129:89
    |
127 |             return cls.model_validate(data)
128 |         except ValueError as e:
129 |             # Re-raise with a more specific message while preserving the original exception
    |                                                                                         ^^^
130 |             raise ValueError(f"Invalid session data: {str(e)}") from e
    |

E501 Line too long (108 > 88)
  --> models\session_manager.py:37:89
   |
35 |             row = self.db_manager.execute(
36 |                 """
37 |                 SELECT session_id, snippet_id, user_id, keyboard_id, snippet_index_start, snippet_index_end,
   |                                                                                         ^^^^^^^^^^^^^^^^^^^^
38 |                        content, start_time, end_time, actual_chars, errors
39 |                 FROM practice_sessions WHERE session_id = ?
   |

E501 Line too long (96 > 88)
  --> models\session_manager.py:81:89
   |
79 |             rows = self.db_manager.execute(
80 |                 (
81 |                     "SELECT session_id, snippet_id, user_id, keyboard_id, snippet_index_start, "
   |                                                                                         ^^^^^^^^
82 |                     "snippet_index_end, content, start_time, end_time, actual_chars, errors "
83 |                     "FROM practice_sessions WHERE snippet_id = ? "
   |

E501 Line too long (93 > 88)
  --> models\session_manager.py:82:89
   |
80 |                 (
81 |                     "SELECT session_id, snippet_id, user_id, keyboard_id, snippet_index_start, "
82 |                     "snippet_index_end, content, start_time, end_time, actual_chars, errors "
   |                                                                                         ^^^^^
83 |                     "FROM practice_sessions WHERE snippet_id = ? "
84 |                     "ORDER BY end_time DESC"
   |

E501 Line too long (101 > 88)
   --> models\session_manager.py:157:89
    |
155 |             """
156 |             INSERT INTO practice_sessions (
157 |                 session_id, snippet_id, user_id, keyboard_id, snippet_index_start, snippet_index_end,
    |                                                                                         ^^^^^^^^^^^^^
158 |                 content, start_time, end_time, actual_chars, errors, ms_per_keystroke
159 |             ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    |

E501 Line too long (94 > 88)
   --> models\session_manager.py:281:89
    |
279 |             print(f"Error deleting all sessions and related data: {e}")
280 |             logging.error(f"Error deleting all sessions and related data: {e}")
281 |             self.debug_util.debugMessage(f"Error deleting all sessions and related data: {e}")
    |                                                                                         ^^^^^^
282 |             return False
    |

E501 Line too long (90 > 88)
   --> models\session_manager.py:292:89
    |
290 |             row = self.db_manager.fetchone(
291 |                 """
292 |                 SELECT session_id, snippet_id, user_id, keyboard_id, snippet_index_start, 
    |                                                                                         ^^
293 |                        snippet_index_end, content, start_time, end_time, actual_chars, errors
294 |                 FROM practice_sessions 
    |

E501 Line too long (93 > 88)
   --> models\session_manager.py:293:89
    |
291 |                 """
292 |                 SELECT session_id, snippet_id, user_id, keyboard_id, snippet_index_start, 
293 |                        snippet_index_end, content, start_time, end_time, actual_chars, errors
    |                                                                                         ^^^^^
294 |                 FROM practice_sessions 
295 |                 WHERE keyboard_id = ? 
    |

E501 Line too long (94 > 88)
   --> models\session_manager.py:334:89
    |
332 |             print(f"Error retrieving latest session for keyboard: {e}")
333 |             logging.error(f"Error retrieving latest session for keyboard: {e}")
334 |             self.debug_util.debugMessage(f"Error retrieving latest session for keyboard: {e}")
    |                                                                                         ^^^^^^
335 |             raise
    |

E501 Line too long (90 > 88)
  --> models\setting.py:19:89
   |
18 |     This exception is raised for validation errors such as invalid format
19 |     or if a setting type ID that is not unique for a given entity is attempted to be used.
   |                                                                                         ^^
20 |     """
   |

E501 Line too long (93 > 88)
  --> models\setting.py:46:89
   |
44 |         setting_type_id: 6-character key identifying the setting type.
45 |         setting_value: The setting value stored as text.
46 |         related_entity_id: UUID string identifying the related entity (user, keyboard, etc.).
   |                                                                                         ^^^^^
47 |         updated_at: ISO datetime indicating when the setting was last updated.
48 |     """
   |

E501 Line too long (92 > 88)
  --> models\setting_manager.py:43:89
   |
41 |             SettingValidationError: If the combination is not unique.
42 |         """
43 |         query = "SELECT 1 FROM settings WHERE setting_type_id = ? AND related_entity_id = ?"
   |                                                                                         ^^^^
44 |         params = [setting_type_id, related_entity_id]
45 |         if setting_id is not None:
   |

E501 Line too long (109 > 88)
  --> models\setting_manager.py:63:89
   |
61 |         """
62 |         Retrieve a single setting by type ID and related entity ID.
63 |         If the setting doesn't exist and a default value is provided, returns a new setting with the default.
   |                                                                                         ^^^^^^^^^^^^^^^^^^^^^
64 |
65 |         Args:
   |

E501 Line too long (100 > 88)
  --> models\setting_manager.py:74:89
   |
73 |         Raises:
74 |             SettingNotFound: If no setting exists with the specified IDs and no default is provided.
   |                                                                                         ^^^^^^^^^^^^
75 |         """
76 |         row = self.db_manager.execute(
   |

E501 Line too long (92 > 88)
  --> models\setting_manager.py:78:89
   |
76 |         row = self.db_manager.execute(
77 |             """
78 |             SELECT setting_id, setting_type_id, setting_value, related_entity_id, updated_at
   |                                                                                         ^^^^
79 |             FROM settings
80 |             WHERE setting_type_id = ? AND related_entity_id = ?
   |

E501 Line too long (90 > 88)
   --> models\setting_manager.py:102:89
    |
100 |                 updated_at=datetime.datetime.now().isoformat(),
101 |             )
102 |             # We don't save it to the database yet - that would be handled by save_setting
    |                                                                                         ^^
103 |             return new_setting
104 |         else:
    |

E501 Line too long (101 > 88)
   --> models\setting_manager.py:106:89
    |
104 |         else:
105 |             raise SettingNotFound(
106 |                 f"Setting with type '{setting_type_id}' for entity '{related_entity_id}' not found. "
    |                                                                                         ^^^^^^^^^^^^^
107 |                 "Please ensure the setting exists or provide a default value."
108 |             )
    |

E501 Line too long (92 > 88)
   --> models\setting_manager.py:122:89
    |
120 |         rows = self.db_manager.execute(
121 |             """
122 |             SELECT setting_id, setting_type_id, setting_value, related_entity_id, updated_at
    |                                                                                         ^^^^
123 |             FROM settings
124 |             WHERE related_entity_id = ?
    |

E501 Line too long (98 > 88)
   --> models\setting_manager.py:160:89
    |
158 |         # Check if a setting with this type and entity already exists
159 |         existing_setting_row = self.db_manager.execute(
160 |             "SELECT setting_id FROM settings WHERE setting_type_id = ? AND related_entity_id = ?",
    |                                                                                         ^^^^^^^^^^
161 |             (setting.setting_type_id, setting.related_entity_id)
162 |         ).fetchone()
    |

E501 Line too long (99 > 88)
   --> models\setting_manager.py:195:89
    |
193 |             """
194 |             INSERT INTO settings_history
195 |             (history_id, setting_id, setting_type_id, setting_value, related_entity_id, updated_at)
    |                                                                                         ^^^^^^^^^^^
196 |             VALUES (?, ?, ?, ?, ?, ?)
197 |             """,
    |

E501 Line too long (93 > 88)
   --> models\setting_manager.py:234:89
    |
232 |             """
233 |             UPDATE settings
234 |             SET setting_type_id = ?, setting_value = ?, related_entity_id = ?, updated_at = ?
    |                                                                                         ^^^^^
235 |             WHERE setting_id = ?
236 |             """,
    |

E501 Line too long (91 > 88)
   --> models\setting_manager.py:273:89
    |
271 |             # Now delete the setting
272 |             self.db_manager.execute(
273 |                 "DELETE FROM settings WHERE setting_type_id = ? AND related_entity_id = ?",
    |                                                                                         ^^^
274 |                 (setting_type_id, related_entity_id),
275 |             )
    |

E501 Line too long (93 > 88)
  --> models\snippet.py:33:89
   |
31 |     Args:
32 |         value: The string to check
33 |         is_content: Whether this is snippet content (code/text) that may legitimately contain
   |                                                                                         ^^^^^
34 |                     quotes and equals signs
35 |     """
   |

E501 Line too long (95 > 88)
  --> models\snippet.py:45:89
   |
43 |         ("INSERT INTO", r"INSERT\s+INTO"),
44 |         ("UPDATE SET", r"UPDATE\s+.*\s+SET"),
45 |         ("SELECT FROM", r"SELECT\s+.*\s+FROM"),  # Catches SELECT * FROM, SELECT col FROM, etc.
   |                                                                                         ^^^^^^^
46 |         ("OR 1=1", r"OR\s+1\s*=\s*1"),
47 |         ("' OR '", r"'\s*OR\s*'"),
   |

E501 Line too long (90 > 88)
  --> models\snippet.py:61:89
   |
59 |     for pattern_name, pattern_regex in core_patterns:
60 |         if re.search(pattern_regex, value, re.IGNORECASE):
61 |             raise ValueError(f"Value contains potentially unsafe pattern: {pattern_name}")
   |                                                                                         ^^
62 |
63 |     # Only check extended patterns if not validating content (code/text)
   |

E501 Line too long (89 > 88)
  --> models\snippet.py:67:89
   |
65 |         for pattern in extended_patterns:
66 |             if pattern.lower() in value.lower():
67 |                 raise ValueError(f"Value contains potentially unsafe pattern: {pattern}")
   |                                                                                         ^
68 |
69 |     return value
   |

E501 Line too long (92 > 88)
  --> models\snippet.py:76:89
   |
75 |     Args:
76 |         value: The value to validate, which can be an int or string representation of an int
   |                                                                                         ^^^^
77 |
78 |     Returns:
   |

E501 Line too long (99 > 88)
  --> models\snippet.py:87:89
   |
85 |         if isinstance(value, str):
86 |             # Ensure string is a valid representation of an integer
87 |             if not value.strip().isdigit() and not (value.startswith("-") and value[1:].isdigit()):
   |                                                                                         ^^^^^^^^^^^
88 |                 raise ValueError("String must represent a valid integer")
89 |             return int(value)
   |

E501 Line too long (90 > 88)
   --> models\snippet.py:167:89
    |
166 |             errors = [
167 |                 ErrorWrapper(ValueError(f"Extra field not permitted: {field}"), loc=field)
    |                                                                                         ^^
168 |                 for field in extra
169 |             ]
    |

E501 Line too long (93 > 88)
  --> models\snippet_manager.py:79:89
   |
77 |         if exists:
78 |             self.db.execute(
79 |                 "UPDATE snippets SET category_id = ?, snippet_name = ? WHERE snippet_id = ?",
   |                                                                                         ^^^^^
80 |                 (snippet.category_id, snippet.snippet_name, snippet.snippet_id),
81 |             )
   |

E501 Line too long (100 > 88)
  --> models\snippet_manager.py:82:89
   |
80 |                 (snippet.category_id, snippet.snippet_name, snippet.snippet_id),
81 |             )
82 |             self.db.execute("DELETE FROM snippet_parts WHERE snippet_id = ?", (snippet.snippet_id,))
   |                                                                                         ^^^^^^^^^^^^
83 |         else:
84 |             self.db.execute(
   |

E501 Line too long (96 > 88)
  --> models\snippet_manager.py:85:89
   |
83 |         else:
84 |             self.db.execute(
85 |                 "INSERT INTO snippets (snippet_id, category_id, snippet_name) VALUES (?, ?, ?)",
   |                                                                                         ^^^^^^^^
86 |                 (snippet.snippet_id, snippet.category_id, snippet.snippet_name),
87 |             )
   |

E501 Line too long (108 > 88)
  --> models\snippet_manager.py:94:89
   |
92 |             part_id = str(uuid.uuid4())
93 |             self.db.execute(
94 |                 "INSERT INTO snippet_parts (part_id, snippet_id, part_number, content) VALUES (?, ?, ?, ?)",
   |                                                                                         ^^^^^^^^^^^^^^^^^^^^
95 |                 (part_id, snippet.snippet_id, i, part_content),
96 |             )
   |

E501 Line too long (98 > 88)
   --> models\snippet_manager.py:113:89
    |
111 |         try:
112 |             cursor = self.db.execute(
113 |                 "SELECT snippet_id, category_id, snippet_name FROM snippets WHERE snippet_id = ?",
    |                                                                                         ^^^^^^^^^^
114 |                 (snippet_id,),
115 |             )
    |

E501 Line too long (94 > 88)
   --> models\snippet_manager.py:126:89
    |
125 |             parts_cursor = self.db.execute(
126 |                 "SELECT content FROM snippet_parts WHERE snippet_id = ? ORDER BY part_number",
    |                                                                                         ^^^^^^
127 |                 (snippet_id,),
128 |             )
    |

E501 Line too long (89 > 88)
   --> models\snippet_manager.py:136:89
    |
134 |             if not full_content or not full_content.strip():
135 |                 logging.warning(
136 |                     f"Empty content found for snippet ID {snippet_id}, using placeholder"
    |                                                                                         ^
137 |                 )
138 |                 full_content = "[Content was empty. Generate new content to practice.]"
    |

E501 Line too long (99 > 88)
   --> models\snippet_manager.py:145:89
    |
143 |             traceback.print_exc()
144 |             logging.error(f"Database error retrieving snippet ID {snippet_id}: {e}")
145 |             self.debug_util.debugMessage(f"Database error retrieving snippet ID {snippet_id}: {e}")
    |                                                                                         ^^^^^^^^^^^
146 |             raise
147 |         except Exception as e:
    |

E501 Line too long (101 > 88)
   --> models\snippet_manager.py:150:89
    |
148 |             traceback.print_exc()
149 |             logging.error(f"Unexpected error retrieving snippet ID {snippet_id}: {e}")
150 |             self.debug_util.debugMessage(f"Unexpected error retrieving snippet ID {snippet_id}: {e}")
    |                                                                                         ^^^^^^^^^^^^^
151 |             raise DatabaseError(
152 |                 f"An unexpected error occurred while retrieving snippet ID {snippet_id}: {e}"
    |

E501 Line too long (93 > 88)
   --> models\snippet_manager.py:152:89
    |
150 |             self.debug_util.debugMessage(f"Unexpected error retrieving snippet ID {snippet_id}: {e}")
151 |             raise DatabaseError(
152 |                 f"An unexpected error occurred while retrieving snippet ID {snippet_id}: {e}"
    |                                                                                         ^^^^^
153 |             ) from e
    |

E501 Line too long (92 > 88)
   --> models\snippet_manager.py:155:89
    |
153 |             ) from e
154 |
155 |     def get_snippet_by_name(self, snippet_name: str, category_id: str) -> Optional[Snippet]:
    |                                                                                         ^^^^
156 |         """Retrieves a snippet by its name and category UUID.
    |

E501 Line too long (93 > 88)
   --> models\snippet_manager.py:170:89
    |
168 |         try:
169 |             cursor = self.db.execute(
170 |                 "SELECT snippet_id FROM snippets WHERE snippet_name = ? AND category_id = ?",
    |                                                                                         ^^^^^
171 |                 (snippet_name, category_id),
172 |             )
    |

E501 Line too long (108 > 88)
   --> models\snippet_manager.py:186:89
    |
184 |             )
185 |             self.debug_util.debugMessage(
186 |                 f"Database error retrieving snippet by name '{snippet_name}' in category {category_id}: {e}"
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^
187 |             )
188 |             raise
    |

E501 Line too long (110 > 88)
   --> models\snippet_manager.py:196:89
    |
194 |             )
195 |             self.debug_util.debugMessage(
196 |                 f"Unexpected error retrieving snippet by name '{snippet_name}' in category {category_id}: {e}"
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^
197 |             )
198 |             raise DatabaseError(
    |

E501 Line too long (98 > 88)
   --> models\snippet_manager.py:232:89
    |
231 |                 parts_cursor = self.db.execute(
232 |                     "SELECT content FROM snippet_parts WHERE snippet_id = ? ORDER BY part_number",
    |                                                                                         ^^^^^^^^^^
233 |                     (current_snippet_id,),
234 |                 )
    |

E501 Line too long (92 > 88)
   --> models\snippet_manager.py:243:89
    |
241 |         except DatabaseError as e:
242 |             traceback.print_exc()
243 |             logging.error(f"Database error listing snippets by category {category_id}: {e}")
    |                                                                                         ^^^^
244 |             self.debug_util.debugMessage(f"Database error listing snippets by category {category_id}: {e}")
245 |             raise
    |

E501 Line too long (107 > 88)
   --> models\snippet_manager.py:244:89
    |
242 |             traceback.print_exc()
243 |             logging.error(f"Database error listing snippets by category {category_id}: {e}")
244 |             self.debug_util.debugMessage(f"Database error listing snippets by category {category_id}: {e}")
    |                                                                                         ^^^^^^^^^^^^^^^^^^^
245 |             raise
246 |         except Exception as e:
    |

E501 Line too long (94 > 88)
   --> models\snippet_manager.py:248:89
    |
246 |         except Exception as e:
247 |             traceback.print_exc()
248 |             logging.error(f"Unexpected error listing snippets by category {category_id}: {e}")
    |                                                                                         ^^^^^^
249 |             self.debug_util.debugMessage(f"Unexpected error listing snippets by category {category_id}: {e}")
250 |             raise DatabaseError(
    |

E501 Line too long (109 > 88)
   --> models\snippet_manager.py:249:89
    |
247 |             traceback.print_exc()
248 |             logging.error(f"Unexpected error listing snippets by category {category_id}: {e}")
249 |             self.debug_util.debugMessage(f"Unexpected error listing snippets by category {category_id}: {e}")
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^
250 |             raise DatabaseError(
251 |                 f"An unexpected error occurred while listing snippets by category {category_id}: {e}"
    |

E501 Line too long (101 > 88)
   --> models\snippet_manager.py:251:89
    |
249 |             self.debug_util.debugMessage(f"Unexpected error listing snippets by category {category_id}: {e}")
250 |             raise DatabaseError(
251 |                 f"An unexpected error occurred while listing snippets by category {category_id}: {e}"
    |                                                                                         ^^^^^^^^^^^^^
252 |             ) from e
    |

E501 Line too long (94 > 88)
   --> models\snippet_manager.py:254:89
    |
252 |             ) from e
253 |
254 |     def search_snippets(self, query: str, category_id: Optional[int] = None) -> List[Snippet]:
    |                                                                                         ^^^^^^
255 |         """Searches for snippets by a query string in their name or content.
    |

E501 Line too long (99 > 88)
   --> models\snippet_manager.py:286:89
    |
284 |             rows = cursor.fetchall()
285 |
286 |             snippet_ids = [row[0] if isinstance(row, tuple) else row["snippet_id"] for row in rows]
    |                                                                                         ^^^^^^^^^^^
287 |
288 |             snippets: List[Snippet] = []
    |

E501 Line too long (98 > 88)
   --> models\snippet_manager.py:359:89
    |
358 |                 parts_cursor = self.db.execute(
359 |                     "SELECT content FROM snippet_parts WHERE snippet_id = ? ORDER BY part_number",
    |                                                                                         ^^^^^^^^^^
360 |                     (snippet_dict["snippet_id"],),
361 |                 )
    |

E501 Line too long (91 > 88)
   --> models\snippet_manager.py:368:89
    |
366 |                 return Snippet(**snippet_dict)
367 |         except Exception:
368 |             # If there's an error checking for existing snippet, continue to create new one
    |                                                                                         ^^^
369 |             pass
    |

E501 Line too long (89 > 88)
   --> models\snippet_manager.py:382:89
    |
380 |         return new_snippet
381 |
382 |     def get_starting_index(self, snippet_id: str, user_id: str, keyboard_id: str) -> int:
    |                                                                                         ^
383 |         """
384 |         Returns the next starting index for a snippet for a given user and keyboard.
    |

E501 Line too long (107 > 88)
   --> models\snippet_manager.py:400:89
    |
398 |                 session_id,
399 |                 snippet_index_end as end_index,
400 |                 rank() over (partition by snippet_id, user_id, keyboard_id order by start_time desc) as rnk
    |                                                                                         ^^^^^^^^^^^^^^^^^^^
401 |             from practice_sessions
402 |             where
    |

E501 Line too long (95 > 88)
  --> models\user.py:76:89
   |
74 |             raise ValueError("Name contains invalid control characters.")
75 |
76 |         # Check for invalid characters (only letters, spaces, hyphens, and apostrophes allowed)
   |                                                                                         ^^^^^^^
77 |         if not all(c.isalpha() or c.isspace() or c in "-.'" for c in stripped_v):
78 |             raise ValueError("Name contains invalid characters.")
   |

E501 Line too long (93 > 88)
  --> models\user.py:82:89
   |
80 |         # Check for leading/trailing spaces, hyphens, or apostrophes
81 |         if stripped_v[0] in " -'" or stripped_v[-1] in " -'":
82 |             raise ValueError("Name cannot start or end with a space, hyphen, or apostrophe.")
   |                                                                                         ^^^^^
83 |
84 |         # Check for consecutive spaces, hyphens, or apostrophes
   |

E501 Line too long (100 > 88)
  --> models\user.py:87:89
   |
85 |         for i in range(len(stripped_v) - 1):
86 |             if stripped_v[i] in " -'" and stripped_v[i + 1] in " -'":
87 |                 raise ValueError("Name cannot contain consecutive spaces, hyphens, or apostrophes.")
   |                                                                                         ^^^^^^^^^^^^
88 |
89 |         return stripped_v
   |

E501 Line too long (89 > 88)
   --> models\user.py:147:89
    |
145 |                 # Check for invalid characters in domain parts
146 |                 if not all(c.isalnum() or c == "-" for c in part):
147 |                     raise ValueError(f"Domain part '{part}' contains invalid characters")
    |                                                                                         ^
148 |
149 |                 # Check for parts starting or ending with a hyphen
    |

E501 Line too long (90 > 88)
   --> models\user.py:161:89
    |
159 |             if len(tld) < 2 or not tld.isalpha():
160 |                 raise ValueError(
161 |                     "Top-level domain must be at least 2 letters and contain only letters"
    |                                                                                         ^^
162 |                 )
    |

E501 Line too long (100 > 88)
  --> models\user_manager.py:28:89
   |
26 |         self.db_manager: DatabaseManager = db_manager
27 |
28 |     def _validate_email_uniqueness(self, email_address: str, user_id: Optional[str] = None) -> None:
   |                                                                                         ^^^^^^^^^^^^
29 |         # Always use lowercase for email comparisons
30 |         email_address_lower = email_address.lower()
   |

E501 Line too long (89 > 88)
  --> models\user_manager.py:37:89
   |
35 |             params.append(user_id)
36 |         if self.db_manager.fetchone(query, tuple(params)):
37 |             raise UserValidationError(f"Email address '{email_address}' must be unique.")
   |                                                                                         ^
38 |
39 |     def get_user_by_id(self, user_id: str) -> User:
   |

E501 Line too long (94 > 88)
  --> models\user_manager.py:41:89
   |
39 |     def get_user_by_id(self, user_id: str) -> User:
40 |         row = self.db_manager.fetchone(
41 |             "SELECT user_id, first_name, surname, email_address FROM users WHERE user_id = ?",
   |                                                                                         ^^^^^^
42 |             (user_id,),
43 |         )
   |

E501 Line too long (98 > 88)
   --> models\user_manager.py:100:89
    |
 98 |     def __insert_user(self, user: User) -> bool:
 99 |         self.db_manager.execute(
100 |             "INSERT INTO users (user_id, first_name, surname, email_address) VALUES (?, ?, ?, ?)",
    |                                                                                         ^^^^^^^^^^
101 |             (user.user_id, user.first_name, user.surname, user.email_address.lower()),
102 |         )
    |

E501 Line too long (96 > 88)
   --> models\user_manager.py:107:89
    |
105 |     def __update_user(self, user: User) -> bool:
106 |         self.db_manager.execute(
107 |             "UPDATE users SET first_name = ?, surname = ?, email_address = ? WHERE user_id = ?",
    |                                                                                         ^^^^^^^^
108 |             (user.first_name, user.surname, user.email_address.lower(), user.user_id),
109 |         )
    |

Found 145 errors.
[*] 4 fixable with the `--fix` option.
