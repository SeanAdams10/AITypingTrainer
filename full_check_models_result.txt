db\database_manager.py:80: error: No overload variant of "print" matches argument types "tuple[object, ...]", "dict[str, str | None]"  [call-overload]
db\database_manager.py:80: note: Possible overload variants:
db\database_manager.py:80: note:     def print(*values: object, sep: str | None = ..., end: str | None = ..., file: SupportsWrite[str] | None = ..., flush: Literal[False] = ...) -> None
db\database_manager.py:80: note:     def print(*values: object, sep: str | None = ..., end: str | None = ..., file: _SupportsWriteAndFlush[str] | None = ..., flush: bool) -> None
db\database_manager.py:236: error: Argument 2 to "debug_print" has incompatible type "**dict[str, object]"; expected "str | None"  [arg-type]
db\database_manager.py:43: error: Unused "type: ignore" comment  [unused-ignore]
db\database_manager.py:49: error: Unused "type: ignore" comment  [unused-ignore]
db\database_manager.py:747: error: Unused "type: ignore" comment  [unused-ignore]
models\user.py:183: error: Missing type parameters for generic type "dict"  [type-arg]
models\snippet.py:120: error: Missing type parameters for generic type "dict"  [type-arg]
models\snippet.py:161: error: "Callable[[BaseModel], dict[str, FieldInfo]]" has no attribute "keys"  [attr-defined]
models\snippet.py:167: error: "object" not callable  [operator]
models\setting.py:96: error: Missing type parameters for generic type "dict"  [type-arg]
models\keyboard.py:58: error: Missing type parameters for generic type "dict"  [type-arg]
models\category.py:57: error: Missing type parameters for generic type "dict"  [type-arg]
models\user_manager.py:87: error: Argument 1 to "__user_exists" of "UserManager" has incompatible type "str | None"; expected "str"  [arg-type]
models\snippet_manager.py:123: error: Invalid index type "str | Any" for "tuple[Any, ...]"; expected type "SupportsIndex"  [index]
models\snippet_manager.py:131: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\snippet_manager.py:228: error: Invalid index type "str | Any" for "tuple[Any, ...]"; expected type "SupportsIndex"  [index]
models\snippet_manager.py:236: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\snippet_manager.py:363: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\snippet_manager.py:372: error: Missing named argument "description" for "Snippet"  [call-arg]
models\snippet_manager.py:414: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\snippet_manager.py:419: error: Returning Any from function declared to return "int"  [no-any-return]
models\setting_manager.py:87: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\setting_manager.py:88: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\setting_manager.py:89: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\setting_manager.py:90: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\setting_manager.py:91: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\setting_manager.py:131: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\setting_manager.py:132: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\setting_manager.py:133: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\setting_manager.py:134: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\setting_manager.py:135: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\llm_ngram_service.py:11: error: Cannot assign to a type  [misc]
models\llm_ngram_service.py:11: error: Incompatible types in assignment (expression has type "type[Exception]", variable has type "type[APIError]")  [assignment]
models\llm_ngram_service.py:11: error: Incompatible types in assignment (expression has type "type[Exception]", variable has type "type[RateLimitError]")  [assignment]
models\llm_ngram_service.py:11: error: Incompatible types in assignment (expression has type "type[Exception]", variable has type "type[APITimeoutError]")  [assignment]
models\llm_ngram_service.py:128: error: "object" has no attribute "model_dump"  [attr-defined]
models\llm_ngram_service.py:145: error: "object" has no attribute "model_dump"  [attr-defined]
models\keystroke_manager.py:63: error: Unused "type: ignore" comment  [unused-ignore]
models\keystroke_manager.py:141: error: Incompatible return value type (got "str", expected "int")  [return-value]
models\keyboard_manager.py:53: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\keyboard_manager.py:54: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\keyboard_manager.py:55: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\keyboard_manager.py:56: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\keyboard_manager.py:71: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\keyboard_manager.py:72: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\keyboard_manager.py:73: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\keyboard_manager.py:74: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\keyboard_manager.py:144: error: Value of type "dict[str, Any] | tuple[Any, ...] | None" is not indexable  [index]
models\keyboard_manager.py:144: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\keyboard_manager.py:146: error: Returning Any from function declared to return "bool"  [no-any-return]
models\category_manager.py:87: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\category_manager.py:105: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\category_manager.py:118: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\category_manager.py:119: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\category_manager.py:199: error: Value of type "dict[str, Any] | tuple[Any, ...] | None" is not indexable  [index]
models\category_manager.py:199: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\category_manager.py:201: error: Returning Any from function declared to return "bool"  [no-any-return]
models\category_manager.py:222: error: Incompatible return value type (got "str | None", expected "str")  [return-value]
models\category_manager.py:229: error: Incompatible return value type (got "str | None", expected "str")  [return-value]
models\ngram_manager.py:76: error: Name "ks_by_index" already defined on line 72  [no-redef]
models\library.py:156: error: Returning Any from function declared to return "bool"  [no-any-return]
models\library.py:156: error: "SnippetManager" has no attribute "delete_snippet"; maybe "delete_all_snippets"?  [attr-defined]
models\dynamic_content_service.py:104: error: Need type annotation for "result" (hint: "result: list[<type>] = ...")  [var-annotated]
models\dynamic_content_service.py:180: error: Need type annotation for "result" (hint: "result: list[<type>] = ...")  [var-annotated]
models\dynamic_content_service.py:233: error: Need type annotation for "result" (hint: "result: list[<type>] = ...")  [var-annotated]
models\dynamic_content_manager.py:178: error: Need type annotation for "result" (hint: "result: list[<type>] = ...")  [var-annotated]
models\dynamic_content_manager.py:231: error: Need type annotation for "result" (hint: "result: list[<type>] = ...")  [var-annotated]
models\session_manager.py:46: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\session_manager.py:47: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\session_manager.py:48: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\session_manager.py:49: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\session_manager.py:50: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\session_manager.py:51: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\session_manager.py:52: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\session_manager.py:53: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\session_manager.py:54: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\session_manager.py:55: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\session_manager.py:56: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\session_manager.py:57: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\session_manager.py:58: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\session_manager.py:59: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\session_manager.py:60: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\session_manager.py:90: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\session_manager.py:91: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\session_manager.py:92: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\session_manager.py:93: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\session_manager.py:94: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\session_manager.py:95: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\session_manager.py:96: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\session_manager.py:97: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\session_manager.py:98: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\session_manager.py:99: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\session_manager.py:100: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\session_manager.py:101: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\session_manager.py:102: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\session_manager.py:103: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\session_manager.py:104: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
models\session_manager.py:219: error: Returning Any from function declared to return "bool"  [no-any-return]
models\session_manager.py:219: error: "CursorProtocol" has no attribute "rowcount"  [attr-defined]
models\ngram_analytics_service.py:192: error: Missing type parameters for generic type "dict"  [type-arg]
models\ngram_analytics_service.py:370: error: Incompatible types in assignment (expression has type "tuple[str, str]", variable has type "tuple[str, str, str]")  [assignment]
models\ngram_analytics_service.py:988: error: "CursorProtocol" has no attribute "rowcount"  [attr-defined]
models\ngram_analytics_service.py:1015: error: Missing type parameters for generic type "dict"  [type-arg]
models\ngram_analytics_service.py:1217: error: "CursorProtocol" has no attribute "rowcount"  [attr-defined]
models\ngram_analytics_service.py:1222: error: "CursorProtocol" has no attribute "rowcount"  [attr-defined]
models\ngram_analytics_service.py:1227: error: "CursorProtocol" has no attribute "rowcount"  [attr-defined]
models\ngram_analytics_service.py:1249: error: Missing type parameters for generic type "dict"  [type-arg]
Found 107 errors in 19 files (checked 22 source files)
models\ngram_analytics_service.py:11:1: I001 [*] Import block is un-sorted or un-formatted
   |
 9 |   """
10 |
11 | / import logging
12 | | import traceback
13 | | from dataclasses import dataclass
14 | | from datetime import datetime
15 | | from math import log
16 | | from typing import Dict, List, Optional, TYPE_CHECKING, Union
17 | |
18 | | from pydantic import BaseModel, Field
19 | |
20 | | from db.database_manager import DatabaseManager
21 | | from helpers.debug_util import DebugUtil
22 | | from models.ngram_manager import NGramManager
   | |_____________________________________________^ I001
23 |
24 |   if TYPE_CHECKING:  # Only for type hints to avoid circular imports at runtime
   |
   = help: Organize imports

models\ngram_analytics_service.py:25:5: I001 [*] Import block is un-sorted or un-formatted
   |
24 |   if TYPE_CHECKING:  # Only for type hints to avoid circular imports at runtime
25 | /     from models.session import Session
26 | |     from models.keystroke import Keystroke
   | |__________________________________________^ I001
27 |
28 |   logger = logging.getLogger(__name__)
   |
   = help: Organize imports

Found 2 errors.
[*] 2 fixable with the `--fix` option.
api\category_api.py:1:1: I001 [*] Import block is un-sorted or un-formatted
  |
1 | / from typing import Dict, List, Tuple, Union, Any
2 | |
3 | | from flask import Blueprint, jsonify, request, Response
4 | | from pydantic import BaseModel, ValidationError
5 | |
6 | | from db.database_manager import DatabaseManager
7 | | from models.category import CategoryManager
  | |___________________________________________^ I001
  |
  = help: Organize imports

api\category_api.py:1:20: F401 [*] `typing.Dict` imported but unused
  |
1 | from typing import Dict, List, Tuple, Union, Any
  |                    ^^^^ F401
2 |
3 | from flask import Blueprint, jsonify, request, Response
  |
  = help: Remove unused import

api\category_api.py:1:26: F401 [*] `typing.List` imported but unused
  |
1 | from typing import Dict, List, Tuple, Union, Any
  |                          ^^^^ F401
2 |
3 | from flask import Blueprint, jsonify, request, Response
  |
  = help: Remove unused import

api\category_api.py:1:46: F401 [*] `typing.Any` imported but unused
  |
1 | from typing import Dict, List, Tuple, Union, Any
  |                                              ^^^ F401
2 |
3 | from flask import Blueprint, jsonify, request, Response
  |
  = help: Remove unused import

api\category_graphql.py:45:41: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `_info`
   |
43 |     category = Field(CategoryType, category_id=Int(name="categoryId", required=True))
44 |
45 |     def resolve_categories(self, _info: Any) -> TypedList[Category]:
   |                                         ^^^ ANN401
46 |         """
47 |         Resolve all categories.
   |

api\category_graphql.py:57:39: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `_info`
   |
55 |         return CategoryManager.list_categories()
56 |
57 |     def resolve_category(self, _info: Any, category_id: int) -> Optional[Category]:
   |                                       ^^^ ANN401
58 |         """
59 |         Resolve a specific category by ID.
   |

api\category_graphql.py:85:29: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `_info`
   |
83 |     category = Field(lambda: CategoryType)
84 |
85 |     def mutate(self, _info: Any, category_name: str) -> "CreateCategory":
   |                             ^^^ ANN401
86 |         """
87 |         Create a new category with the provided name.
   |

api\category_graphql.py:105:13: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
    |
103 |         except (CategoryValidationError, ValueError) as e:
104 |             # Graphene will convert this to a proper GraphQL error
105 |             raise Exception(str(e))
    |             ^^^^^^^^^^^^^^^^^^^^^^^ B904
    |

api\category_graphql.py:121:22: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `_info`
    |
120 |     def mutate(
121 |         self, _info: Any, category_id: int, category_name: str
    |                      ^^^ ANN401
122 |     ) -> "UpdateCategory":
123 |         """
    |

api\category_graphql.py:143:13: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
    |
141 |         except (CategoryValidationError, CategoryNotFound, ValueError) as e:
142 |             # Graphene will convert this to a proper GraphQL error
143 |             raise Exception(str(e))
    |             ^^^^^^^^^^^^^^^^^^^^^^^ B904
    |

api\category_graphql.py:157:29: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `_info`
    |
155 |     ok = Boolean()
156 |
157 |     def mutate(self, _info: Any, category_id: int) -> "DeleteCategory":
    |                             ^^^ ANN401
158 |         """
159 |         Delete a category by ID.
    |

api\category_graphql.py:177:13: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
    |
175 |         except CategoryNotFound as e:
176 |             # Graphene will convert this to a proper GraphQL error
177 |             raise Exception(str(e))
    |             ^^^^^^^^^^^^^^^^^^^^^^^ B904
    |

api\dbviewer_api.py:34:5: ANN201 Missing return type annotation for public function `list_tables`
   |
33 | @dbviewer_api.route("/tables", methods=["GET"])
34 | def list_tables():
   |     ^^^^^^^^^^^ ANN201
35 |     """List all available database tables."""
36 |     try:
   |
   = help: Add return type annotation

api\dbviewer_api.py:52:5: ANN201 Missing return type annotation for public function `get_table_data`
   |
51 | @dbviewer_api.route("/table", methods=["GET"])
52 | def get_table_data():
   |     ^^^^^^^^^^^^^^ ANN201
53 |     """Get table data with pagination, sorting, and filtering.
   |
   = help: Add return type annotation

api\dbviewer_api.py:101:5: ANN201 Missing return type annotation for public function `export_table_to_csv`
    |
100 | @dbviewer_api.route("/export", methods=["GET"])
101 | def export_table_to_csv():
    |     ^^^^^^^^^^^^^^^^^^^ ANN201
102 |     """Export table data to CSV format.
    |
    = help: Add return type annotation

api\keystroke_api.py:8:1: E402 Module level import not at top of file
  |
6 | keystroke_api = Blueprint("keystroke_api", __name__)
7 |
8 | from typing import Optional
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
  |

api\keystroke_api.py:22:5: ANN201 Missing return type annotation for public function `api_record_keystroke`
   |
21 | @keystroke_api.route("/api/keystrokes", methods=["POST"])
22 | def api_record_keystroke():
   |     ^^^^^^^^^^^^^^^^^^^^ ANN201
23 |     import sys
   |
   = help: Add return type annotation

api\keystroke_api.py:71:5: ANN201 Missing return type annotation for public function `api_list_keystrokes`
   |
70 | @keystroke_api.route("/api/keystrokes", methods=["GET"])
71 | def api_list_keystrokes():
   |     ^^^^^^^^^^^^^^^^^^^ ANN201
72 |     session_id = request.args.get("session_id")
73 |     if not session_id:
   |
   = help: Add return type annotation

api\library_graphql.py:18:5: ANN201 Missing return type annotation for public function `get_library_manager`
   |
18 | def get_library_manager():
   |     ^^^^^^^^^^^^^^^^^^^ ANN201
19 |     # Dependency injection for testability
20 |     db_manager = getattr(g, "db_manager", None)
   |
   = help: Add return type annotation

api\library_graphql.py:52:9: ANN201 Missing return type annotation for public function `resolve_categories`
   |
50 |     snippet_parts = List(SnippetPartType, snippet_id=Int(required=True))
51 |
52 |     def resolve_categories(self, info):
   |         ^^^^^^^^^^^^^^^^^^ ANN201
53 |         mgr = get_library_manager()
54 |         return mgr.list_categories()
   |
   = help: Add return type annotation

api\library_graphql.py:52:34: ANN001 Missing type annotation for function argument `info`
   |
50 |     snippet_parts = List(SnippetPartType, snippet_id=Int(required=True))
51 |
52 |     def resolve_categories(self, info):
   |                                  ^^^^ ANN001
53 |         mgr = get_library_manager()
54 |         return mgr.list_categories()
   |

api\library_graphql.py:56:9: ANN201 Missing return type annotation for public function `resolve_snippets`
   |
54 |         return mgr.list_categories()
55 |
56 |     def resolve_snippets(self, info, category_id):
   |         ^^^^^^^^^^^^^^^^ ANN201
57 |         mgr = get_library_manager()
58 |         return mgr.list_snippets(category_id)
   |
   = help: Add return type annotation

api\library_graphql.py:56:32: ANN001 Missing type annotation for function argument `info`
   |
54 |         return mgr.list_categories()
55 |
56 |     def resolve_snippets(self, info, category_id):
   |                                ^^^^ ANN001
57 |         mgr = get_library_manager()
58 |         return mgr.list_snippets(category_id)
   |

api\library_graphql.py:56:38: ANN001 Missing type annotation for function argument `category_id`
   |
54 |         return mgr.list_categories()
55 |
56 |     def resolve_snippets(self, info, category_id):
   |                                      ^^^^^^^^^^^ ANN001
57 |         mgr = get_library_manager()
58 |         return mgr.list_snippets(category_id)
   |

api\library_graphql.py:60:9: ANN201 Missing return type annotation for public function `resolve_snippet`
   |
58 |         return mgr.list_snippets(category_id)
59 |
60 |     def resolve_snippet(self, info, snippet_id):
   |         ^^^^^^^^^^^^^^^ ANN201
61 |         mgr = get_library_manager()
62 |         snippets = mgr.list_snippets(-1)  # Dummy call to get type
   |
   = help: Add return type annotation

api\library_graphql.py:60:31: ANN001 Missing type annotation for function argument `info`
   |
58 |         return mgr.list_snippets(category_id)
59 |
60 |     def resolve_snippet(self, info, snippet_id):
   |                               ^^^^ ANN001
61 |         mgr = get_library_manager()
62 |         snippets = mgr.list_snippets(-1)  # Dummy call to get type
   |

api\library_graphql.py:60:37: ANN001 Missing type annotation for function argument `snippet_id`
   |
58 |         return mgr.list_snippets(category_id)
59 |
60 |     def resolve_snippet(self, info, snippet_id):
   |                                     ^^^^^^^^^^ ANN001
61 |         mgr = get_library_manager()
62 |         snippets = mgr.list_snippets(-1)  # Dummy call to get type
   |

api\library_graphql.py:68:9: ANN201 Missing return type annotation for public function `resolve_snippet_parts`
   |
66 |         return None
67 |
68 |     def resolve_snippet_parts(self, info, snippet_id):
   |         ^^^^^^^^^^^^^^^^^^^^^ ANN201
69 |         mgr = get_library_manager()
70 |         return mgr.list_parts(snippet_id)
   |
   = help: Add return type annotation

api\library_graphql.py:68:37: ANN001 Missing type annotation for function argument `info`
   |
66 |         return None
67 |
68 |     def resolve_snippet_parts(self, info, snippet_id):
   |                                     ^^^^ ANN001
69 |         mgr = get_library_manager()
70 |         return mgr.list_parts(snippet_id)
   |

api\library_graphql.py:68:43: ANN001 Missing type annotation for function argument `snippet_id`
   |
66 |         return None
67 |
68 |     def resolve_snippet_parts(self, info, snippet_id):
   |                                           ^^^^^^^^^^ ANN001
69 |         mgr = get_library_manager()
70 |         return mgr.list_parts(snippet_id)
   |

api\library_graphql.py:82:9: ANN201 Missing return type annotation for public function `mutate`
   |
80 |     error = String()
81 |
82 |     def mutate(self, info, category_name):
   |         ^^^^^^ ANN201
83 |         mgr = get_library_manager()
84 |         try:
   |
   = help: Add return type annotation

api\library_graphql.py:82:22: ANN001 Missing type annotation for function argument `info`
   |
80 |     error = String()
81 |
82 |     def mutate(self, info, category_name):
   |                      ^^^^ ANN001
83 |         mgr = get_library_manager()
84 |         try:
   |

api\library_graphql.py:82:28: ANN001 Missing type annotation for function argument `category_name`
   |
80 |     error = String()
81 |
82 |     def mutate(self, info, category_name):
   |                            ^^^^^^^^^^^^^ ANN001
83 |         mgr = get_library_manager()
84 |         try:
   |

api\library_graphql.py:101:9: ANN201 Missing return type annotation for public function `mutate`
    |
 99 |     error = String()
100 |
101 |     def mutate(self, info, category_id, category_name):
    |         ^^^^^^ ANN201
102 |         mgr = get_library_manager()
103 |         try:
    |
    = help: Add return type annotation

api\library_graphql.py:101:22: ANN001 Missing type annotation for function argument `info`
    |
 99 |     error = String()
100 |
101 |     def mutate(self, info, category_id, category_name):
    |                      ^^^^ ANN001
102 |         mgr = get_library_manager()
103 |         try:
    |

api\library_graphql.py:101:28: ANN001 Missing type annotation for function argument `category_id`
    |
 99 |     error = String()
100 |
101 |     def mutate(self, info, category_id, category_name):
    |                            ^^^^^^^^^^^ ANN001
102 |         mgr = get_library_manager()
103 |         try:
    |

api\library_graphql.py:101:41: ANN001 Missing type annotation for function argument `category_name`
    |
 99 |     error = String()
100 |
101 |     def mutate(self, info, category_id, category_name):
    |                                         ^^^^^^^^^^^^^ ANN001
102 |         mgr = get_library_manager()
103 |         try:
    |

api\library_graphql.py:117:9: ANN201 Missing return type annotation for public function `mutate`
    |
115 |     error = String()
116 |
117 |     def mutate(self, info, category_id):
    |         ^^^^^^ ANN201
118 |         mgr = get_library_manager()
119 |         try:
    |
    = help: Add return type annotation

api\library_graphql.py:117:22: ANN001 Missing type annotation for function argument `info`
    |
115 |     error = String()
116 |
117 |     def mutate(self, info, category_id):
    |                      ^^^^ ANN001
118 |         mgr = get_library_manager()
119 |         try:
    |

api\library_graphql.py:117:28: ANN001 Missing type annotation for function argument `category_id`
    |
115 |     error = String()
116 |
117 |     def mutate(self, info, category_id):
    |                            ^^^^^^^^^^^ ANN001
118 |         mgr = get_library_manager()
119 |         try:
    |

api\library_graphql.py:136:9: ANN201 Missing return type annotation for public function `mutate`
    |
134 |     error = String()
135 |
136 |     def mutate(self, info, category_id, snippet_name, content):
    |         ^^^^^^ ANN201
137 |         mgr = get_library_manager()
138 |         try:
    |
    = help: Add return type annotation

api\library_graphql.py:136:22: ANN001 Missing type annotation for function argument `info`
    |
134 |     error = String()
135 |
136 |     def mutate(self, info, category_id, snippet_name, content):
    |                      ^^^^ ANN001
137 |         mgr = get_library_manager()
138 |         try:
    |

api\library_graphql.py:136:28: ANN001 Missing type annotation for function argument `category_id`
    |
134 |     error = String()
135 |
136 |     def mutate(self, info, category_id, snippet_name, content):
    |                            ^^^^^^^^^^^ ANN001
137 |         mgr = get_library_manager()
138 |         try:
    |

api\library_graphql.py:136:41: ANN001 Missing type annotation for function argument `snippet_name`
    |
134 |     error = String()
135 |
136 |     def mutate(self, info, category_id, snippet_name, content):
    |                                         ^^^^^^^^^^^^ ANN001
137 |         mgr = get_library_manager()
138 |         try:
    |

api\library_graphql.py:136:55: ANN001 Missing type annotation for function argument `content`
    |
134 |     error = String()
135 |
136 |     def mutate(self, info, category_id, snippet_name, content):
    |                                                       ^^^^^^^ ANN001
137 |         mgr = get_library_manager()
138 |         try:
    |

api\library_graphql.py:157:9: ANN201 Missing return type annotation for public function `mutate`
    |
155 |     error = String()
156 |
157 |     def mutate(self, info, snippet_id, snippet_name, content, category_id=None):
    |         ^^^^^^ ANN201
158 |         mgr = get_library_manager()
159 |         try:
    |
    = help: Add return type annotation

api\library_graphql.py:157:22: ANN001 Missing type annotation for function argument `info`
    |
155 |     error = String()
156 |
157 |     def mutate(self, info, snippet_id, snippet_name, content, category_id=None):
    |                      ^^^^ ANN001
158 |         mgr = get_library_manager()
159 |         try:
    |

api\library_graphql.py:157:28: ANN001 Missing type annotation for function argument `snippet_id`
    |
155 |     error = String()
156 |
157 |     def mutate(self, info, snippet_id, snippet_name, content, category_id=None):
    |                            ^^^^^^^^^^ ANN001
158 |         mgr = get_library_manager()
159 |         try:
    |

api\library_graphql.py:157:40: ANN001 Missing type annotation for function argument `snippet_name`
    |
155 |     error = String()
156 |
157 |     def mutate(self, info, snippet_id, snippet_name, content, category_id=None):
    |                                        ^^^^^^^^^^^^ ANN001
158 |         mgr = get_library_manager()
159 |         try:
    |

api\library_graphql.py:157:54: ANN001 Missing type annotation for function argument `content`
    |
155 |     error = String()
156 |
157 |     def mutate(self, info, snippet_id, snippet_name, content, category_id=None):
    |                                                      ^^^^^^^ ANN001
158 |         mgr = get_library_manager()
159 |         try:
    |

api\library_graphql.py:157:63: ANN001 Missing type annotation for function argument `category_id`
    |
155 |     error = String()
156 |
157 |     def mutate(self, info, snippet_id, snippet_name, content, category_id=None):
    |                                                               ^^^^^^^^^^^ ANN001
158 |         mgr = get_library_manager()
159 |         try:
    |

api\library_graphql.py:173:9: ANN201 Missing return type annotation for public function `mutate`
    |
171 |     error = String()
172 |
173 |     def mutate(self, info, snippet_id):
    |         ^^^^^^ ANN201
174 |         mgr = get_library_manager()
175 |         try:
    |
    = help: Add return type annotation

api\library_graphql.py:173:22: ANN001 Missing type annotation for function argument `info`
    |
171 |     error = String()
172 |
173 |     def mutate(self, info, snippet_id):
    |                      ^^^^ ANN001
174 |         mgr = get_library_manager()
175 |         try:
    |

api\library_graphql.py:173:28: ANN001 Missing type annotation for function argument `snippet_id`
    |
171 |     error = String()
172 |
173 |     def mutate(self, info, snippet_id):
    |                            ^^^^^^^^^^ ANN001
174 |         mgr = get_library_manager()
175 |         try:
    |

api\library_graphql.py:195:5: ANN201 Missing return type annotation for public function `graphql_api`
    |
194 | @library_graphql.route("/", methods=["POST", "GET"])
195 | def graphql_api():
    |     ^^^^^^^^^^^ ANN201
196 |     data = request.get_json()
197 |     result = schema.execute(
    |
    = help: Add return type annotation

api\run_library_api.py:26:5: ANN201 Missing return type annotation for public function `init_db`
   |
25 | # Initialize database tables on startup
26 | def init_db():
   |     ^^^^^^^ ANN201
27 |     """Initialize database tables"""
28 |     print("Initializing database tables...")
   |
   = help: Add return type annotation: `None`

api\session_api.py:16:5: ANN201 Missing return type annotation for public function `api_create_session`
   |
15 | @session_api.route("/api/sessions", methods=["POST"])
16 | def api_create_session():
   |     ^^^^^^^^^^^^^^^^^^ ANN201
17 |     try:
18 |         data = request.get_json()
   |
   = help: Add return type annotation

api\session_api.py:34:5: ANN201 Missing return type annotation for public function `api_get_session_info`
   |
33 | @session_api.route("/api/session/info", methods=["GET"])
34 | def api_get_session_info():
   |     ^^^^^^^^^^^^^^^^^^^^ ANN201
35 |     """Get last session indices and snippet length for a snippet_id."""
36 |     snippet_id = request.args.get("snippet_id", type=int)
   |
   = help: Add return type annotation

api\session_api.py:48:5: ANN201 Missing return type annotation for public function `api_get_session`
   |
47 | @session_api.route("/api/sessions/<session_id>", methods=["GET"])
48 | def api_get_session(session_id):
   |     ^^^^^^^^^^^^^^^ ANN201
49 |     session = Session.get_by_id(session_id)
50 |     if not session:
   |
   = help: Add return type annotation

api\session_api.py:48:21: ANN001 Missing type annotation for function argument `session_id`
   |
47 | @session_api.route("/api/sessions/<session_id>", methods=["GET"])
48 | def api_get_session(session_id):
   |                     ^^^^^^^^^^ ANN001
49 |     session = Session.get_by_id(session_id)
50 |     if not session:
   |

api\session_api.py:56:5: ANN201 Missing return type annotation for public function `api_update_session`
   |
55 | @session_api.route("/api/sessions/<session_id>", methods=["PUT"])
56 | def api_update_session(session_id):
   |     ^^^^^^^^^^^^^^^^^^ ANN201
57 |     session = Session.get_by_id(session_id)
58 |     if not session:
   |
   = help: Add return type annotation

api\session_api.py:56:24: ANN001 Missing type annotation for function argument `session_id`
   |
55 | @session_api.route("/api/sessions/<session_id>", methods=["PUT"])
56 | def api_update_session(session_id):
   |                        ^^^^^^^^^^ ANN001
57 |     session = Session.get_by_id(session_id)
58 |     if not session:
   |

api\snippet_api.py:19:5: ANN201 Missing return type annotation for public function `get_snippet`
   |
18 | @snippet_api.route("/api/snippets/<int:snippet_id>", methods=["GET"])
19 | def get_snippet(snippet_id: int):
   |     ^^^^^^^^^^^ ANN201
20 |     """Get a single snippet by ID.
   |
   = help: Add return type annotation

api\snippet_api.py:50:5: ANN201 Missing return type annotation for public function `api_get_snippets`
   |
49 | @snippet_api.route("/api/snippets", methods=["GET"])
50 | def api_get_snippets():
   |     ^^^^^^^^^^^^^^^^ ANN201
51 |     """Get all snippets for a specific category.
   |
   = help: Add return type annotation

api\snippet_api.py:87:5: ANN201 Missing return type annotation for public function `api_create_practice_snippet`
   |
86 | @snippet_api.route("/api/create-practice-snippet", methods=["POST"])
87 | def api_create_practice_snippet():
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
88 |     """Create a new practice snippet using the PracticeGenerator.
   |
   = help: Add return type annotation

api\snippet_api.py:107:5: ANN201 Missing return type annotation for public function `create_snippet`
    |
106 | @snippet_api.route("/api/snippets", methods=["POST"])
107 | def create_snippet():
    |     ^^^^^^^^^^^^^^ ANN201
108 |     """Create a new snippet.
    |
    = help: Add return type annotation

api\snippet_api.py:200:5: ANN201 Missing return type annotation for public function `edit_snippet`
    |
199 | @snippet_api.route("/api/snippets/<int:snippet_id>", methods=["PUT"])
200 | def edit_snippet(snippet_id: int):
    |     ^^^^^^^^^^^^ ANN201
201 |     """Update an existing snippet.
    |
    = help: Add return type annotation

api\snippet_api.py:253:5: ANN201 Missing return type annotation for public function `delete_snippet`
    |
252 | @snippet_api.route("/api/snippets/<int:snippet_id>", methods=["DELETE"])
253 | def delete_snippet(snippet_id: int):
    |     ^^^^^^^^^^^^^^ ANN201
254 |     """Delete a snippet by ID.
    |
    = help: Add return type annotation

api\unified_graphql.py:114:22: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `_info`
    |
113 |     def mutate(
114 |         self, _info: Any, category_id: int, snippet_name: str, content: str
    |                      ^^^ ANN401
115 |     ) -> CreateSnippetOutput:
116 |         """Create a new snippet with the provided data."""
    |

api\unified_graphql.py:160:16: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `_info`
    |
158 |     def mutate(
159 |         self,
160 |         _info: Any,
    |                ^^^ ANN401
161 |         snippet_id: int,
162 |         snippet_name: Optional[str] = None,
    |

api\unified_graphql.py:205:29: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `_info`
    |
203 |     Output = DeleteSnippetOutput
204 |
205 |     def mutate(self, _info: Any, snippet_id: int) -> DeleteSnippetOutput:
    |                             ^^^ ANN401
206 |         """Delete a snippet by ID."""
207 |         try:
    |

api\unified_graphql.py:252:29: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `_info`
    |
250 |     Output = CreateCategoryOutput
251 |
252 |     def mutate(self, _info: Any, category_name: str) -> CreateCategoryOutput:
    |                             ^^^ ANN401
253 |         """Create a new category with the provided name."""
254 |         try:
    |

api\unified_graphql.py:291:22: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `_info`
    |
290 |     def mutate(
291 |         self, _info: Any, category_id: int, category_name: str
    |                      ^^^ ANN401
292 |     ) -> UpdateCategoryOutput:
293 |         """Update an existing category with the provided name."""
    |

api\unified_graphql.py:330:29: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `_info`
    |
328 |     Output = DeleteCategoryOutput
329 |
330 |     def mutate(self, _info: Any, category_id: int) -> DeleteCategoryOutput:
    |                             ^^^ ANN401
331 |         """Delete a category by ID."""
332 |         try:
    |

api\unified_graphql.py:362:39: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `_info`
    |
360 |     category = Field(CategoryType, category_id=Int(required=True, name="categoryId"))
361 |
362 |     def resolve_snippets(self, _info: Any, category_id: int) -> TypedList[SnippetModel]:
    |                                       ^^^ ANN401
363 |         """Resolve all snippets for a given category."""
364 |         manager = get_snippet_manager()
    |

api\unified_graphql.py:367:38: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `_info`
    |
365 |         return manager.list_snippets(category_id)
366 |
367 |     def resolve_snippet(self, _info: Any, snippet_id: int) -> Optional[SnippetModel]:
    |                                      ^^^ ANN401
368 |         """Resolve a specific snippet by ID."""
369 |         try:
    |

api\unified_graphql.py:375:41: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `_info`
    |
373 |             return None
374 |
375 |     def resolve_categories(self, _info: Any) -> TypedList[Category]:
    |                                         ^^^ ANN401
376 |         """Resolve all categories."""
377 |         db_manager = get_db_manager()
    |

api\unified_graphql.py:381:39: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `_info`
    |
379 |         return cat_mgr.list_categories()
380 |
381 |     def resolve_category(self, _info: Any, category_id: int) -> Optional[Category]:
    |                                       ^^^ ANN401
382 |         """Resolve a specific category by ID."""
383 |         try:
    |

check_db_schema.py:6:5: ANN201 Missing return type annotation for public function `check_schema`
  |
6 | def check_schema(db_path: str):
  |     ^^^^^^^^^^^^ ANN201
7 |     """Check the database schema."""
8 |     conn = sqlite3.connect(db_path)
  |
  = help: Add return type annotation: `None`

db\database_manager.py:525:13: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
    |
523 |                 self._debug_message(f" Rollback failed: {rollback_exc}")
524 |             self._translate_and_raise(e)
525 |             raise AssertionError("unreachable")
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ B904
526 |
527 |     def execute_many(
    |

db\database_manager.py:615:13: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
    |
613 |                 self._debug_message(f" Rollback failed: {rollback_exc}")
614 |             self._translate_and_raise(e)
615 |             raise AssertionError("unreachable")
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ B904
616 |
617 |     # --- Bulk helper methods for execute_many ---
    |

db\migrations\check_snippet_parts_count.py:3:1: I001 [*] Import block is un-sorted or un-formatted
   |
 1 |   #!/usr/bin/env python
 2 |
 3 | / import boto3
 4 | | import psycopg2
 5 | | import sqlite3
 6 | | import sys
 7 | | import os
 8 | | import logging
   | |______________^ I001
 9 |
10 |   # Configure logging
   |
   = help: Organize imports

db\migrations\check_snippet_parts_count.py:24:5: ANN201 Missing return type annotation for public function `get_aurora_connection`
   |
22 | SCHEMA_NAME = "typing"
23 |
24 | def get_aurora_connection():
   |     ^^^^^^^^^^^^^^^^^^^^^ ANN201
25 |     """Get a connection to AWS Aurora PostgreSQL."""
26 |     try:
   |
   = help: Add return type annotation

db\migrations\check_snippet_parts_count.py:64:5: ANN201 Missing return type annotation for public function `get_sqlite_connection`
   |
62 |         raise
63 |
64 | def get_sqlite_connection(db_path):
   |     ^^^^^^^^^^^^^^^^^^^^^ ANN201
65 |     """Get a connection to SQLite database."""
66 |     try:
   |
   = help: Add return type annotation

db\migrations\check_snippet_parts_count.py:64:27: ANN001 Missing type annotation for function argument `db_path`
   |
62 |         raise
63 |
64 | def get_sqlite_connection(db_path):
   |                           ^^^^^^^ ANN001
65 |     """Get a connection to SQLite database."""
66 |     try:
   |

db\migrations\check_snippet_parts_count.py:73:5: ANN201 Missing return type annotation for public function `main`
   |
71 |         raise
72 |
73 | def main():
   |     ^^^^ ANN201
74 |     """Main entry point for checking snippet_parts row counts."""
75 |     if len(sys.argv) != 2:
   |
   = help: Add return type annotation: `int | None`

db\migrations\migrate_snippet_parts.py:14:1: I001 [*] Import block is un-sorted or un-formatted
   |
12 |   """
13 |
14 | / import argparse
15 | | import boto3
16 | | import logging
17 | | import os
18 | | import psycopg2
19 | | import sqlite3
20 | | import sys
21 | | import traceback
22 | | import uuid
   | |___________^ I001
23 |
24 |   # Configure logging with both console and file output
   |
   = help: Organize imports

db\migrations\migrate_snippet_parts.py:21:8: F401 [*] `traceback` imported but unused
   |
19 | import sqlite3
20 | import sys
21 | import traceback
   |        ^^^^^^^^^ F401
22 | import uuid
   |
   = help: Remove unused import: `traceback`

db\migrations\migrate_snippet_parts.py:45:5: ANN201 Missing return type annotation for public function `get_aurora_connection`
   |
43 | SCHEMA_NAME = "typing"
44 |
45 | def get_aurora_connection():
   |     ^^^^^^^^^^^^^^^^^^^^^ ANN201
46 |     """Connect to AWS Aurora using credentials from Secrets Manager."""
47 |     try:
   |
   = help: Add return type annotation

db\migrations\migrate_snippet_parts.py:82:121: E501 Line too long (121 > 120)
   |
80 |             logger.error(f"Failed to connect to Aurora database: {e}")
81 |             logger.error(
82 |                 f"Connection details: host={cfg['host']}, port={cfg['port']}, db={cfg['dbname']}, user={cfg['username']}"
   |                                                                                                                         ^ E501
83 |             )
84 |             raise
   |

db\migrations\migrate_snippet_parts.py:93:5: ANN201 Missing return type annotation for public function `get_sqlite_connection`
   |
93 | def get_sqlite_connection(db_path):
   |     ^^^^^^^^^^^^^^^^^^^^^ ANN201
94 |     """Connect to SQLite database."""
95 |     if not os.path.exists(db_path):
   |
   = help: Add return type annotation

db\migrations\migrate_snippet_parts.py:93:27: ANN001 Missing type annotation for function argument `db_path`
   |
93 | def get_sqlite_connection(db_path):
   |                           ^^^^^^^ ANN001
94 |     """Connect to SQLite database."""
95 |     if not os.path.exists(db_path):
   |

db\migrations\migrate_snippet_parts.py:102:5: ANN201 Missing return type annotation for public function `get_sqlite_schema`
    |
102 | def get_sqlite_schema(conn):
    |     ^^^^^^^^^^^^^^^^^ ANN201
103 |     """Get the snippet_parts table schema from SQLite."""
104 |     cursor = conn.cursor()
    |
    = help: Add return type annotation

db\migrations\migrate_snippet_parts.py:102:23: ANN001 Missing type annotation for function argument `conn`
    |
102 | def get_sqlite_schema(conn):
    |                       ^^^^ ANN001
103 |     """Get the snippet_parts table schema from SQLite."""
104 |     cursor = conn.cursor()
    |

db\migrations\migrate_snippet_parts.py:115:5: ANN201 Missing return type annotation for public function `recreate_aurora_snippet_parts_table`
    |
115 | def recreate_aurora_snippet_parts_table(conn):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
116 |     """Drop and recreate the snippet_parts table in Aurora with PostgreSQL-compatible syntax."""
117 |     cursor = conn.cursor()
    |
    = help: Add return type annotation: `None`

db\migrations\migrate_snippet_parts.py:115:41: ANN001 Missing type annotation for function argument `conn`
    |
115 | def recreate_aurora_snippet_parts_table(conn):
    |                                         ^^^^ ANN001
116 |     """Drop and recreate the snippet_parts table in Aurora with PostgreSQL-compatible syntax."""
117 |     cursor = conn.cursor()
    |

db\migrations\migrate_snippet_parts.py:145:5: ANN201 Missing return type annotation for public function `row_to_dict`
    |
145 | def row_to_dict(cursor, row):
    |     ^^^^^^^^^^^ ANN201
146 |     """Convert a row tuple to a dictionary with column names as keys."""
147 |     return {col[0]: row[idx] for idx, col in enumerate(cursor.description)}
    |
    = help: Add return type annotation

db\migrations\migrate_snippet_parts.py:145:17: ANN001 Missing type annotation for function argument `cursor`
    |
145 | def row_to_dict(cursor, row):
    |                 ^^^^^^ ANN001
146 |     """Convert a row tuple to a dictionary with column names as keys."""
147 |     return {col[0]: row[idx] for idx, col in enumerate(cursor.description)}
    |

db\migrations\migrate_snippet_parts.py:145:25: ANN001 Missing type annotation for function argument `row`
    |
145 | def row_to_dict(cursor, row):
    |                         ^^^ ANN001
146 |     """Convert a row tuple to a dictionary with column names as keys."""
147 |     return {col[0]: row[idx] for idx, col in enumerate(cursor.description)}
    |

db\migrations\migrate_snippet_parts.py:150:5: ANN201 Missing return type annotation for public function `get_all_snippet_parts_rows`
    |
150 | def get_all_snippet_parts_rows(conn):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
151 |     """Get all rows from the snippet_parts table in SQLite."""
152 |     cursor = conn.cursor()
    |
    = help: Add return type annotation

db\migrations\migrate_snippet_parts.py:150:32: ANN001 Missing type annotation for function argument `conn`
    |
150 | def get_all_snippet_parts_rows(conn):
    |                                ^^^^ ANN001
151 |     """Get all rows from the snippet_parts table in SQLite."""
152 |     cursor = conn.cursor()
    |

db\migrations\migrate_snippet_parts.py:170:5: ANN201 Missing return type annotation for public function `migrate_and_verify_rows`
    |
170 | def migrate_and_verify_rows(sqlite_conn, aurora_conn):
    |     ^^^^^^^^^^^^^^^^^^^^^^^ ANN201
171 |     """Migrate rows from SQLite to Aurora one by one, verifying each after insertion."""
172 |     rows, columns = get_all_snippet_parts_rows(sqlite_conn)
    |
    = help: Add return type annotation

db\migrations\migrate_snippet_parts.py:170:29: ANN001 Missing type annotation for function argument `sqlite_conn`
    |
170 | def migrate_and_verify_rows(sqlite_conn, aurora_conn):
    |                             ^^^^^^^^^^^ ANN001
171 |     """Migrate rows from SQLite to Aurora one by one, verifying each after insertion."""
172 |     rows, columns = get_all_snippet_parts_rows(sqlite_conn)
    |

db\migrations\migrate_snippet_parts.py:170:42: ANN001 Missing type annotation for function argument `aurora_conn`
    |
170 | def migrate_and_verify_rows(sqlite_conn, aurora_conn):
    |                                          ^^^^^^^^^^^ ANN001
171 |     """Migrate rows from SQLite to Aurora one by one, verifying each after insertion."""
172 |     rows, columns = get_all_snippet_parts_rows(sqlite_conn)
    |

db\migrations\migrate_snippet_parts.py:238:121: E501 Line too long (129 > 120)
    |
237 |                     if sqlite_val != aurora_val:
238 |                         logger.error(f"Row {i+1}/{len(rows)} mismatch in column {col}: SQLite={sqlite_val}, Aurora={aurora_val}")
    |                                                                                                                         ^^^^^^^^^ E501
239 |                         match = False
    |

db\migrations\migrate_snippet_parts.py:269:5: ANN201 Missing return type annotation for public function `verify_only`
    |
269 | def verify_only(sqlite_conn, aurora_conn):
    |     ^^^^^^^^^^^ ANN201
270 |     """Check and compare row counts between SQLite and Aurora without migration."""
271 |     # SQLite count
    |
    = help: Add return type annotation

db\migrations\migrate_snippet_parts.py:269:17: ANN001 Missing type annotation for function argument `sqlite_conn`
    |
269 | def verify_only(sqlite_conn, aurora_conn):
    |                 ^^^^^^^^^^^ ANN001
270 |     """Check and compare row counts between SQLite and Aurora without migration."""
271 |     # SQLite count
    |

db\migrations\migrate_snippet_parts.py:269:30: ANN001 Missing type annotation for function argument `aurora_conn`
    |
269 | def verify_only(sqlite_conn, aurora_conn):
    |                              ^^^^^^^^^^^ ANN001
270 |     """Check and compare row counts between SQLite and Aurora without migration."""
271 |     # SQLite count
    |

db\migrations\migrate_snippet_parts.py:295:5: ANN201 Missing return type annotation for public function `main`
    |
295 | def main():
    |     ^^^^ ANN201
296 |     """Main entry point for the snippet_parts migration script."""
297 |     parser = argparse.ArgumentParser(description="Migrate snippet_parts table from SQLite to AWS Aurora")
    |
    = help: Add return type annotation: `int | None`

db\migrations\migrate_snippet_parts.py:299:121: E501 Line too long (121 > 120)
    |
297 |     parser = argparse.ArgumentParser(description="Migrate snippet_parts table from SQLite to AWS Aurora")
298 |     parser.add_argument("--db-path", required=True, help="Path to SQLite database")
299 |     parser.add_argument("--verify-only", action="store_true", help="Only verify row counts without performing migration")
    |                                                                                                                         ^ E501
300 |     args = parser.parse_args()
    |

db\migrations\migrate_sqlite_to_aurora.py:36:5: ANN201 Missing return type annotation for public function `get_aurora_connection`
   |
36 | def get_aurora_connection():
   |     ^^^^^^^^^^^^^^^^^^^^^ ANN201
37 |     """Connect to AWS Aurora using credentials from Secrets Manager."""
38 |     try:
   |
   = help: Add return type annotation

db\migrations\migrate_sqlite_to_aurora.py:73:121: E501 Line too long (121 > 120)
   |
71 |             logger.error(f"Failed to connect to Aurora database: {e}")
72 |             logger.error(
73 |                 f"Connection details: host={cfg['host']}, port={cfg['port']}, db={cfg['dbname']}, user={cfg['username']}"
   |                                                                                                                         ^ E501
74 |             )
75 |             raise
   |

db\migrations\migrate_sqlite_to_aurora.py:84:5: ANN201 Missing return type annotation for public function `get_sqlite_connection`
   |
84 | def get_sqlite_connection(db_path):
   |     ^^^^^^^^^^^^^^^^^^^^^ ANN201
85 |     """Connect to SQLite database."""
86 |     try:
   |
   = help: Add return type annotation

db\migrations\migrate_sqlite_to_aurora.py:84:27: ANN001 Missing type annotation for function argument `db_path`
   |
84 | def get_sqlite_connection(db_path):
   |                           ^^^^^^^ ANN001
85 |     """Connect to SQLite database."""
86 |     try:
   |

db\migrations\migrate_sqlite_to_aurora.py:95:5: ANN201 Missing return type annotation for public function `ensure_schema_exists`
   |
95 | def ensure_schema_exists(conn):
   |     ^^^^^^^^^^^^^^^^^^^^ ANN201
96 |     """Create the schema if it doesn't exist."""
97 |     cursor = conn.cursor()
   |
   = help: Add return type annotation: `None`

db\migrations\migrate_sqlite_to_aurora.py:95:26: ANN001 Missing type annotation for function argument `conn`
   |
95 | def ensure_schema_exists(conn):
   |                          ^^^^ ANN001
96 |     """Create the schema if it doesn't exist."""
97 |     cursor = conn.cursor()
   |

db\migrations\migrate_sqlite_to_aurora.py:103:5: ANN201 Missing return type annotation for public function `create_aurora_tables`
    |
103 | def create_aurora_tables(conn):
    |     ^^^^^^^^^^^^^^^^^^^^ ANN201
104 |     """Create all required tables in Aurora."""
105 |     cursor = conn.cursor()
    |
    = help: Add return type annotation: `None`

db\migrations\migrate_sqlite_to_aurora.py:103:26: ANN001 Missing type annotation for function argument `conn`
    |
103 | def create_aurora_tables(conn):
    |                          ^^^^ ANN001
104 |     """Create all required tables in Aurora."""
105 |     cursor = conn.cursor()
    |

db\migrations\migrate_sqlite_to_aurora.py:268:5: ANN201 Missing return type annotation for public function `copy_table_data`
    |
268 | def copy_table_data(sqlite_conn, aurora_conn, table_name, debug=False):
    |     ^^^^^^^^^^^^^^^ ANN201
269 |     """Copy data from SQLite table to Aurora table."""
270 |     sqlite_cursor = sqlite_conn.cursor()
    |
    = help: Add return type annotation

db\migrations\migrate_sqlite_to_aurora.py:268:21: ANN001 Missing type annotation for function argument `sqlite_conn`
    |
268 | def copy_table_data(sqlite_conn, aurora_conn, table_name, debug=False):
    |                     ^^^^^^^^^^^ ANN001
269 |     """Copy data from SQLite table to Aurora table."""
270 |     sqlite_cursor = sqlite_conn.cursor()
    |

db\migrations\migrate_sqlite_to_aurora.py:268:34: ANN001 Missing type annotation for function argument `aurora_conn`
    |
268 | def copy_table_data(sqlite_conn, aurora_conn, table_name, debug=False):
    |                                  ^^^^^^^^^^^ ANN001
269 |     """Copy data from SQLite table to Aurora table."""
270 |     sqlite_cursor = sqlite_conn.cursor()
    |

db\migrations\migrate_sqlite_to_aurora.py:268:47: ANN001 Missing type annotation for function argument `table_name`
    |
268 | def copy_table_data(sqlite_conn, aurora_conn, table_name, debug=False):
    |                                               ^^^^^^^^^^ ANN001
269 |     """Copy data from SQLite table to Aurora table."""
270 |     sqlite_cursor = sqlite_conn.cursor()
    |

db\migrations\migrate_sqlite_to_aurora.py:268:59: ANN001 Missing type annotation for function argument `debug`
    |
268 | def copy_table_data(sqlite_conn, aurora_conn, table_name, debug=False):
    |                                                           ^^^^^ ANN001
269 |     """Copy data from SQLite table to Aurora table."""
270 |     sqlite_cursor = sqlite_conn.cursor()
    |

db\migrations\migrate_sqlite_to_aurora.py:287:57: B905 [*] `zip()` without an explicit `strict=` parameter
    |
285 |         if debug:
286 |             logger.info(f"Table {table_name} structure: {column_names}")
287 |             logger.info(f"Sample row from SQLite: {dict(zip(column_names, rows[0]))}")
    |                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^ B905
288 |
289 |         # Build the INSERT statement for Aurora
    |
    = help: Add explicit value for parameter `strict=`

db\migrations\migrate_sqlite_to_aurora.py:336:5: ANN201 Missing return type annotation for public function `migrate_single_table`
    |
336 | def migrate_single_table(sqlite_conn, aurora_conn, table_name):
    |     ^^^^^^^^^^^^^^^^^^^^ ANN201
337 |     """Migrate just a single table with debug info."""
338 |     logger.info(f"Starting focused migration of table: {table_name}")
    |
    = help: Add return type annotation

db\migrations\migrate_sqlite_to_aurora.py:336:26: ANN001 Missing type annotation for function argument `sqlite_conn`
    |
336 | def migrate_single_table(sqlite_conn, aurora_conn, table_name):
    |                          ^^^^^^^^^^^ ANN001
337 |     """Migrate just a single table with debug info."""
338 |     logger.info(f"Starting focused migration of table: {table_name}")
    |

db\migrations\migrate_sqlite_to_aurora.py:336:39: ANN001 Missing type annotation for function argument `aurora_conn`
    |
336 | def migrate_single_table(sqlite_conn, aurora_conn, table_name):
    |                                       ^^^^^^^^^^^ ANN001
337 |     """Migrate just a single table with debug info."""
338 |     logger.info(f"Starting focused migration of table: {table_name}")
    |

db\migrations\migrate_sqlite_to_aurora.py:336:52: ANN001 Missing type annotation for function argument `table_name`
    |
336 | def migrate_single_table(sqlite_conn, aurora_conn, table_name):
    |                                                    ^^^^^^^^^^ ANN001
337 |     """Migrate just a single table with debug info."""
338 |     logger.info(f"Starting focused migration of table: {table_name}")
    |

db\migrations\migrate_sqlite_to_aurora.py:363:5: ANN201 Missing return type annotation for public function `fix_snippet_parts`
    |
363 | def fix_snippet_parts(sqlite_conn, aurora_conn):
    |     ^^^^^^^^^^^^^^^^^ ANN201
364 |     """Special handler for snippet_parts table to fix NULL primary key issue."""
365 |     logger.info("Using special handler for snippet_parts table")
    |
    = help: Add return type annotation: `None`

db\migrations\migrate_sqlite_to_aurora.py:363:23: ANN001 Missing type annotation for function argument `sqlite_conn`
    |
363 | def fix_snippet_parts(sqlite_conn, aurora_conn):
    |                       ^^^^^^^^^^^ ANN001
364 |     """Special handler for snippet_parts table to fix NULL primary key issue."""
365 |     logger.info("Using special handler for snippet_parts table")
    |

db\migrations\migrate_sqlite_to_aurora.py:363:36: ANN001 Missing type annotation for function argument `aurora_conn`
    |
363 | def fix_snippet_parts(sqlite_conn, aurora_conn):
    |                                    ^^^^^^^^^^^ ANN001
364 |     """Special handler for snippet_parts table to fix NULL primary key issue."""
365 |     logger.info("Using special handler for snippet_parts table")
    |

db\migrations\migrate_sqlite_to_aurora.py:425:121: E501 Line too long (125 > 120)
    |
423 |                     import uuid
424 |                     row_values[0] = str(uuid.uuid4())
425 |                     logger.info(f"Generated new part_id {row_values[0]} for snippet_id {row_values[1]} part {row_values[2]}")
    |                                                                                                                         ^^^^^ E501
426 |
427 |                 # Ensure content isn't too long
    |

db\migrations\migrate_sqlite_to_aurora.py:472:5: ANN201 Missing return type annotation for public function `migrate_data`
    |
472 | def migrate_data(sqlite_conn, aurora_conn):
    |     ^^^^^^^^^^^^ ANN201
473 |     """Copy all data from SQLite to Aurora in correct order respecting foreign keys."""
    |
    = help: Add return type annotation

db\migrations\migrate_sqlite_to_aurora.py:472:18: ANN001 Missing type annotation for function argument `sqlite_conn`
    |
472 | def migrate_data(sqlite_conn, aurora_conn):
    |                  ^^^^^^^^^^^ ANN001
473 |     """Copy all data from SQLite to Aurora in correct order respecting foreign keys."""
    |

db\migrations\migrate_sqlite_to_aurora.py:472:31: ANN001 Missing type annotation for function argument `aurora_conn`
    |
472 | def migrate_data(sqlite_conn, aurora_conn):
    |                               ^^^^^^^^^^^ ANN001
473 |     """Copy all data from SQLite to Aurora in correct order respecting foreign keys."""
    |

db\migrations\migrate_sqlite_to_aurora.py:500:5: ANN201 Missing return type annotation for public function `get_sqlite_table_list`
    |
500 | def get_sqlite_table_list(conn):
    |     ^^^^^^^^^^^^^^^^^^^^^ ANN201
501 |     """Get list of tables from SQLite database."""
502 |     cursor = conn.cursor()
    |
    = help: Add return type annotation

db\migrations\migrate_sqlite_to_aurora.py:500:27: ANN001 Missing type annotation for function argument `conn`
    |
500 | def get_sqlite_table_list(conn):
    |                           ^^^^ ANN001
501 |     """Get list of tables from SQLite database."""
502 |     cursor = conn.cursor()
    |

db\migrations\migrate_sqlite_to_aurora.py:509:5: ANN201 Missing return type annotation for public function `get_aurora_table_list`
    |
509 | def get_aurora_table_list(conn):
    |     ^^^^^^^^^^^^^^^^^^^^^ ANN201
510 |     """Get list of tables from Aurora database."""
511 |     cursor = conn.cursor()
    |
    = help: Add return type annotation

db\migrations\migrate_sqlite_to_aurora.py:509:27: ANN001 Missing type annotation for function argument `conn`
    |
509 | def get_aurora_table_list(conn):
    |                           ^^^^ ANN001
510 |     """Get list of tables from Aurora database."""
511 |     cursor = conn.cursor()
    |

db\migrations\migrate_sqlite_to_aurora.py:520:5: ANN201 Missing return type annotation for public function `get_row_counts`
    |
520 | def get_row_counts(conn, table_list, is_sqlite=True):
    |     ^^^^^^^^^^^^^^ ANN201
521 |     """Get row counts for all tables."""
522 |     counts = {}
    |
    = help: Add return type annotation

db\migrations\migrate_sqlite_to_aurora.py:520:20: ANN001 Missing type annotation for function argument `conn`
    |
520 | def get_row_counts(conn, table_list, is_sqlite=True):
    |                    ^^^^ ANN001
521 |     """Get row counts for all tables."""
522 |     counts = {}
    |

db\migrations\migrate_sqlite_to_aurora.py:520:26: ANN001 Missing type annotation for function argument `table_list`
    |
520 | def get_row_counts(conn, table_list, is_sqlite=True):
    |                          ^^^^^^^^^^ ANN001
521 |     """Get row counts for all tables."""
522 |     counts = {}
    |

db\migrations\migrate_sqlite_to_aurora.py:520:38: ANN001 Missing type annotation for function argument `is_sqlite`
    |
520 | def get_row_counts(conn, table_list, is_sqlite=True):
    |                                      ^^^^^^^^^ ANN001
521 |     """Get row counts for all tables."""
522 |     counts = {}
    |

db\migrations\migrate_sqlite_to_aurora.py:543:5: ANN201 Missing return type annotation for public function `verify_migration`
    |
543 | def verify_migration(sqlite_conn, aurora_conn, expected_tables):
    |     ^^^^^^^^^^^^^^^^ ANN201
544 |     """Verify the migration by comparing tables and row counts."""
545 |     logger.info("Verifying migration...")
    |
    = help: Add return type annotation

db\migrations\migrate_sqlite_to_aurora.py:543:22: ANN001 Missing type annotation for function argument `sqlite_conn`
    |
543 | def verify_migration(sqlite_conn, aurora_conn, expected_tables):
    |                      ^^^^^^^^^^^ ANN001
544 |     """Verify the migration by comparing tables and row counts."""
545 |     logger.info("Verifying migration...")
    |

db\migrations\migrate_sqlite_to_aurora.py:543:35: ANN001 Missing type annotation for function argument `aurora_conn`
    |
543 | def verify_migration(sqlite_conn, aurora_conn, expected_tables):
    |                                   ^^^^^^^^^^^ ANN001
544 |     """Verify the migration by comparing tables and row counts."""
545 |     logger.info("Verifying migration...")
    |

db\migrations\migrate_sqlite_to_aurora.py:543:48: ANN001 Missing type annotation for function argument `expected_tables`
    |
543 | def verify_migration(sqlite_conn, aurora_conn, expected_tables):
    |                                                ^^^^^^^^^^^^^^^ ANN001
544 |     """Verify the migration by comparing tables and row counts."""
545 |     logger.info("Verifying migration...")
    |

db\migrations\migrate_sqlite_to_aurora.py:593:5: ANN201 Missing return type annotation for public function `main`
    |
593 | def main():
    |     ^^^^ ANN201
594 |     """Main entry point for migration script."""
595 |     parser = argparse.ArgumentParser(description="Migrate SQLite database to AWS Aurora")
    |
    = help: Add return type annotation: `int | None`

desktop_ui\api_key_dialog.py:337:16: B025 try-except block with duplicate exception `Exception`
    |
335 |             self.accept()
336 |
337 |         except Exception as e:
    |                ^^^^^^^^^ B025
338 |             QMessageBox.critical(self, "Save Error", f"Failed to save API key: {str(e)}")
    |

desktop_ui\api_server_manager.py:54:13: F841 Local variable `response` is assigned to but never used
   |
52 |             # Try to connect to the server
53 |             # Even if we get a 400 error (method not allowed), it means the server is running
54 |             response = requests.get(self._api_url, timeout=2)
   |             ^^^^^^^^ F841
55 |             return True
56 |         except requests.exceptions.ConnectionError:
   |
   = help: Remove assignment to unused variable `response`

desktop_ui\consistency_typing.py:7:1: I001 [*] Import block is un-sorted or un-formatted
   |
 5 |   """
 6 |
 7 | / import datetime
 8 | | import logging
 9 | | import math
10 | | import statistics
11 | | import time
12 | | import uuid
13 | | from typing import Any, Dict, List, Optional, Union
14 | |
15 | | from PySide6.QtCore import Qt, QTimer
16 | | from PySide6.QtGui import QColor, QFont, QPalette, QTextCharFormat, QTextCursor
17 | | from PySide6.QtWidgets import (
18 | |     QDialog,
19 | |     QGridLayout,
20 | |     QHBoxLayout,
21 | |     QLabel,
22 | |     QProgressBar,
23 | |     QPushButton,
24 | |     QRadioButton,
25 | |     QSizePolicy,
26 | |     QSpacerItem,
27 | |     QSpinBox,
28 | |     QStatusBar,
29 | |     QTextEdit,
30 | |     QVBoxLayout,
31 | |     QWidget,
32 | |     QButtonGroup,
33 | |     QGroupBox,
34 | |     QSlider,
35 | |     QCheckBox,
36 | | )
37 | |
38 | | from db.database_manager import DatabaseManager
39 | | from models.keyboard_manager import KeyboardManager, KeyboardNotFound
40 | | from models.keystroke import Keystroke
41 | | from models.keystroke_manager import KeystrokeManager
42 | | from models.session import Session
43 | | from models.session_manager import SessionManager
44 | | from models.user_manager import UserManager, UserNotFound
   | |_________________________________________________________^ I001
   |
   = help: Organize imports

desktop_ui\consistency_typing.py:8:8: F401 [*] `logging` imported but unused
   |
 7 | import datetime
 8 | import logging
   |        ^^^^^^^ F401
 9 | import math
10 | import statistics
   |
   = help: Remove unused import: `logging`

desktop_ui\consistency_typing.py:9:8: F401 [*] `math` imported but unused
   |
 7 | import datetime
 8 | import logging
 9 | import math
   |        ^^^^ F401
10 | import statistics
11 | import time
   |
   = help: Remove unused import: `math`

desktop_ui\consistency_typing.py:12:8: F401 [*] `uuid` imported but unused
   |
10 | import statistics
11 | import time
12 | import uuid
   |        ^^^^ F401
13 | from typing import Any, Dict, List, Optional, Union
   |
   = help: Remove unused import: `uuid`

desktop_ui\consistency_typing.py:13:47: F401 [*] `typing.Union` imported but unused
   |
11 | import time
12 | import uuid
13 | from typing import Any, Dict, List, Optional, Union
   |                                               ^^^^^ F401
14 |
15 | from PySide6.QtCore import Qt, QTimer
   |
   = help: Remove unused import: `typing.Union`

desktop_ui\consistency_typing.py:25:5: F401 [*] `PySide6.QtWidgets.QSizePolicy` imported but unused
   |
23 |     QPushButton,
24 |     QRadioButton,
25 |     QSizePolicy,
   |     ^^^^^^^^^^^ F401
26 |     QSpacerItem,
27 |     QSpinBox,
   |
   = help: Remove unused import

desktop_ui\consistency_typing.py:26:5: F401 [*] `PySide6.QtWidgets.QSpacerItem` imported but unused
   |
24 |     QRadioButton,
25 |     QSizePolicy,
26 |     QSpacerItem,
   |     ^^^^^^^^^^^ F401
27 |     QSpinBox,
28 |     QStatusBar,
   |
   = help: Remove unused import

desktop_ui\consistency_typing.py:39:37: F401 [*] `models.keyboard_manager.KeyboardManager` imported but unused
   |
38 | from db.database_manager import DatabaseManager
39 | from models.keyboard_manager import KeyboardManager, KeyboardNotFound
   |                                     ^^^^^^^^^^^^^^^ F401
40 | from models.keystroke import Keystroke
41 | from models.keystroke_manager import KeystrokeManager
   |
   = help: Remove unused import

desktop_ui\consistency_typing.py:39:54: F401 [*] `models.keyboard_manager.KeyboardNotFound` imported but unused
   |
38 | from db.database_manager import DatabaseManager
39 | from models.keyboard_manager import KeyboardManager, KeyboardNotFound
   |                                                      ^^^^^^^^^^^^^^^^ F401
40 | from models.keystroke import Keystroke
41 | from models.keystroke_manager import KeystrokeManager
   |
   = help: Remove unused import

desktop_ui\consistency_typing.py:40:30: F401 [*] `models.keystroke.Keystroke` imported but unused
   |
38 | from db.database_manager import DatabaseManager
39 | from models.keyboard_manager import KeyboardManager, KeyboardNotFound
40 | from models.keystroke import Keystroke
   |                              ^^^^^^^^^ F401
41 | from models.keystroke_manager import KeystrokeManager
42 | from models.session import Session
   |
   = help: Remove unused import: `models.keystroke.Keystroke`

desktop_ui\consistency_typing.py:41:38: F401 [*] `models.keystroke_manager.KeystrokeManager` imported but unused
   |
39 | from models.keyboard_manager import KeyboardManager, KeyboardNotFound
40 | from models.keystroke import Keystroke
41 | from models.keystroke_manager import KeystrokeManager
   |                                      ^^^^^^^^^^^^^^^^ F401
42 | from models.session import Session
43 | from models.session_manager import SessionManager
   |
   = help: Remove unused import: `models.keystroke_manager.KeystrokeManager`

desktop_ui\consistency_typing.py:42:28: F401 [*] `models.session.Session` imported but unused
   |
40 | from models.keystroke import Keystroke
41 | from models.keystroke_manager import KeystrokeManager
42 | from models.session import Session
   |                            ^^^^^^^ F401
43 | from models.session_manager import SessionManager
44 | from models.user_manager import UserManager, UserNotFound
   |
   = help: Remove unused import: `models.session.Session`

desktop_ui\consistency_typing.py:43:36: F401 [*] `models.session_manager.SessionManager` imported but unused
   |
41 | from models.keystroke_manager import KeystrokeManager
42 | from models.session import Session
43 | from models.session_manager import SessionManager
   |                                    ^^^^^^^^^^^^^^ F401
44 | from models.user_manager import UserManager, UserNotFound
   |
   = help: Remove unused import: `models.session_manager.SessionManager`

desktop_ui\consistency_typing.py:44:33: F401 [*] `models.user_manager.UserManager` imported but unused
   |
42 | from models.session import Session
43 | from models.session_manager import SessionManager
44 | from models.user_manager import UserManager, UserNotFound
   |                                 ^^^^^^^^^^^ F401
   |
   = help: Remove unused import

desktop_ui\consistency_typing.py:44:46: F401 [*] `models.user_manager.UserNotFound` imported but unused
   |
42 | from models.session import Session
43 | from models.session_manager import SessionManager
44 | from models.user_manager import UserManager, UserNotFound
   |                                              ^^^^^^^^^^^^ F401
   |
   = help: Remove unused import

desktop_ui\consistency_typing.py:435:16: B007 Loop control variable `char` not used within loop body
    |
433 |         current_text = self.typing_input.toPlainText()
434 |         
435 |         for i, char in enumerate(self.display_text):
    |                ^^^^ B007
436 |             cursor.setPosition(i)
437 |             cursor.setPosition(i + 1, QTextCursor.MoveMode.KeepAnchor)
    |
    = help: Rename unused `char` to `_char`

desktop_ui\db_viewer_dialog.py:306:24: F821 Undefined name `QProgressBar`
    |
305 |             # Show progress dialog
306 |             progress = QProgressBar(self)
    |                        ^^^^^^^^^^^^ F821
307 |             progress.setWindowTitle("Exporting data...")
308 |             progress.setRange(0, 0)  # Indeterminate
    |

desktop_ui\drill_config.py:9:1: I001 [*] Import block is un-sorted or un-formatted
   |
 8 |   # Standard library imports
 9 | / import os
10 | | from typing import List, Optional
11 | |
12 | | # Third-party imports
13 | | from PySide6 import QtCore, QtWidgets
14 | | from PySide6.QtWidgets import QStatusBar
15 | |
16 | | # Local application imports
17 | | from db.database_manager import DatabaseManager
18 | | from desktop_ui.typing_drill import TypingDrillScreen
19 | | from models.category import Category
20 | | from models.category_manager import CategoryManager
21 | | from models.dynamic_content_service import DynamicContentService
22 | | from models.keyboard_manager import KeyboardManager
23 | | from models.setting import Setting
24 | | from models.setting_manager import SettingManager
25 | | from models.snippet import Snippet
26 | | from models.snippet_manager import SnippetManager
27 | | from models.user_manager import UserManager
28 | | from helpers.debug_util import DebugUtil
   | |________________________________________^ I001
29 |
30 |   # Define project_root if needed
   |
   = help: Organize imports

desktop_ui\drill_config.py:109:121: E501 Line too long (134 > 120)
    |
107 |                         self.debug_util.debugMessage(f"User type: {type(self.current_user)}")
108 |                         self.debug_util.debugMessage(
109 |                             f"User attributes: {vars(self.current_user) if hasattr(self.current_user, '__dict__') else 'No __dict__'}"
    |                                                                                                                         ^^^^^^^^^^^^^^ E501
110 |                         )
111 |                     except Exception as e:
    |

desktop_ui\drill_config.py:458:121: E501 Line too long (122 > 120)
    |
456 |                             start_idx = 0
457 |                     else:
458 |                         self.debug_util.debugMessage(" No snippet manager or user/keyboard ID, using default start index")
    |                                                                                                                         ^^ E501
459 |                         
460 |                     self.start_index.setMaximum(len(snippet.content) - 1)
    |

desktop_ui\drill_screen_tester.py:20:1: E402 Module level import not at top of file
   |
18 |     sys.path.insert(0, project_root)
19 |
20 | import sys
   | ^^^^^^^^^^ E402
21 |
22 | from PySide6 import QtWidgets
   |

desktop_ui\drill_screen_tester.py:22:1: E402 Module level import not at top of file
   |
20 | import sys
21 |
22 | from PySide6 import QtWidgets
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
23 |
24 | # Dummy snippet data for demonstration
   |

desktop_ui\dynamic_config.py:8:1: I001 [*] Import block is un-sorted or un-formatted
   |
 6 |   """
 7 |
 8 | / from typing import Optional
 9 | | from uuid import uuid4
10 | |
11 | | from PySide6 import QtWidgets
12 | | from PySide6.QtCore import Qt
13 | | from PySide6.QtWidgets import QStatusBar
14 | |
15 | | from db.database_manager import DatabaseManager
16 | | from desktop_ui.typing_drill import TypingDrillScreen
17 | |
18 | | from models.category_manager import CategoryManager
19 | | from models.dynamic_content_service import ContentMode, DynamicContentService
20 | | from models.keyboard_manager import KeyboardManager
21 | | from models.llm_ngram_service import LLMMissingAPIKeyError, LLMNgramService
22 | | from models.ngram_analytics_service import NGramAnalyticsService
23 | | from models.ngram_manager import NGramManager
24 | | from models.setting import Setting
25 | | from models.setting_manager import SettingManager
26 | |
27 | | from models.snippet_manager import SnippetManager
28 | | from models.user_manager import UserManager
   | |___________________________________________^ I001
   |
   = help: Organize imports

desktop_ui\graphql_client.py:14:9: ANN204 Missing return type annotation for special method `__init__`
   |
13 | class GraphQLClient:
14 |     def __init__(self, api_url: str = API_URL):
   |         ^^^^^^^^ ANN204
15 |         self.api_url = api_url
   |
   = help: Add return type annotation: `None`

desktop_ui\ngram_heatmap_screen.py:276:9: F841 Local variable `min_speed` is assigned to but never used
    |
275 |         # Get filter values
276 |         min_speed = self.speed_min_spin.value()
    |         ^^^^^^^^^ F841
277 |         max_speed = self.speed_max_spin.value()
278 |         ngram_size = self.ngram_size_combo.currentData()
    |
    = help: Remove assignment to unused variable `min_speed`

desktop_ui\ngram_heatmap_screen.py:277:9: F841 Local variable `max_speed` is assigned to but never used
    |
275 |         # Get filter values
276 |         min_speed = self.speed_min_spin.value()
277 |         max_speed = self.speed_max_spin.value()
    |         ^^^^^^^^^ F841
278 |         ngram_size = self.ngram_size_combo.currentData()
    |
    = help: Remove assignment to unused variable `max_speed`

desktop_ui\ngram_heatmap_screen.py:278:9: F841 Local variable `ngram_size` is assigned to but never used
    |
276 |         min_speed = self.speed_min_spin.value()
277 |         max_speed = self.speed_max_spin.value()
278 |         ngram_size = self.ngram_size_combo.currentData()
    |         ^^^^^^^^^^ F841
279 |
280 |         # Update display
    |
    = help: Remove assignment to unused variable `ngram_size`

desktop_ui\ngram_llm_screen.py:22:32: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `parent`
   |
21 | class NgramLLMScreen(QWidget):
22 |     def __init__(self, parent: Optional[Any] = None) -> None:
   |                                ^^^^^^^^^^^^^ ANN401
23 |         super().__init__(parent)
24 |         self.setWindowTitle("LLM N-Gram Word Generator")
   |

desktop_ui\query_screen.py:7:1: I001 [*] Import block is un-sorted or un-formatted
   |
 5 |   """
 6 |
 7 | / from typing import Any, Dict, List, Optional
 8 | |
 9 | | from PySide6 import QtWidgets
10 | | from PySide6.QtWidgets import (
11 | |     QDialog,
12 | |     QGridLayout,
13 | |     QHBoxLayout,
14 | |     QHeaderView,
15 | |     QLabel,
16 | |     QLineEdit,
17 | |     QMessageBox,
18 | |     QPushButton,
19 | |     QPlainTextEdit,
20 | |     QTableWidget,
21 | |     QTableWidgetItem,
22 | |     QVBoxLayout,
23 | | )
24 | |
25 | | from db.database_manager import DatabaseManager
26 | | from models.session_manager import SessionManager
   | |_________________________________________________^ I001
   |
   = help: Organize imports

desktop_ui\scaffold_add_speed_summary_for_session.py:15:1: I001 [*] Import block is un-sorted or un-formatted
   |
13 |   sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), "..")))
14 |
15 | / from PySide6 import QtCore, QtWidgets
16 | | from PySide6.QtCore import QThread, Signal
17 | | from PySide6.QtWidgets import QMessageBox, QProgressBar, QTextEdit, QLineEdit
18 | |
19 | | from db.database_manager import ConnectionType, DatabaseManager
20 | | from models.ngram_analytics_service import NGramAnalyticsService
21 | | from models.ngram_manager import NGramManager
   | |_____________________________________________^ I001
   |
   = help: Organize imports

desktop_ui\scaffold_add_speed_summary_for_session.py:15:21: F401 [*] `PySide6.QtCore` imported but unused
   |
13 | sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), "..")))
14 |
15 | from PySide6 import QtCore, QtWidgets
   |                     ^^^^^^ F401
16 | from PySide6.QtCore import QThread, Signal
17 | from PySide6.QtWidgets import QMessageBox, QProgressBar, QTextEdit, QLineEdit
   |
   = help: Remove unused import: `PySide6.QtCore`

desktop_ui\scaffold_add_speed_summary_for_session.py:30:9: ANN204 Missing return type annotation for special method `__init__`
   |
28 |     error = Signal(str)      # Signal with error message
29 |     
30 |     def __init__(self, analytics_service: NGramAnalyticsService, session_id: str):
   |         ^^^^^^^^ ANN204
31 |         super().__init__()
32 |         self.analytics_service = analytics_service
   |
   = help: Add return type annotation: `None`

desktop_ui\scaffold_add_speed_summary_for_session.py:35:9: ANN201 Missing return type annotation for public function `run`
   |
33 |         self.session_id = session_id
34 |     
35 |     def run(self):
   |         ^^^ ANN201
36 |         try:
37 |             result = self.analytics_service.add_speed_summary_for_session(self.session_id)
   |
   = help: Add return type annotation: `None`

desktop_ui\scaffold_add_speed_summary_for_session.py:75:9: ANN201 Missing return type annotation for public function `setup_ui`
   |
73 |         self.load_recent_sessions()
74 |     
75 |     def setup_ui(self):
   |         ^^^^^^^^ ANN201
76 |         """Set up the user interface."""
77 |         layout = QtWidgets.QVBoxLayout(self)
   |
   = help: Add return type annotation: `None`

desktop_ui\scaffold_add_speed_summary_for_session.py:121:121: E501 Line too long (122 > 120)
    |
119 |         self.process_button = QtWidgets.QPushButton("Process Session")
120 |         self.process_button.setStyleSheet(
121 |             "QPushButton { background-color: #2196F3; color: white; padding: 10px; font-size: 14px; border-radius: 5px; }"
    |                                                                                                                         ^^ E501
122 |             "QPushButton:hover { background-color: #1976D2; }"
123 |             "QPushButton:disabled { background-color: #cccccc; }"
    |

desktop_ui\scaffold_add_speed_summary_for_session.py:143:9: ANN201 Missing return type annotation for public function `load_recent_sessions`
    |
141 |         layout.addWidget(close_button)
142 |     
143 |     def load_recent_sessions(self):
    |         ^^^^^^^^^^^^^^^^^^^^ ANN201
144 |         """Load recent sessions into the dropdown."""
145 |         try:
    |
    = help: Add return type annotation: `None`

desktop_ui\scaffold_add_speed_summary_for_session.py:157:121: E501 Line too long (128 > 120)
    |
155 |             self.recent_sessions_combo.addItem("Select a session...", "")
156 |             for session in sessions:
157 |                 display_text = f"{session['session_id'][:8]}... ({session['start_time']}) - {session['ms_per_keystroke']:.1f}ms"
    |                                                                                                                         ^^^^^^^^ E501
158 |                 self.recent_sessions_combo.addItem(display_text, session['session_id'])
    |

desktop_ui\scaffold_add_speed_summary_for_session.py:163:9: ANN201 Missing return type annotation for public function `on_session_selected`
    |
161 |             self.results_text.append(f"Error loading sessions: {str(e)}")
162 |     
163 |     def on_session_selected(self, text):
    |         ^^^^^^^^^^^^^^^^^^^ ANN201
164 |         """Handle session selection from dropdown."""
165 |         current_data = self.recent_sessions_combo.currentData()
    |
    = help: Add return type annotation: `None`

desktop_ui\scaffold_add_speed_summary_for_session.py:163:35: ANN001 Missing type annotation for function argument `text`
    |
161 |             self.results_text.append(f"Error loading sessions: {str(e)}")
162 |     
163 |     def on_session_selected(self, text):
    |                                   ^^^^ ANN001
164 |         """Handle session selection from dropdown."""
165 |         current_data = self.recent_sessions_combo.currentData()
    |

desktop_ui\scaffold_add_speed_summary_for_session.py:169:9: ANN201 Missing return type annotation for public function `start_processing`
    |
167 |             self.session_input.setText(current_data)
168 |     
169 |     def start_processing(self):
    |         ^^^^^^^^^^^^^^^^ ANN201
170 |         """Start the processing in a background thread."""
171 |         session_id = self.session_input.text().strip()
    |
    = help: Add return type annotation: `None`

desktop_ui\scaffold_add_speed_summary_for_session.py:188:9: ANN201 Missing return type annotation for public function `on_processing_finished`
    |
186 |         self.worker.start()
187 |     
188 |     def on_processing_finished(self, result: dict):
    |         ^^^^^^^^^^^^^^^^^^^^^^ ANN201
189 |         """Handle successful completion of processing."""
190 |         self.progress_bar.setVisible(False)
    |
    = help: Add return type annotation: `None`

desktop_ui\scaffold_add_speed_summary_for_session.py:196:34: F541 [*] f-string without any placeholders
    |
194 |         curr_updated = result.get('curr_updated', 0)
195 |         
196 |         self.results_text.append(f"\n Processing completed successfully!")
    |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ F541
197 |         self.results_text.append(f" {curr_updated} records updated in ngram_speed_summary_curr")
198 |         self.results_text.append(f" {hist_inserted} records inserted into ngram_speed_summary_hist")
    |
    = help: Remove extraneous `f` prefix

desktop_ui\scaffold_add_speed_summary_for_session.py:209:9: ANN201 Missing return type annotation for public function `on_processing_error`
    |
207 |         )
208 |     
209 |     def on_processing_error(self, error_message: str):
    |         ^^^^^^^^^^^^^^^^^^^ ANN201
210 |         """Handle errors during processing."""
211 |         self.progress_bar.setVisible(False)
    |
    = help: Add return type annotation: `None`

desktop_ui\scaffold_add_speed_summary_for_session.py:214:34: F541 [*] f-string without any placeholders
    |
212 |         self.process_button.setEnabled(True)
213 |         
214 |         self.results_text.append(f"\n Error during processing:")
    |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ F541
215 |         self.results_text.append(f"   {error_message}")
    |
    = help: Remove extraneous `f` prefix

desktop_ui\scaffold_add_speed_summary_for_session.py:224:9: ANN201 Missing return type annotation for public function `closeEvent`
    |
222 |         )
223 |     
224 |     def closeEvent(self, event):
    |         ^^^^^^^^^^ ANN201
225 |         """Handle window close event."""
226 |         if self.worker and self.worker.isRunning():
    |
    = help: Add return type annotation: `None`

desktop_ui\scaffold_add_speed_summary_for_session.py:224:26: ANN001 Missing type annotation for function argument `event`
    |
222 |         )
223 |     
224 |     def closeEvent(self, event):
    |                          ^^^^^ ANN001
225 |         """Handle window close event."""
226 |         if self.worker and self.worker.isRunning():
    |

desktop_ui\scaffold_add_speed_summary_for_session.py:245:5: ANN201 Missing return type annotation for public function `launch_scaffold_add_speed_summary_for_session`
    |
245 | def launch_scaffold_add_speed_summary_for_session():
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
246 |     """Launch the ScaffoldAddSpeedSummaryForSession application."""
247 |     app = QtWidgets.QApplication.instance()
    |
    = help: Add return type annotation: `None`

desktop_ui\scaffold_bulk_insert_performance.py:18:20: F401 [*] `typing.Dict` imported but unused
   |
16 | from dataclasses import dataclass
17 | from datetime import datetime, timezone
18 | from typing import Dict, List, Optional, Tuple
   |                    ^^^^ F401
19 | from uuid import uuid4
   |
   = help: Remove unused import

desktop_ui\scaffold_bulk_insert_performance.py:18:32: F401 [*] `typing.Optional` imported but unused
   |
16 | from dataclasses import dataclass
17 | from datetime import datetime, timezone
18 | from typing import Dict, List, Optional, Tuple
   |                                ^^^^^^^^ F401
19 | from uuid import uuid4
   |
   = help: Remove unused import

desktop_ui\scaffold_bulk_insert_performance.py:40:1: E402 Module level import not at top of file
   |
38 |     sys.path.insert(0, project_root)
39 |
40 | from db.database_manager import BulkMethod, ConnectionType, DatabaseManager
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
   |

desktop_ui\scaffold_bulk_insert_performance.py:132:35: ANN001 Missing type annotation for function argument `func`
    |
130 |         return rows
131 |
132 |     def _timeit(self, label: str, func, rows_count: int) -> float:
    |                                   ^^^^ ANN001
133 |         t0 = time.perf_counter()
134 |         func()
    |

desktop_ui\scaffold_catchup_speed_summary.py:32:9: ANN204 Missing return type annotation for special method `__init__`
   |
30 |     session_processed = Signal(str, int, int)  # Signal for individual session progress (session_info, current, total)
31 |
32 |     def __init__(self, analytics_service: NGramAnalyticsService):
   |         ^^^^^^^^ ANN204
33 |         super().__init__()
34 |         self.analytics_service = analytics_service
   |
   = help: Add return type annotation: `None`

desktop_ui\scaffold_catchup_speed_summary.py:36:9: ANN201 Missing return type annotation for public function `run`
   |
34 |         self.analytics_service = analytics_service
35 |
36 |     def run(self):
   |         ^^^ ANN201
37 |         try:
38 |             result = self.catchup_speed_summary_with_progress()
   |
   = help: Add return type annotation: `None`

desktop_ui\scaffold_catchup_speed_summary.py:147:9: ANN201 Missing return type annotation for public function `setup_ui`
    |
145 |         self.load_session_stats()
146 |
147 |     def setup_ui(self):
    |         ^^^^^^^^ ANN201
148 |         """Set up the user interface."""
149 |         layout = QtWidgets.QVBoxLayout(self)
    |
    = help: Add return type annotation: `None`

desktop_ui\scaffold_catchup_speed_summary.py:179:121: E501 Line too long (141 > 120)
    |
177 | 
178 | 
179 |  padding: 12px; font-size: 14px; border-radius: 5px; font-weight: bold; }"
    |                                                       ^^^^^^^^^^^^^^^^^^^^^ E501
180 | 
181 | 
    |

desktop_ui\scaffold_catchup_speed_summary.py:217:9: ANN201 Missing return type annotation for public function `load_session_stats`
    |
215 |         layout.addLayout(button_layout)
216 |
217 |     def load_session_stats(self):
    |         ^^^^^^^^^^^^^^^^^^ ANN201
218 |         """Load and display session statistics."""
219 |         try:
    |
    = help: Add return type annotation: `None`

desktop_ui\scaffold_catchup_speed_summary.py:246:9: ANN201 Missing return type annotation for public function `start_catchup`
    |
244 |             self.catchup_button.setEnabled(False)
245 |
246 |     def start_catchup(self):
    |         ^^^^^^^^^^^^^ ANN201
247 |         """Start the catchup process in a background thread."""
248 |         reply = QMessageBox.question(
    |
    = help: Add return type annotation: `None`

desktop_ui\scaffold_catchup_speed_summary.py:275:9: ANN201 Missing return type annotation for public function `on_session_processed`
    |
273 |         self.worker.start()
274 |
275 |     def on_session_processed(self, session_info: str, current: int, total: int):
    |         ^^^^^^^^^^^^^^^^^^^^ ANN201
276 |         """Handle individual session processing updates."""
277 |         # Update progress bar
    |
    = help: Add return type annotation: `None`

desktop_ui\scaffold_catchup_speed_summary.py:288:9: ANN201 Missing return type annotation for public function `on_catchup_finished`
    |
286 |         scrollbar.setValue(scrollbar.maximum())
287 |
288 |     def on_catchup_finished(self, result: dict):
    |         ^^^^^^^^^^^^^^^^^^^ ANN201
289 |         """Handle successful completion of catchup."""
290 |         self.progress_bar.setValue(100)  # Ensure it shows 100% complete
    |
    = help: Add return type annotation: `None`

desktop_ui\scaffold_catchup_speed_summary.py:314:9: ANN201 Missing return type annotation for public function `on_catchup_error`
    |
312 |         )
313 |
314 |     def on_catchup_error(self, error_message: str):
    |         ^^^^^^^^^^^^^^^^ ANN201
315 |         """Handle errors during catchup."""
316 |         self.progress_bar.setVisible(False)
    |
    = help: Add return type annotation: `None`

desktop_ui\scaffold_catchup_speed_summary.py:327:9: ANN201 Missing return type annotation for public function `closeEvent`
    |
325 |         )
326 |
327 |     def closeEvent(self, event):
    |         ^^^^^^^^^^ ANN201
328 |         """Handle window close event."""
329 |         if self.worker and self.worker.isRunning():
    |
    = help: Add return type annotation: `None`

desktop_ui\scaffold_catchup_speed_summary.py:327:26: ANN001 Missing type annotation for function argument `event`
    |
325 |         )
326 |
327 |     def closeEvent(self, event):
    |                          ^^^^^ ANN001
328 |         """Handle window close event."""
329 |         if self.worker and self.worker.isRunning():
    |

desktop_ui\scaffold_catchup_speed_summary.py:349:5: ANN201 Missing return type annotation for public function `launch_scaffold_catchup_speed_summary`
    |
349 | def launch_scaffold_catchup_speed_summary():
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
350 |     """Launch the ScaffoldCatchupSpeedSummary application."""
351 |     app = QtWidgets.QApplication.instance()
    |
    = help: Add return type annotation: `None`

desktop_ui\scaffold_summarize_session_ngrams.py:30:9: ANN204 Missing return type annotation for special method `__init__`
   |
28 |     error = Signal(str)  # Signal with error message
29 |
30 |     def __init__(self, analytics_service: NGramAnalyticsService):
   |         ^^^^^^^^ ANN204
31 |         super().__init__()
32 |         self.analytics_service = analytics_service
   |
   = help: Add return type annotation: `None`

desktop_ui\scaffold_summarize_session_ngrams.py:34:9: ANN201 Missing return type annotation for public function `run`
   |
32 |         self.analytics_service = analytics_service
33 |
34 |     def run(self):
   |         ^^^ ANN201
35 |         try:
36 |             result = self.analytics_service.summarize_session_ngrams()
   |
   = help: Add return type annotation: `None`

desktop_ui\scaffold_summarize_session_ngrams.py:71:9: ANN201 Missing return type annotation for public function `setup_ui`
   |
69 |         self.setup_ui()
70 |
71 |     def setup_ui(self):
   |         ^^^^^^^^ ANN201
72 |         """Set up the user interface."""
73 |         layout = QtWidgets.QVBoxLayout(self)
   |
   = help: Add return type annotation: `None`

desktop_ui\scaffold_summarize_session_ngrams.py:98:121: E501 Line too long (122 > 120)
    |
 96 |         self.summarize_button = QtWidgets.QPushButton("Summarize Ngrams")
 97 |         self.summarize_button.setStyleSheet(
 98 |             "QPushButton { background-color: #4CAF50; color: white; padding: 10px; font-size: 14px; border-radius: 5px; }"
    |                                                                                                                         ^^ E501
 99 |             "QPushButton:hover { background-color: #45a049; }"
100 |             "QPushButton:disabled { background-color: #cccccc; }"
    |

desktop_ui\scaffold_summarize_session_ngrams.py:122:9: ANN201 Missing return type annotation for public function `start_summarization`
    |
120 |         layout.addWidget(close_button)
121 |
122 |     def start_summarization(self):
    |         ^^^^^^^^^^^^^^^^^^^ ANN201
123 |         """Start the summarization process in a background thread."""
124 |         self.summarize_button.setEnabled(False)
    |
    = help: Add return type annotation: `None`

desktop_ui\scaffold_summarize_session_ngrams.py:136:9: ANN201 Missing return type annotation for public function `on_summarization_finished`
    |
134 |         self.worker.start()
135 |
136 |     def on_summarization_finished(self, records_inserted: int):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
137 |         """Handle successful completion of summarization."""
138 |         self.progress_bar.setVisible(False)
    |
    = help: Add return type annotation: `None`

desktop_ui\scaffold_summarize_session_ngrams.py:154:9: ANN201 Missing return type annotation for public function `on_summarization_error`
    |
152 |         )
153 |
154 |     def on_summarization_error(self, error_message: str):
    |         ^^^^^^^^^^^^^^^^^^^^^^ ANN201
155 |         """Handle errors during summarization."""
156 |         self.progress_bar.setVisible(False)
    |
    = help: Add return type annotation: `None`

desktop_ui\scaffold_summarize_session_ngrams.py:169:9: ANN201 Missing return type annotation for public function `closeEvent`
    |
167 |         )
168 |
169 |     def closeEvent(self, event):
    |         ^^^^^^^^^^ ANN201
170 |         """Handle window close event."""
171 |         if self.worker and self.worker.isRunning():
    |
    = help: Add return type annotation: `None`

desktop_ui\scaffold_summarize_session_ngrams.py:169:26: ANN001 Missing type annotation for function argument `event`
    |
167 |         )
168 |
169 |     def closeEvent(self, event):
    |                          ^^^^^ ANN001
170 |         """Handle window close event."""
171 |         if self.worker and self.worker.isRunning():
    |

desktop_ui\scaffold_summarize_session_ngrams.py:190:5: ANN201 Missing return type annotation for public function `launch_scaffold_summarize_session_ngrams`
    |
190 | def launch_scaffold_summarize_session_ngrams():
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
191 |     """Launch the ScaffoldSummarizeSessionNgrams application."""
192 |     app = QtWidgets.QApplication.instance()
    |
    = help: Add return type annotation: `None`

desktop_ui\snippet_model_tester.py:119:121: E501 Line too long (147 > 120)
    |
117 | 
118 | 
119 | p.snippet_name} - {snip.content[:40]}{'...' if len(snip.content)>40 else ''}"
    |                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
120 | 
121 | 
    |

desktop_ui\snippet_scaffold.py:20:41: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `snippet_manager`
   |
18 |     """
19 |
20 |     def __init__(self, snippet_manager: Any) -> None:
   |                                         ^^^ ANN401
21 |         super().__init__()
22 |         self.snippet_manager = snippet_manager
   |

desktop_ui\space_invaders_game.py:7:1: I001 [*] Import block is un-sorted or un-formatted
   |
 5 |   """
 6 |
 7 | / import random
 8 | | from typing import List, Optional
 9 | |
10 | | from PySide6.QtCore import QTimer, Qt
11 | | from PySide6.QtGui import QColor, QFont, QKeyEvent, QPaintEvent, QPainter, QPen
12 | | from PySide6.QtWidgets import QDialog, QLabel, QVBoxLayout, QWidget
   | |___________________________________________________________________^ I001
   |
   = help: Organize imports

desktop_ui\splash.py:48:24: ANN001 Missing type annotation for function argument `graphql`
   |
46 |     """
47 |
48 |     def __init__(self, graphql=None, config: Optional[SplashConfig] = None) -> None:
   |                        ^^^^^^^ ANN001
49 |         super().__init__()
50 |         self.setWindowTitle("AI Typing Trainer")
   |

desktop_ui\splash.py:156:30: F821 Undefined name `GraphQLServerThread`
    |
154 |     def _start_graphql_server(self) -> None:
155 |         self.status_label.setText("Starting up GraphQL")
156 |         self.server_thread = GraphQLServerThread()
    |                              ^^^^^^^^^^^^^^^^^^^ F821
157 |         self.server_thread.started_signal.connect(self._poll_graphql)
158 |         self.server_thread.start()
    |

desktop_ui\typing_drill.py:8:1: I001 [*] Import block is un-sorted or un-formatted
   |
 7 |   # Move all imports to the top of the file for PEP8 compliance
 8 | / import datetime
 9 | | import logging
10 | | import time
11 | | import traceback
12 | | import uuid
13 | | from typing import TYPE_CHECKING, Any, Dict, List, Optional
14 | |
15 | | from PySide6.QtCore import Qt, QTimer
16 | | from PySide6.QtGui import QColor, QFont, QPalette, QTextCharFormat, QTextCursor
17 | | from PySide6.QtWidgets import (
18 | |     QDialog,
19 | |     QGridLayout,
20 | |     QHBoxLayout,
21 | |     QLabel,
22 | |     QProgressBar,
23 | |     QPushButton,
24 | |     QSizePolicy,
25 | |     QSpacerItem,
26 | |     QStatusBar,
27 | |     QTextEdit,
28 | |     QVBoxLayout,
29 | |     QWidget,
30 | | )
31 | |
32 | | from helpers.debug_util import DebugUtil
33 | | from models.keyboard_manager import KeyboardManager, KeyboardNotFound
34 | | from models.ngram_manager import NGramManager
35 | | from models.ngram_analytics_service import NGramAnalyticsService
36 | | from models.session import Session
37 | | from models.session_manager import SessionManager
38 | | from models.user_manager import UserManager, UserNotFound
   | |_________________________________________________________^ I001
39 |
40 |   if TYPE_CHECKING:
   |
   = help: Organize imports

desktop_ui\typing_drill.py:456:13: ANN202 Missing return type annotation for private function `ensure_uuid`
    |
454 |         """
455 |
456 |         def ensure_uuid(val):
    |             ^^^^^^^^^^^ ANN202
457 |             try:
458 |                 return str(uuid.UUID(str(val)))
    |
    = help: Add return type annotation

desktop_ui\typing_drill.py:456:25: ANN001 Missing type annotation for function argument `val`
    |
454 |         """
455 |
456 |         def ensure_uuid(val):
    |                         ^^^ ANN001
457 |             try:
458 |                 return str(uuid.UUID(str(val)))
    |

examples\service_usage_example.py:15:1: E402 Module level import not at top of file
   |
13 |     sys.path.insert(0, project_root)
14 |
15 | from services import init_services
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
   |

examples\service_usage_example.py:18:5: ANN201 Missing return type annotation for public function `main`
   |
18 | def main():
   |     ^^^^ ANN201
19 |     """Demonstrate service initialization and usage."""
20 |     try:
   |
   = help: Add return type annotation: `int`

examples\service_usage_example.py:49:9: ANN204 Missing return type annotation for special method `__init__`
   |
47 | # Example of how to use the services in a class:
48 | class MyApplication:
49 |     def __init__(self, snippet_manager, session_manager):
   |         ^^^^^^^^ ANN204
50 |         self.snippet_manager = snippet_manager
51 |         self.session_manager = session_manager
   |
   = help: Add return type annotation: `None`

examples\service_usage_example.py:49:24: ANN001 Missing type annotation for function argument `snippet_manager`
   |
47 | # Example of how to use the services in a class:
48 | class MyApplication:
49 |     def __init__(self, snippet_manager, session_manager):
   |                        ^^^^^^^^^^^^^^^ ANN001
50 |         self.snippet_manager = snippet_manager
51 |         self.session_manager = session_manager
   |

examples\service_usage_example.py:49:41: ANN001 Missing type annotation for function argument `session_manager`
   |
47 | # Example of how to use the services in a class:
48 | class MyApplication:
49 |     def __init__(self, snippet_manager, session_manager):
   |                                         ^^^^^^^^^^^^^^^ ANN001
50 |         self.snippet_manager = snippet_manager
51 |         self.session_manager = session_manager
   |

examples\service_usage_example.py:53:9: ANN201 Missing return type annotation for public function `do_something`
   |
51 |         self.session_manager = session_manager
52 |
53 |     def do_something(self):
   |         ^^^^^^^^^^^^ ANN201
54 |         """Example method showing service usage."""
55 |         # Use the injected services
   |
   = help: Add return type annotation: `None`

helpers\debug_util.py:54:35: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `*args`
   |
52 |         return self._mode
53 |
54 |     def debugMessage(self, *args: Any, **kwargs: Any) -> None:
   |                                   ^^^ ANN401
55 |         """
56 |         Output a debug message based on the current debug mode.
   |

helpers\debug_util.py:54:50: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `**kwargs`
   |
52 |         return self._mode
53 |
54 |     def debugMessage(self, *args: Any, **kwargs: Any) -> None:
   |                                                  ^^^ ANN401
55 |         """
56 |         Output a debug message based on the current debug mode.
   |

inspect_db.py:5:5: ANN201 Missing return type annotation for public function `inspect_database`
  |
5 | def inspect_database(db_path):
  |     ^^^^^^^^^^^^^^^^ ANN201
6 |     """Inspect the database schema and print detailed information."""
7 |     print(f"\nInspecting database at: {db_path}")
  |
  = help: Add return type annotation: `None`

inspect_db.py:5:22: ANN001 Missing type annotation for function argument `db_path`
  |
5 | def inspect_database(db_path):
  |                      ^^^^^^^ ANN001
6 |     """Inspect the database schema and print detailed information."""
7 |     print(f"\nInspecting database at: {db_path}")
  |

inspect_db.py:54:5: ANN201 Missing return type annotation for public function `main`
   |
52 |         conn.close()
53 |
54 | def main():
   |     ^^^^ ANN201
55 |     """Main function to inspect the database."""
56 |     # Create a temporary database file
   |
   = help: Add return type annotation: `None`

inspect_db.py:103:121: E501 Line too long (161 > 120)
    |
101 | 
102 | 
103 |  else 'NULL':10} DEFAULT: {default_val or 'None':10} {'PRIMARY KEY' if pk else ''}")
    |                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
104 | 
105 | 
    |

main.py:4:5: ANN201 Missing return type annotation for public function `main`
  |
4 | def main():
  |     ^^^^ ANN201
5 |     desktop_ui.main_menu.launch_main_menu()
  |
  = help: Add return type annotation: `None`

migrate_add_text_index.py:14:1: I001 [*] Import block is un-sorted or un-formatted
   |
12 |   """
13 |
14 | / import os
15 | | import sqlite3
16 | | import sys
17 | | from pathlib import Path
   | |________________________^ I001
18 |
19 |   def get_database_path():
   |
   = help: Organize imports

migrate_add_text_index.py:14:8: F401 [*] `os` imported but unused
   |
12 | """
13 |
14 | import os
   |        ^^ F401
15 | import sqlite3
16 | import sys
   |
   = help: Remove unused import: `os`

migrate_add_text_index.py:19:5: ANN201 Missing return type annotation for public function `get_database_path`
   |
17 | from pathlib import Path
18 |
19 | def get_database_path():
   |     ^^^^^^^^^^^^^^^^^ ANN201
20 |     """Get the path to the typing_data.db database."""
21 |     # Get the project root directory
   |
   = help: Add return type annotation

migrate_add_text_index.py:32:5: ANN201 Missing return type annotation for public function `check_column_exists`
   |
30 |     return str(db_path)
31 |
32 | def check_column_exists(cursor, table_name, column_name):
   |     ^^^^^^^^^^^^^^^^^^^ ANN201
33 |     """Check if a column exists in the specified table."""
34 |     cursor.execute(f"PRAGMA table_info({table_name})")
   |
   = help: Add return type annotation

migrate_add_text_index.py:32:25: ANN001 Missing type annotation for function argument `cursor`
   |
30 |     return str(db_path)
31 |
32 | def check_column_exists(cursor, table_name, column_name):
   |                         ^^^^^^ ANN001
33 |     """Check if a column exists in the specified table."""
34 |     cursor.execute(f"PRAGMA table_info({table_name})")
   |

migrate_add_text_index.py:32:33: ANN001 Missing type annotation for function argument `table_name`
   |
30 |     return str(db_path)
31 |
32 | def check_column_exists(cursor, table_name, column_name):
   |                                 ^^^^^^^^^^ ANN001
33 |     """Check if a column exists in the specified table."""
34 |     cursor.execute(f"PRAGMA table_info({table_name})")
   |

migrate_add_text_index.py:32:45: ANN001 Missing type annotation for function argument `column_name`
   |
30 |     return str(db_path)
31 |
32 | def check_column_exists(cursor, table_name, column_name):
   |                                             ^^^^^^^^^^^ ANN001
33 |     """Check if a column exists in the specified table."""
34 |     cursor.execute(f"PRAGMA table_info({table_name})")
   |

migrate_add_text_index.py:38:5: ANN201 Missing return type annotation for public function `migrate_add_text_index`
   |
36 |     return any(col[1] == column_name for col in columns)
37 |
38 | def migrate_add_text_index():
   |     ^^^^^^^^^^^^^^^^^^^^^^ ANN201
39 |     """Add text_index column to session_keystrokes table and populate it."""
40 |     db_path = get_database_path()
   |
   = help: Add return type annotation: `None`

migrate_add_text_index.py:92:39: B007 Loop control variable `keystroke_time` not used within loop body
   |
91 |             # Update each keystroke with its text_index (0-based)
92 |             for index, (keystroke_id, keystroke_time) in enumerate(keystrokes):
   |                                       ^^^^^^^^^^^^^^ B007
93 |                 cursor.execute("""
94 |                     UPDATE session_keystrokes 
   |
   = help: Rename unused `keystroke_time` to `_keystroke_time`

migrate_add_text_index_cloud.py:16:21: F401 [*] `pathlib.Path` imported but unused
   |
14 | import os
15 | import sys
16 | from pathlib import Path
   |                     ^^^^ F401
17 |
18 | # Ensure project root is in sys.path before any project imports
   |
   = help: Remove unused import: `pathlib.Path`

migrate_add_text_index_cloud.py:21:1: I001 [*] Import block is un-sorted or un-formatted
   |
19 | sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__))))
20 |
21 | from db.database_manager import ConnectionType, DatabaseManager
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ I001
22 |
23 | def migrate_add_text_index_cloud():
   |
   = help: Organize imports

migrate_add_text_index_cloud.py:23:5: ANN201 Missing return type annotation for public function `migrate_add_text_index_cloud`
   |
21 | from db.database_manager import ConnectionType, DatabaseManager
22 |
23 | def migrate_add_text_index_cloud():
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
24 |     """Add text_index column to session_keystrokes table and populate it (CLOUD VERSION)."""
   |
   = help: Add return type annotation: `None`

models\ngram_analytics_service.py:11:1: I001 [*] Import block is un-sorted or un-formatted
   |
 9 |   """
10 |
11 | / import logging
12 | | import traceback
13 | | from dataclasses import dataclass
14 | | from datetime import datetime
15 | | from math import log
16 | | from typing import Dict, List, Optional, TYPE_CHECKING, Union
17 | |
18 | | from pydantic import BaseModel, Field
19 | |
20 | | from db.database_manager import DatabaseManager
21 | | from helpers.debug_util import DebugUtil
22 | | from models.ngram_manager import NGramManager
   | |_____________________________________________^ I001
23 |
24 |   if TYPE_CHECKING:  # Only for type hints to avoid circular imports at runtime
   |
   = help: Organize imports

models\ngram_analytics_service.py:25:5: I001 [*] Import block is un-sorted or un-formatted
   |
24 |   if TYPE_CHECKING:  # Only for type hints to avoid circular imports at runtime
25 | /     from models.session import Session
26 | |     from models.keystroke import Keystroke
   | |__________________________________________^ I001
27 |
28 |   logger = logging.getLogger(__name__)
   |
   = help: Organize imports

scripts\fix_all_critical_errors.py:7:1: I001 [*] Import block is un-sorted or un-formatted
   |
 5 |   """
 6 |
 7 | / import re
 8 | | import os
 9 | | from typing import List, Tuple
   | |______________________________^ I001
10 |
11 |   def fix_file_content(file_path: str, fixes: List[Tuple[str, str]]) -> bool:
   |
   = help: Organize imports

scripts\fix_all_critical_errors.py:31:5: ANN201 Missing return type annotation for public function `fix_test_snippet`
   |
29 |     return False
30 |
31 | def fix_test_snippet():
   |     ^^^^^^^^^^^^^^^^ ANN201
32 |     """Fix all critical errors in test_snippet.py"""
33 |     file_path = r"d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py"
   |
   = help: Add return type annotation

scripts\fix_all_critical_errors.py:67:5: ANN201 Missing return type annotation for public function `fix_test_snippet_manager`
   |
65 |     return fix_file_content(file_path, fixes)
66 |
67 | def fix_test_snippet_manager():
   |     ^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
68 |     """Fix all critical errors in test_snippet_manager.py"""
69 |     file_path = r"d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet_manager.py"
   |
   = help: Add return type annotation

scripts\fix_all_critical_errors.py:74:121: E501 Line too long (123 > 120)
   |
72 |         # Fix missing description argument and category_id type
73 |         (r'Snippet\(\s*snippet_name=([^,]+),\s*content=([^,]+),\s*category_id=([^,\)]+)\s*\)',
74 |          r'Snippet(snippet_name=\1, content=\2, category_id=\3 or "default_category_id", description="Test description")'),
   |                                                                                                                         ^^^ E501
75 |     ]
   |

scripts\fix_all_critical_errors.py:79:5: ANN201 Missing return type annotation for public function `fix_conftest`
   |
77 |     return fix_file_content(file_path, fixes)
78 |
79 | def fix_conftest():
   |     ^^^^^^^^^^^^ ANN201
80 |     """Fix all critical errors in conftest.py"""
81 |     file_path = r"d:\SeanDevLocal\AITypingTrainer\tests\models\conftest.py"
   |
   = help: Add return type annotation

scripts\fix_all_critical_errors.py:98:121: E501 Line too long (164 > 120)
   |
96 | 
97 | id,\s*keyboard_id=([^.]+)\.keyboard_id',
98 | .user_id or "default_user_id", keyboard_id=\3.keyboard_id or "default_keyboard_id"'),
   |                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
99 | 
   |

scripts\fix_all_critical_errors.py:103:5: ANN201 Missing return type annotation for public function `fix_test_ngram_size`
    |
101 |     return fix_file_content(file_path, fixes)
102 |
103 | def fix_test_ngram_size():
    |     ^^^^^^^^^^^^^^^^^^^ ANN201
104 |     """Fix all critical errors in test_ngram_size.py"""
105 |     file_path = r"d:\SeanDevLocal\AITypingTrainer\tests\models\test_ngram_size.py"
    |
    = help: Add return type annotation

scripts\fix_all_critical_errors.py:119:5: ANN201 Missing return type annotation for public function `fix_test_db_viewer_dialog`
    |
117 |     return fix_file_content(file_path, fixes)
118 |
119 | def fix_test_db_viewer_dialog():
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
120 |     """Fix critical errors in test_db_viewer_dialog.py"""
121 |     file_path = r"d:\SeanDevLocal\AITypingTrainer\tests\desktop_ui\test_db_viewer_dialog.py"
    |
    = help: Add return type annotation

scripts\fix_all_critical_errors.py:135:5: ANN201 Missing return type annotation for public function `main`
    |
133 |     return fix_file_content(file_path, fixes)
134 |
135 | def main():
    |     ^^^^ ANN201
136 |     """Run all fixes"""
137 |     print("Starting comprehensive fix for all critical type errors...")
    |
    = help: Add return type annotation: `None`

scripts\fix_all_remaining_critical_errors.py:7:1: I001 [*] Import block is un-sorted or un-formatted
   |
 5 |   """
 6 |
 7 | / import re
 8 | | from pathlib import Path
   | |________________________^ I001
 9 |
10 |   def fix_test_snippet_py():
   |
   = help: Organize imports

scripts\fix_all_remaining_critical_errors.py:10:5: ANN201 Missing return type annotation for public function `fix_test_snippet_py`
   |
 8 | from pathlib import Path
 9 |
10 | def fix_test_snippet_py():
   |     ^^^^^^^^^^^^^^^^^^^ ANN201
11 |     """Fix all critical type errors in test_snippet.py"""
12 |     file_path = Path("tests/models/test_snippet.py")
   |
   = help: Add return type annotation: `None`

scripts\fix_all_remaining_critical_errors.py:52:5: ANN201 Missing return type annotation for public function `fix_test_snippet_manager_py`
   |
50 |     print(f"Fixed critical type errors in {file_path}")
51 |
52 | def fix_test_snippet_manager_py():
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
53 |     """Fix all critical type errors in test_snippet_manager.py"""
54 |     file_path = Path("tests/models/test_snippet_manager.py")
   |
   = help: Add return type annotation: `None`

scripts\fix_all_remaining_critical_errors.py:74:5: ANN201 Missing return type annotation for public function `fix_conftest_py`
   |
72 |     print(f"Fixed critical type errors in {file_path}")
73 |
74 | def fix_conftest_py():
   |     ^^^^^^^^^^^^^^^ ANN201
75 |     """Fix all critical type errors in conftest.py"""
76 |     file_path = Path("tests/models/conftest.py")
   |
   = help: Add return type annotation: `None`

scripts\fix_all_remaining_critical_errors.py:85:121: E501 Line too long (157 > 120)
   |
83 | 
84 | 
85 | er_id": user_id,\s*"keyboard_id": keyboard_id,\s*"snippet_id": snippet_id,?\s*\}',
   |                                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
86 | 
87 | 
   |

scripts\fix_all_remaining_critical_errors.py:109:5: ANN201 Missing return type annotation for public function `fix_test_ngram_size_py`
    |
107 |     print(f"Fixed critical type errors in {file_path}")
108 |
109 | def fix_test_ngram_size_py():
    |     ^^^^^^^^^^^^^^^^^^^^^^ ANN201
110 |     """Fix all critical type errors in test_ngram_size.py"""
111 |     file_path = Path("tests/models/test_ngram_size.py")
    |
    = help: Add return type annotation: `None`

scripts\fix_all_remaining_critical_errors.py:137:5: ANN201 Missing return type annotation for public function `fix_test_ngram_analytics_service_py`
    |
135 |     print(f"Fixed critical type errors in {file_path}")
136 |
137 | def fix_test_ngram_analytics_service_py():
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
138 |     """Fix undefined name errors in test_ngram_analytics_service.py"""
139 |     file_path = Path("tests/models/test_ngram_analytics_service.py")
    |
    = help: Add return type annotation: `None`

scripts\fix_all_remaining_critical_errors.py:152:5: ANN201 Missing return type annotation for public function `fix_database_viewer_service_py`
    |
150 |     print(f"Fixed undefined name errors in {file_path}")
151 |
152 | def fix_database_viewer_service_py():
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
153 |     """Fix type assignment error in database_viewer_service.py"""
154 |     file_path = Path("services/database_viewer_service.py")
    |
    = help: Add return type annotation: `None`

scripts\fix_all_remaining_critical_errors.py:171:5: ANN201 Missing return type annotation for public function `fix_test_db_viewer_dialog_py`
    |
169 |     print(f"Fixed type assignment error in {file_path}")
170 |
171 | def fix_test_db_viewer_dialog_py():
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
172 |     """Fix syntax and type errors in test_db_viewer_dialog.py"""
173 |     file_path = Path("tests/desktop_ui/test_db_viewer_dialog.py")
    |
    = help: Add return type annotation: `None`

scripts\fix_all_remaining_critical_errors.py:184:9: B007 Loop control variable `i` not used within loop body
    |
182 |     fixed_lines = []
183 |     
184 |     for i, line in enumerate(lines):
    |         ^ B007
185 |         # Look for unterminated strings (odd number of quotes)
186 |         if line.count('"') % 2 != 0 and not line.strip().endswith('\\'):
    |
    = help: Rename unused `i` to `_i`

scripts\fix_all_remaining_critical_errors.py:196:121: E501 Line too long (126 > 120)
    |
194 |     content = re.sub(
195 |         r'return app if app is not None else QApplication\(\[\]\)',
196 |         r'app_instance = app if app is not None else QApplication([])\n    return app_instance  # type: ignore[return-value]',
    |                                                                                                                         ^^^^^^ E501
197 |         content
198 |     )
    |

scripts\fix_all_remaining_critical_errors.py:206:5: ANN201 Missing return type annotation for public function `main`
    |
204 |     print(f"Fixed syntax and type errors in {file_path}")
205 |
206 | def main():
    |     ^^^^ ANN201
207 |     """Run all fixes"""
208 |     print("Starting comprehensive fix for all remaining critical type errors...")
    |
    = help: Add return type annotation: `None`

scripts\fix_db_viewer_dialog_annotations.py:11:5: ANN201 Missing return type annotation for public function `fix_test_db_viewer_dialog_annotations`
   |
11 | def fix_test_db_viewer_dialog_annotations():
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
12 |     """Fix missing type annotations in test_db_viewer_dialog.py."""
   |
   = help: Add return type annotation: `None`

scripts\fix_db_viewer_dialog_annotations.py:37:121: E501 Line too long (128 > 120)
   |
36 |  mock decorators
37 | ox, mock_get_save_filename, qtapp, mock_db_viewer_service, qtbot\):'
   |                                                              ^^^^^^^^ E501
38 | et_save_filename: Any, qtapp: QApplication, mock_db_viewer_service: MagicMock, qtbot: QtBot) -> None:'
39 | tent)
   |

scripts\fix_db_viewer_dialog_annotations.py:38:121: E501 Line too long (162 > 120)
   |
36 | 
37 | _filename, qtapp, mock_db_viewer_service, qtbot\):'
38 |  Any, qtapp: QApplication, mock_db_viewer_service: MagicMock, qtbot: QtBot) -> None:'
   |                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
39 | 
   |

scripts\fix_db_viewer_dialog_annotations.py:48:9: ANN202 Missing return type annotation for private function `fix_remaining_tests`
   |
46 |     # Fix 5: Handle any remaining test functions that might have been missed
47 |     remaining_test_pattern = r'def (test_\w+)\(([^)]+)\):'
48 |     def fix_remaining_tests(match):
   |         ^^^^^^^^^^^^^^^^^^^ ANN202
49 |         func_name = match.group(1)
50 |         params = match.group(2)
   |
   = help: Add return type annotation

scripts\fix_db_viewer_dialog_annotations.py:48:29: ANN001 Missing type annotation for function argument `match`
   |
46 |     # Fix 5: Handle any remaining test functions that might have been missed
47 |     remaining_test_pattern = r'def (test_\w+)\(([^)]+)\):'
48 |     def fix_remaining_tests(match):
   |                             ^^^^^ ANN001
49 |         func_name = match.group(1)
50 |         params = match.group(2)
   |

scripts\fix_remaining_critical_errors_targeted.py:27:9: ANN202 Missing return type annotation for private function `fix_snippet_constructor`
   |
25 |     snippet_pattern = r'Snippet\(\s*([^)]*?)\s*\)'
26 |     
27 |     def fix_snippet_constructor(match):
   |         ^^^^^^^^^^^^^^^^^^^^^^^ ANN202
28 |         args = match.group(1)
29 |         # If description is not present, add it
   |
   = help: Add return type annotation

scripts\fix_remaining_critical_errors_targeted.py:27:33: ANN001 Missing type annotation for function argument `match`
   |
25 |     snippet_pattern = r'Snippet\(\s*([^)]*?)\s*\)'
26 |     
27 |     def fix_snippet_constructor(match):
   |                                 ^^^^^ ANN001
28 |         args = match.group(1)
29 |         # If description is not present, add it
   |

scripts\fix_remaining_critical_errors_targeted.py:96:9: ANN202 Missing return type annotation for private function `fix_snippet_constructor`
   |
94 |     snippet_pattern = r'Snippet\(\s*([^)]*?)\s*\)'
95 |     
96 |     def fix_snippet_constructor(match):
   |         ^^^^^^^^^^^^^^^^^^^^^^^ ANN202
97 |         args = match.group(1)
98 |         # If description is not present, add it
   |
   = help: Add return type annotation: `str`

scripts\fix_remaining_critical_errors_targeted.py:96:33: ANN001 Missing type annotation for function argument `match`
   |
94 |     snippet_pattern = r'Snippet\(\s*([^)]*?)\s*\)'
95 |     
96 |     def fix_snippet_constructor(match):
   |                                 ^^^^^ ANN001
97 |         args = match.group(1)
98 |         # If description is not present, add it
   |

scripts\fix_snippet_test_errors.py:18:9: ANN202 Missing return type annotation for private function `add_description_if_missing`
   |
16 |     snippet_pattern = r'(Snippet\(\s*(?:[^)]*?))\)'
17 |     
18 |     def add_description_if_missing(match):
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN202
19 |         constructor_content = match.group(1)
20 |         if 'description=' not in constructor_content:
   |
   = help: Add return type annotation

scripts\fix_snippet_test_errors.py:18:36: ANN001 Missing type annotation for function argument `match`
   |
16 |     snippet_pattern = r'(Snippet\(\s*(?:[^)]*?))\)'
17 |     
18 |     def add_description_if_missing(match):
   |                                    ^^^^^ ANN001
19 |         constructor_content = match.group(1)
20 |         if 'description=' not in constructor_content:
   |

scripts\fix_snippet_test_errors.py:37:9: ANN202 Missing return type annotation for private function `add_description_if_missing`
   |
35 |     category_pattern = r'(Category\(\s*(?:[^)]*?))\)'
36 |     
37 |     def add_description_if_missing(match):
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN202
38 |         constructor_content = match.group(1)
39 |         if 'description=' not in constructor_content:
   |
   = help: Add return type annotation

scripts\fix_snippet_test_errors.py:37:36: ANN001 Missing type annotation for function argument `match`
   |
35 |     category_pattern = r'(Category\(\s*(?:[^)]*?))\)'
36 |     
37 |     def add_description_if_missing(match):
   |                                    ^^^^^ ANN001
38 |         constructor_content = match.group(1)
39 |         if 'description=' not in constructor_content:
   |

scripts\fix_snippet_test_errors.py:44:121: E501 Line too long (121 > 120)
   |
42 |                 return f'{constructor_content}\n                description="Test category description",\n            )'
43 |             else:
44 |                 return f'{constructor_content},\n                description="Test category description",\n            )'
   |                                                                                                                         ^ E501
45 |         return match.group(0)
   |

scripts\fix_snippet_test_errors.py:125:5: ANN201 Missing return type annotation for public function `main`
    |
125 | def main():
    |     ^^^^ ANN201
126 |     """Main function to apply all fixes."""
    |
    = help: Add return type annotation: `None`

scripts\fix_snippet_test_errors_v2.py:11:5: ANN201 Missing return type annotation for public function `fix_test_snippet_errors_v2`
   |
11 | def fix_test_snippet_errors_v2():
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
12 |     """Fix all remaining type errors in test_snippet.py comprehensively."""
   |
   = help: Add return type annotation: `None`

scripts\fix_snippet_test_errors_v2.py:29:9: ANN202 Missing return type annotation for private function `fix_snippet_constructor`
   |
27 |     # Pattern: Snippet(...) without description
28 |     snippet_pattern = r'Snippet\(\s*([^)]*?)\s*\)'
29 |     def fix_snippet_constructor(match):
   |         ^^^^^^^^^^^^^^^^^^^^^^^ ANN202
30 |         args = match.group(1)
31 |         # Skip if already has description
   |
   = help: Add return type annotation

scripts\fix_snippet_test_errors_v2.py:29:33: ANN001 Missing type annotation for function argument `match`
   |
27 |     # Pattern: Snippet(...) without description
28 |     snippet_pattern = r'Snippet\(\s*([^)]*?)\s*\)'
29 |     def fix_snippet_constructor(match):
   |                                 ^^^^^ ANN001
30 |         args = match.group(1)
31 |         # Skip if already has description
   |

scripts\fix_snippet_test_errors_v2.py:45:9: ANN202 Missing return type annotation for private function `fix_category_constructor`
   |
43 |     # Pattern: Category(...) without description
44 |     category_pattern = r'Category\(\s*([^)]*?)\s*\)'
45 |     def fix_category_constructor(match):
   |         ^^^^^^^^^^^^^^^^^^^^^^^^ ANN202
46 |         args = match.group(1)
47 |         # Skip if already has description
   |
   = help: Add return type annotation

scripts\fix_snippet_test_errors_v2.py:45:34: ANN001 Missing type annotation for function argument `match`
   |
43 |     # Pattern: Category(...) without description
44 |     category_pattern = r'Category\(\s*([^)]*?)\s*\)'
45 |     def fix_category_constructor(match):
   |                                  ^^^^^ ANN001
46 |         args = match.group(1)
47 |         # Skip if already has description
   |

scripts\fix_snippet_test_errors_v2.py:80:121: E501 Line too long (136 > 120)
   |
78 | 
79 | :\s*"""Test updating a non-existent snippet\."""',
80 | one:\n    """Test updating a non-existent snippet (duplicate test)."""',
   |                                                          ^^^^^^^^^^^^^^^^ E501
81 | 
82 | 
   |

scripts\fix_snippet_test_final.py:7:1: I001 [*] Import block is un-sorted or un-formatted
   |
 5 |   """
 6 |
 7 | / import re
 8 | | import os
   | |_________^ I001
 9 |
10 |   def fix_test_snippet_final():
   |
   = help: Organize imports

scripts\fix_snippet_test_final.py:10:5: ANN201 Missing return type annotation for public function `fix_test_snippet_final`
   |
 8 | import os
 9 |
10 | def fix_test_snippet_final():
   |     ^^^^^^^^^^^^^^^^^^^^^^ ANN201
11 |     """Apply final comprehensive fixes to test_snippet.py"""
   |
   = help: Add return type annotation: `None`

scripts\fix_snippet_test_final.py:29:121: E501 Line too long (162 > 120)
   |
27 | 
28 | \s*\n\s*content=([^,\)]+)\s*\n\s*\)', 
29 | ,\n            content=\3,\n            description="Test description",\n        )'),
   |                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
30 | 
31 | 
   |

scripts\fix_snippet_test_final.py:81:121: E501 Line too long (134 > 120)
   |
80 | 
81 | )]+)\) -> None:\s*"""Test updating a snippet that doesn\'t exist\."""',
   |                                                           ^^^^^^^^^^^^^^ E501
82 | icate(\1) -> None:\n    """Test updating a snippet that doesn\'t exist (duplicate test)."""',
83 | 
   |

scripts\fix_snippet_test_final.py:82:121: E501 Line too long (156 > 120)
   |
80 | 
81 | one:\s*"""Test updating a snippet that doesn\'t exist\."""',
82 | > None:\n    """Test updating a snippet that doesn\'t exist (duplicate test)."""',
   |                                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
83 | 
   |

services\database_viewer_service.py:59:9: ANN204 Missing return type annotation for special method `__init__`
   |
57 |     """
58 |
59 |     def __init__(self, db_manager: DatabaseManager):
   |         ^^^^^^^^ ANN204
60 |         """
61 |         Initialize the DatabaseViewerService with a database manager.
   |
   = help: Add return type annotation: `None`

services\library_service.py:47:9: ANN204 Missing return type annotation for special method `__init__`
   |
45 |     metadata = metadata
46 |
47 |     def __init__(self, session):
   |         ^^^^^^^^ ANN204
48 |         self.session = session
   |
   = help: Add return type annotation: `None`

services\library_service.py:47:24: ANN001 Missing type annotation for function argument `session`
   |
45 |     metadata = metadata
46 |
47 |     def __init__(self, session):
   |                        ^^^^^^^ ANN001
48 |         self.session = session
   |

services\library_service.py:51:9: ANN201 Missing return type annotation for public function `add_category`
   |
50 |     # Category methods
51 |     def add_category(self, name):
   |         ^^^^^^^^^^^^ ANN201
52 |         if not name or len(name) > 50 or not name.isascii():
53 |             raise ValidationError("Invalid category name")
   |
   = help: Add return type annotation

services\library_service.py:51:28: ANN001 Missing type annotation for function argument `name`
   |
50 |     # Category methods
51 |     def add_category(self, name):
   |                            ^^^^ ANN001
52 |         if not name or len(name) > 50 or not name.isascii():
53 |             raise ValidationError("Invalid category name")
   |

services\library_service.py:60:9: ANN201 Missing return type annotation for public function `get_categories`
   |
58 |         return cat
59 |
60 |     def get_categories(self):
   |         ^^^^^^^^^^^^^^ ANN201
61 |         return self.session.query(Category).all()
   |
   = help: Add return type annotation

services\library_service.py:63:9: ANN201 Missing return type annotation for public function `edit_category`
   |
61 |         return self.session.query(Category).all()
62 |
63 |     def edit_category(self, category_id, new_name):
   |         ^^^^^^^^^^^^^ ANN201
64 |         if not new_name or len(new_name) > 50 or not new_name.isascii():
65 |             raise ValidationError("Invalid category name")
   |
   = help: Add return type annotation

services\library_service.py:63:29: ANN001 Missing type annotation for function argument `category_id`
   |
61 |         return self.session.query(Category).all()
62 |
63 |     def edit_category(self, category_id, new_name):
   |                             ^^^^^^^^^^^ ANN001
64 |         if not new_name or len(new_name) > 50 or not new_name.isascii():
65 |             raise ValidationError("Invalid category name")
   |

services\library_service.py:63:42: ANN001 Missing type annotation for function argument `new_name`
   |
61 |         return self.session.query(Category).all()
62 |
63 |     def edit_category(self, category_id, new_name):
   |                                          ^^^^^^^^ ANN001
64 |         if not new_name or len(new_name) > 50 or not new_name.isascii():
65 |             raise ValidationError("Invalid category name")
   |

services\library_service.py:78:9: ANN201 Missing return type annotation for public function `delete_category`
   |
76 |         return cat
77 |
78 |     def delete_category(self, category_id):
   |         ^^^^^^^^^^^^^^^ ANN201
79 |         cat = self.session.query(Category).filter_by(category_id=category_id).first()
80 |         if not cat:
   |
   = help: Add return type annotation: `None`

services\library_service.py:78:31: ANN001 Missing type annotation for function argument `category_id`
   |
76 |         return cat
77 |
78 |     def delete_category(self, category_id):
   |                               ^^^^^^^^^^^ ANN001
79 |         cat = self.session.query(Category).filter_by(category_id=category_id).first()
80 |         if not cat:
   |

services\library_service.py:85:9: ANN201 Missing return type annotation for public function `add_snippet`
   |
84 |     # Snippet methods
85 |     def add_snippet(self, category_id, name, content):
   |         ^^^^^^^^^^^ ANN201
86 |         if not name or len(name) > 50 or not name.isascii():
87 |             raise ValidationError("Invalid snippet name")
   |
   = help: Add return type annotation

services\library_service.py:85:27: ANN001 Missing type annotation for function argument `category_id`
   |
84 |     # Snippet methods
85 |     def add_snippet(self, category_id, name, content):
   |                           ^^^^^^^^^^^ ANN001
86 |         if not name or len(name) > 50 or not name.isascii():
87 |             raise ValidationError("Invalid snippet name")
   |

services\library_service.py:85:40: ANN001 Missing type annotation for function argument `name`
   |
84 |     # Snippet methods
85 |     def add_snippet(self, category_id, name, content):
   |                                        ^^^^ ANN001
86 |         if not name or len(name) > 50 or not name.isascii():
87 |             raise ValidationError("Invalid snippet name")
   |

services\library_service.py:85:46: ANN001 Missing type annotation for function argument `content`
   |
84 |     # Snippet methods
85 |     def add_snippet(self, category_id, name, content):
   |                                              ^^^^^^^ ANN001
86 |         if not name or len(name) > 50 or not name.isascii():
87 |             raise ValidationError("Invalid snippet name")
   |

services\library_service.py:100:9: ANN201 Missing return type annotation for public function `get_snippets`
    |
 98 |         return snip
 99 |
100 |     def get_snippets(self, category_id):
    |         ^^^^^^^^^^^^ ANN201
101 |         return self.session.query(Snippet).filter_by(category_id=category_id).all()
    |
    = help: Add return type annotation

services\library_service.py:100:28: ANN001 Missing type annotation for function argument `category_id`
    |
 98 |         return snip
 99 |
100 |     def get_snippets(self, category_id):
    |                            ^^^^^^^^^^^ ANN001
101 |         return self.session.query(Snippet).filter_by(category_id=category_id).all()
    |

services\library_service.py:103:9: ANN201 Missing return type annotation for public function `edit_snippet`
    |
101 |         return self.session.query(Snippet).filter_by(category_id=category_id).all()
102 |
103 |     def edit_snippet(self, snippet_id, new_name, new_content, new_category_id=None):
    |         ^^^^^^^^^^^^ ANN201
104 |         if not new_name or len(new_name) > 50 or not new_name.isascii():
105 |             raise ValidationError("Invalid snippet name")
    |
    = help: Add return type annotation

services\library_service.py:103:28: ANN001 Missing type annotation for function argument `snippet_id`
    |
101 |         return self.session.query(Snippet).filter_by(category_id=category_id).all()
102 |
103 |     def edit_snippet(self, snippet_id, new_name, new_content, new_category_id=None):
    |                            ^^^^^^^^^^ ANN001
104 |         if not new_name or len(new_name) > 50 or not new_name.isascii():
105 |             raise ValidationError("Invalid snippet name")
    |

services\library_service.py:103:40: ANN001 Missing type annotation for function argument `new_name`
    |
101 |         return self.session.query(Snippet).filter_by(category_id=category_id).all()
102 |
103 |     def edit_snippet(self, snippet_id, new_name, new_content, new_category_id=None):
    |                                        ^^^^^^^^ ANN001
104 |         if not new_name or len(new_name) > 50 or not new_name.isascii():
105 |             raise ValidationError("Invalid snippet name")
    |

services\library_service.py:103:50: ANN001 Missing type annotation for function argument `new_content`
    |
101 |         return self.session.query(Snippet).filter_by(category_id=category_id).all()
102 |
103 |     def edit_snippet(self, snippet_id, new_name, new_content, new_category_id=None):
    |                                                  ^^^^^^^^^^^ ANN001
104 |         if not new_name or len(new_name) > 50 or not new_name.isascii():
105 |             raise ValidationError("Invalid snippet name")
    |

services\library_service.py:103:63: ANN001 Missing type annotation for function argument `new_category_id`
    |
101 |         return self.session.query(Snippet).filter_by(category_id=category_id).all()
102 |
103 |     def edit_snippet(self, snippet_id, new_name, new_content, new_category_id=None):
    |                                                               ^^^^^^^^^^^^^^^ ANN001
104 |         if not new_name or len(new_name) > 50 or not new_name.isascii():
105 |             raise ValidationError("Invalid snippet name")
    |

services\library_service.py:129:9: ANN201 Missing return type annotation for public function `delete_snippet`
    |
127 |         return snip
128 |
129 |     def delete_snippet(self, snippet_id):
    |         ^^^^^^^^^^^^^^ ANN201
130 |         snip = self.session.query(Snippet).filter_by(snippet_id=snippet_id).first()
131 |         if not snip:
    |
    = help: Add return type annotation: `None`

services\library_service.py:129:30: ANN001 Missing type annotation for function argument `snippet_id`
    |
127 |         return snip
128 |
129 |     def delete_snippet(self, snippet_id):
    |                              ^^^^^^^^^^ ANN001
130 |         snip = self.session.query(Snippet).filter_by(snippet_id=snippet_id).first()
131 |         if not snip:
    |

test_debug_mode.py:18:5: ANN201 Missing return type annotation for public function `test_debug_mode_functionality`
   |
18 | def test_debug_mode_functionality():
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
19 |     """Test the debug mode functionality with different settings."""
   |
   = help: Add return type annotation: `None`

test_debug_mode.py:55:5: ANN201 Missing return type annotation for public function `test_main_menu_integration`
   |
55 | def test_main_menu_integration():
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
56 |     """Test the main menu integration with debug mode."""
   |
   = help: Add return type annotation: `None`

test_debug_util_integration.py:6:1: I001 [*] Import block is un-sorted or un-formatted
   |
 4 |   """
 5 |
 6 | / import os
 7 | | import sys
 8 | | import tempfile
 9 | | from io import StringIO
10 | | from contextlib import redirect_stdout
   | |______________________________________^ I001
11 |
12 |   # Add project root to path
   |
   = help: Organize imports

test_debug_util_integration.py:15:1: I001 [*] Import block is un-sorted or un-formatted
   |
13 |   sys.path.insert(0, os.path.dirname(__file__))
14 |
15 | / from helpers.debug_util import DebugUtil
16 | | from db.database_manager import DatabaseManager, ConnectionType
   | |_______________________________________________________________^ I001
   |
   = help: Organize imports

test_debug_util_integration.py:19:5: ANN201 Missing return type annotation for public function `test_debug_util_standalone`
   |
19 | def test_debug_util_standalone():
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
20 |     """Test the DebugUtil class functionality standalone."""
   |
   = help: Add return type annotation: `None`

test_debug_util_integration.py:59:5: ANN201 Missing return type annotation for public function `test_database_manager_integration`
   |
59 | def test_database_manager_integration():
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
60 |     """Test DatabaseManager integration with DebugUtil."""
   |
   = help: Add return type annotation: `None`

test_debug_util_integration.py:106:9: E722 Do not use bare `except`
    |
104 |         try:
105 |             os.unlink(temp_db_path)
106 |         except:
    |         ^^^^^^ E722
107 |             pass
    |

test_debug_util_integration.py:135:9: E722 Do not use bare `except`
    |
133 |         try:
134 |             os.unlink(temp_db_path)
135 |         except:
    |         ^^^^^^ E722
136 |             pass
    |

test_debug_util_integration.py:141:5: ANN201 Missing return type annotation for public function `test_fallback_behavior`
    |
141 | def test_fallback_behavior():
    |     ^^^^^^^^^^^^^^^^^^^^^^ ANN201
142 |     """Test fallback behavior when DebugUtil is not provided."""
    |
    = help: Add return type annotation: `None`

test_debug_util_integration.py:174:9: E722 Do not use bare `except`
    |
172 |         try:
173 |             os.unlink(temp_db_path)
174 |         except:
    |         ^^^^^^ E722
175 |             pass
    |

test_main_menu_args.py:6:1: I001 [*] Import block is un-sorted or un-formatted
  |
4 |   """
5 |
6 | / import sys
7 | | import os
  | |_________^ I001
8 |
9 |   # Add project root to path
  |
  = help: Organize imports

test_main_menu_args.py:12:5: ANN201 Missing return type annotation for public function `test_argument_parsing`
   |
10 | sys.path.insert(0, os.path.dirname(__file__))
11 |
12 | def test_argument_parsing():
   |     ^^^^^^^^^^^^^^^^^^^^^ ANN201
13 |     """Test the command line argument parsing logic from main_menu.py"""
   |
   = help: Add return type annotation: `None`

tests\db\test_database_manager.py:8:1: I001 [*] Import block is un-sorted or un-formatted
   |
 6 |   """
 7 |
 8 | / import os
 9 | | import tempfile
10 | | from typing import Any, Generator, Iterable, Optional, TextIO, Tuple, cast
11 | |
12 | | import pytest
13 | |
14 | | from db.database_manager import (
15 | |     CLOUD_DEPENDENCIES_AVAILABLE,
16 | |     ConnectionType,
17 | |     DatabaseManager,
18 | |     BulkMethod,
19 | | )
20 | | from db.database_manager import (
21 | |     CursorProtocol as DBCursorProtocol,
22 | | )
23 | | from db.exceptions import (
24 | |     ConstraintError,
25 | |     DatabaseError,
26 | |     DBConnectionError,
27 | |     ForeignKeyError,
28 | |     SchemaError,
29 | |     TableNotFoundError,
30 | | )
   | |_^ I001
31 |
32 |   # Test data constants
   |
   = help: Organize imports

tests\db\test_database_manager.py:466:88: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `capsys`
    |
464 |         assert [r["id"] for r in results] == ids
465 |
466 |     def test_postgres_bulk_insert_performance(self, cloud_db: DatabaseManager, capsys: Any) -> None:
    |                                                                                        ^^^ ANN401
467 |         import time
    |

tests\db\test_database_manager.py:657:121: E501 Line too long (143 > 120)
    |
655 |  WHERE id=%s"),
656 | 
657 | WHERE table_schema = %s AND table_type = 'BASE TABLE' ORDER BY table_name",
    |                                                      ^^^^^^^^^^^^^^^^^^^^^^^ E501
658 | WHERE table_schema = typing AND table_type = 'BASE TABLE' ORDER BY table_name",
659 | 
    |

tests\db\test_database_manager.py:658:121: E501 Line too long (147 > 120)
    |
656 | 
657 | ERE table_schema = %s AND table_type = 'BASE TABLE' ORDER BY table_name",
658 | ERE table_schema = typing AND table_type = 'BASE TABLE' ORDER BY table_name",
    |                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
659 | 
660 | oo WHERE id=%s"),
    |

tests\desktop_ui\test_db_viewer_dialog.py:22:5: ANN201 Missing return type annotation for public function `qtapp`
   |
21 | @pytest.fixture
22 | def qtapp():
   |     ^^^^^ ANN201
23 |     """Create a QApplication instance for testing.
24 |     This avoids conflicts with pytest-flask by creating a dedicated QApplication for Qt tests.
   |
   = help: Add return type annotation

tests\desktop_ui\test_db_viewer_dialog.py:35:9: ANN204 Missing return type annotation for special method `__init__`
   |
33 |     """Simple QtBot class to replace pytest-qt's qtbot when it's not available."""
34 |
35 |     def __init__(self, app):
   |         ^^^^^^^^ ANN204
36 |         self.app = app
37 |         self.widgets = []
   |
   = help: Add return type annotation: `None`

tests\desktop_ui\test_db_viewer_dialog.py:35:24: ANN001 Missing type annotation for function argument `app`
   |
33 |     """Simple QtBot class to replace pytest-qt's qtbot when it's not available."""
34 |
35 |     def __init__(self, app):
   |                        ^^^ ANN001
36 |         self.app = app
37 |         self.widgets = []
   |

tests\desktop_ui\test_db_viewer_dialog.py:39:9: ANN201 Missing return type annotation for public function `addWidget`
   |
37 |         self.widgets = []
38 |
39 |     def addWidget(self, widget):
   |         ^^^^^^^^^ ANN201
40 |         """Keep track of widgets to ensure they don't get garbage collected."""
41 |         self.widgets.append(widget)
   |
   = help: Add return type annotation

tests\desktop_ui\test_db_viewer_dialog.py:39:25: ANN001 Missing type annotation for function argument `widget`
   |
37 |         self.widgets = []
38 |
39 |     def addWidget(self, widget):
   |                         ^^^^^^ ANN001
40 |         """Keep track of widgets to ensure they don't get garbage collected."""
41 |         self.widgets.append(widget)
   |

tests\desktop_ui\test_db_viewer_dialog.py:44:9: ANN201 Missing return type annotation for public function `mouseClick`
   |
42 |         return widget
43 |
44 |     def mouseClick(self, widget, button=Qt.LeftButton, pos=None):
   |         ^^^^^^^^^^ ANN201
45 |         """Simulate mouse click."""
46 |         if pos is None:
   |
   = help: Add return type annotation: `None`

tests\desktop_ui\test_db_viewer_dialog.py:44:26: ANN001 Missing type annotation for function argument `widget`
   |
42 |         return widget
43 |
44 |     def mouseClick(self, widget, button=Qt.LeftButton, pos=None):
   |                          ^^^^^^ ANN001
45 |         """Simulate mouse click."""
46 |         if pos is None:
   |

tests\desktop_ui\test_db_viewer_dialog.py:44:34: ANN001 Missing type annotation for function argument `button`
   |
42 |         return widget
43 |
44 |     def mouseClick(self, widget, button=Qt.LeftButton, pos=None):
   |                                  ^^^^^^ ANN001
45 |         """Simulate mouse click."""
46 |         if pos is None:
   |

tests\desktop_ui\test_db_viewer_dialog.py:44:56: ANN001 Missing type annotation for function argument `pos`
   |
42 |         return widget
43 |
44 |     def mouseClick(self, widget, button=Qt.LeftButton, pos=None):
   |                                                        ^^^ ANN001
45 |         """Simulate mouse click."""
46 |         if pos is None:
   |

tests\desktop_ui\test_db_viewer_dialog.py:57:5: ANN201 Missing return type annotation for public function `qtbot`
   |
56 | @pytest.fixture
57 | def qtbot(qtapp):
   |     ^^^^^ ANN201
58 |     """Create a QtBot instance for testing when pytest-qt's qtbot isn't available."""
59 |     return QtBot(qtapp)
   |
   = help: Add return type annotation

tests\desktop_ui\test_db_viewer_dialog.py:57:11: ANN001 Missing type annotation for function argument `qtapp`
   |
56 | @pytest.fixture
57 | def qtbot(qtapp):
   |           ^^^^^ ANN001
58 |     """Create a QtBot instance for testing when pytest-qt's qtbot isn't available."""
59 |     return QtBot(qtapp)
   |

tests\desktop_ui\test_db_viewer_dialog.py:63:5: ANN201 Missing return type annotation for public function `mock_db_viewer_service`
   |
62 | @pytest.fixture
63 | def mock_db_viewer_service():
   |     ^^^^^^^^^^^^^^^^^^^^^^ ANN201
64 |     """Create a mock DatabaseViewerService for testing."""
65 |     service = MagicMock(spec=DatabaseViewerService)
   |
   = help: Add return type annotation

tests\desktop_ui\test_db_viewer_dialog.py:85:5: ANN201 Missing return type annotation for public function `test_db_viewer_dialog_initialization`
   |
85 | def test_db_viewer_dialog_initialization(qtapp, mock_db_viewer_service, qtbot):
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
86 |     """Test that the DatabaseViewerDialog initializes correctly."""
87 |     # Setup mock for table data with more complete structure
   |
   = help: Add return type annotation: `None`

tests\desktop_ui\test_db_viewer_dialog.py:85:42: ANN001 Missing type annotation for function argument `qtapp`
   |
85 | def test_db_viewer_dialog_initialization(qtapp, mock_db_viewer_service, qtbot):
   |                                          ^^^^^ ANN001
86 |     """Test that the DatabaseViewerDialog initializes correctly."""
87 |     # Setup mock for table data with more complete structure
   |

tests\desktop_ui\test_db_viewer_dialog.py:85:49: ANN001 Missing type annotation for function argument `mock_db_viewer_service`
   |
85 | def test_db_viewer_dialog_initialization(qtapp, mock_db_viewer_service, qtbot):
   |                                                 ^^^^^^^^^^^^^^^^^^^^^^ ANN001
86 |     """Test that the DatabaseViewerDialog initializes correctly."""
87 |     # Setup mock for table data with more complete structure
   |

tests\desktop_ui\test_db_viewer_dialog.py:85:73: ANN001 Missing type annotation for function argument `qtbot`
   |
85 | def test_db_viewer_dialog_initialization(qtapp, mock_db_viewer_service, qtbot):
   |                                                                         ^^^^^ ANN001
86 |     """Test that the DatabaseViewerDialog initializes correctly."""
87 |     # Setup mock for table data with more complete structure
   |

tests\desktop_ui\test_db_viewer_dialog.py:137:5: ANN201 Missing return type annotation for public function `test_table_selection`
    |
137 | def test_table_selection(qtapp, mock_db_viewer_service, qtbot):
    |     ^^^^^^^^^^^^^^^^^^^^ ANN201
138 |     """Test that selecting a table loads its data."""
139 |     dialog = DatabaseViewerDialog(service=mock_db_viewer_service)
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_db_viewer_dialog.py:137:26: ANN001 Missing type annotation for function argument `qtapp`
    |
137 | def test_table_selection(qtapp, mock_db_viewer_service, qtbot):
    |                          ^^^^^ ANN001
138 |     """Test that selecting a table loads its data."""
139 |     dialog = DatabaseViewerDialog(service=mock_db_viewer_service)
    |

tests\desktop_ui\test_db_viewer_dialog.py:137:33: ANN001 Missing type annotation for function argument `mock_db_viewer_service`
    |
137 | def test_table_selection(qtapp, mock_db_viewer_service, qtbot):
    |                                 ^^^^^^^^^^^^^^^^^^^^^^ ANN001
138 |     """Test that selecting a table loads its data."""
139 |     dialog = DatabaseViewerDialog(service=mock_db_viewer_service)
    |

tests\desktop_ui\test_db_viewer_dialog.py:137:57: ANN001 Missing type annotation for function argument `qtbot`
    |
137 | def test_table_selection(qtapp, mock_db_viewer_service, qtbot):
    |                                                         ^^^^^ ANN001
138 |     """Test that selecting a table loads its data."""
139 |     dialog = DatabaseViewerDialog(service=mock_db_viewer_service)
    |

tests\desktop_ui\test_db_viewer_dialog.py:184:5: ANN201 Missing return type annotation for public function `test_pagination`
    |
184 | def test_pagination(qtapp, mock_db_viewer_service, qtbot):
    |     ^^^^^^^^^^^^^^^ ANN201
185 |     """Test pagination controls."""
186 |     # First prepare the mock to return pagination data
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_db_viewer_dialog.py:184:21: ANN001 Missing type annotation for function argument `qtapp`
    |
184 | def test_pagination(qtapp, mock_db_viewer_service, qtbot):
    |                     ^^^^^ ANN001
185 |     """Test pagination controls."""
186 |     # First prepare the mock to return pagination data
    |

tests\desktop_ui\test_db_viewer_dialog.py:184:28: ANN001 Missing type annotation for function argument `mock_db_viewer_service`
    |
184 | def test_pagination(qtapp, mock_db_viewer_service, qtbot):
    |                            ^^^^^^^^^^^^^^^^^^^^^^ ANN001
185 |     """Test pagination controls."""
186 |     # First prepare the mock to return pagination data
    |

tests\desktop_ui\test_db_viewer_dialog.py:184:52: ANN001 Missing type annotation for function argument `qtbot`
    |
184 | def test_pagination(qtapp, mock_db_viewer_service, qtbot):
    |                                                    ^^^^^ ANN001
185 |     """Test pagination controls."""
186 |     # First prepare the mock to return pagination data
    |

tests\desktop_ui\test_db_viewer_dialog.py:241:5: ANN201 Missing return type annotation for public function `test_sorting`
    |
241 | def test_sorting(qtapp, mock_db_viewer_service, qtbot):
    |     ^^^^^^^^^^^^ ANN201
242 |     """Test column sorting."""
243 |     dialog = DatabaseViewerDialog(service=mock_db_viewer_service)
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_db_viewer_dialog.py:241:18: ANN001 Missing type annotation for function argument `qtapp`
    |
241 | def test_sorting(qtapp, mock_db_viewer_service, qtbot):
    |                  ^^^^^ ANN001
242 |     """Test column sorting."""
243 |     dialog = DatabaseViewerDialog(service=mock_db_viewer_service)
    |

tests\desktop_ui\test_db_viewer_dialog.py:241:25: ANN001 Missing type annotation for function argument `mock_db_viewer_service`
    |
241 | def test_sorting(qtapp, mock_db_viewer_service, qtbot):
    |                         ^^^^^^^^^^^^^^^^^^^^^^ ANN001
242 |     """Test column sorting."""
243 |     dialog = DatabaseViewerDialog(service=mock_db_viewer_service)
    |

tests\desktop_ui\test_db_viewer_dialog.py:241:49: ANN001 Missing type annotation for function argument `qtbot`
    |
241 | def test_sorting(qtapp, mock_db_viewer_service, qtbot):
    |                                                 ^^^^^ ANN001
242 |     """Test column sorting."""
243 |     dialog = DatabaseViewerDialog(service=mock_db_viewer_service)
    |

tests\desktop_ui\test_db_viewer_dialog.py:310:5: ANN201 Missing return type annotation for public function `test_filtering`
    |
310 | def test_filtering(qtapp, mock_db_viewer_service, qtbot):
    |     ^^^^^^^^^^^^^^ ANN201
311 |     """Test table filtering."""
312 |     dialog = DatabaseViewerDialog(service=mock_db_viewer_service)
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_db_viewer_dialog.py:310:20: ANN001 Missing type annotation for function argument `qtapp`
    |
310 | def test_filtering(qtapp, mock_db_viewer_service, qtbot):
    |                    ^^^^^ ANN001
311 |     """Test table filtering."""
312 |     dialog = DatabaseViewerDialog(service=mock_db_viewer_service)
    |

tests\desktop_ui\test_db_viewer_dialog.py:310:27: ANN001 Missing type annotation for function argument `mock_db_viewer_service`
    |
310 | def test_filtering(qtapp, mock_db_viewer_service, qtbot):
    |                           ^^^^^^^^^^^^^^^^^^^^^^ ANN001
311 |     """Test table filtering."""
312 |     dialog = DatabaseViewerDialog(service=mock_db_viewer_service)
    |

tests\desktop_ui\test_db_viewer_dialog.py:310:51: ANN001 Missing type annotation for function argument `qtbot`
    |
310 | def test_filtering(qtapp, mock_db_viewer_service, qtbot):
    |                                                   ^^^^^ ANN001
311 |     """Test table filtering."""
312 |     dialog = DatabaseViewerDialog(service=mock_db_viewer_service)
    |

tests\desktop_ui\test_db_viewer_dialog.py:352:5: ANN201 Missing return type annotation for public function `test_export_to_csv`
    |
350 | @patch("PySide6.QtWidgets.QFileDialog.getSaveFileName")
351 | @patch("PySide6.QtWidgets.QMessageBox.information")
352 | def test_export_to_csv(mock_info_box, mock_get_save_filename, qtapp, mock_db_viewer_service, qtbot):
    |     ^^^^^^^^^^^^^^^^^^ ANN201
353 |     """Test exporting to CSV."""
354 |     # Setup mock to return a file path
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_db_viewer_dialog.py:352:24: ANN001 Missing type annotation for function argument `mock_info_box`
    |
350 | @patch("PySide6.QtWidgets.QFileDialog.getSaveFileName")
351 | @patch("PySide6.QtWidgets.QMessageBox.information")
352 | def test_export_to_csv(mock_info_box, mock_get_save_filename, qtapp, mock_db_viewer_service, qtbot):
    |                        ^^^^^^^^^^^^^ ANN001
353 |     """Test exporting to CSV."""
354 |     # Setup mock to return a file path
    |

tests\desktop_ui\test_db_viewer_dialog.py:352:39: ANN001 Missing type annotation for function argument `mock_get_save_filename`
    |
350 | @patch("PySide6.QtWidgets.QFileDialog.getSaveFileName")
351 | @patch("PySide6.QtWidgets.QMessageBox.information")
352 | def test_export_to_csv(mock_info_box, mock_get_save_filename, qtapp, mock_db_viewer_service, qtbot):
    |                                       ^^^^^^^^^^^^^^^^^^^^^^ ANN001
353 |     """Test exporting to CSV."""
354 |     # Setup mock to return a file path
    |

tests\desktop_ui\test_db_viewer_dialog.py:352:63: ANN001 Missing type annotation for function argument `qtapp`
    |
350 | @patch("PySide6.QtWidgets.QFileDialog.getSaveFileName")
351 | @patch("PySide6.QtWidgets.QMessageBox.information")
352 | def test_export_to_csv(mock_info_box, mock_get_save_filename, qtapp, mock_db_viewer_service, qtbot):
    |                                                               ^^^^^ ANN001
353 |     """Test exporting to CSV."""
354 |     # Setup mock to return a file path
    |

tests\desktop_ui\test_db_viewer_dialog.py:352:70: ANN001 Missing type annotation for function argument `mock_db_viewer_service`
    |
350 | @patch("PySide6.QtWidgets.QFileDialog.getSaveFileName")
351 | @patch("PySide6.QtWidgets.QMessageBox.information")
352 | def test_export_to_csv(mock_info_box, mock_get_save_filename, qtapp, mock_db_viewer_service, qtbot):
    |                                                                      ^^^^^^^^^^^^^^^^^^^^^^ ANN001
353 |     """Test exporting to CSV."""
354 |     # Setup mock to return a file path
    |

tests\desktop_ui\test_db_viewer_dialog.py:352:94: ANN001 Missing type annotation for function argument `qtbot`
    |
350 | @patch("PySide6.QtWidgets.QFileDialog.getSaveFileName")
351 | @patch("PySide6.QtWidgets.QMessageBox.information")
352 | def test_export_to_csv(mock_info_box, mock_get_save_filename, qtapp, mock_db_viewer_service, qtbot):
    |                                                                                              ^^^^^ ANN001
353 |     """Test exporting to CSV."""
354 |     # Setup mock to return a file path
    |

tests\desktop_ui\test_db_viewer_dialog.py:371:9: ANN202 Missing return type annotation for private function `custom_export`
    |
370 |     # Create a custom implementation of export_to_csv to bypass QFileDialog issue
371 |     def custom_export():
    |         ^^^^^^^^^^^^^ ANN202
372 |         # This simulates user selecting a file name from QFileDialog
373 |         # and the method proceeding with that file name
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_db_viewer_dialog.py:405:5: ANN201 Missing return type annotation for public function `test_error_handling`
    |
405 | def test_error_handling(qtapp, mock_db_viewer_service, qtbot):
    |     ^^^^^^^^^^^^^^^^^^^ ANN201
406 |     """Test error handling for service exceptions."""
407 |     dialog = DatabaseViewerDialog(service=mock_db_viewer_service)
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_db_viewer_dialog.py:405:25: ANN001 Missing type annotation for function argument `qtapp`
    |
405 | def test_error_handling(qtapp, mock_db_viewer_service, qtbot):
    |                         ^^^^^ ANN001
406 |     """Test error handling for service exceptions."""
407 |     dialog = DatabaseViewerDialog(service=mock_db_viewer_service)
    |

tests\desktop_ui\test_db_viewer_dialog.py:405:32: ANN001 Missing type annotation for function argument `mock_db_viewer_service`
    |
405 | def test_error_handling(qtapp, mock_db_viewer_service, qtbot):
    |                                ^^^^^^^^^^^^^^^^^^^^^^ ANN001
406 |     """Test error handling for service exceptions."""
407 |     dialog = DatabaseViewerDialog(service=mock_db_viewer_service)
    |

tests\desktop_ui\test_db_viewer_dialog.py:405:56: ANN001 Missing type annotation for function argument `qtbot`
    |
405 | def test_error_handling(qtapp, mock_db_viewer_service, qtbot):
    |                                                        ^^^^^ ANN001
406 |     """Test error handling for service exceptions."""
407 |     dialog = DatabaseViewerDialog(service=mock_db_viewer_service)
    |

tests\desktop_ui\test_db_viewer_dialog.py:429:5: ANN201 Missing return type annotation for public function `test_empty_table_handling`
    |
429 | def test_empty_table_handling(qtapp, mock_db_viewer_service, qtbot):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
430 |     """Test handling of empty tables."""
431 |     # Configure service to return empty table data
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_db_viewer_dialog.py:429:31: ANN001 Missing type annotation for function argument `qtapp`
    |
429 | def test_empty_table_handling(qtapp, mock_db_viewer_service, qtbot):
    |                               ^^^^^ ANN001
430 |     """Test handling of empty tables."""
431 |     # Configure service to return empty table data
    |

tests\desktop_ui\test_db_viewer_dialog.py:429:38: ANN001 Missing type annotation for function argument `mock_db_viewer_service`
    |
429 | def test_empty_table_handling(qtapp, mock_db_viewer_service, qtbot):
    |                                      ^^^^^^^^^^^^^^^^^^^^^^ ANN001
430 |     """Test handling of empty tables."""
431 |     # Configure service to return empty table data
    |

tests\desktop_ui\test_db_viewer_dialog.py:429:62: ANN001 Missing type annotation for function argument `qtbot`
    |
429 | def test_empty_table_handling(qtapp, mock_db_viewer_service, qtbot):
    |                                                              ^^^^^ ANN001
430 |     """Test handling of empty tables."""
431 |     # Configure service to return empty table data
    |

tests\desktop_ui\test_db_viewer_dialog.py:460:5: ANN201 Missing return type annotation for public function `test_count_result_edge_cases`
    |
460 | def test_count_result_edge_cases(qtapp, qtbot):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
461 |     """Test edge cases in count result handling that could cause tuple index out of range."""
462 |     from services.database_viewer_service import DatabaseViewerService
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_db_viewer_dialog.py:460:34: ANN001 Missing type annotation for function argument `qtapp`
    |
460 | def test_count_result_edge_cases(qtapp, qtbot):
    |                                  ^^^^^ ANN001
461 |     """Test edge cases in count result handling that could cause tuple index out of range."""
462 |     from services.database_viewer_service import DatabaseViewerService
    |

tests\desktop_ui\test_db_viewer_dialog.py:460:41: ANN001 Missing type annotation for function argument `qtbot`
    |
460 | def test_count_result_edge_cases(qtapp, qtbot):
    |                                         ^^^^^ ANN001
461 |     """Test edge cases in count result handling that could cause tuple index out of range."""
462 |     from services.database_viewer_service import DatabaseViewerService
    |

tests\desktop_ui\test_db_viewer_dialog.py:462:5: I001 [*] Import block is un-sorted or un-formatted
    |
460 |   def test_count_result_edge_cases(qtapp, qtbot):
461 |       """Test edge cases in count result handling that could cause tuple index out of range."""
462 | /     from services.database_viewer_service import DatabaseViewerService
463 | |     from unittest.mock import MagicMock
    | |_______________________________________^ I001
464 |
465 |       # Create a real service instance with mocked db_manager
    |
    = help: Organize imports

tests\desktop_ui\test_db_viewer_dialog.py:503:5: ANN201 Missing return type annotation for public function `test_pagination_with_zero_total_pages`
    |
503 | def test_pagination_with_zero_total_pages(qtapp, mock_db_viewer_service, qtbot):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
504 |     """Test pagination controls when total_pages is 0."""
505 |     # Configure service to return data with 0 total pages
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_db_viewer_dialog.py:503:43: ANN001 Missing type annotation for function argument `qtapp`
    |
503 | def test_pagination_with_zero_total_pages(qtapp, mock_db_viewer_service, qtbot):
    |                                           ^^^^^ ANN001
504 |     """Test pagination controls when total_pages is 0."""
505 |     # Configure service to return data with 0 total pages
    |

tests\desktop_ui\test_db_viewer_dialog.py:503:50: ANN001 Missing type annotation for function argument `mock_db_viewer_service`
    |
503 | def test_pagination_with_zero_total_pages(qtapp, mock_db_viewer_service, qtbot):
    |                                                  ^^^^^^^^^^^^^^^^^^^^^^ ANN001
504 |     """Test pagination controls when total_pages is 0."""
505 |     # Configure service to return data with 0 total pages
    |

tests\desktop_ui\test_db_viewer_dialog.py:503:74: ANN001 Missing type annotation for function argument `qtbot`
    |
503 | def test_pagination_with_zero_total_pages(qtapp, mock_db_viewer_service, qtbot):
    |                                                                          ^^^^^ ANN001
504 |     """Test pagination controls when total_pages is 0."""
505 |     # Configure service to return data with 0 total pages
    |

tests\desktop_ui\test_db_viewer_dialog.py:531:5: ANN201 Missing return type annotation for public function `test_service_integration_with_real_count_scenarios`
    |
531 | def test_service_integration_with_real_count_scenarios(qtapp, qtbot):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
532 |     """Test service integration with various count result scenarios."""
533 |     from services.database_viewer_service import DatabaseViewerService
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_db_viewer_dialog.py:531:56: ANN001 Missing type annotation for function argument `qtapp`
    |
531 | def test_service_integration_with_real_count_scenarios(qtapp, qtbot):
    |                                                        ^^^^^ ANN001
532 |     """Test service integration with various count result scenarios."""
533 |     from services.database_viewer_service import DatabaseViewerService
    |

tests\desktop_ui\test_db_viewer_dialog.py:531:63: ANN001 Missing type annotation for function argument `qtbot`
    |
531 | def test_service_integration_with_real_count_scenarios(qtapp, qtbot):
    |                                                               ^^^^^ ANN001
532 |     """Test service integration with various count result scenarios."""
533 |     from services.database_viewer_service import DatabaseViewerService
    |

tests\desktop_ui\test_db_viewer_dialog.py:533:5: I001 [*] Import block is un-sorted or un-formatted
    |
531 |   def test_service_integration_with_real_count_scenarios(qtapp, qtbot):
532 |       """Test service integration with various count result scenarios."""
533 | /     from services.database_viewer_service import DatabaseViewerService
534 | |     from unittest.mock import MagicMock
    | |_______________________________________^ I001
535 |
536 |       # Create service with mocked database manager
    |
    = help: Organize imports

tests\desktop_ui\test_db_viewer_dialog_fixed.py:41:33: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `widget`
   |
39 |         self.widgets: List[Any] = []
40 |
41 |     def addWidget(self, widget: Any) -> Any:
   |                                 ^^^ ANN401
42 |         """Keep track of widgets to ensure they don't get garbage collected."""
43 |         self.widgets.append(widget)
   |

tests\desktop_ui\test_db_viewer_dialog_fixed.py:41:41: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `addWidget`
   |
39 |         self.widgets: List[Any] = []
40 |
41 |     def addWidget(self, widget: Any) -> Any:
   |                                         ^^^ ANN401
42 |         """Keep track of widgets to ensure they don't get garbage collected."""
43 |         self.widgets.append(widget)
   |

tests\desktop_ui\test_db_viewer_dialog_fixed.py:46:34: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `widget`
   |
44 |         return widget
45 |
46 |     def mouseClick(self, widget: Any, button: Any = Qt.LeftButton, pos: Any = None) -> None:
   |                                  ^^^ ANN401
47 |         """Simulate mouse click."""
48 |         if pos is None:
   |

tests\desktop_ui\test_db_viewer_dialog_fixed.py:46:47: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `button`
   |
44 |         return widget
45 |
46 |     def mouseClick(self, widget: Any, button: Any = Qt.LeftButton, pos: Any = None) -> None:
   |                                               ^^^ ANN401
47 |         """Simulate mouse click."""
48 |         if pos is None:
   |

tests\desktop_ui\test_db_viewer_dialog_fixed.py:46:73: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `pos`
   |
44 |         return widget
45 |
46 |     def mouseClick(self, widget: Any, button: Any = Qt.LeftButton, pos: Any = None) -> None:
   |                                                                         ^^^ ANN401
47 |         """Simulate mouse click."""
48 |         if pos is None:
   |

tests\desktop_ui\test_library_main_ui_new.py:76:5: ANN201 Missing return type annotation for public function `qt_app`
   |
75 | @pytest.fixture(scope="module")
76 | def qt_app():
   |     ^^^^^^ ANN201
77 |     """Provide a QApplication instance for UI tests."""
78 |     app = QApplication.instance()
   |
   = help: Add return type annotation

tests\desktop_ui\test_library_main_ui_new.py:85:5: ANN201 Missing return type annotation for public function `mock_db_manager`
   |
84 | @pytest.fixture
85 | def mock_db_manager(db_manager):
   |     ^^^^^^^^^^^^^^^ ANN201
86 |     # Patch CategoryManager and SnippetManager to use the test db
87 |     return db_manager
   |
   = help: Add return type annotation

tests\desktop_ui\test_library_main_ui_new.py:85:21: ANN001 Missing type annotation for function argument `db_manager`
   |
84 | @pytest.fixture
85 | def mock_db_manager(db_manager):
   |                     ^^^^^^^^^^ ANN001
86 |     # Patch CategoryManager and SnippetManager to use the test db
87 |     return db_manager
   |

tests\desktop_ui\test_library_main_ui_new.py:91:5: ANN201 Missing return type annotation for public function `main_window`
   |
90 | @pytest.fixture
91 | def main_window(qt_app, mock_db_manager):
   |     ^^^^^^^^^^^ ANN201
92 |     win = library_main.LibraryMainWindow(db_manager=mock_db_manager, testing_mode=True)
93 |     yield win
   |
   = help: Add return type annotation

tests\desktop_ui\test_library_main_ui_new.py:91:17: ANN001 Missing type annotation for function argument `qt_app`
   |
90 | @pytest.fixture
91 | def main_window(qt_app, mock_db_manager):
   |                 ^^^^^^ ANN001
92 |     win = library_main.LibraryMainWindow(db_manager=mock_db_manager, testing_mode=True)
93 |     yield win
   |

tests\desktop_ui\test_library_main_ui_new.py:91:25: ANN001 Missing type annotation for function argument `mock_db_manager`
   |
90 | @pytest.fixture
91 | def main_window(qt_app, mock_db_manager):
   |                         ^^^^^^^^^^^^^^^ ANN001
92 |     win = library_main.LibraryMainWindow(db_manager=mock_db_manager, testing_mode=True)
93 |     yield win
   |

tests\desktop_ui\test_library_main_ui_new.py:153:10: B017 Do not assert blind exception: `Exception`
    |
151 | def test_create_snippet_invalid_category(library_manager: LibraryManager) -> None:
152 |     """Test creating a snippet with an invalid category."""
153 |     with pytest.raises(Exception):
    |          ^^^^^^^^^^^^^^^^^^^^^^^^ B017
154 |         library_manager.create_snippet("nonexistent", "Name", "Content")
    |

tests\desktop_ui\test_library_main_ui_new.py:159:10: B017 Do not assert blind exception: `Exception`
    |
157 | def test_edit_snippet_invalid_id(library_manager: LibraryManager) -> None:
158 |     """Test editing a snippet with an invalid ID."""
159 |     with pytest.raises(Exception):
    |          ^^^^^^^^^^^^^^^^^^^^^^^^ B017
160 |         library_manager.edit_snippet("badid", "Name", "Content")
    |

tests\desktop_ui\test_library_main_ui_new.py:183:9: ANN201 Missing return type annotation for public function `test_load_data_and_initial_state`
    |
182 | class TestLibraryMainWindowUI:
183 |     def test_load_data_and_initial_state(self, main_window):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
184 |         win = main_window
185 |         # Should load with no categories/snippets
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:183:48: ANN001 Missing type annotation for function argument `main_window`
    |
182 | class TestLibraryMainWindowUI:
183 |     def test_load_data_and_initial_state(self, main_window):
    |                                                ^^^^^^^^^^^ ANN001
184 |         win = main_window
185 |         # Should load with no categories/snippets
    |

tests\desktop_ui\test_library_main_ui_new.py:190:9: ANN201 Missing return type annotation for public function `test_add_category`
    |
188 |         assert win.status.text() == ""
189 |
190 |     def test_add_category(self, main_window, monkeypatch):
    |         ^^^^^^^^^^^^^^^^^ ANN201
191 |         win = main_window
192 |         # Simulate dialog returning Accepted and a name
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:190:33: ANN001 Missing type annotation for function argument `main_window`
    |
188 |         assert win.status.text() == ""
189 |
190 |     def test_add_category(self, main_window, monkeypatch):
    |                                 ^^^^^^^^^^^ ANN001
191 |         win = main_window
192 |         # Simulate dialog returning Accepted and a name
    |

tests\desktop_ui\test_library_main_ui_new.py:190:46: ANN001 Missing type annotation for function argument `monkeypatch`
    |
188 |         assert win.status.text() == ""
189 |
190 |     def test_add_category(self, main_window, monkeypatch):
    |                                              ^^^^^^^^^^^ ANN001
191 |         win = main_window
192 |         # Simulate dialog returning Accepted and a name
    |

tests\desktop_ui\test_library_main_ui_new.py:202:9: ANN201 Missing return type annotation for public function `test_edit_category`
    |
200 |         assert win.categoryList.count() > 0
201 |
202 |     def test_edit_category(self, main_window, monkeypatch):
    |         ^^^^^^^^^^^^^^^^^^ ANN201
203 |         win = main_window
204 |         # Ensure there is at least one category to edit
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:202:34: ANN001 Missing type annotation for function argument `main_window`
    |
200 |         assert win.categoryList.count() > 0
201 |
202 |     def test_edit_category(self, main_window, monkeypatch):
    |                                  ^^^^^^^^^^^ ANN001
203 |         win = main_window
204 |         # Ensure there is at least one category to edit
    |

tests\desktop_ui\test_library_main_ui_new.py:202:47: ANN001 Missing type annotation for function argument `monkeypatch`
    |
200 |         assert win.categoryList.count() > 0
201 |
202 |     def test_edit_category(self, main_window, monkeypatch):
    |                                               ^^^^^^^^^^^ ANN001
203 |         win = main_window
204 |         # Ensure there is at least one category to edit
    |

tests\desktop_ui\test_library_main_ui_new.py:208:21: ANN202 Missing return type annotation for private function `exec_`
    |
207 |             class FakeAddDialog:
208 |                 def exec_(self):
    |                     ^^^^^ ANN202
209 |                     return 1
    |
    = help: Add return type annotation: `int`

tests\desktop_ui\test_library_main_ui_new.py:211:21: ANN202 Missing return type annotation for private function `get_value`
    |
209 |                     return 1
210 |
211 |                 def get_value(self):
    |                     ^^^^^^^^^ ANN202
212 |                     return "Initial Cat"
    |
    = help: Add return type annotation: `str`

tests\desktop_ui\test_library_main_ui_new.py:220:17: ANN202 Missing return type annotation for private function `exec_`
    |
219 |         class FakeEditDialog:
220 |             def exec_(self):
    |                 ^^^^^ ANN202
221 |                 return 1
    |
    = help: Add return type annotation: `int`

tests\desktop_ui\test_library_main_ui_new.py:223:17: ANN202 Missing return type annotation for private function `get_value`
    |
221 |                 return 1
222 |
223 |             def get_value(self):
    |                 ^^^^^^^^^ ANN202
224 |                 return "Renamed Cat"
    |
    = help: Add return type annotation: `str`

tests\desktop_ui\test_library_main_ui_new.py:231:9: ANN201 Missing return type annotation for public function `test_delete_category`
    |
229 |         assert win.status.text() == "Category updated."
230 |
231 |     def test_delete_category(self, main_window, monkeypatch):
    |         ^^^^^^^^^^^^^^^^^^^^ ANN201
232 |         win = main_window
233 |         win.categoryList.setCurrentRow(0)
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:231:36: ANN001 Missing type annotation for function argument `main_window`
    |
229 |         assert win.status.text() == "Category updated."
230 |
231 |     def test_delete_category(self, main_window, monkeypatch):
    |                                    ^^^^^^^^^^^ ANN001
232 |         win = main_window
233 |         win.categoryList.setCurrentRow(0)
    |

tests\desktop_ui\test_library_main_ui_new.py:231:49: ANN001 Missing type annotation for function argument `monkeypatch`
    |
229 |         assert win.status.text() == "Category updated."
230 |
231 |     def test_delete_category(self, main_window, monkeypatch):
    |                                                 ^^^^^^^^^^^ ANN001
232 |         win = main_window
233 |         win.categoryList.setCurrentRow(0)
    |

tests\desktop_ui\test_library_main_ui_new.py:241:9: ANN201 Missing return type annotation for public function `test_add_snippet`
    |
239 |         assert win.status.text() == "Category deleted."
240 |
241 |     def test_add_snippet(self, main_window, monkeypatch):
    |         ^^^^^^^^^^^^^^^^ ANN201
242 |         win = main_window
243 |         # Add a category first
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:241:32: ANN001 Missing type annotation for function argument `main_window`
    |
239 |         assert win.status.text() == "Category deleted."
240 |
241 |     def test_add_snippet(self, main_window, monkeypatch):
    |                                ^^^^^^^^^^^ ANN001
242 |         win = main_window
243 |         # Add a category first
    |

tests\desktop_ui\test_library_main_ui_new.py:241:45: ANN001 Missing type annotation for function argument `monkeypatch`
    |
239 |         assert win.status.text() == "Category deleted."
240 |
241 |     def test_add_snippet(self, main_window, monkeypatch):
    |                                             ^^^^^^^^^^^ ANN001
242 |         win = main_window
243 |         # Add a category first
    |

tests\desktop_ui\test_library_main_ui_new.py:259:9: ANN201 Missing return type annotation for public function `test_edit_snippet`
    |
257 |         assert win.status.text() == "Snippet added."
258 |
259 |     def test_edit_snippet(self, main_window, monkeypatch):
    |         ^^^^^^^^^^^^^^^^^ ANN201
260 |         win = main_window
261 |         win.snippetList.setCurrentRow(0)
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:259:33: ANN001 Missing type annotation for function argument `main_window`
    |
257 |         assert win.status.text() == "Snippet added."
258 |
259 |     def test_edit_snippet(self, main_window, monkeypatch):
    |                                 ^^^^^^^^^^^ ANN001
260 |         win = main_window
261 |         win.snippetList.setCurrentRow(0)
    |

tests\desktop_ui\test_library_main_ui_new.py:259:46: ANN001 Missing type annotation for function argument `monkeypatch`
    |
257 |         assert win.status.text() == "Snippet added."
258 |
259 |     def test_edit_snippet(self, main_window, monkeypatch):
    |                                              ^^^^^^^^^^^ ANN001
260 |         win = main_window
261 |         win.snippetList.setCurrentRow(0)
    |

tests\desktop_ui\test_library_main_ui_new.py:271:9: ANN201 Missing return type annotation for public function `test_delete_snippet`
    |
269 |         assert win.status.text() == "Snippet updated."
270 |
271 |     def test_delete_snippet(self, main_window, monkeypatch):
    |         ^^^^^^^^^^^^^^^^^^^ ANN201
272 |         win = main_window
273 |         win.snippetList.setCurrentRow(0)
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:271:35: ANN001 Missing type annotation for function argument `main_window`
    |
269 |         assert win.status.text() == "Snippet updated."
270 |
271 |     def test_delete_snippet(self, main_window, monkeypatch):
    |                                   ^^^^^^^^^^^ ANN001
272 |         win = main_window
273 |         win.snippetList.setCurrentRow(0)
    |

tests\desktop_ui\test_library_main_ui_new.py:271:48: ANN001 Missing type annotation for function argument `monkeypatch`
    |
269 |         assert win.status.text() == "Snippet updated."
270 |
271 |     def test_delete_snippet(self, main_window, monkeypatch):
    |                                                ^^^^^^^^^^^ ANN001
272 |         win = main_window
273 |         win.snippetList.setCurrentRow(0)
    |

tests\desktop_ui\test_library_main_ui_new.py:279:9: ANN201 Missing return type annotation for public function `test_filter_snippets`
    |
277 |         assert win.status.text() == "Snippet deleted."
278 |
279 |     def test_filter_snippets(self, main_window, monkeypatch):
    |         ^^^^^^^^^^^^^^^^^^^^ ANN201
280 |         win = main_window
281 |         # Add a snippet again
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:279:36: ANN001 Missing type annotation for function argument `main_window`
    |
277 |         assert win.status.text() == "Snippet deleted."
278 |
279 |     def test_filter_snippets(self, main_window, monkeypatch):
    |                                    ^^^^^^^^^^^ ANN001
280 |         win = main_window
281 |         # Add a snippet again
    |

tests\desktop_ui\test_library_main_ui_new.py:279:49: ANN001 Missing type annotation for function argument `monkeypatch`
    |
277 |         assert win.status.text() == "Snippet deleted."
278 |
279 |     def test_filter_snippets(self, main_window, monkeypatch):
    |                                                 ^^^^^^^^^^^ ANN001
280 |         win = main_window
281 |         # Add a snippet again
    |

tests\desktop_ui\test_library_main_ui_new.py:297:9: ANN201 Missing return type annotation for public function `test_show_error_and_info`
    |
295 |         assert win.snippetList.count() == 2
296 |
297 |     def test_show_error_and_info(self, main_window):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
298 |         win = main_window
299 |         win.show_error("ErrMsg")
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:297:40: ANN001 Missing type annotation for function argument `main_window`
    |
295 |         assert win.snippetList.count() == 2
296 |
297 |     def test_show_error_and_info(self, main_window):
    |                                        ^^^^^^^^^^^ ANN001
298 |         win = main_window
299 |         win.show_error("ErrMsg")
    |

tests\desktop_ui\test_library_main_ui_new.py:304:9: ANN201 Missing return type annotation for public function `test_update_snippet_buttons_state`
    |
302 |         assert win.status.text() == "InfoMsg"
303 |
304 |     def test_update_snippet_buttons_state(self, main_window):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
305 |         win = main_window
306 |         win.update_snippet_buttons_state(True)
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:304:49: ANN001 Missing type annotation for function argument `main_window`
    |
302 |         assert win.status.text() == "InfoMsg"
303 |
304 |     def test_update_snippet_buttons_state(self, main_window):
    |                                                 ^^^^^^^^^^^ ANN001
305 |         win = main_window
306 |         win.update_snippet_buttons_state(True)
    |

tests\desktop_ui\test_library_main_ui_new.py:315:9: ANN201 Missing return type annotation for public function `test_on_category_selection_changed_and_load_snippets`
    |
313 |         assert not win.delSnipBtn.isEnabled()
314 |
315 |     def test_on_category_selection_changed_and_load_snippets(self, main_window):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
316 |         win = main_window
317 |         win.categoryList.setCurrentRow(0)
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:315:68: ANN001 Missing type annotation for function argument `main_window`
    |
313 |         assert not win.delSnipBtn.isEnabled()
314 |
315 |     def test_on_category_selection_changed_and_load_snippets(self, main_window):
    |                                                                    ^^^^^^^^^^^ ANN001
316 |         win = main_window
317 |         win.categoryList.setCurrentRow(0)
    |

tests\desktop_ui\test_library_main_ui_new.py:322:9: ANN201 Missing return type annotation for public function `test_on_snippet_selection_changed`
    |
320 |         assert win.snippetList.count() >= 0
321 |
322 |     def test_on_snippet_selection_changed(self, main_window):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
323 |         win = main_window
324 |         if win.snippetList.count() > 0:
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:322:49: ANN001 Missing type annotation for function argument `main_window`
    |
320 |         assert win.snippetList.count() >= 0
321 |
322 |     def test_on_snippet_selection_changed(self, main_window):
    |                                                 ^^^^^^^^^^^ ANN001
323 |         win = main_window
324 |         if win.snippetList.count() > 0:
    |

tests\desktop_ui\test_library_main_ui_new.py:329:9: ANN201 Missing return type annotation for public function `test_view_snippet`
    |
327 |             assert win.selected_snippet is not None
328 |
329 |     def test_view_snippet(self, main_window, monkeypatch):
    |         ^^^^^^^^^^^^^^^^^ ANN201
330 |         win = main_window
331 |         if win.snippetList.count() > 0:
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:329:33: ANN001 Missing type annotation for function argument `main_window`
    |
327 |             assert win.selected_snippet is not None
328 |
329 |     def test_view_snippet(self, main_window, monkeypatch):
    |                                 ^^^^^^^^^^^ ANN001
330 |         win = main_window
331 |         if win.snippetList.count() > 0:
    |

tests\desktop_ui\test_library_main_ui_new.py:329:46: ANN001 Missing type annotation for function argument `monkeypatch`
    |
327 |             assert win.selected_snippet is not None
328 |
329 |     def test_view_snippet(self, main_window, monkeypatch):
    |                                              ^^^^^^^^^^^ ANN001
330 |         win = main_window
331 |         if win.snippetList.count() > 0:
    |

tests\desktop_ui\test_library_main_ui_new.py:339:9: ANN201 Missing return type annotation for public function `test_add_category_error`
    |
337 |             win.view_snippet(item)
338 |
339 |     def test_add_category_error(self, main_window, monkeypatch):
    |         ^^^^^^^^^^^^^^^^^^^^^^^ ANN201
340 |         win = main_window
341 |         # Simulate dialog accepted but error in save_category
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:339:39: ANN001 Missing type annotation for function argument `main_window`
    |
337 |             win.view_snippet(item)
338 |
339 |     def test_add_category_error(self, main_window, monkeypatch):
    |                                       ^^^^^^^^^^^ ANN001
340 |         win = main_window
341 |         # Simulate dialog accepted but error in save_category
    |

tests\desktop_ui\test_library_main_ui_new.py:339:52: ANN001 Missing type annotation for function argument `monkeypatch`
    |
337 |             win.view_snippet(item)
338 |
339 |     def test_add_category_error(self, main_window, monkeypatch):
    |                                                    ^^^^^^^^^^^ ANN001
340 |         win = main_window
341 |         # Simulate dialog accepted but error in save_category
    |

tests\desktop_ui\test_library_main_ui_new.py:354:9: ANN201 Missing return type annotation for public function `test_add_snippet_error`
    |
352 |         assert "Failed to add category" in win.status.text()
353 |
354 |     def test_add_snippet_error(self, main_window, monkeypatch):
    |         ^^^^^^^^^^^^^^^^^^^^^^ ANN201
355 |         # Ensure a category exists and is selected
356 |         if not main_window.categories:
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:354:38: ANN001 Missing type annotation for function argument `main_window`
    |
352 |         assert "Failed to add category" in win.status.text()
353 |
354 |     def test_add_snippet_error(self, main_window, monkeypatch):
    |                                      ^^^^^^^^^^^ ANN001
355 |         # Ensure a category exists and is selected
356 |         if not main_window.categories:
    |

tests\desktop_ui\test_library_main_ui_new.py:354:51: ANN001 Missing type annotation for function argument `monkeypatch`
    |
352 |         assert "Failed to add category" in win.status.text()
353 |
354 |     def test_add_snippet_error(self, main_window, monkeypatch):
    |                                                   ^^^^^^^^^^^ ANN001
355 |         # Ensure a category exists and is selected
356 |         if not main_window.categories:
    |

tests\desktop_ui\test_library_main_ui_new.py:359:21: ANN202 Missing return type annotation for private function `exec_`
    |
358 |             class FakeCatDialog:
359 |                 def exec_(self):
    |                     ^^^^^ ANN202
360 |                     return 1
    |
    = help: Add return type annotation: `int`

tests\desktop_ui\test_library_main_ui_new.py:362:21: ANN202 Missing return type annotation for private function `get_value`
    |
360 |                     return 1
361 |
362 |                 def get_value(self):
    |                     ^^^^^^^^^ ANN202
363 |                     return "CatForError"
    |
    = help: Add return type annotation: `str`

tests\desktop_ui\test_library_main_ui_new.py:370:17: ANN202 Missing return type annotation for private function `exec_`
    |
369 |         class FakeDialog:
370 |             def exec_(self):
    |                 ^^^^^ ANN202
371 |                 return 1
    |
    = help: Add return type annotation: `int`

tests\desktop_ui\test_library_main_ui_new.py:373:17: ANN202 Missing return type annotation for private function `get_values`
    |
371 |                 return 1
372 |
373 |             def get_values(self):
    |                 ^^^^^^^^^^ ANN202
374 |                 return ("ErrSnip", "X")
    |
    = help: Add return type annotation

tests\desktop_ui\test_library_main_ui_new.py:378:13: ANN202 Missing return type annotation for private function `fail_save_snippet`
    |
376 |         monkeypatch.setattr(library_main, "SnippetDialog", lambda *a, **k: FakeDialog())
377 |
378 |         def fail_save_snippet(snip):
    |             ^^^^^^^^^^^^^^^^^ ANN202
379 |             raise Exception("failsnip")
    |
    = help: Add return type annotation: `Never`

tests\desktop_ui\test_library_main_ui_new.py:378:31: ANN001 Missing type annotation for function argument `snip`
    |
376 |         monkeypatch.setattr(library_main, "SnippetDialog", lambda *a, **k: FakeDialog())
377 |
378 |         def fail_save_snippet(snip):
    |                               ^^^^ ANN001
379 |             raise Exception("failsnip")
    |

tests\desktop_ui\test_library_main_ui_new.py:385:9: ANN201 Missing return type annotation for public function `test_edit_category_error`
    |
383 |         assert "failsnip" in main_window.status.text()
384 |
385 |     def test_edit_category_error(self, main_window, monkeypatch):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
386 |         win = main_window
387 |         # Ensure a category exists and is selected
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:385:40: ANN001 Missing type annotation for function argument `main_window`
    |
383 |         assert "failsnip" in main_window.status.text()
384 |
385 |     def test_edit_category_error(self, main_window, monkeypatch):
    |                                        ^^^^^^^^^^^ ANN001
386 |         win = main_window
387 |         # Ensure a category exists and is selected
    |

tests\desktop_ui\test_library_main_ui_new.py:385:53: ANN001 Missing type annotation for function argument `monkeypatch`
    |
383 |         assert "failsnip" in main_window.status.text()
384 |
385 |     def test_edit_category_error(self, main_window, monkeypatch):
    |                                                     ^^^^^^^^^^^ ANN001
386 |         win = main_window
387 |         # Ensure a category exists and is selected
    |

tests\desktop_ui\test_library_main_ui_new.py:391:21: ANN202 Missing return type annotation for private function `exec_`
    |
390 |             class FakeAddDialog:
391 |                 def exec_(self):
    |                     ^^^^^ ANN202
392 |                     return 1
    |
    = help: Add return type annotation: `int`

tests\desktop_ui\test_library_main_ui_new.py:394:21: ANN202 Missing return type annotation for private function `get_value`
    |
392 |                     return 1
393 |
394 |                 def get_value(self):
    |                     ^^^^^^^^^ ANN202
395 |                     return "ErrEditCat"
    |
    = help: Add return type annotation: `str`

tests\desktop_ui\test_library_main_ui_new.py:412:9: ANN201 Missing return type annotation for public function `test_edit_snippet_error`
    |
410 |         assert "Failed to update category" in win.status.text() or "failcat2" in win.status.text()
411 |
412 |     def test_edit_snippet_error(self, main_window, monkeypatch):
    |         ^^^^^^^^^^^^^^^^^^^^^^^ ANN201
413 |         win = main_window
414 |         # Ensure a snippet exists and is selected
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:412:39: ANN001 Missing type annotation for function argument `main_window`
    |
410 |         assert "Failed to update category" in win.status.text() or "failcat2" in win.status.text()
411 |
412 |     def test_edit_snippet_error(self, main_window, monkeypatch):
    |                                       ^^^^^^^^^^^ ANN001
413 |         win = main_window
414 |         # Ensure a snippet exists and is selected
    |

tests\desktop_ui\test_library_main_ui_new.py:412:52: ANN001 Missing type annotation for function argument `monkeypatch`
    |
410 |         assert "Failed to update category" in win.status.text() or "failcat2" in win.status.text()
411 |
412 |     def test_edit_snippet_error(self, main_window, monkeypatch):
    |                                                    ^^^^^^^^^^^ ANN001
413 |         win = main_window
414 |         # Ensure a snippet exists and is selected
    |

tests\desktop_ui\test_library_main_ui_new.py:420:25: ANN202 Missing return type annotation for private function `exec_`
    |
419 |                 class FakeCatDialog:
420 |                     def exec_(self):
    |                         ^^^^^ ANN202
421 |                         return 1
    |
    = help: Add return type annotation: `int`

tests\desktop_ui\test_library_main_ui_new.py:423:25: ANN202 Missing return type annotation for private function `get_value`
    |
421 |                         return 1
422 |
423 |                     def get_value(self):
    |                         ^^^^^^^^^ ANN202
424 |                         return "CatForEditError"
    |
    = help: Add return type annotation: `str`

tests\desktop_ui\test_library_main_ui_new.py:431:21: ANN202 Missing return type annotation for private function `exec_`
    |
430 |             class FakeAddDialog:
431 |                 def exec_(self):
    |                     ^^^^^ ANN202
432 |                     return 1
    |
    = help: Add return type annotation: `int`

tests\desktop_ui\test_library_main_ui_new.py:434:21: ANN202 Missing return type annotation for private function `get_values`
    |
432 |                     return 1
433 |
434 |                 def get_values(self):
    |                     ^^^^^^^^^^ ANN202
435 |                     return ("SnippetToEditError", "ContentToEditError")
    |
    = help: Add return type annotation

tests\desktop_ui\test_library_main_ui_new.py:442:17: ANN202 Missing return type annotation for private function `exec_`
    |
441 |         class FakeDialog:
442 |             def exec_(self):
    |                 ^^^^^ ANN202
443 |                 return 1
    |
    = help: Add return type annotation: `int`

tests\desktop_ui\test_library_main_ui_new.py:445:17: ANN202 Missing return type annotation for private function `get_values`
    |
443 |                 return 1
444 |
445 |             def get_values(self):
    |                 ^^^^^^^^^^ ANN202
446 |                 return ("ErrEditSnip", "X")
    |
    = help: Add return type annotation

tests\desktop_ui\test_library_main_ui_new.py:450:13: ANN202 Missing return type annotation for private function `fail_save_snippet`
    |
448 |         monkeypatch.setattr(library_main, "SnippetDialog", lambda *a, **k: FakeDialog())
449 |
450 |         def fail_save_snippet(snip):
    |             ^^^^^^^^^^^^^^^^^ ANN202
451 |             raise Exception("failsnip2")
    |
    = help: Add return type annotation: `Never`

tests\desktop_ui\test_library_main_ui_new.py:450:31: ANN001 Missing type annotation for function argument `snip`
    |
448 |         monkeypatch.setattr(library_main, "SnippetDialog", lambda *a, **k: FakeDialog())
449 |
450 |         def fail_save_snippet(snip):
    |                               ^^^^ ANN001
451 |             raise Exception("failsnip2")
    |

tests\desktop_ui\test_library_main_ui_new.py:457:9: ANN201 Missing return type annotation for public function `test_delete_category_error`
    |
455 |         assert "Failed to update snippet" in win.status.text() or "failsnip2" in win.status.text()
456 |
457 |     def test_delete_category_error(self, main_window, monkeypatch):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
458 |         # Ensure a category exists and is selected
459 |         if not main_window.categories:
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:457:42: ANN001 Missing type annotation for function argument `main_window`
    |
455 |         assert "Failed to update snippet" in win.status.text() or "failsnip2" in win.status.text()
456 |
457 |     def test_delete_category_error(self, main_window, monkeypatch):
    |                                          ^^^^^^^^^^^ ANN001
458 |         # Ensure a category exists and is selected
459 |         if not main_window.categories:
    |

tests\desktop_ui\test_library_main_ui_new.py:457:55: ANN001 Missing type annotation for function argument `monkeypatch`
    |
455 |         assert "Failed to update snippet" in win.status.text() or "failsnip2" in win.status.text()
456 |
457 |     def test_delete_category_error(self, main_window, monkeypatch):
    |                                                       ^^^^^^^^^^^ ANN001
458 |         # Ensure a category exists and is selected
459 |         if not main_window.categories:
    |

tests\desktop_ui\test_library_main_ui_new.py:462:21: ANN202 Missing return type annotation for private function `exec_`
    |
461 |             class FakeCatDialog:
462 |                 def exec_(self):
    |                     ^^^^^ ANN202
463 |                     return 1
    |
    = help: Add return type annotation: `int`

tests\desktop_ui\test_library_main_ui_new.py:465:21: ANN202 Missing return type annotation for private function `get_value`
    |
463 |                     return 1
464 |
465 |                 def get_value(self):
    |                     ^^^^^^^^^ ANN202
466 |                     return "CatForDeleteError"
    |
    = help: Add return type annotation: `str`

tests\desktop_ui\test_library_main_ui_new.py:477:13: ANN202 Missing return type annotation for private function `fail_delete_category_by_id`
    |
475 |         )
476 |
477 |         def fail_delete_category_by_id(cid):
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN202
478 |             raise Exception("faildelcat")
    |
    = help: Add return type annotation: `Never`

tests\desktop_ui\test_library_main_ui_new.py:477:40: ANN001 Missing type annotation for function argument `cid`
    |
475 |         )
476 |
477 |         def fail_delete_category_by_id(cid):
    |                                        ^^^ ANN001
478 |             raise Exception("faildelcat")
    |

tests\desktop_ui\test_library_main_ui_new.py:489:9: ANN201 Missing return type annotation for public function `test_delete_snippet_error`
    |
487 |         )
488 |
489 |     def test_delete_snippet_error(self, main_window, monkeypatch):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
490 |         win = main_window
491 |         # Ensure a category exists and is selected
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:489:41: ANN001 Missing type annotation for function argument `main_window`
    |
487 |         )
488 |
489 |     def test_delete_snippet_error(self, main_window, monkeypatch):
    |                                         ^^^^^^^^^^^ ANN001
490 |         win = main_window
491 |         # Ensure a category exists and is selected
    |

tests\desktop_ui\test_library_main_ui_new.py:489:54: ANN001 Missing type annotation for function argument `monkeypatch`
    |
487 |         )
488 |
489 |     def test_delete_snippet_error(self, main_window, monkeypatch):
    |                                                      ^^^^^^^^^^^ ANN001
490 |         win = main_window
491 |         # Ensure a category exists and is selected
    |

tests\desktop_ui\test_library_main_ui_new.py:495:21: ANN202 Missing return type annotation for private function `exec_`
    |
494 |             class FakeCatDialog:
495 |                 def exec_(self):
    |                     ^^^^^ ANN202
496 |                     return 1
    |
    = help: Add return type annotation: `int`

tests\desktop_ui\test_library_main_ui_new.py:498:21: ANN202 Missing return type annotation for private function `get_value`
    |
496 |                     return 1
497 |
498 |                 def get_value(self):
    |                     ^^^^^^^^^ ANN202
499 |                     return "CatForDeleteError"
    |
    = help: Add return type annotation: `str`

tests\desktop_ui\test_library_main_ui_new.py:508:21: ANN202 Missing return type annotation for private function `exec_`
    |
507 |             class FakeSnipDialog:
508 |                 def exec_(self):
    |                     ^^^^^ ANN202
509 |                     return 1
    |
    = help: Add return type annotation: `int`

tests\desktop_ui\test_library_main_ui_new.py:511:21: ANN202 Missing return type annotation for private function `get_values`
    |
509 |                     return 1
510 |
511 |                 def get_values(self):
    |                     ^^^^^^^^^^ ANN202
512 |                     return ("ToDelError", "X")
    |
    = help: Add return type annotation

tests\desktop_ui\test_library_main_ui_new.py:519:13: ANN202 Missing return type annotation for private function `fail_delete_snippet`
    |
517 |         monkeypatch.setattr("PySide6.QtWidgets.QMessageBox.question", lambda *a, **k: 16384)  # Yes
518 |
519 |         def fail_delete_snippet(sid):
    |             ^^^^^^^^^^^^^^^^^^^ ANN202
520 |             raise Exception("faildelsnip")
    |
    = help: Add return type annotation: `Never`

tests\desktop_ui\test_library_main_ui_new.py:519:33: ANN001 Missing type annotation for function argument `sid`
    |
517 |         monkeypatch.setattr("PySide6.QtWidgets.QMessageBox.question", lambda *a, **k: 16384)  # Yes
518 |
519 |         def fail_delete_snippet(sid):
    |                                 ^^^ ANN001
520 |             raise Exception("faildelsnip")
    |

tests\desktop_ui\test_library_main_ui_new.py:526:9: ANN201 Missing return type annotation for public function `test_load_data_error`
    |
524 |         assert "Failed to delete snippet" in win.status.text() or "faildelsnip" in win.status.text()
525 |
526 |     def test_load_data_error(self, main_window, monkeypatch):
    |         ^^^^^^^^^^^^^^^^^^^^ ANN201
527 |         win = main_window
528 |         monkeypatch.setattr(
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:526:36: ANN001 Missing type annotation for function argument `main_window`
    |
524 |         assert "Failed to delete snippet" in win.status.text() or "faildelsnip" in win.status.text()
525 |
526 |     def test_load_data_error(self, main_window, monkeypatch):
    |                                    ^^^^^^^^^^^ ANN001
527 |         win = main_window
528 |         monkeypatch.setattr(
    |

tests\desktop_ui\test_library_main_ui_new.py:526:49: ANN001 Missing type annotation for function argument `monkeypatch`
    |
524 |         assert "Failed to delete snippet" in win.status.text() or "faildelsnip" in win.status.text()
525 |
526 |     def test_load_data_error(self, main_window, monkeypatch):
    |                                                 ^^^^^^^^^^^ ANN001
527 |         win = main_window
528 |         monkeypatch.setattr(
    |

tests\desktop_ui\test_library_main_ui_new.py:536:9: ANN201 Missing return type annotation for public function `test_load_snippets_error`
    |
534 |         assert "Error loading data" in win.status.text()
535 |
536 |     def test_load_snippets_error(self, main_window, monkeypatch):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
537 |         win = main_window
538 |         win.categoryList.setCurrentRow(0)
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:536:40: ANN001 Missing type annotation for function argument `main_window`
    |
534 |         assert "Error loading data" in win.status.text()
535 |
536 |     def test_load_snippets_error(self, main_window, monkeypatch):
    |                                        ^^^^^^^^^^^ ANN001
537 |         win = main_window
538 |         win.categoryList.setCurrentRow(0)
    |

tests\desktop_ui\test_library_main_ui_new.py:536:53: ANN001 Missing type annotation for function argument `monkeypatch`
    |
534 |         assert "Error loading data" in win.status.text()
535 |
536 |     def test_load_snippets_error(self, main_window, monkeypatch):
    |                                                     ^^^^^^^^^^^ ANN001
537 |         win = main_window
538 |         win.categoryList.setCurrentRow(0)
    |

tests\desktop_ui\test_library_main_ui_new.py:551:5: ANN201 Missing return type annotation for public function `test_window_initialization`
    |
551 | def test_window_initialization(main_window):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
552 |     """Test that the main window initializes with the correct default state.
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:551:32: ANN001 Missing type annotation for function argument `main_window`
    |
551 | def test_window_initialization(main_window):
    |                                ^^^^^^^^^^^ ANN001
552 |     """Test that the main window initializes with the correct default state.
    |

tests\desktop_ui\test_library_main_ui_new.py:597:5: ANN201 Missing return type annotation for public function `test_add_category_ui`
    |
597 | def test_add_category_ui(main_window, monkeypatch):
    |     ^^^^^^^^^^^^^^^^^^^^ ANN201
598 |     # Simulate CategoryDialog returning Accepted and a name
599 |     class FakeDialog:
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:597:26: ANN001 Missing type annotation for function argument `main_window`
    |
597 | def test_add_category_ui(main_window, monkeypatch):
    |                          ^^^^^^^^^^^ ANN001
598 |     # Simulate CategoryDialog returning Accepted and a name
599 |     class FakeDialog:
    |

tests\desktop_ui\test_library_main_ui_new.py:597:39: ANN001 Missing type annotation for function argument `monkeypatch`
    |
597 | def test_add_category_ui(main_window, monkeypatch):
    |                                       ^^^^^^^^^^^ ANN001
598 |     # Simulate CategoryDialog returning Accepted and a name
599 |     class FakeDialog:
    |

tests\desktop_ui\test_library_main_ui_new.py:600:13: ANN202 Missing return type annotation for private function `exec_`
    |
598 |     # Simulate CategoryDialog returning Accepted and a name
599 |     class FakeDialog:
600 |         def exec_(self):
    |             ^^^^^ ANN202
601 |             return 1  # Accepted
    |
    = help: Add return type annotation: `int`

tests\desktop_ui\test_library_main_ui_new.py:603:13: ANN202 Missing return type annotation for private function `get_value`
    |
601 |             return 1  # Accepted
602 |
603 |         def get_value(self):
    |             ^^^^^^^^^ ANN202
604 |             return "UI Cat"
    |
    = help: Add return type annotation: `str`

tests\desktop_ui\test_library_main_ui_new.py:612:5: ANN201 Missing return type annotation for public function `test_edit_category_ui`
    |
612 | def test_edit_category_ui(main_window, monkeypatch):
    |     ^^^^^^^^^^^^^^^^^^^^^ ANN201
613 |     # Ensure there is at least one category to edit
614 |     if not main_window.categories:
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:612:27: ANN001 Missing type annotation for function argument `main_window`
    |
612 | def test_edit_category_ui(main_window, monkeypatch):
    |                           ^^^^^^^^^^^ ANN001
613 |     # Ensure there is at least one category to edit
614 |     if not main_window.categories:
    |

tests\desktop_ui\test_library_main_ui_new.py:612:40: ANN001 Missing type annotation for function argument `monkeypatch`
    |
612 | def test_edit_category_ui(main_window, monkeypatch):
    |                                        ^^^^^^^^^^^ ANN001
613 |     # Ensure there is at least one category to edit
614 |     if not main_window.categories:
    |

tests\desktop_ui\test_library_main_ui_new.py:617:17: ANN202 Missing return type annotation for private function `exec_`
    |
616 |         class FakeAddDialog:
617 |             def exec_(self):
    |                 ^^^^^ ANN202
618 |                 return 1
    |
    = help: Add return type annotation: `int`

tests\desktop_ui\test_library_main_ui_new.py:620:17: ANN202 Missing return type annotation for private function `get_value`
    |
618 |                 return 1
619 |
620 |             def get_value(self):
    |                 ^^^^^^^^^ ANN202
621 |                 return "Initial Cat"
    |
    = help: Add return type annotation: `str`

tests\desktop_ui\test_library_main_ui_new.py:629:13: ANN202 Missing return type annotation for private function `exec_`
    |
628 |     class FakeEditDialog:
629 |         def exec_(self):
    |             ^^^^^ ANN202
630 |             return 1
    |
    = help: Add return type annotation: `int`

tests\desktop_ui\test_library_main_ui_new.py:632:13: ANN202 Missing return type annotation for private function `get_value`
    |
630 |             return 1
631 |
632 |         def get_value(self):
    |             ^^^^^^^^^ ANN202
633 |             return "Renamed Cat"
    |
    = help: Add return type annotation: `str`

tests\desktop_ui\test_library_main_ui_new.py:641:5: ANN201 Missing return type annotation for public function `test_delete_category_ui`
    |
641 | def test_delete_category_ui(main_window, monkeypatch):
    |     ^^^^^^^^^^^^^^^^^^^^^^^ ANN201
642 |     # Add a category to delete
643 |     cat = library_main.Category(category_name="ToDelete", description="")
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:641:29: ANN001 Missing type annotation for function argument `main_window`
    |
641 | def test_delete_category_ui(main_window, monkeypatch):
    |                             ^^^^^^^^^^^ ANN001
642 |     # Add a category to delete
643 |     cat = library_main.Category(category_name="ToDelete", description="")
    |

tests\desktop_ui\test_library_main_ui_new.py:641:42: ANN001 Missing type annotation for function argument `monkeypatch`
    |
641 | def test_delete_category_ui(main_window, monkeypatch):
    |                                          ^^^^^^^^^^^ ANN001
642 |     # Add a category to delete
643 |     cat = library_main.Category(category_name="ToDelete", description="")
    |

tests\desktop_ui\test_library_main_ui_new.py:660:5: ANN201 Missing return type annotation for public function `test_add_snippet_ui`
    |
660 | def test_add_snippet_ui(main_window, monkeypatch):
    |     ^^^^^^^^^^^^^^^^^^^ ANN201
661 |     # Ensure a category exists and is selected
662 |     if not main_window.categories:
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:660:25: ANN001 Missing type annotation for function argument `main_window`
    |
660 | def test_add_snippet_ui(main_window, monkeypatch):
    |                         ^^^^^^^^^^^ ANN001
661 |     # Ensure a category exists and is selected
662 |     if not main_window.categories:
    |

tests\desktop_ui\test_library_main_ui_new.py:660:38: ANN001 Missing type annotation for function argument `monkeypatch`
    |
660 | def test_add_snippet_ui(main_window, monkeypatch):
    |                                      ^^^^^^^^^^^ ANN001
661 |     # Ensure a category exists and is selected
662 |     if not main_window.categories:
    |

tests\desktop_ui\test_library_main_ui_new.py:665:17: ANN202 Missing return type annotation for private function `exec_`
    |
664 |         class FakeCatDialog:
665 |             def exec_(self):
    |                 ^^^^^ ANN202
666 |                 return 1
    |
    = help: Add return type annotation: `int`

tests\desktop_ui\test_library_main_ui_new.py:668:17: ANN202 Missing return type annotation for private function `get_value`
    |
666 |                 return 1
667 |
668 |             def get_value(self):
    |                 ^^^^^^^^^ ANN202
669 |                 return "CatForSnippet"
    |
    = help: Add return type annotation: `str`

tests\desktop_ui\test_library_main_ui_new.py:676:13: ANN202 Missing return type annotation for private function `exec_`
    |
675 |     class FakeDialog:
676 |         def exec_(self):
    |             ^^^^^ ANN202
677 |             return 1
    |
    = help: Add return type annotation: `int`

tests\desktop_ui\test_library_main_ui_new.py:679:13: ANN202 Missing return type annotation for private function `get_values`
    |
677 |             return 1
678 |
679 |         def get_values(self):
    |             ^^^^^^^^^^ ANN202
680 |             return ("SnippetA", "ContentA")
    |
    = help: Add return type annotation

tests\desktop_ui\test_library_main_ui_new.py:688:5: ANN201 Missing return type annotation for public function `test_edit_snippet_ui`
    |
688 | def test_edit_snippet_ui(main_window, monkeypatch):
    |     ^^^^^^^^^^^^^^^^^^^^ ANN201
689 |     # Ensure there is at least one snippet to edit
690 |     if not main_window.snippets:
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:688:26: ANN001 Missing type annotation for function argument `main_window`
    |
688 | def test_edit_snippet_ui(main_window, monkeypatch):
    |                          ^^^^^^^^^^^ ANN001
689 |     # Ensure there is at least one snippet to edit
690 |     if not main_window.snippets:
    |

tests\desktop_ui\test_library_main_ui_new.py:688:39: ANN001 Missing type annotation for function argument `monkeypatch`
    |
688 | def test_edit_snippet_ui(main_window, monkeypatch):
    |                                       ^^^^^^^^^^^ ANN001
689 |     # Ensure there is at least one snippet to edit
690 |     if not main_window.snippets:
    |

tests\desktop_ui\test_library_main_ui_new.py:695:21: ANN202 Missing return type annotation for private function `exec_`
    |
694 |             class FakeCatDialog:
695 |                 def exec_(self):
    |                     ^^^^^ ANN202
696 |                     return 1
    |
    = help: Add return type annotation: `int`

tests\desktop_ui\test_library_main_ui_new.py:698:21: ANN202 Missing return type annotation for private function `get_value`
    |
696 |                     return 1
697 |
698 |                 def get_value(self):
    |                     ^^^^^^^^^ ANN202
699 |                     return "CatForEdit"
    |
    = help: Add return type annotation: `str`

tests\desktop_ui\test_library_main_ui_new.py:706:17: ANN202 Missing return type annotation for private function `exec_`
    |
705 |         class FakeAddDialog:
706 |             def exec_(self):
    |                 ^^^^^ ANN202
707 |                 return 1
    |
    = help: Add return type annotation: `int`

tests\desktop_ui\test_library_main_ui_new.py:709:17: ANN202 Missing return type annotation for private function `get_values`
    |
707 |                 return 1
708 |
709 |             def get_values(self):
    |                 ^^^^^^^^^^ ANN202
710 |                 return ("SnippetToEdit", "ContentToEdit")
    |
    = help: Add return type annotation

tests\desktop_ui\test_library_main_ui_new.py:717:13: ANN202 Missing return type annotation for private function `exec_`
    |
716 |     class FakeEditDialog:
717 |         def exec_(self):
    |             ^^^^^ ANN202
718 |             return 1
    |
    = help: Add return type annotation: `int`

tests\desktop_ui\test_library_main_ui_new.py:720:13: ANN202 Missing return type annotation for private function `get_values`
    |
718 |             return 1
719 |
720 |         def get_values(self):
    |             ^^^^^^^^^^ ANN202
721 |             return ("SnippetA-Edit", "ContentA-Edit")
    |
    = help: Add return type annotation

tests\desktop_ui\test_library_main_ui_new.py:729:5: ANN201 Missing return type annotation for public function `test_delete_snippet_ui`
    |
729 | def test_delete_snippet_ui(main_window, monkeypatch):
    |     ^^^^^^^^^^^^^^^^^^^^^^ ANN201
730 |     # Ensure a category exists and is selected
731 |     if not main_window.categories:
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:729:28: ANN001 Missing type annotation for function argument `main_window`
    |
729 | def test_delete_snippet_ui(main_window, monkeypatch):
    |                            ^^^^^^^^^^^ ANN001
730 |     # Ensure a category exists and is selected
731 |     if not main_window.categories:
    |

tests\desktop_ui\test_library_main_ui_new.py:729:41: ANN001 Missing type annotation for function argument `monkeypatch`
    |
729 | def test_delete_snippet_ui(main_window, monkeypatch):
    |                                         ^^^^^^^^^^^ ANN001
730 |     # Ensure a category exists and is selected
731 |     if not main_window.categories:
    |

tests\desktop_ui\test_library_main_ui_new.py:734:17: ANN202 Missing return type annotation for private function `exec_`
    |
733 |         class FakeCatDialog:
734 |             def exec_(self):
    |                 ^^^^^ ANN202
735 |                 return 1
    |
    = help: Add return type annotation: `int`

tests\desktop_ui\test_library_main_ui_new.py:737:17: ANN202 Missing return type annotation for private function `get_value`
    |
735 |                 return 1
736 |
737 |             def get_value(self):
    |                 ^^^^^^^^^ ANN202
738 |                 return "CatForDelete"
    |
    = help: Add return type annotation: `str`

tests\desktop_ui\test_library_main_ui_new.py:747:17: ANN202 Missing return type annotation for private function `exec_`
    |
746 |         class FakeSnipDialog:
747 |             def exec_(self):
    |                 ^^^^^ ANN202
748 |                 return 1
    |
    = help: Add return type annotation: `int`

tests\desktop_ui\test_library_main_ui_new.py:750:17: ANN202 Missing return type annotation for private function `get_values`
    |
748 |                 return 1
749 |
750 |             def get_values(self):
    |                 ^^^^^^^^^^ ANN202
751 |                 return ("ToDel", "X")
    |
    = help: Add return type annotation

tests\desktop_ui\test_library_main_ui_new.py:766:5: ANN201 Missing return type annotation for public function `test_filter_snippets`
    |
766 | def test_filter_snippets(main_window):
    |     ^^^^^^^^^^^^^^^^^^^^ ANN201
767 |     main_window.search_input.setText("Edit")
768 |     # Should only show snippets with 'Edit' in name
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:766:26: ANN001 Missing type annotation for function argument `main_window`
    |
766 | def test_filter_snippets(main_window):
    |                          ^^^^^^^^^^^ ANN001
767 |     main_window.search_input.setText("Edit")
768 |     # Should only show snippets with 'Edit' in name
    |

tests\desktop_ui\test_library_main_ui_new.py:775:5: ANN201 Missing return type annotation for public function `test_show_error_and_info`
    |
775 | def test_show_error_and_info(main_window):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
776 |     main_window.show_error("errormsg")
777 |     assert main_window.status.text() == "errormsg"
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:775:30: ANN001 Missing type annotation for function argument `main_window`
    |
775 | def test_show_error_and_info(main_window):
    |                              ^^^^^^^^^^^ ANN001
776 |     main_window.show_error("errormsg")
777 |     assert main_window.status.text() == "errormsg"
    |

tests\desktop_ui\test_library_main_ui_new.py:782:5: ANN201 Missing return type annotation for public function `test_update_snippet_buttons_state`
    |
782 | def test_update_snippet_buttons_state(main_window):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
783 |     main_window.update_snippet_buttons_state(True)
784 |     assert main_window.addSnipBtn.isEnabled()
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:782:39: ANN001 Missing type annotation for function argument `main_window`
    |
782 | def test_update_snippet_buttons_state(main_window):
    |                                       ^^^^^^^^^^^ ANN001
783 |     main_window.update_snippet_buttons_state(True)
784 |     assert main_window.addSnipBtn.isEnabled()
    |

tests\desktop_ui\test_library_main_ui_new.py:789:5: ANN201 Missing return type annotation for public function `test_add_category_error`
    |
789 | def test_add_category_error(monkeypatch, main_window):
    |     ^^^^^^^^^^^^^^^^^^^^^^^ ANN201
790 |     class FakeDialog:
791 |         def exec_(self):
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:789:29: ANN001 Missing type annotation for function argument `monkeypatch`
    |
789 | def test_add_category_error(monkeypatch, main_window):
    |                             ^^^^^^^^^^^ ANN001
790 |     class FakeDialog:
791 |         def exec_(self):
    |

tests\desktop_ui\test_library_main_ui_new.py:789:42: ANN001 Missing type annotation for function argument `main_window`
    |
789 | def test_add_category_error(monkeypatch, main_window):
    |                                          ^^^^^^^^^^^ ANN001
790 |     class FakeDialog:
791 |         def exec_(self):
    |

tests\desktop_ui\test_library_main_ui_new.py:791:13: ANN202 Missing return type annotation for private function `exec_`
    |
789 | def test_add_category_error(monkeypatch, main_window):
790 |     class FakeDialog:
791 |         def exec_(self):
    |             ^^^^^ ANN202
792 |             return 1
    |
    = help: Add return type annotation: `int`

tests\desktop_ui\test_library_main_ui_new.py:794:13: ANN202 Missing return type annotation for private function `get_value`
    |
792 |             return 1
793 |
794 |         def get_value(self):
    |             ^^^^^^^^^ ANN202
795 |             return "ErrorCat"
    |
    = help: Add return type annotation: `str`

tests\desktop_ui\test_library_main_ui_new.py:799:9: ANN202 Missing return type annotation for private function `fail_save_category`
    |
797 |     monkeypatch.setattr(library_main, "CategoryDialog", lambda *a, **k: FakeDialog())
798 |
799 |     def fail_save_category(cat):
    |         ^^^^^^^^^^^^^^^^^^ ANN202
800 |         raise Exception("failcat")
    |
    = help: Add return type annotation: `Never`

tests\desktop_ui\test_library_main_ui_new.py:799:28: ANN001 Missing type annotation for function argument `cat`
    |
797 |     monkeypatch.setattr(library_main, "CategoryDialog", lambda *a, **k: FakeDialog())
798 |
799 |     def fail_save_category(cat):
    |                            ^^^ ANN001
800 |         raise Exception("failcat")
    |

tests\desktop_ui\test_library_main_ui_new.py:807:5: ANN201 Missing return type annotation for public function `test_add_snippet_error`
    |
807 | def test_add_snippet_error(monkeypatch, main_window):
    |     ^^^^^^^^^^^^^^^^^^^^^^ ANN201
808 |     # Ensure a category exists and is selected
809 |     if not main_window.categories:
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:807:28: ANN001 Missing type annotation for function argument `monkeypatch`
    |
807 | def test_add_snippet_error(monkeypatch, main_window):
    |                            ^^^^^^^^^^^ ANN001
808 |     # Ensure a category exists and is selected
809 |     if not main_window.categories:
    |

tests\desktop_ui\test_library_main_ui_new.py:807:41: ANN001 Missing type annotation for function argument `main_window`
    |
807 | def test_add_snippet_error(monkeypatch, main_window):
    |                                         ^^^^^^^^^^^ ANN001
808 |     # Ensure a category exists and is selected
809 |     if not main_window.categories:
    |

tests\desktop_ui\test_library_main_ui_new.py:812:17: ANN202 Missing return type annotation for private function `exec_`
    |
811 |         class FakeCatDialog:
812 |             def exec_(self):
    |                 ^^^^^ ANN202
813 |                 return 1
    |
    = help: Add return type annotation: `int`

tests\desktop_ui\test_library_main_ui_new.py:815:17: ANN202 Missing return type annotation for private function `get_value`
    |
813 |                 return 1
814 |
815 |             def get_value(self):
    |                 ^^^^^^^^^ ANN202
816 |                 return "CatForError"
    |
    = help: Add return type annotation: `str`

tests\desktop_ui\test_library_main_ui_new.py:823:13: ANN202 Missing return type annotation for private function `exec_`
    |
822 |     class FakeDialog:
823 |         def exec_(self):
    |             ^^^^^ ANN202
824 |             return 1
    |
    = help: Add return type annotation: `int`

tests\desktop_ui\test_library_main_ui_new.py:826:13: ANN202 Missing return type annotation for private function `get_values`
    |
824 |             return 1
825 |
826 |         def get_values(self):
    |             ^^^^^^^^^^ ANN202
827 |             return ("ErrSnip", "X")
    |
    = help: Add return type annotation

tests\desktop_ui\test_library_main_ui_new.py:831:9: ANN202 Missing return type annotation for private function `fail_save_snippet`
    |
829 |     monkeypatch.setattr(library_main, "SnippetDialog", lambda *a, **k: FakeDialog())
830 |
831 |     def fail_save_snippet(snip):
    |         ^^^^^^^^^^^^^^^^^ ANN202
832 |         raise Exception("failsnip")
    |
    = help: Add return type annotation: `Never`

tests\desktop_ui\test_library_main_ui_new.py:831:27: ANN001 Missing type annotation for function argument `snip`
    |
829 |     monkeypatch.setattr(library_main, "SnippetDialog", lambda *a, **k: FakeDialog())
830 |
831 |     def fail_save_snippet(snip):
    |                           ^^^^ ANN001
832 |         raise Exception("failsnip")
    |

tests\desktop_ui\test_library_main_ui_new.py:839:5: ANN201 Missing return type annotation for public function `test_edit_category_no_selection`
    |
839 | def test_edit_category_no_selection(main_window):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
840 |     main_window.categoryList.clearSelection()
841 |     main_window.edit_category()
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:839:37: ANN001 Missing type annotation for function argument `main_window`
    |
839 | def test_edit_category_no_selection(main_window):
    |                                     ^^^^^^^^^^^ ANN001
840 |     main_window.categoryList.clearSelection()
841 |     main_window.edit_category()
    |

tests\desktop_ui\test_library_main_ui_new.py:845:5: ANN201 Missing return type annotation for public function `test_delete_category_no_selection`
    |
845 | def test_delete_category_no_selection(main_window):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
846 |     main_window.categoryList.clearSelection()
847 |     main_window.delete_category()
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:845:39: ANN001 Missing type annotation for function argument `main_window`
    |
845 | def test_delete_category_no_selection(main_window):
    |                                       ^^^^^^^^^^^ ANN001
846 |     main_window.categoryList.clearSelection()
847 |     main_window.delete_category()
    |

tests\desktop_ui\test_library_main_ui_new.py:851:5: ANN201 Missing return type annotation for public function `test_add_snippet_no_category`
    |
851 | def test_add_snippet_no_category(main_window):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
852 |     main_window.selected_category = None
853 |     main_window.add_snippet()
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:851:34: ANN001 Missing type annotation for function argument `main_window`
    |
851 | def test_add_snippet_no_category(main_window):
    |                                  ^^^^^^^^^^^ ANN001
852 |     main_window.selected_category = None
853 |     main_window.add_snippet()
    |

tests\desktop_ui\test_library_main_ui_new.py:857:5: ANN201 Missing return type annotation for public function `test_edit_snippet_no_selection`
    |
857 | def test_edit_snippet_no_selection(main_window):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
858 |     main_window.snippetList.clearSelection()
859 |     main_window.edit_snippet()
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:857:36: ANN001 Missing type annotation for function argument `main_window`
    |
857 | def test_edit_snippet_no_selection(main_window):
    |                                    ^^^^^^^^^^^ ANN001
858 |     main_window.snippetList.clearSelection()
859 |     main_window.edit_snippet()
    |

tests\desktop_ui\test_library_main_ui_new.py:863:5: ANN201 Missing return type annotation for public function `test_delete_snippet_no_selection`
    |
863 | def test_delete_snippet_no_selection(main_window):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
864 |     main_window.snippetList.clearSelection()
865 |     main_window.delete_snippet()
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:863:38: ANN001 Missing type annotation for function argument `main_window`
    |
863 | def test_delete_snippet_no_selection(main_window):
    |                                      ^^^^^^^^^^^ ANN001
864 |     main_window.snippetList.clearSelection()
865 |     main_window.delete_snippet()
    |

tests\desktop_ui\test_library_main_ui_new.py:869:5: ANN201 Missing return type annotation for public function `test_edit_category_error`
    |
869 | def test_edit_category_error(monkeypatch, main_window):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
870 |     # Ensure a category exists and is selected
871 |     if not main_window.categories:
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:869:30: ANN001 Missing type annotation for function argument `monkeypatch`
    |
869 | def test_edit_category_error(monkeypatch, main_window):
    |                              ^^^^^^^^^^^ ANN001
870 |     # Ensure a category exists and is selected
871 |     if not main_window.categories:
    |

tests\desktop_ui\test_library_main_ui_new.py:869:43: ANN001 Missing type annotation for function argument `main_window`
    |
869 | def test_edit_category_error(monkeypatch, main_window):
    |                                           ^^^^^^^^^^^ ANN001
870 |     # Ensure a category exists and is selected
871 |     if not main_window.categories:
    |

tests\desktop_ui\test_library_main_ui_new.py:874:17: ANN202 Missing return type annotation for private function `exec_`
    |
873 |         class FakeCatDialog:
874 |             def exec_(self):
    |                 ^^^^^ ANN202
875 |                 return 1
    |
    = help: Add return type annotation: `int`

tests\desktop_ui\test_library_main_ui_new.py:877:17: ANN202 Missing return type annotation for private function `get_value`
    |
875 |                 return 1
876 |
877 |             def get_value(self):
    |                 ^^^^^^^^^ ANN202
878 |                 return "ErrEditCat"
    |
    = help: Add return type annotation: `str`

tests\desktop_ui\test_library_main_ui_new.py:885:13: ANN202 Missing return type annotation for private function `exec_`
    |
884 |     class FakeDialog:
885 |         def exec_(self):
    |             ^^^^^ ANN202
886 |             return 1
    |
    = help: Add return type annotation: `int`

tests\desktop_ui\test_library_main_ui_new.py:888:13: ANN202 Missing return type annotation for private function `get_value`
    |
886 |             return 1
887 |
888 |         def get_value(self):
    |             ^^^^^^^^^ ANN202
889 |             return "ErrEditCat"
    |
    = help: Add return type annotation: `str`

tests\desktop_ui\test_library_main_ui_new.py:893:9: ANN202 Missing return type annotation for private function `fail_save_category`
    |
891 |     monkeypatch.setattr(library_main, "CategoryDialog", lambda *a, **k: FakeDialog())
892 |
893 |     def fail_save_category(cat):
    |         ^^^^^^^^^^^^^^^^^^ ANN202
894 |         raise Exception("failcat2")
    |
    = help: Add return type annotation: `Never`

tests\desktop_ui\test_library_main_ui_new.py:893:28: ANN001 Missing type annotation for function argument `cat`
    |
891 |     monkeypatch.setattr(library_main, "CategoryDialog", lambda *a, **k: FakeDialog())
892 |
893 |     def fail_save_category(cat):
    |                            ^^^ ANN001
894 |         raise Exception("failcat2")
    |

tests\desktop_ui\test_library_main_ui_new.py:904:5: ANN201 Missing return type annotation for public function `test_edit_snippet_error`
    |
904 | def test_edit_snippet_error(monkeypatch, main_window):
    |     ^^^^^^^^^^^^^^^^^^^^^^^ ANN201
905 |     # Ensure a snippet exists and is selected
906 |     if not main_window.snippets:
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:904:29: ANN001 Missing type annotation for function argument `monkeypatch`
    |
904 | def test_edit_snippet_error(monkeypatch, main_window):
    |                             ^^^^^^^^^^^ ANN001
905 |     # Ensure a snippet exists and is selected
906 |     if not main_window.snippets:
    |

tests\desktop_ui\test_library_main_ui_new.py:904:42: ANN001 Missing type annotation for function argument `main_window`
    |
904 | def test_edit_snippet_error(monkeypatch, main_window):
    |                                          ^^^^^^^^^^^ ANN001
905 |     # Ensure a snippet exists and is selected
906 |     if not main_window.snippets:
    |

tests\desktop_ui\test_library_main_ui_new.py:911:21: ANN202 Missing return type annotation for private function `exec_`
    |
910 |             class FakeCatDialog:
911 |                 def exec_(self):
    |                     ^^^^^ ANN202
912 |                     return 1
    |
    = help: Add return type annotation: `int`

tests\desktop_ui\test_library_main_ui_new.py:914:21: ANN202 Missing return type annotation for private function `get_value`
    |
912 |                     return 1
913 |
914 |                 def get_value(self):
    |                     ^^^^^^^^^ ANN202
915 |                     return "CatForEditError"
    |
    = help: Add return type annotation: `str`

tests\desktop_ui\test_library_main_ui_new.py:922:17: ANN202 Missing return type annotation for private function `exec_`
    |
921 |         class FakeAddDialog:
922 |             def exec_(self):
    |                 ^^^^^ ANN202
923 |                 return 1
    |
    = help: Add return type annotation: `int`

tests\desktop_ui\test_library_main_ui_new.py:925:17: ANN202 Missing return type annotation for private function `get_values`
    |
923 |                 return 1
924 |
925 |             def get_values(self):
    |                 ^^^^^^^^^^ ANN202
926 |                 return ("SnippetToEditError", "ContentToEditError")
    |
    = help: Add return type annotation

tests\desktop_ui\test_library_main_ui_new.py:933:13: ANN202 Missing return type annotation for private function `exec_`
    |
932 |     class FakeDialog:
933 |         def exec_(self):
    |             ^^^^^ ANN202
934 |             return 1
    |
    = help: Add return type annotation: `int`

tests\desktop_ui\test_library_main_ui_new.py:936:13: ANN202 Missing return type annotation for private function `get_values`
    |
934 |             return 1
935 |
936 |         def get_values(self):
    |             ^^^^^^^^^^ ANN202
937 |             return ("ErrEditSnip", "X")
    |
    = help: Add return type annotation

tests\desktop_ui\test_library_main_ui_new.py:941:9: ANN202 Missing return type annotation for private function `fail_save_snippet`
    |
939 |     monkeypatch.setattr(library_main, "SnippetDialog", lambda *a, **k: FakeDialog())
940 |
941 |     def fail_save_snippet(snip):
    |         ^^^^^^^^^^^^^^^^^ ANN202
942 |         raise Exception("failsnip2")
    |
    = help: Add return type annotation: `Never`

tests\desktop_ui\test_library_main_ui_new.py:941:27: ANN001 Missing type annotation for function argument `snip`
    |
939 |     monkeypatch.setattr(library_main, "SnippetDialog", lambda *a, **k: FakeDialog())
940 |
941 |     def fail_save_snippet(snip):
    |                           ^^^^ ANN001
942 |         raise Exception("failsnip2")
    |

tests\desktop_ui\test_library_main_ui_new.py:952:5: ANN201 Missing return type annotation for public function `test_delete_category_error`
    |
952 | def test_delete_category_error(monkeypatch, main_window):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
953 |     # Ensure a category exists and is selected
954 |     if not main_window.categories:
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:952:32: ANN001 Missing type annotation for function argument `monkeypatch`
    |
952 | def test_delete_category_error(monkeypatch, main_window):
    |                                ^^^^^^^^^^^ ANN001
953 |     # Ensure a category exists and is selected
954 |     if not main_window.categories:
    |

tests\desktop_ui\test_library_main_ui_new.py:952:45: ANN001 Missing type annotation for function argument `main_window`
    |
952 | def test_delete_category_error(monkeypatch, main_window):
    |                                             ^^^^^^^^^^^ ANN001
953 |     # Ensure a category exists and is selected
954 |     if not main_window.categories:
    |

tests\desktop_ui\test_library_main_ui_new.py:957:17: ANN202 Missing return type annotation for private function `exec_`
    |
956 |         class FakeCatDialog:
957 |             def exec_(self):
    |                 ^^^^^ ANN202
958 |                 return 1
    |
    = help: Add return type annotation: `int`

tests\desktop_ui\test_library_main_ui_new.py:960:17: ANN202 Missing return type annotation for private function `get_value`
    |
958 |                 return 1
959 |
960 |             def get_value(self):
    |                 ^^^^^^^^^ ANN202
961 |                 return "CatForDelete"
    |
    = help: Add return type annotation: `str`

tests\desktop_ui\test_library_main_ui_new.py:972:9: ANN202 Missing return type annotation for private function `fail_delete_category_by_id`
    |
970 |     )
971 |
972 |     def fail_delete_category_by_id(cid):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN202
973 |         raise Exception("faildelcat")
    |
    = help: Add return type annotation: `Never`

tests\desktop_ui\test_library_main_ui_new.py:972:36: ANN001 Missing type annotation for function argument `cid`
    |
970 |     )
971 |
972 |     def fail_delete_category_by_id(cid):
    |                                    ^^^ ANN001
973 |         raise Exception("faildelcat")
    |

tests\desktop_ui\test_library_main_ui_new.py:982:5: ANN201 Missing return type annotation for public function `test_delete_snippet_error`
    |
982 | def test_delete_snippet_error(monkeypatch, main_window):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
983 |     # Ensure a category exists and is selected
984 |     if not main_window.categories:
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:982:31: ANN001 Missing type annotation for function argument `monkeypatch`
    |
982 | def test_delete_snippet_error(monkeypatch, main_window):
    |                               ^^^^^^^^^^^ ANN001
983 |     # Ensure a category exists and is selected
984 |     if not main_window.categories:
    |

tests\desktop_ui\test_library_main_ui_new.py:982:44: ANN001 Missing type annotation for function argument `main_window`
    |
982 | def test_delete_snippet_error(monkeypatch, main_window):
    |                                            ^^^^^^^^^^^ ANN001
983 |     # Ensure a category exists and is selected
984 |     if not main_window.categories:
    |

tests\desktop_ui\test_library_main_ui_new.py:987:17: ANN202 Missing return type annotation for private function `exec_`
    |
986 |         class FakeCatDialog:
987 |             def exec_(self):
    |                 ^^^^^ ANN202
988 |                 return 1
    |
    = help: Add return type annotation: `int`

tests\desktop_ui\test_library_main_ui_new.py:990:17: ANN202 Missing return type annotation for private function `get_value`
    |
988 |                 return 1
989 |
990 |             def get_value(self):
    |                 ^^^^^^^^^ ANN202
991 |                 return "CatForDeleteError"
    |
    = help: Add return type annotation: `str`

tests\desktop_ui\test_library_main_ui_new.py:1000:17: ANN202 Missing return type annotation for private function `exec_`
     |
 999 |         class FakeSnipDialog:
1000 |             def exec_(self):
     |                 ^^^^^ ANN202
1001 |                 return 1
     |
     = help: Add return type annotation: `int`

tests\desktop_ui\test_library_main_ui_new.py:1003:17: ANN202 Missing return type annotation for private function `get_values`
     |
1001 |                 return 1
1002 |
1003 |             def get_values(self):
     |                 ^^^^^^^^^^ ANN202
1004 |                 return ("ToDelError", "X")
     |
     = help: Add return type annotation

tests\desktop_ui\test_library_main_ui_new.py:1015:9: ANN202 Missing return type annotation for private function `fail_delete_snippet`
     |
1013 |     )
1014 |
1015 |     def fail_delete_snippet(sid):
     |         ^^^^^^^^^^^^^^^^^^^ ANN202
1016 |         raise Exception("faildelsnip")
     |
     = help: Add return type annotation: `Never`

tests\desktop_ui\test_library_main_ui_new.py:1015:29: ANN001 Missing type annotation for function argument `sid`
     |
1013 |     )
1014 |
1015 |     def fail_delete_snippet(sid):
     |                             ^^^ ANN001
1016 |         raise Exception("faildelsnip")
     |

tests\desktop_ui\test_library_main_ui_new.py:1026:5: ANN201 Missing return type annotation for public function `test_view_snippet_dialog`
     |
1026 | def test_view_snippet_dialog(monkeypatch, main_window):
     |     ^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
1027 |     # Ensure a category exists and is selected
1028 |     if not main_window.categories:
     |
     = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:1026:30: ANN001 Missing type annotation for function argument `monkeypatch`
     |
1026 | def test_view_snippet_dialog(monkeypatch, main_window):
     |                              ^^^^^^^^^^^ ANN001
1027 |     # Ensure a category exists and is selected
1028 |     if not main_window.categories:
     |

tests\desktop_ui\test_library_main_ui_new.py:1026:43: ANN001 Missing type annotation for function argument `main_window`
     |
1026 | def test_view_snippet_dialog(monkeypatch, main_window):
     |                                           ^^^^^^^^^^^ ANN001
1027 |     # Ensure a category exists and is selected
1028 |     if not main_window.categories:
     |

tests\desktop_ui\test_library_main_ui_new.py:1031:17: ANN202 Missing return type annotation for private function `exec_`
     |
1030 |         class FakeCatDialog:
1031 |             def exec_(self):
     |                 ^^^^^ ANN202
1032 |                 return 1
     |
     = help: Add return type annotation: `int`

tests\desktop_ui\test_library_main_ui_new.py:1034:17: ANN202 Missing return type annotation for private function `get_value`
     |
1032 |                 return 1
1033 |
1034 |             def get_value(self):
     |                 ^^^^^^^^^ ANN202
1035 |                 return "CatForView"
     |
     = help: Add return type annotation: `str`

tests\desktop_ui\test_library_main_ui_new.py:1044:17: ANN202 Missing return type annotation for private function `exec_`
     |
1043 |         class FakeSnipDialog:
1044 |             def exec_(self):
     |                 ^^^^^ ANN202
1045 |                 return 1
     |
     = help: Add return type annotation: `int`

tests\desktop_ui\test_library_main_ui_new.py:1047:17: ANN202 Missing return type annotation for private function `get_values`
     |
1045 |                 return 1
1046 |
1047 |             def get_values(self):
     |                 ^^^^^^^^^^ ANN202
1048 |                 return ("ViewMe", "Content")
     |
     = help: Add return type annotation

tests\desktop_ui\test_library_main_ui_new.py:1056:13: ANN204 Missing return type annotation for special method `__init__`
     |
1055 |     class FakeViewDialog:
1056 |         def __init__(self, **kwargs):
     |             ^^^^^^^^ ANN204
1057 |             called["shown"] = True
     |
     = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:1056:28: ANN003 Missing type annotation for `**kwargs`
     |
1055 |     class FakeViewDialog:
1056 |         def __init__(self, **kwargs):
     |                            ^^^^^^^^ ANN003
1057 |             called["shown"] = True
     |

tests\desktop_ui\test_library_main_ui_new.py:1059:13: ANN202 Missing return type annotation for private function `exec_`
     |
1057 |             called["shown"] = True
1058 |
1059 |         def exec_(self):
     |             ^^^^^ ANN202
1060 |             called["exec"] = True
     |
     = help: Add return type annotation: `None`

tests\desktop_ui\test_ngram_heatmap_dialog.py:8:1: I001 [*] Import block is un-sorted or un-formatted
   |
 6 |   """
 7 |
 8 | / import os
 9 | | import sys
10 | | from unittest.mock import Mock, patch, MagicMock
11 | |
12 | | import pytest
13 | | from PySide6 import QtWidgets, QtCore
   | |_____________________________________^ I001
14 |
15 |   # Ensure project root is in sys.path
   |
   = help: Organize imports

tests\desktop_ui\test_ngram_heatmap_dialog.py:18:1: I001 [*] Import block is un-sorted or un-formatted
   |
16 |   sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), "..", "..")))
17 |
18 | / from desktop_ui.ngram_heatmap_screen import NGramHeatmapDialog
19 | | from models.ngram_analytics_service import NGramHeatmapData
20 | | from models.user import User
21 | | from models.keyboard import Keyboard
   | |____________________________________^ I001
   |
   = help: Organize imports

tests\desktop_ui\test_users_and_keyboards.py:6:1: I001 [*] Import block is un-sorted or un-formatted
   |
 4 |   Updated to use PySide6 instead of PyQt5.
 5 |   """
 6 | / import pytest
 7 | | from typing import Generator, List, Tuple
 8 | | from unittest.mock import MagicMock, patch
 9 | | from PySide6 import QtCore, QtWidgets
10 | | from PySide6.QtCore import Qt
11 | | from pytestqt.qtbot import QtBot
12 | |
13 | | from db.database_manager import DatabaseManager
14 | | from desktop_ui.users_and_keyboards import UsersAndKeyboards
15 | | from models.keyboard import Keyboard
16 | | from models.keyboard_manager import KeyboardManager
17 | | from models.user import User
18 | | from models.user_manager import UserManager
   | |___________________________________________^ I001
19 |
20 |   # Test data constants
   |
   = help: Organize imports

tests\models\debug_session_tests.py:119:13: F841 Local variable `s` is assigned to but never used
    |
118 |         try:
119 |             s = Session.from_dict(data)
    |             ^ F841
120 |             print(f"Case {idx} passed successfully")
121 |             if expected_exception_type:
    |
    = help: Remove assignment to unused variable `s`

tests\models\debug_test_snippet_manager.py:11:121: E501 Line too long (121 > 120)
   |
 9 |     # Run the tests with detailed error reporting
10 |     # Run a specific test that might be failing
11 |     test_path = "tests/models/test_snippet_manager.py::TestCreateSnippet::test_create_snippet_pydantic_validation_errors"
   |                                                                                                                         ^ E501
12 |     print(f"\nRunning test: {test_path}\n")
13 |     exit_code = pytest.main([test_path, "-vv"])
   |

tests\models\import_test.py:10:39: F401 `models.ngram_analyzer.NGram` imported but unused; consider using `importlib.util.find_spec` to test for availability
   |
 8 | try:
 9 |     # Import and print what's available in the module
10 |     from models.ngram_analyzer import NGram, NGramAnalyzer
   |                                       ^^^^^ F401
11 |
12 |     print("Successfully imported NGramAnalyzer and NGram")
   |
   = help: Remove unused import

tests\models\import_test.py:10:46: F401 `models.ngram_analyzer.NGramAnalyzer` imported but unused; consider using `importlib.util.find_spec` to test for availability
   |
 8 | try:
 9 |     # Import and print what's available in the module
10 |     from models.ngram_analyzer import NGram, NGramAnalyzer
   |                                              ^^^^^^^^^^^^^ F401
11 |
12 |     print("Successfully imported NGramAnalyzer and NGram")
   |
   = help: Remove unused import

tests\models\import_test.py:16:43: F401 `models.ngram_analyzer.NGramStats` imported but unused; consider using `importlib.util.find_spec` to test for availability
   |
14 |     # Try to access the required imports that are failing
15 |     try:
16 |         from models.ngram_analyzer import NGramStats
   |                                           ^^^^^^^^^^ F401
17 |         print("NGramStats exists")
18 |     except ImportError:
   |
   = help: Remove unused import: `models.ngram_analyzer.NGramStats`

tests\models\import_test.py:22:43: F401 `models.ngram_analyzer.Session` imported but unused; consider using `importlib.util.find_spec` to test for availability
   |
21 |     try:
22 |         from models.ngram_analyzer import Session
   |                                           ^^^^^^^ F401
23 |         print("Session exists")
24 |     except ImportError:
   |
   = help: Remove unused import: `models.ngram_analyzer.Session`

tests\models\test_dynamic_content_manager.py:6:1: I001 [*] Import block is un-sorted or un-formatted
   |
 4 |   """
 5 |
 6 | / import pytest
 7 | | import random
 8 | | from unittest.mock import patch
 9 | | from typing import List, cast
10 | |
11 | | from models.dynamic_content_manager import DynamicContentManager, ContentMode
12 | | from models.llm_ngram_service import LLMNgramService
   | |____________________________________________________^ I001
   |
   = help: Organize imports

tests\models\test_keyboard.py:73:44: F841 Local variable `excinfo` is assigned to but never used
   |
71 | def test_keyboard_target_ms_none() -> None:
72 |     # Test that validator rejects None values
73 |     with pytest.raises(ValidationError) as excinfo:
   |                                            ^^^^^^^ F841
74 |         # We need to use a dict and model_validate to bypass Pydantic's type checking
75 |         # and test our explicit None validator
   |
   = help: Remove assignment to unused variable `excinfo`

tests\models\test_keystroke_manager.py:602:121: E501 Line too long (246 > 120)
    |
600 | 
601 | 
602 | pet_index_end, content, start_time, end_time, actual_chars, errors, ms_per_keystroke) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)",
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
603 | 
604 | 
    |

tests\models\test_keystroke_manager.py:684:121: E501 Line too long (250 > 120)
    |
682 | 
683 | 
684 | snippet_index_end, content, start_time, end_time, actual_chars, errors, ms_per_keystroke) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)",
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
685 | 
686 | 
    |

tests\models\test_llm_ngram_service.py:1:1: I001 [*] Import block is un-sorted or un-formatted
  |
1 | / from unittest.mock import patch
2 | | import pytest
3 | |
4 | | from models.llm_ngram_service import LLMMissingAPIKeyError, LLMNgramService
  | |___________________________________________________________________________^ I001
  |
  = help: Organize imports

tests\models\test_llm_ngram_service.py:7:5: ANN201 Missing return type annotation for public function `test_missing_api_key`
  |
7 | def test_missing_api_key():
  |     ^^^^^^^^^^^^^^^^^^^^ ANN201
8 |     with pytest.raises(LLMMissingAPIKeyError):
9 |         LLMNgramService(api_key=None)  # type: ignore
  |
  = help: Add return type annotation: `None`

tests\models\test_llm_ngram_service.py:12:5: ANN201 Missing return type annotation for public function `test_invalid_ngrams`
   |
12 | def test_invalid_ngrams():
   |     ^^^^^^^^^^^^^^^^^^^ ANN201
13 |     svc = LLMNgramService(api_key="sk-test")
14 |     with pytest.raises(ValueError):
   |
   = help: Add return type annotation: `None`

tests\models\test_next_session_position.py:18:1: E402 Module level import not at top of file
   |
16 |     sys.path.insert(0, project_root)
17 |
18 | from db.database_manager import DatabaseManager
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
19 | from models.session import Session
20 | from models.session_manager import SessionManager
   |

tests\models\test_next_session_position.py:19:1: E402 Module level import not at top of file
   |
18 | from db.database_manager import DatabaseManager
19 | from models.session import Session
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
20 | from models.session_manager import SessionManager
   |

tests\models\test_next_session_position.py:20:1: E402 Module level import not at top of file
   |
18 | from db.database_manager import DatabaseManager
19 | from models.session import Session
20 | from models.session_manager import SessionManager
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
   |

tests\models\test_next_session_position.py:24:5: ANN201 Missing return type annotation for public function `temp_db`
   |
23 | @pytest.fixture
24 | def temp_db():
   |     ^^^^^^^ ANN201
25 |     """Create a temporary in-memory database for testing."""
26 |     db_manager = DatabaseManager(":memory:")
   |
   = help: Add return type annotation

tests\models\test_next_session_position.py:151:5: F841 Local variable `snippet_length` is assigned to but never used
    |
149 |     session_manager = temp_db["session_manager"]
150 |     snippet_id = temp_db["snippet_id"]
151 |     snippet_length = len(temp_db["snippet_content"])
    |     ^^^^^^^^^^^^^^ F841
152 |
153 |     # Create a session with end position beyond actual snippet length (simulating content change)
    |
    = help: Remove assignment to unused variable `snippet_length`

tests\models\test_ngram.py:1:1: I001 [*] Import block is un-sorted or un-formatted
   |
 1 | / import uuid
 2 | | from datetime import datetime, timedelta, timezone
 3 | |
 4 | | import pytest
 5 | |
 6 | | from models.ngram import (
 7 | |     ErrorNGram,
 8 | |     Keystroke,
 9 | |     MIN_NGRAM_SIZE,
10 | |     MAX_NGRAM_SIZE,
11 | |     SpeedMode,
12 | |     SpeedNGram,
13 | |     has_sequence_separators,
14 | |     is_valid_ngram_text,
15 | |     nfc,
16 | | )
   | |_^ I001
   |
   = help: Organize imports

tests\models\test_ngram.py:9:5: F401 [*] `models.ngram.MIN_NGRAM_SIZE` imported but unused
   |
 7 |     ErrorNGram,
 8 |     Keystroke,
 9 |     MIN_NGRAM_SIZE,
   |     ^^^^^^^^^^^^^^ F401
10 |     MAX_NGRAM_SIZE,
11 |     SpeedMode,
   |
   = help: Remove unused import

tests\models\test_ngram.py:15:5: F401 [*] `models.ngram.nfc` imported but unused
   |
13 |     has_sequence_separators,
14 |     is_valid_ngram_text,
15 |     nfc,
   |     ^^^ F401
16 | )
   |
   = help: Remove unused import

tests\models\test_ngram.py:24:9: ANN201 Missing return type annotation for public function `test_keystroke_basic`
   |
23 | class TestKeystroke:
24 |     def test_keystroke_basic(self):
   |         ^^^^^^^^^^^^^^^^^^^^ ANN201
25 |         k = Keystroke(keystroke_time=ts(0), text_index=0, expected_char="a", keystroke_char="a", is_error=False)
26 |         assert k.expected_char == "a"
   |
   = help: Add return type annotation: `None`

tests\models\test_ngram.py:29:9: ANN201 Missing return type annotation for public function `test_keystroke_nfc_single_char`
   |
27 |         assert k.keystroke_char == "a"
28 |
29 |     def test_keystroke_nfc_single_char(self):
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
30 |         # composed e + 
31 |         k = Keystroke(keystroke_time=ts(0), text_index=0, expected_char="e\u0301", keystroke_char="", is_error=False)
   |
   = help: Add return type annotation: `None`

tests\models\test_ngram.py:37:9: ANN201 Missing return type annotation for public function `test_has_sequence_separators`
   |
36 | class TestNGramTextRules:
37 |     def test_has_sequence_separators(self):
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
38 |         assert has_sequence_separators("a b") is True
39 |         assert has_sequence_separators("ab") is False
   |
   = help: Add return type annotation: `None`

tests\models\test_ngram.py:41:9: ANN201 Missing return type annotation for public function `test_is_valid_ngram_text`
   |
39 |         assert has_sequence_separators("ab") is False
40 |
41 |     def test_is_valid_ngram_text(self):
   |         ^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
42 |         assert is_valid_ngram_text("ab") is True
43 |         assert is_valid_ngram_text("a") is False  # too short
   |
   = help: Add return type annotation: `None`

tests\models\test_ngram.py:48:9: ANN201 Missing return type annotation for public function `test_speed_ngram_computes_ms_per_keystroke`
   |
47 | class TestSpeedNGram:
48 |     def test_speed_ngram_computes_ms_per_keystroke(self):
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
49 |         ng = SpeedNGram(
50 |             id=uuid.uuid4(),
   |
   = help: Add return type annotation: `None`

tests\models\test_ngram.py:60:9: ANN201 Missing return type annotation for public function `test_speed_ngram_rejects_separators`
   |
58 |         assert ng.ms_per_keystroke == pytest.approx(50.0)
59 |
60 |     def test_speed_ngram_rejects_separators(self):
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
61 |         with pytest.raises(Exception):
62 |             SpeedNGram(
   |
   = help: Add return type annotation: `None`

tests\models\test_ngram.py:61:14: B017 Do not assert blind exception: `Exception`
   |
60 |     def test_speed_ngram_rejects_separators(self):
61 |         with pytest.raises(Exception):
   |              ^^^^^^^^^^^^^^^^^^^^^^^^ B017
62 |             SpeedNGram(
63 |                 id=uuid.uuid4(),
   |

tests\models\test_ngram.py:71:9: ANN201 Missing return type annotation for public function `test_speed_ngram_invalid_size`
   |
69 |             )
70 |
71 |     def test_speed_ngram_invalid_size(self):
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
72 |         with pytest.raises(Exception):
73 |             SpeedNGram(
   |
   = help: Add return type annotation: `None`

tests\models\test_ngram.py:72:14: B017 Do not assert blind exception: `Exception`
   |
71 |     def test_speed_ngram_invalid_size(self):
72 |         with pytest.raises(Exception):
   |              ^^^^^^^^^^^^^^^^^^^^^^^^ B017
73 |             SpeedNGram(
74 |                 id=uuid.uuid4(),
   |

tests\models\test_ngram.py:82:9: ANN201 Missing return type annotation for public function `test_speed_ngram_at_max_size`
   |
80 |             )
81 |
82 |     def test_speed_ngram_at_max_size(self):
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
83 |         text = "a" * MAX_NGRAM_SIZE
84 |         ng = SpeedNGram(
   |
   = help: Add return type annotation: `None`

tests\models\test_ngram.py:96:9: ANN201 Missing return type annotation for public function `test_speed_ngram_rejects_over_max`
   |
94 |         assert ng.ms_per_keystroke == pytest.approx(10.0)
95 |
96 |     def test_speed_ngram_rejects_over_max(self):
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
97 |         text = "a" * (MAX_NGRAM_SIZE + 1)
98 |         with pytest.raises(Exception):
   |
   = help: Add return type annotation: `None`

tests\models\test_ngram.py:98:14: B017 Do not assert blind exception: `Exception`
    |
 96 |     def test_speed_ngram_rejects_over_max(self):
 97 |         text = "a" * (MAX_NGRAM_SIZE + 1)
 98 |         with pytest.raises(Exception):
    |              ^^^^^^^^^^^^^^^^^^^^^^^^ B017
 99 |             SpeedNGram(
100 |                 id=uuid.uuid4(),
    |

tests\models\test_ngram.py:110:9: ANN201 Missing return type annotation for public function `test_error_ngram_pattern_last_char_only`
    |
109 | class TestErrorNGram:
110 |     def test_error_ngram_pattern_last_char_only(self):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
111 |         # differs only on last char
112 |         ErrorNGram(
    |
    = help: Add return type annotation: `None`

tests\models\test_ngram.py:121:9: ANN201 Missing return type annotation for public function `test_error_ngram_pattern_invalid_first_char`
    |
119 |         )
120 |
121 |     def test_error_ngram_pattern_invalid_first_char(self):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
122 |         with pytest.raises(Exception):
123 |             ErrorNGram(
    |
    = help: Add return type annotation: `None`

tests\models\test_ngram.py:122:14: B017 Do not assert blind exception: `Exception`
    |
121 |     def test_error_ngram_pattern_invalid_first_char(self):
122 |         with pytest.raises(Exception):
    |              ^^^^^^^^^^^^^^^^^^^^^^^^ B017
123 |             ErrorNGram(
124 |                 id=uuid.uuid4(),
    |

tests\models\test_ngram.py:132:9: ANN201 Missing return type annotation for public function `test_error_ngram_rejects_separators`
    |
130 |             )
131 |
132 |     def test_error_ngram_rejects_separators(self):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
133 |         with pytest.raises(Exception):
134 |             ErrorNGram(
    |
    = help: Add return type annotation: `None`

tests\models\test_ngram.py:133:14: B017 Do not assert blind exception: `Exception`
    |
132 |     def test_error_ngram_rejects_separators(self):
133 |         with pytest.raises(Exception):
    |              ^^^^^^^^^^^^^^^^^^^^^^^^ B017
134 |             ErrorNGram(
135 |                 id=uuid.uuid4(),
    |

tests\models\test_ngram.py:143:9: ANN201 Missing return type annotation for public function `test_error_ngram_at_max_size`
    |
141 |             )
142 |
143 |     def test_error_ngram_at_max_size(self):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
144 |         exp = "a" * (MAX_NGRAM_SIZE - 1) + "b"
145 |         act = "a" * (MAX_NGRAM_SIZE - 1) + "x"
    |
    = help: Add return type annotation: `None`

tests\models\test_ngram.py:156:9: ANN201 Missing return type annotation for public function `test_error_ngram_rejects_over_max`
    |
154 |         assert e.size == MAX_NGRAM_SIZE
155 |
156 |     def test_error_ngram_rejects_over_max(self):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
157 |         exp = "a" * MAX_NGRAM_SIZE + "b"
158 |         act = "a" * MAX_NGRAM_SIZE + "x"
    |
    = help: Add return type annotation: `None`

tests\models\test_ngram.py:159:14: B017 Do not assert blind exception: `Exception`
    |
157 |         exp = "a" * MAX_NGRAM_SIZE + "b"
158 |         act = "a" * MAX_NGRAM_SIZE + "x"
159 |         with pytest.raises(Exception):
    |              ^^^^^^^^^^^^^^^^^^^^^^^^ B017
160 |             ErrorNGram(
161 |                 id=uuid.uuid4(),
    |

tests\models\test_ngram_analytics_service.py:19:1: I001 [*] Import block is un-sorted or un-formatted
   |
17 |   sys.path.insert(0, "d:\\SeanDevLocal\\AITypingTrainer")
18 |
19 | / from db.database_manager import DatabaseManager
20 | | from models.ngram_analytics_service import (
21 | |     DecayingAverageCalculator,
22 | |     NGramAnalyticsService,
23 | |     NGramHeatmapData,
24 | |     NGramHistoricalData,
25 | |     NGramPerformanceData,
26 | | )
27 | | from models.ngram_manager import NGramManager
28 | |
29 | | # Import fixtures and types from conftest
30 | | # Note: do not import unused test-only types from conftest; prior names
31 | | # (MockNGramSpeedData, MockSessionData, ngram_speed_test_data) no longer exist.
32 | | from tests.models.conftest import MockNGramSpeedData, MockSessionData
   | |_____________________________________________________________________^ I001
   |
   = help: Organize imports

tests\models\test_ngram_analytics_service.py:199:38: F821 Undefined name `temp_db`
    |
197 |         over the specified time window.
198 |         """
199 |         ngram_manager = NGramManager(temp_db)
    |                                      ^^^^^^^ F821
200 |         service = NGramAnalyticsService(temp_db, ngram_manager)
    |

tests\models\test_ngram_analytics_service.py:200:41: F821 Undefined name `temp_db`
    |
198 |         """
199 |         ngram_manager = NGramManager(temp_db)
200 |         service = NGramAnalyticsService(temp_db, ngram_manager)
    |                                         ^^^^^^^ F821
201 |
202 |         # TODO: Set up test data
    |

tests\models\test_ngram_analytics_service.py:265:38: F821 Undefined name `temp_db`
    |
263 |         with proper parameter handling and filtering.
264 |         """
265 |         ngram_manager = NGramManager(temp_db)
    |                                      ^^^^^^^ F821
266 |         service = NGramAnalyticsService(temp_db, ngram_manager)
    |

tests\models\test_ngram_analytics_service.py:266:41: F821 Undefined name `temp_db`
    |
264 |         """
265 |         ngram_manager = NGramManager(temp_db)
266 |         service = NGramAnalyticsService(temp_db, ngram_manager)
    |                                         ^^^^^^^ F821
267 |
268 |         # Set up test data - create practice session and n-gram error data
    |

tests\models\test_ngram_analytics_service.py:274:9: F821 Undefined name `temp_db`
    |
273 |         # Insert test session with all required fields
274 |         temp_db.execute(
    |         ^^^^^^^ F821
275 |             """INSERT INTO practice_sessions 
276 |             (session_id, user_id, keyboard_id, snippet_id, snippet_index_start, snippet_index_end, 
    |

tests\models\test_ngram_analytics_service.py:296:9: F821 Undefined name `temp_db`
    |
295 |         # Insert test n-gram error data
296 |         temp_db.execute(
    |         ^^^^^^^ F821
297 |             "INSERT INTO session_ngram_errors (session_id, ngram_text, ngram_size) VALUES (?, ?, ?)",
298 |             (session_id, "th", 2),
    |

tests\models\test_ngram_analytics_service.py:300:9: F821 Undefined name `temp_db`
    |
298 |             (session_id, "th", 2),
299 |         )
300 |         temp_db.execute(
    |         ^^^^^^^ F821
301 |             "INSERT INTO session_ngram_errors (session_id, ngram_text, ngram_size) VALUES (?, ?, ?)",
302 |             (session_id, "the", 3),
    |

tests\models\test_ngram_analytics_service.py:304:9: F821 Undefined name `temp_db`
    |
302 |             (session_id, "the", 3),
303 |         )
304 |         temp_db.execute(
    |         ^^^^^^^ F821
305 |             "INSERT INTO session_ngram_errors (session_id, ngram_text, ngram_size) VALUES (?, ?, ?)",
306 |             (session_id, "er", 2),
    |

tests\models\test_ngram_analytics_service.py:309:9: F821 Undefined name `temp_db`
    |
307 |         )
308 |         # Add more occurrences to meet minimum count requirement
309 |         temp_db.execute(
    |         ^^^^^^^ F821
310 |             "INSERT INTO session_ngram_errors (session_id, ngram_text, ngram_size) VALUES (?, ?, ?)",
311 |             (session_id, "th", 2),
    |

tests\models\test_ngram_analytics_service.py:313:9: F821 Undefined name `temp_db`
    |
311 |             (session_id, "th", 2),
312 |         )
313 |         temp_db.execute(
    |         ^^^^^^^ F821
314 |             "INSERT INTO session_ngram_errors (session_id, ngram_text, ngram_size) VALUES (?, ?, ?)",
315 |             (session_id, "the", 3),
    |

tests\models\test_ngram_analytics_service.py:614:9: F841 Local variable `service` is assigned to but never used
    |
612 |         """
613 |         ngram_manager = NGramManager(temp_db)
614 |         service = NGramAnalyticsService(temp_db, ngram_manager)
    |         ^^^^^^^ F841
615 |
616 |         # Verify table schemas are compatible
    |
    = help: Remove assignment to unused variable `service`

tests\models\test_ngram_analytics_service_session_methods.py:63:9: ANN201 Missing return type annotation for public function `test_summarize_with_ngram_speed_only`
   |
61 |         (3, 3),  # Multiple ngram speed entries
62 |     ])
63 |     def test_summarize_with_ngram_speed_only(
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
64 |         self, 
65 |         analytics_service: NGramAnalyticsService,
   |
   = help: Add return type annotation: `None`

tests\models\test_ngram_analytics_service_session_methods.py:111:9: ANN201 Missing return type annotation for public function `test_summarize_with_ngram_errors_only`
    |
109 |         (2, 2),  # Multiple error entries
110 |     ])
111 |     def test_summarize_with_ngram_errors_only(
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
112 |         self,
113 |         analytics_service: NGramAnalyticsService,
    |
    = help: Add return type annotation: `None`

tests\models\test_ngram_analytics_service_session_methods.py:133:13: B007 Loop control variable `i` not used within loop body
    |
131 |         # Create error data
132 |         error_data = []
133 |         for i in range(error_count):
    |             ^ B007
134 |             error_data.append({
135 |                 'ngram_size': 2,
    |
    = help: Rename unused `i` to `_i`

tests\models\test_ngram_analytics_service_session_methods.py:156:9: ANN201 Missing return type annotation for public function `test_summarize_with_speed_and_errors`
    |
154 |         assert summary_records[0]['error_count'] == expected_errors
155 |     
156 |     def test_summarize_with_speed_and_errors(
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
157 |         self,
158 |         analytics_service: NGramAnalyticsService,
    |
    = help: Add return type annotation: `None`

tests\models\test_ngram_analytics_service_session_methods.py:217:9: ANN201 Missing return type annotation for public function `test_summarize_with_keystrokes`
    |
215 |         (3, 3),  # Multiple keystrokes
216 |     ])
217 |     def test_summarize_with_keystrokes(
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
218 |         self,
219 |         analytics_service: NGramAnalyticsService,
    |
    = help: Add return type annotation: `None`

tests\models\test_ngram_analytics_service_session_methods.py:262:9: ANN201 Missing return type annotation for public function `test_no_sessions_missing`
    |
260 |             assert record['avg_ms_per_keystroke'] > 0
261 |     
262 |     def test_no_sessions_missing(
    |         ^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
263 |         self,
264 |         analytics_service: NGramAnalyticsService,
    |
    = help: Add return type annotation: `None`

tests\models\test_ngram_analytics_service_session_methods.py:293:9: ANN201 Missing return type annotation for public function `test_sessions_missing_no_data`
    |
291 |         assert result == 0
292 |     
293 |     def test_sessions_missing_no_data(
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
294 |         self,
295 |         analytics_service: NGramAnalyticsService,
    |
    = help: Add return type annotation: `None`

tests\models\test_ngram_analytics_service_session_methods.py:311:9: ANN201 Missing return type annotation for public function `test_single_session_processing`
    |
309 |     """Test cases for AddSpeedSummaryForSession method."""
310 |     
311 |     def test_single_session_processing(
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
312 |         self,
313 |         analytics_service: NGramAnalyticsService,
    |
    = help: Add return type annotation: `None`

tests\models\test_ngram_analytics_service_session_methods.py:346:9: ANN201 Missing return type annotation for public function `test_nonexistent_session`
    |
344 |         assert result['curr_updated'] >= 0
345 |     
346 |     def test_nonexistent_session(
    |         ^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
347 |         self,
348 |         analytics_service: NGramAnalyticsService
    |
    = help: Add return type annotation: `None`

tests\models\test_ngram_analytics_service_session_methods.py:356:9: ANN201 Missing return type annotation for public function `test_multiple_ngrams_processing`
    |
354 |             analytics_service.add_speed_summary_for_session(fake_session_id)
355 |     
356 |     def test_multiple_ngrams_processing(
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
357 |         self,
358 |         analytics_service: NGramAnalyticsService,
    |
    = help: Add return type annotation: `None`

tests\models\test_ngram_analytics_service_session_methods.py:405:9: ANN201 Missing return type annotation for public function `test_empty_database_catchup`
    |
403 |     """Test cases for CatchupSpeedSummary method."""
404 |     
405 |     def test_empty_database_catchup(
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
406 |         self,
407 |         analytics_service: NGramAnalyticsService
    |
    = help: Add return type annotation: `None`

tests\models\test_ngram_analytics_service_session_methods.py:417:9: ANN201 Missing return type annotation for public function `test_single_session_catchup`
    |
415 |         assert result['total_curr_updated'] == 0
416 |     
417 |     def test_single_session_catchup(
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
418 |         self,
419 |         analytics_service: NGramAnalyticsService,
    |
    = help: Add return type annotation: `None`

tests\models\test_ngram_analytics_service_session_methods.py:451:9: ANN201 Missing return type annotation for public function `test_multiple_sessions_catchup`
    |
449 |         assert result['total_curr_updated'] >= 0
450 |     
451 |     def test_multiple_sessions_catchup(
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
452 |         self,
453 |         analytics_service: NGramAnalyticsService,
    |
    = help: Add return type annotation: `None`

tests\models\test_ngram_analytics_service_session_methods.py:486:9: ANN201 Missing return type annotation for public function `test_catchup_with_session_errors`
    |
484 |         # (verified by the method's internal logging)
485 |     
486 |     def test_catchup_with_session_errors(
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
487 |         self,
488 |         analytics_service: NGramAnalyticsService,
    |
    = help: Add return type annotation: `None`

tests\models\test_ngram_analytics_service_session_methods.py:524:9: ANN201 Missing return type annotation for public function `test_full_workflow_integration`
    |
522 |     """Integration tests combining multiple methods."""
523 |     
524 |     def test_full_workflow_integration(
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
525 |         self,
526 |         analytics_service: NGramAnalyticsService,
    |
    = help: Add return type annotation: `None`

tests\models\test_ngram_manager.py:1:1: I001 [*] Import block is un-sorted or un-formatted
  |
1 | / import uuid
2 | | from datetime import datetime, timedelta, timezone
3 | | import sqlite3
4 | | import pytest
5 | |
6 | | from models.ngram_manager import NGramManager
7 | | from models.ngram import Keystroke, SpeedMode, MAX_NGRAM_SIZE
  | |_____________________________________________________________^ I001
  |
  = help: Organize imports

tests\models\test_ngram_manager.py:3:8: F401 [*] `sqlite3` imported but unused
  |
1 | import uuid
2 | from datetime import datetime, timedelta, timezone
3 | import sqlite3
  |        ^^^^^^^ F401
4 | import pytest
  |
  = help: Remove unused import: `sqlite3`

tests\models\test_ngram_manager.py:7:37: F401 [*] `models.ngram.SpeedMode` imported but unused
  |
6 | from models.ngram_manager import NGramManager
7 | from models.ngram import Keystroke, SpeedMode, MAX_NGRAM_SIZE
  |                                     ^^^^^^^^^ F401
  |
  = help: Remove unused import

tests\models\test_ngram_manager.py:7:48: F401 [*] `models.ngram.MAX_NGRAM_SIZE` imported but unused
  |
6 | from models.ngram_manager import NGramManager
7 | from models.ngram import Keystroke, SpeedMode, MAX_NGRAM_SIZE
  |                                                ^^^^^^^^^^^^^^ F401
  |
  = help: Remove unused import

tests\models\test_ngram_manager.py:14:5: ANN201 Missing return type annotation for public function `make_k`
   |
14 | def make_k(text: str, start_ms: int = 0, step_ms: int = 100):
   |     ^^^^^^ ANN201
15 |     # Build keystrokes for expected text with perfect typing
16 |     ks = []
   |
   = help: Add return type annotation

tests\models\test_ngram_manager.py:25:9: ANN201 Missing return type annotation for public function `test_clean_windows_and_gross_up`
   |
24 | class TestAnalyzeBasic:
25 |     def test_clean_windows_and_gross_up(self):
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
26 |         mgr = NGramManager()
27 |         expected = "Then"  # no separators
   |
   = help: Add return type annotation: `None`

tests\models\test_ngram_manager.py:43:9: ANN201 Missing return type annotation for public function `test_ignored_zero_duration`
   |
41 |         assert first4.duration_ms == pytest.approx(2666.6666666667, rel=1e-3)
42 |
43 |     def test_ignored_zero_duration(self):
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
44 |         mgr = NGramManager()
45 |         expected = "ab"
   |
   = help: Add return type annotation: `None`

tests\models\test_ngram_manager.py:53:9: ANN201 Missing return type annotation for public function `test_separators_split_runs`
   |
51 |         assert speed == [] and errors == []
52 |
53 |     def test_separators_split_runs(self):
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
54 |         mgr = NGramManager()
55 |         expected = "hi there"  # space splits
   |
   = help: Add return type annotation: `None`

tests\models\test_ngram_manager.py:64:9: ANN201 Missing return type annotation for public function `test_error_last_only`
   |
63 | class TestErrorClassification:
64 |     def test_error_last_only(self):
   |         ^^^^^^^^^^^^^^^^^^^^ ANN201
65 |         mgr = NGramManager()
66 |         expected = "th"
   |
   = help: Add return type annotation: `None`

tests\models\test_ngram_manager.py:80:9: ANN201 Missing return type annotation for public function `test_error_not_last_is_ignored`
   |
78 |         assert err.duration_ms > 0
79 |
80 |     def test_error_not_last_is_ignored(self):
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
81 |         mgr = NGramManager()
82 |         expected = "th"
   |
   = help: Add return type annotation: `None`

tests\models\test_ngram_orchestrator_process_end_of_session.py:36:5: ANN201 Missing return type annotation for public function `test_process_end_of_session_success_path`
   |
36 | def test_process_end_of_session_success_path(db_with_tables, test_user, test_keyboard):
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
37 |     # Arrange: create snippet (for FK completeness) and a new Session not yet in DB
38 |     from tests.models.conftest import TestSessionMethodsFixtures
   |
   = help: Add return type annotation: `None`

tests\models\test_ngram_orchestrator_process_end_of_session.py:36:46: ANN001 Missing type annotation for function argument `db_with_tables`
   |
36 | def test_process_end_of_session_success_path(db_with_tables, test_user, test_keyboard):
   |                                              ^^^^^^^^^^^^^^ ANN001
37 |     # Arrange: create snippet (for FK completeness) and a new Session not yet in DB
38 |     from tests.models.conftest import TestSessionMethodsFixtures
   |

tests\models\test_ngram_orchestrator_process_end_of_session.py:36:62: ANN001 Missing type annotation for function argument `test_user`
   |
36 | def test_process_end_of_session_success_path(db_with_tables, test_user, test_keyboard):
   |                                                              ^^^^^^^^^ ANN001
37 |     # Arrange: create snippet (for FK completeness) and a new Session not yet in DB
38 |     from tests.models.conftest import TestSessionMethodsFixtures
   |

tests\models\test_ngram_orchestrator_process_end_of_session.py:36:73: ANN001 Missing type annotation for function argument `test_keyboard`
   |
36 | def test_process_end_of_session_success_path(db_with_tables, test_user, test_keyboard):
   |                                                                         ^^^^^^^^^^^^^ ANN001
37 |     # Arrange: create snippet (for FK completeness) and a new Session not yet in DB
38 |     from tests.models.conftest import TestSessionMethodsFixtures
   |

tests\models\test_ngram_orchestrator_process_end_of_session.py:124:5: ANN201 Missing return type annotation for public function `test_process_end_of_session_session_save_failure`
    |
124 | def test_process_end_of_session_session_save_failure(db_with_tables, test_user):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
125 |     """Fails at step 1: session save should raise due to FK violation (invalid keyboard_id)."""
126 |     from tests.models.conftest import TestSessionMethodsFixtures
    |
    = help: Add return type annotation: `None`

tests\models\test_ngram_orchestrator_process_end_of_session.py:124:54: ANN001 Missing type annotation for function argument `db_with_tables`
    |
124 | def test_process_end_of_session_session_save_failure(db_with_tables, test_user):
    |                                                      ^^^^^^^^^^^^^^ ANN001
125 |     """Fails at step 1: session save should raise due to FK violation (invalid keyboard_id)."""
126 |     from tests.models.conftest import TestSessionMethodsFixtures
    |

tests\models\test_ngram_orchestrator_process_end_of_session.py:124:70: ANN001 Missing type annotation for function argument `test_user`
    |
124 | def test_process_end_of_session_session_save_failure(db_with_tables, test_user):
    |                                                                      ^^^^^^^^^ ANN001
125 |     """Fails at step 1: session save should raise due to FK violation (invalid keyboard_id)."""
126 |     from tests.models.conftest import TestSessionMethodsFixtures
    |

tests\models\test_ngram_orchestrator_process_end_of_session.py:166:5: ANN201 Missing return type annotation for public function `test_process_end_of_session_keystrokes_save_failure`
    |
166 | def test_process_end_of_session_keystrokes_save_failure(db_with_tables, test_user, test_keyboard):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
167 |     """Fails at step 2: keystrokes save should return False due to invalid keystroke session_id."""
168 |     from tests.models.conftest import TestSessionMethodsFixtures
    |
    = help: Add return type annotation: `None`

tests\models\test_ngram_orchestrator_process_end_of_session.py:166:57: ANN001 Missing type annotation for function argument `db_with_tables`
    |
166 | def test_process_end_of_session_keystrokes_save_failure(db_with_tables, test_user, test_keyboard):
    |                                                         ^^^^^^^^^^^^^^ ANN001
167 |     """Fails at step 2: keystrokes save should return False due to invalid keystroke session_id."""
168 |     from tests.models.conftest import TestSessionMethodsFixtures
    |

tests\models\test_ngram_orchestrator_process_end_of_session.py:166:73: ANN001 Missing type annotation for function argument `test_user`
    |
166 | def test_process_end_of_session_keystrokes_save_failure(db_with_tables, test_user, test_keyboard):
    |                                                                         ^^^^^^^^^ ANN001
167 |     """Fails at step 2: keystrokes save should return False due to invalid keystroke session_id."""
168 |     from tests.models.conftest import TestSessionMethodsFixtures
    |

tests\models\test_ngram_orchestrator_process_end_of_session.py:166:84: ANN001 Missing type annotation for function argument `test_keyboard`
    |
166 | def test_process_end_of_session_keystrokes_save_failure(db_with_tables, test_user, test_keyboard):
    |                                                                                    ^^^^^^^^^^^^^ ANN001
167 |     """Fails at step 2: keystrokes save should return False due to invalid keystroke session_id."""
168 |     from tests.models.conftest import TestSessionMethodsFixtures
    |

tests\models\test_ngram_orchestrator_process_end_of_session.py:215:5: ANN201 Missing return type annotation for public function `test_process_end_of_session_summarization_failure`
    |
215 | def test_process_end_of_session_summarization_failure(db_with_tables, test_user, test_keyboard):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
216 |     """Fails at step 4: drop summary table to force summarization SQL to fail after n-grams."""
217 |     from tests.models.conftest import TestSessionMethodsFixtures
    |
    = help: Add return type annotation: `None`

tests\models\test_ngram_orchestrator_process_end_of_session.py:215:55: ANN001 Missing type annotation for function argument `db_with_tables`
    |
215 | def test_process_end_of_session_summarization_failure(db_with_tables, test_user, test_keyboard):
    |                                                       ^^^^^^^^^^^^^^ ANN001
216 |     """Fails at step 4: drop summary table to force summarization SQL to fail after n-grams."""
217 |     from tests.models.conftest import TestSessionMethodsFixtures
    |

tests\models\test_ngram_orchestrator_process_end_of_session.py:215:71: ANN001 Missing type annotation for function argument `test_user`
    |
215 | def test_process_end_of_session_summarization_failure(db_with_tables, test_user, test_keyboard):
    |                                                                       ^^^^^^^^^ ANN001
216 |     """Fails at step 4: drop summary table to force summarization SQL to fail after n-grams."""
217 |     from tests.models.conftest import TestSessionMethodsFixtures
    |

tests\models\test_ngram_orchestrator_process_end_of_session.py:215:82: ANN001 Missing type annotation for function argument `test_keyboard`
    |
215 | def test_process_end_of_session_summarization_failure(db_with_tables, test_user, test_keyboard):
    |                                                                                  ^^^^^^^^^^^^^ ANN001
216 |     """Fails at step 4: drop summary table to force summarization SQL to fail after n-grams."""
217 |     from tests.models.conftest import TestSessionMethodsFixtures
    |

tests\models\test_simple.py:5:5: ANN201 Missing return type annotation for public function `test_simple`
  |
3 | """
4 |
5 | def test_simple():
  |     ^^^^^^^^^^^ ANN201
6 |     """A simple test that should always pass."""
7 |     assert 1 + 1 == 2
  |
  = help: Add return type annotation: `None`

tests\models\test_snippet.py:593:5: F811 Redefinition of unused `test_update_nonexistent_snippet` from line 421
    |
593 | def test_update_nonexistent_snippet(snippet_manager: SnippetManager) -> None:
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ F811
594 |     """Test updating a snippet that does not exist."""
595 |     non_existent_snippet_id = str(uuid.uuid4())
    |
    = help: Remove definition: `test_update_nonexistent_snippet`

tests\models\test_user_manager_fixes.py:6:1: I001 [*] Import block is un-sorted or un-formatted
   |
 4 |   """
 5 |
 6 | / import pytest
 7 | | from unittest.mock import Mock, MagicMock
 8 | | from typing import Dict, Any, List
 9 | | import uuid
10 | |
11 | | from models.user_manager import UserManager, UserNotFound, UserValidationError
12 | | from models.user import User
   | |____________________________^ I001
   |
   = help: Organize imports

tests\models\test_user_manager_fixes.py:7:33: F401 [*] `unittest.mock.MagicMock` imported but unused
  |
6 | import pytest
7 | from unittest.mock import Mock, MagicMock
  |                                 ^^^^^^^^^ F401
8 | from typing import Dict, Any, List
9 | import uuid
  |
  = help: Remove unused import: `unittest.mock.MagicMock`

tests\models\test_user_manager_fixes.py:12:25: F401 [*] `models.user.User` imported but unused
   |
11 | from models.user_manager import UserManager, UserNotFound, UserValidationError
12 | from models.user import User
   |                         ^^^^ F401
   |
   = help: Remove unused import: `models.user.User`

web_ui\__init_LLM_ngrams__.py:9:5: ANN201 Missing return type annotation for public function `ngram_words_page`
   |
 8 | @web_ui.route("/ngram-words", methods=["GET"])
 9 | def ngram_words_page():
   |     ^^^^^^^^^^^^^^^^ ANN201
10 |     return render_template("ngram_words.html")
   |
   = help: Add return type annotation

web_ui\__init_LLM_ngrams__.py:14:5: ANN201 Missing return type annotation for public function `api_ngram_words`
   |
13 | @web_ui.route("/api/ngram-words", methods=["POST"])
14 | def api_ngram_words():
   |     ^^^^^^^^^^^^^^^ ANN201
15 |     data = request.get_json()
16 |     snippets = data.get("snippets", [])
   |
   = help: Add return type annotation

web_ui\__init_LLM_ngrams__.py:27:13: F821 Undefined name `os`
   |
25 |     try:
26 |         with open(
27 |             os.path.join(os.path.dirname(__file__), "../Keys/OpenAPI_Key.txt"), "r"
   |             ^^ F821
28 |         ) as f:
29 |             openai.api_key = f.read().strip()
   |

web_ui\__init_LLM_ngrams__.py:27:26: F821 Undefined name `os`
   |
25 |     try:
26 |         with open(
27 |             os.path.join(os.path.dirname(__file__), "../Keys/OpenAPI_Key.txt"), "r"
   |                          ^^ F821
28 |         ) as f:
29 |             openai.api_key = f.read().strip()
   |

web_ui\__init_LLM_ngrams__.py:38:121: E501 Line too long (340 > 120)
   |
36 | 
37 | 
38 | ngrams {ngrams}. Can you please assemble this list in random order into a space delimited string, with a maximum length of {max_length} characters. I'm OK if you repeat certain words, and also if you include the actual ngram.
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
39 | 
   |

web_ui\__init_LLM_ngrams__.py:51:5: F841 Local variable `generated_text` is assigned to but never used
   |
49 |     )
50 |
51 |     generated_text = response.choices[0].text.strip()
   |     ^^^^^^^^^^^^^^ F841
52 |
53 |     # --- Replace this with your OpenAI API key and call if available ---
   |
   = help: Remove assignment to unused variable `generated_text`

Found 730 errors.
[*] 65 fixable with the `--fix` option (247 hidden fixes can be enabled with the `--unsafe-fixes` option).
============================= test session starts =============================
platform win32 -- Python 3.13.2, pytest-8.4.1, pluggy-1.6.0 -- D:\SeanDevLocal\AITypingTrainer\.venv\Scripts\python.exe
cachedir: .pytest_cache
PySide6 6.9.1 -- Qt runtime 6.9.1 -- Qt compiled 6.9.1
rootdir: D:\SeanDevLocal\AITypingTrainer
configfile: pytest.ini
plugins: anyio-4.10.0, cov-6.2.1, mock-3.14.1, qt-4.5.0
collecting ... collected 509 items

tests/models/test_category.py::TestCategoryModel::test_category_creation_valid PASSED [  0%]
tests/models/test_category.py::TestCategoryModel::test_category_name_validation[-Category name cannot be blank.] PASSED [  0%]
tests/models/test_category.py::TestCategoryModel::test_category_name_validation[   -Category name cannot be blank.] PASSED [  0%]
tests/models/test_category.py::TestCategoryModel::test_category_name_validation[AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA-Category name must be at most 64 characters.] PASSED [  0%]
tests/models/test_category.py::TestCategoryModel::test_category_name_validation[NonASCII\xd1ame-Category name must be ASCII-only.] PASSED [  0%]
tests/models/test_category.py::TestCategoryModel::test_category_exceptions_instantiable PASSED [  1%]
tests/models/test_category.py::TestCategoryModel::test_category_init_autogenerates_id PASSED [  1%]
tests/models/test_category.py::TestCategoryModel::test_category_from_dict_valid_and_extra_fields PASSED [  1%]
tests/models/test_category.py::TestCategoryModel::test_category_to_dict PASSED [  1%]
tests/models/test_category.py::TestCategoryModel::test_category_field_type_and_value_errors[category_id-123-Input should be a valid string] PASSED [  1%]
tests/models/test_category.py::TestCategoryModel::test_category_field_type_and_value_errors[category_id-not-a-uuid-category_id must be a valid UUID string] PASSED [  2%]
tests/models/test_category.py::TestCategoryModel::test_category_field_type_and_value_errors[category_name-None-Input should be a valid string] PASSED [  2%]
tests/models/test_category.py::TestCategoryModel::test_category_field_type_and_value_errors[category_name--Category name cannot be blank] PASSED [  2%]
tests/models/test_category.py::TestCategoryModel::test_category_field_type_and_value_errors[category_name- -Category name cannot be blank] PASSED [  2%]
tests/models/test_category.py::TestCategoryModel::test_category_field_type_and_value_errors[category_name-AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA-Category name must be at most 64 characters] PASSED [  2%]
tests/models/test_category.py::TestCategoryModel::test_category_field_type_and_value_errors[category_name-NonASCII\xd1ame-Category name must be ASCII-only] PASSED [  3%]
tests/models/test_category.py::TestCategoryModel::test_category_db_rows_fail_validation PASSED [  3%]
tests/models/test_category_manager.py::TestCategoryManager::test_create_category_valid PASSED [  3%]
tests/models/test_category_manager.py::TestCategoryManager::test_create_category_invalid_format[-blank] PASSED [  3%]
tests/models/test_category_manager.py::TestCategoryManager::test_create_category_invalid_format[  -blank] PASSED [  3%]
tests/models/test_category_manager.py::TestCategoryManager::test_create_category_invalid_format[AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA-at most 64 characters] PASSED [  4%]
tests/models/test_category_manager.py::TestCategoryManager::test_create_category_invalid_format[Caf\xe9 NonASCII-ASCII-only] PASSED [  4%]
tests/models/test_category_manager.py::TestCategoryManager::test_create_category_duplicate_name PASSED [  4%]
tests/models/test_category_manager.py::TestCategoryManager::test_get_category_by_id PASSED [  4%]
tests/models/test_category_manager.py::TestCategoryManager::test_get_category_by_id_not_found PASSED [  4%]
tests/models/test_category_manager.py::TestCategoryManager::test_get_category_by_id_invalid_uuid PASSED [  5%]
tests/models/test_category_manager.py::TestCategoryManager::test_get_category_by_name PASSED [  5%]
tests/models/test_category_manager.py::TestCategoryManager::test_get_category_by_name_not_found PASSED [  5%]
tests/models/test_category_manager.py::TestCategoryManager::test_get_category_by_name_case_sensitive PASSED [  5%]
tests/models/test_category_manager.py::TestCategoryManager::test_list_all_categories_empty PASSED [  5%]
tests/models/test_category_manager.py::TestCategoryManager::test_list_all_categories_populated PASSED [  6%]
tests/models/test_category_manager.py::TestCategoryManager::test_update_category_valid_name PASSED [  6%]
tests/models/test_category_manager.py::TestCategoryManager::test_update_category_invalid_format[-blank] PASSED [  6%]
tests/models/test_category_manager.py::TestCategoryManager::test_update_category_invalid_format[AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA-at most 64 characters] PASSED [  6%]
tests/models/test_category_manager.py::TestCategoryManager::test_update_category_invalid_format[Caf\xe9 Again-ASCII-only] PASSED [  6%]
tests/models/test_category_manager.py::TestCategoryManager::test_update_category_to_duplicate_name PASSED [  7%]
tests/models/test_category_manager.py::TestCategoryManager::test_update_category_to_case_variant_duplicate PASSED [  7%]
tests/models/test_category_manager.py::TestCategoryManager::test_update_category_to_same_name PASSED [  7%]
tests/models/test_category_manager.py::TestCategoryManager::test_delete_category_by_id PASSED [  7%]
tests/models/test_category_manager.py::TestCategoryManager::test_delete_category_by_id_invalid_uuid PASSED [  7%]
tests/models/test_category_manager.py::TestCategoryManager::test_delete_nonexistent_category PASSED [  8%]
tests/models/test_category_manager.py::TestCategoryManager::test_delete_all_categories PASSED [  8%]
tests/models/test_category_manager.py::TestCategoryManager::test_category_validation_blank_and_duplicate PASSED [  8%]
tests/models/test_category_manager.py::TestCategoryManager::test_save_category_non_string_name PASSED [  8%]
tests/models/test_category_manager.py::TestCategoryManager::test_delete_category_alias PASSED [  8%]
tests/models/test_category_manager.py::TestCategoryManager::test_save_category_unexpected_db_error PASSED [  9%]
tests/models/test_dynamic_content_manager.py::TestDynamicContentManagerInitialization::test_init_with_valid_params PASSED [  9%]
tests/models/test_dynamic_content_manager.py::TestDynamicContentManagerInitialization::test_init_with_defaults PASSED [  9%]
tests/models/test_dynamic_content_manager.py::TestDynamicContentManagerInitialization::test_invalid_practice_length_too_small PASSED [  9%]
tests/models/test_dynamic_content_manager.py::TestDynamicContentManagerInitialization::test_invalid_practice_length_too_large PASSED [  9%]
tests/models/test_dynamic_content_manager.py::TestDynamicContentManagerInitialization::test_invalid_practice_length_type PASSED [ 10%]
tests/models/test_dynamic_content_manager.py::TestDynamicContentManagerInitialization::test_mode_setter_with_string PASSED [ 10%]
tests/models/test_dynamic_content_manager.py::TestDynamicContentManagerInitialization::test_mode_setter_with_invalid_string PASSED [ 10%]
tests/models/test_dynamic_content_manager.py::TestDynamicContentManagerInitialization::test_mode_setter_with_enum PASSED [ 10%]
tests/models/test_dynamic_content_manager.py::TestDynamicContentManagerValidation::test_validate_missing_ngrams PASSED [ 10%]
tests/models/test_dynamic_content_manager.py::TestDynamicContentManagerValidation::test_validate_missing_in_scope_keys PASSED [ 11%]
tests/models/test_dynamic_content_manager.py::TestDynamicContentManagerValidation::test_validate_missing_llm_service_for_words_mode PASSED [ 11%]
tests/models/test_dynamic_content_manager.py::TestDynamicContentManagerValidation::test_validate_missing_llm_service_for_mixed_mode PASSED [ 11%]
tests/models/test_dynamic_content_manager.py::TestNGramOnlyMode::test_generate_ngram_content FAILED [ 11%]
tests/models/test_dynamic_content_manager.py::TestNGramOnlyMode::test_ngram_content_custom_delimiter PASSED [ 11%]
tests/models/test_dynamic_content_manager.py::TestNGramOnlyMode::test_ngram_content_respects_length_limit PASSED [ 11%]
tests/models/test_dynamic_content_manager.py::TestNGramOnlyMode::test_ngram_content_filters_out_of_scope_chars FAILED [ 12%]
tests/models/test_dynamic_content_manager.py::TestWordsOnlyMode::test_generate_words_content PASSED [ 12%]
tests/models/test_dynamic_content_manager.py::TestWordsOnlyMode::test_words_content_filters_out_of_scope_chars PASSED [ 12%]
tests/models/test_dynamic_content_manager.py::TestWordsOnlyMode::test_words_content_custom_delimiter PASSED [ 12%]
tests/models/test_dynamic_content_manager.py::TestMixedMode::test_generate_mixed_content PASSED [ 12%]
tests/models/test_dynamic_content_manager.py::TestMixedMode::test_mixed_content_has_variety FAILED [ 13%]
tests/models/test_keyboard.py::test_keyboard_valid PASSED                [ 13%]
tests/models/test_keyboard.py::test_keyboard_empty_name PASSED           [ 13%]
tests/models/test_keyboard.py::test_keyboard_name_strip PASSED           [ 13%]
tests/models/test_keyboard.py::test_keyboard_default_target_ms PASSED    [ 13%]
tests/models/test_keyboard.py::test_keyboard_custom_target_ms PASSED     [ 14%]
tests/models/test_keyboard.py::test_keyboard_target_ms_too_low PASSED    [ 14%]
tests/models/test_keyboard.py::test_keyboard_target_ms_too_high PASSED   [ 14%]
tests/models/test_keyboard.py::test_keyboard_target_ms_none PASSED       [ 14%]
tests/models/test_keyboard_manager.py::test_create_keyboard PASSED       [ 14%]
tests/models/test_keyboard_manager.py::test_get_keyboard PASSED          [ 15%]
tests/models/test_keyboard_manager.py::test_update_keyboard_name PASSED  [ 15%]
tests/models/test_keyboard_manager.py::test_update_keyboard_target_speed PASSED [ 15%]
tests/models/test_keyboard_manager.py::test_delete_keyboard PASSED       [ 15%]
tests/models/test_keystroke.py::TestKeystrokeCreation::test_keystroke_creation_with_valid_data PASSED [ 15%]
tests/models/test_keystroke.py::TestKeystrokeCreation::test_keystroke_creation_with_defaults PASSED [ 16%]
tests/models/test_keystroke.py::TestKeystrokeCreation::test_keystroke_id_auto_generation PASSED [ 16%]
tests/models/test_keystroke.py::TestKeystrokeCreation::test_keystroke_time_auto_generation PASSED [ 16%]
tests/models/test_keystroke.py::TestKeystrokeCreation::test_keystroke_with_none_session_id PASSED [ 16%]
tests/models/test_keystroke.py::TestKeystrokeCreation::test_keystroke_with_error_true PASSED [ 16%]
tests/models/test_keystroke.py::TestKeystrokeCreation::test_keystroke_with_empty_strings PASSED [ 17%]
tests/models/test_keystroke.py::TestKeystrokeCreation::test_keystroke_with_valid_text_index PASSED [ 17%]
tests/models/test_keystroke.py::TestKeystrokeCreation::test_keystroke_with_negative_text_index_raises_error PASSED [ 17%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_with_valid_data PASSED [ 17%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_with_minimal_data PASSED [ 17%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_datetime_iso_string PASSED [ 18%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_datetime_iso_string_with_z PASSED [ 18%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_invalid_datetime_string PASSED [ 18%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_non_datetime_object PASSED [ 18%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_is_error_string_values[true-True] PASSED [ 18%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_is_error_string_values[True-True] PASSED [ 19%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_is_error_string_values[1-True] PASSED [ 19%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_is_error_string_values[t-True] PASSED [ 19%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_is_error_string_values[y-True] PASSED [ 19%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_is_error_string_values[yes-True] PASSED [ 19%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_is_error_string_values[false-False] PASSED [ 20%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_is_error_string_values[False-False] PASSED [ 20%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_is_error_string_values[0-False] PASSED [ 20%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_is_error_string_values[f-False] PASSED [ 20%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_is_error_string_values[n-False] PASSED [ 20%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_is_error_string_values[no-False] PASSED [ 21%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_is_error_string_values[-False] PASSED [ 21%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_is_error_string_values[other-False] PASSED [ 21%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_is_error_integer_values[0-False] PASSED [ 21%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_is_error_integer_values[1-True] PASSED [ 21%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_is_error_integer_values[-1-True] PASSED [ 22%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_is_error_integer_values[42-True] PASSED [ 22%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_is_error_none_value PASSED [ 22%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_session_id_conversion PASSED [ 22%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_session_id_invalid_conversion PASSED [ 22%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_keystroke_id_conversion PASSED [ 22%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_keystroke_id_invalid_conversion PASSED [ 23%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_empty_dict PASSED [ 23%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_text_index_valid_conversion[0-0_0] PASSED [ 23%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_text_index_valid_conversion[5-5_0] PASSED [ 23%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_text_index_valid_conversion[42-42_0] PASSED [ 23%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_text_index_valid_conversion[999999-999999_0] PASSED [ 24%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_text_index_valid_conversion[0-0_1] PASSED [ 24%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_text_index_valid_conversion[5-5_1] PASSED [ 24%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_text_index_valid_conversion[42-42_1] PASSED [ 24%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_text_index_valid_conversion[999999-999999_1] PASSED [ 24%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_text_index_invalid_conversion[invalid] PASSED [ 25%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_text_index_invalid_conversion[not-a-number] PASSED [ 25%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_text_index_invalid_conversion[text_index_value2] PASSED [ 25%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_text_index_invalid_conversion[text_index_value3] PASSED [ 25%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_text_index_invalid_conversion[None] PASSED [ 25%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_text_index_invalid_conversion[-1_0] PASSED [ 26%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_text_index_invalid_conversion[-100_0] PASSED [ 26%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_text_index_invalid_conversion[-1_1] PASSED [ 26%]
tests/models/test_keystroke.py::TestKeystrokeFromDict::test_from_dict_text_index_invalid_conversion[-100_1] PASSED [ 26%]
tests/models/test_keystroke.py::TestKeystrokeToDict::test_to_dict_complete_data PASSED [ 26%]
tests/models/test_keystroke.py::TestKeystrokeToDict::test_to_dict_datetime_serialization PASSED [ 27%]
tests/models/test_keystroke.py::TestKeystrokeToDict::test_to_dict_with_none_values PASSED [ 27%]
tests/models/test_keystroke.py::TestKeystrokeToDict::test_to_dict_roundtrip PASSED [ 27%]
tests/models/test_keystroke.py::TestKeystrokeClassMethods::test_get_for_session_success PASSED [ 27%]
tests/models/test_keystroke.py::TestKeystrokeClassMethods::test_get_for_session_empty_result PASSED [ 27%]
tests/models/test_keystroke.py::TestKeystrokeClassMethods::test_get_for_session_none_result PASSED [ 28%]
tests/models/test_keystroke.py::TestKeystrokeClassMethods::test_get_errors_for_session_success PASSED [ 28%]
tests/models/test_keystroke.py::TestKeystrokeClassMethods::test_get_errors_for_session_empty_result PASSED [ 28%]
tests/models/test_keystroke.py::TestKeystrokeClassMethods::test_delete_all_keystrokes_success PASSED [ 28%]
tests/models/test_keystroke.py::TestKeystrokeClassMethods::test_delete_all_keystrokes_exception PASSED [ 28%]
tests/models/test_keystroke.py::TestKeystrokeEdgeCases::test_keystroke_with_unicode_characters PASSED [ 29%]
tests/models/test_keystroke.py::TestKeystrokeEdgeCases::test_keystroke_with_special_characters PASSED [ 29%]
tests/models/test_keystroke.py::TestKeystrokeEdgeCases::test_keystroke_with_very_long_strings PASSED [ 29%]
tests/models/test_keystroke.py::TestKeystrokeEdgeCases::test_keystroke_with_negative_time_since_previous PASSED [ 29%]
tests/models/test_keystroke.py::TestKeystrokeEdgeCases::test_keystroke_with_zero_time_since_previous PASSED [ 29%]
tests/models/test_keystroke.py::TestKeystrokeEdgeCases::test_keystroke_with_very_large_time_since_previous PASSED [ 30%]
tests/models/test_keystroke.py::TestKeystrokeEdgeCases::test_from_dict_with_extra_fields PASSED [ 30%]
tests/models/test_keystroke.py::TestKeystrokeIntegration::test_full_workflow_create_save_retrieve PASSED [ 30%]
tests/models/test_keystroke.py::TestKeystrokeIntegration::test_model_consistency_with_specification PASSED [ 30%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerInitialization::test_init_default_database_manager PASSED [ 30%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerInitialization::test_init_custom_database_manager PASSED [ 31%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerInitialization::test_init_none_database_manager PASSED [ 31%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerAddKeystroke::test_add_single_keystroke PASSED [ 31%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerAddKeystroke::test_add_multiple_keystrokes PASSED [ 31%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerAddKeystroke::test_add_keystroke_with_error PASSED [ 31%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerGetKeystrokesForSession::test_get_keystrokes_for_session_success PASSED [ 32%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerGetKeystrokesForSession::test_get_keystrokes_for_session_empty PASSED [ 32%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerGetKeystrokesForSession::test_get_keystrokes_replaces_existing_list PASSED [ 32%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerGetKeystrokesForSession::test_get_keystrokes_with_uuid_session_id PASSED [ 32%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerSaveKeystrokes::test_save_keystrokes_success FAILED [ 32%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerSaveKeystrokes::test_save_keystrokes_empty_list PASSED [ 33%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerSaveKeystrokes::test_save_keystrokes_database_error FAILED [ 33%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerSaveKeystrokes::test_save_keystrokes_with_special_characters FAILED [ 33%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerSaveKeystrokes::test_save_keystrokes_boolean_conversion FAILED [ 33%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerDeleteKeystrokes::test_delete_keystrokes_by_session_success PASSED [ 33%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerDeleteKeystrokes::test_delete_keystrokes_by_session_database_error PASSED [ 33%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerDeleteKeystrokes::test_delete_keystrokes_by_session_uuid PASSED [ 34%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerDeleteKeystrokes::test_delete_all_keystrokes_success PASSED [ 34%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerDeleteKeystrokes::test_delete_all_keystrokes_database_error PASSED [ 34%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerDeleteKeystrokes::test_delete_keystrokes_empty_session_id PASSED [ 34%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerCountKeystrokes::test_count_keystrokes_dict_result PASSED [ 34%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerCountKeystrokes::test_count_keystrokes_tuple_result PASSED [ 35%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerCountKeystrokes::test_count_keystrokes_zero_result PASSED [ 35%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerCountKeystrokes::test_count_keystrokes_none_result PASSED [ 35%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerCountKeystrokes::test_count_keystrokes_none_count_value PASSED [ 35%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerCountKeystrokes::test_count_keystrokes_database_error PASSED [ 35%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerCountKeystrokes::test_count_keystrokes_result_conversion_error PASSED [ 36%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerCountKeystrokes::test_count_keystrokes_uuid_session_id PASSED [ 36%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerIntegration::test_full_keystroke_workflow FAILED [ 36%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerIntegration::test_concurrent_session_handling PASSED [ 36%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerEdgeCases::test_extreme_session_id_values PASSED [ 36%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerEdgeCases::test_extreme_keystroke_values PASSED [ 37%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerEdgeCases::test_unicode_and_special_characters FAILED [ 37%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerEdgeCases::test_memory_management_large_list PASSED [ 37%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerErrorHandling::test_database_connection_failure FAILED [ 37%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerErrorHandling::test_invalid_keystroke_data PASSED [ 37%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerErrorHandling::test_partial_save_failure FAILED [ 38%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerErrorHandling::test_network_timeout_simulation FAILED [ 38%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerCompatibility::test_different_datetime_formats PASSED [ 38%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerCompatibility::test_boolean_variations PASSED [ 38%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerCompatibility::test_numeric_edge_cases PASSED [ 38%]
tests/models/test_keystroke_manager.py::TestKeystrokeManagerCompatibility::test_string_encoding_variants PASSED [ 39%]
tests/models/test_llm_ngram_service.py::test_missing_api_key FAILED      [ 39%]
tests/models/test_llm_ngram_service.py::test_invalid_ngrams PASSED       [ 39%]
tests/models/test_llm_ngram_service.py::test_llm_success PASSED          [ 39%]
tests/models/test_llm_ngram_service.py::test_llm_trims_to_max_length PASSED [ 39%]
tests/models/test_next_session_position.py::test_get_next_position_no_previous_session PASSED [ 40%]
tests/models/test_next_session_position.py::test_get_next_position_continue_from_previous PASSED [ 40%]
tests/models/test_next_session_position.py::test_get_next_position_wrap_around PASSED [ 40%]
tests/models/test_next_session_position.py::test_get_next_position_beyond_length PASSED [ 40%]
tests/models/test_next_session_position.py::test_get_next_position_multiple_sessions PASSED [ 40%]
tests/models/test_ngram.py::TestKeystroke::test_keystroke_basic PASSED   [ 41%]
tests/models/test_ngram.py::TestKeystroke::test_keystroke_nfc_single_char FAILED [ 41%]
tests/models/test_ngram.py::TestNGramTextRules::test_has_sequence_separators PASSED [ 41%]
tests/models/test_ngram.py::TestNGramTextRules::test_is_valid_ngram_text PASSED [ 41%]
tests/models/test_ngram.py::TestSpeedNGram::test_speed_ngram_computes_ms_per_keystroke PASSED [ 41%]
tests/models/test_ngram.py::TestSpeedNGram::test_speed_ngram_rejects_separators PASSED [ 42%]
tests/models/test_ngram.py::TestSpeedNGram::test_speed_ngram_invalid_size PASSED [ 42%]
tests/models/test_ngram.py::TestSpeedNGram::test_speed_ngram_at_max_size PASSED [ 42%]
tests/models/test_ngram.py::TestSpeedNGram::test_speed_ngram_rejects_over_max PASSED [ 42%]
tests/models/test_ngram.py::TestErrorNGram::test_error_ngram_pattern_last_char_only PASSED [ 42%]
tests/models/test_ngram.py::TestErrorNGram::test_error_ngram_pattern_invalid_first_char PASSED [ 43%]
tests/models/test_ngram.py::TestErrorNGram::test_error_ngram_rejects_separators PASSED [ 43%]
tests/models/test_ngram.py::TestErrorNGram::test_error_ngram_at_max_size PASSED [ 43%]
tests/models/test_ngram.py::TestErrorNGram::test_error_ngram_rejects_over_max PASSED [ 43%]
tests/models/test_ngram_analytics_service.py::TestDecayingAverageCalculator::test_calculate_decaying_average_basic PASSED [ 43%]
tests/models/test_ngram_analytics_service.py::TestDecayingAverageCalculator::test_calculate_decaying_average_single_value PASSED [ 44%]
tests/models/test_ngram_analytics_service.py::TestDecayingAverageCalculator::test_calculate_decaying_average_empty_values PASSED [ 44%]
tests/models/test_ngram_analytics_service.py::TestDecayingAverageCalculator::test_calculate_decaying_average_max_samples PASSED [ 44%]
tests/models/test_ngram_analytics_service.py::TestNGramAnalyticsService::test_init_with_valid_dependencies PASSED [ 44%]
tests/models/test_ngram_analytics_service.py::TestNGramAnalyticsService::test_init_with_none_dependencies PASSED [ 44%]
tests/models/test_ngram_analytics_service.py::TestNGramAnalyticsService::test_refresh_speed_summaries_basic ERROR [ 44%]
tests/models/test_ngram_analytics_service.py::TestNGramAnalyticsService::test_get_speed_heatmap_data_basic SKIPPED [ 45%]
tests/models/test_ngram_analytics_service.py::TestNGramAnalyticsService::test_get_performance_trends_basic SKIPPED [ 45%]
tests/models/test_ngram_analytics_service.py::TestNGramAnalyticsService::test_slowest_n_moved_from_ngram_manager SKIPPED [ 45%]
tests/models/test_ngram_analytics_service.py::TestNGramAnalyticsService::test_error_n_moved_from_ngram_manager SKIPPED [ 45%]
tests/models/test_ngram_analytics_service.py::TestNGramAnalyticsService::test_dual_insert_creates_records_in_both_tables FAILED [ 45%]
tests/models/test_ngram_analytics_service.py::TestNGramAnalyticsService::test_history_table_accumulates_all_records FAILED [ 46%]
tests/models/test_ngram_analytics_service.py::TestNGramAnalyticsService::test_get_ngram_history_retrieval FAILED [ 46%]
tests/models/test_ngram_analytics_service.py::TestNGramAnalyticsService::test_history_table_schema_compatibility FAILED [ 46%]
tests/models/test_ngram_analytics_service.py::TestNGramPerformanceData::test_valid_performance_data PASSED [ 46%]
tests/models/test_ngram_analytics_service.py::TestNGramPerformanceData::test_invalid_performance_data PASSED [ 46%]
tests/models/test_ngram_analytics_service.py::TestNGramHeatmapData::test_valid_heatmap_data PASSED [ 47%]
tests/models/test_ngram_analytics_service_session_methods.py::TestSummarizeSessionNgrams::test_summarize_with_ngram_speed_only[1-1] ERROR [ 47%]
tests/models/test_ngram_analytics_service_session_methods.py::TestSummarizeSessionNgrams::test_summarize_with_ngram_speed_only[3-3] ERROR [ 47%]
tests/models/test_ngram_analytics_service_session_methods.py::TestSummarizeSessionNgrams::test_summarize_with_ngram_errors_only[1-1] ERROR [ 47%]
tests/models/test_ngram_analytics_service_session_methods.py::TestSummarizeSessionNgrams::test_summarize_with_ngram_errors_only[2-2] ERROR [ 47%]
tests/models/test_ngram_analytics_service_session_methods.py::TestSummarizeSessionNgrams::test_summarize_with_speed_and_errors ERROR [ 48%]
tests/models/test_ngram_analytics_service_session_methods.py::TestSummarizeSessionNgrams::test_summarize_with_keystrokes[1-1] ERROR [ 48%]
tests/models/test_ngram_analytics_service_session_methods.py::TestSummarizeSessionNgrams::test_summarize_with_keystrokes[3-3] ERROR [ 48%]
tests/models/test_ngram_analytics_service_session_methods.py::TestSummarizeSessionNgrams::test_no_sessions_missing ERROR [ 48%]
tests/models/test_ngram_analytics_service_session_methods.py::TestSummarizeSessionNgrams::test_sessions_missing_no_data ERROR [ 48%]
tests/models/test_ngram_analytics_service_session_methods.py::TestAddSpeedSummaryForSession::test_single_session_processing ERROR [ 49%]
tests/models/test_ngram_analytics_service_session_methods.py::TestAddSpeedSummaryForSession::test_nonexistent_session PASSED [ 49%]
tests/models/test_ngram_analytics_service_session_methods.py::TestAddSpeedSummaryForSession::test_multiple_ngrams_processing ERROR [ 49%]
tests/models/test_ngram_analytics_service_session_methods.py::TestCatchupSpeedSummary::test_empty_database_catchup PASSED [ 49%]
tests/models/test_ngram_analytics_service_session_methods.py::TestCatchupSpeedSummary::test_single_session_catchup ERROR [ 49%]
tests/models/test_ngram_analytics_service_session_methods.py::TestCatchupSpeedSummary::test_multiple_sessions_catchup ERROR [ 50%]
tests/models/test_ngram_analytics_service_session_methods.py::TestCatchupSpeedSummary::test_catchup_with_session_errors ERROR [ 50%]
tests/models/test_ngram_analytics_service_session_methods.py::TestIntegrationScenarios::test_full_workflow_integration ERROR [ 50%]
tests/models/test_ngram_manager.py::TestAnalyzeBasic::test_clean_windows_and_gross_up PASSED [ 50%]
tests/models/test_ngram_manager.py::TestAnalyzeBasic::test_ignored_zero_duration PASSED [ 50%]
tests/models/test_ngram_manager.py::TestAnalyzeBasic::test_separators_split_runs PASSED [ 51%]
tests/models/test_ngram_manager.py::TestErrorClassification::test_error_last_only PASSED [ 51%]
tests/models/test_ngram_manager.py::TestErrorClassification::test_error_not_last_is_ignored PASSED [ 51%]
tests/models/test_ngram_orchestrator_process_end_of_session.py::test_process_end_of_session_success_path FAILED [ 51%]
tests/models/test_ngram_orchestrator_process_end_of_session.py::test_process_end_of_session_session_save_failure FAILED [ 51%]
tests/models/test_ngram_orchestrator_process_end_of_session.py::test_process_end_of_session_keystrokes_save_failure FAILED [ 52%]
tests/models/test_ngram_orchestrator_process_end_of_session.py::test_process_end_of_session_summarization_failure FAILED [ 52%]
tests/models/test_session.py::test_valid_session_creation PASSED         [ 52%]
tests/models/test_session.py::test_missing_required_fields_raises[snippet_id] PASSED [ 52%]
tests/models/test_session.py::test_missing_required_fields_raises[user_id] PASSED [ 52%]
tests/models/test_session.py::test_missing_required_fields_raises[keyboard_id] PASSED [ 53%]
tests/models/test_session.py::test_missing_required_fields_raises[snippet_index_start] PASSED [ 53%]
tests/models/test_session.py::test_missing_required_fields_raises[snippet_index_end] PASSED [ 53%]
tests/models/test_session.py::test_missing_required_fields_raises[content] PASSED [ 53%]
tests/models/test_session.py::test_missing_required_fields_raises[start_time] PASSED [ 53%]
tests/models/test_session.py::test_missing_required_fields_raises[end_time] PASSED [ 54%]
tests/models/test_session.py::test_missing_required_fields_raises[actual_chars] PASSED [ 54%]
tests/models/test_session.py::test_missing_required_fields_raises[errors] PASSED [ 54%]
tests/models/test_session.py::test_invalid_field_values_raise[session_id-not-a-uuid] PASSED [ 54%]
tests/models/test_session.py::test_invalid_field_values_raise[snippet_id-not-a-uuid] PASSED [ 54%]
tests/models/test_session.py::test_invalid_field_values_raise[user_id-not-a-uuid] PASSED [ 55%]
tests/models/test_session.py::test_invalid_field_values_raise[keyboard_id-not-a-uuid] PASSED [ 55%]
tests/models/test_session.py::test_invalid_field_values_raise[snippet_index_start--1] PASSED [ 55%]
tests/models/test_session.py::test_invalid_field_values_raise[snippet_index_end-0] PASSED [ 55%]
tests/models/test_session.py::test_invalid_field_values_raise[start_time-not-a-date] PASSED [ 55%]
tests/models/test_session.py::test_invalid_field_values_raise[end_time-12345] PASSED [ 55%]
tests/models/test_session.py::test_invalid_field_values_raise[actual_chars-not-an-int] PASSED [ 56%]
tests/models/test_session.py::test_invalid_field_values_raise[errors-not-an-int] PASSED [ 56%]
tests/models/test_session.py::test_index_business_rules[0-0-True] PASSED [ 56%]
tests/models/test_session.py::test_index_business_rules[5-5-True] PASSED [ 56%]
tests/models/test_session.py::test_index_business_rules[10-5-True] PASSED [ 56%]
tests/models/test_session.py::test_index_business_rules[-1-5-True] PASSED [ 57%]
tests/models/test_session.py::test_index_business_rules[0-1-False] PASSED [ 57%]
tests/models/test_session.py::test_index_business_rules[2-5-False] PASSED [ 57%]
tests/models/test_session.py::test_start_time_after_end_time_raises PASSED [ 57%]
tests/models/test_session.py::test_computed_properties PASSED            [ 57%]
tests/models/test_session.py::test_correctness_and_accuracy[5-0-1.0-1.0] PASSED [ 58%]
tests/models/test_session.py::test_correctness_and_accuracy[5-5-0.0-0.0] PASSED [ 58%]
tests/models/test_session.py::test_correctness_and_accuracy[0-0-0.0-0.0] PASSED [ 58%]
tests/models/test_session.py::test_wpm_cpm_zero_and_normal[start_time0-end_time0-0.0-0.0] PASSED [ 58%]
tests/models/test_session.py::test_wpm_cpm_zero_and_normal[start_time1-end_time1-1.0-5.0] PASSED [ 58%]
tests/models/test_session.py::test_to_dict_and_from_dict PASSED          [ 59%]
tests/models/test_session.py::test_from_dict_ignores_calculated_fields PASSED [ 59%]
tests/models/test_session.py::test_from_dict_with_extra_fields_raises PASSED [ 59%]
tests/models/test_session.py::test_get_summary_truncates_content PASSED  [ 59%]
tests/models/test_session.py::test_extra_fields_forbidden_on_creation PASSED [ 59%]
tests/models/test_session.py::test_ms_per_keystroke_zero_chars PASSED    [ 60%]
tests/models/test_session.py::test_session_id_default_factory PASSED     [ 60%]
tests/models/test_session.py::test_content_required_if_actual_chars PASSED [ 60%]
tests/models/test_session_manager.py::test_save_and_get_session PASSED   [ 60%]
tests/models/test_session_manager.py::test_update_session PASSED         [ 60%]
tests/models/test_session_manager.py::test_list_sessions_for_snippet PASSED [ 61%]
tests/models/test_session_manager.py::test_delete_session_by_id PASSED   [ 61%]
tests/models/test_session_manager.py::test_delete_all PASSED             [ 61%]
tests/models/test_session_manager.py::test_save_session_returns_id PASSED [ 61%]
tests/models/test_session_manager.py::test_get_nonexistent_session PASSED [ 61%]
tests/models/test_session_manager.py::test_list_sessions_for_snippet_empty PASSED [ 62%]
tests/models/test_setting.py::TestSettingModel::test_setting_creation_valid PASSED [ 62%]
tests/models/test_setting.py::TestSettingModel::test_setting_type_id_validation[-setting_type_id must be exactly 6 characters] PASSED [ 62%]
tests/models/test_setting.py::TestSettingModel::test_setting_type_id_validation[ABC-setting_type_id must be exactly 6 characters] PASSED [ 62%]
tests/models/test_setting.py::TestSettingModel::test_setting_type_id_validation[ABCDEFG-setting_type_id must be exactly 6 characters] PASSED [ 62%]
tests/models/test_setting.py::TestSettingModel::test_setting_type_id_validation[ABCD\u20ac\u03a9-setting_type_id must be ASCII-only] PASSED [ 63%]
tests/models/test_setting.py::TestSettingModel::test_setting_exceptions_instantiable PASSED [ 63%]
tests/models/test_setting.py::TestSettingModel::test_setting_init_autogenerates_id PASSED [ 63%]
tests/models/test_setting.py::TestSettingModel::test_setting_from_dict_valid_and_extra_fields PASSED [ 63%]
tests/models/test_setting.py::TestSettingModel::test_setting_to_dict PASSED [ 63%]
tests/models/test_setting.py::TestSettingModel::test_setting_field_type_and_value_errors[setting_id-123-Input should be a valid string] PASSED [ 64%]
tests/models/test_setting.py::TestSettingModel::test_setting_field_type_and_value_errors[setting_id-not-a-uuid-setting_id must be a valid UUID string] PASSED [ 64%]
tests/models/test_setting.py::TestSettingModel::test_setting_field_type_and_value_errors[setting_type_id-None-Input should be a valid string] PASSED [ 64%]
tests/models/test_setting.py::TestSettingModel::test_setting_field_type_and_value_errors[setting_type_id--setting_type_id must be exactly 6 characters] PASSED [ 64%]
tests/models/test_setting.py::TestSettingModel::test_setting_field_type_and_value_errors[setting_type_id-ABC-setting_type_id must be exactly 6 characters] PASSED [ 64%]
tests/models/test_setting.py::TestSettingModel::test_setting_field_type_and_value_errors[related_entity_id-None-Input should be a valid string] PASSED [ 65%]
tests/models/test_setting.py::TestSettingModel::test_setting_field_type_and_value_errors[related_entity_id-not-a-uuid-related_entity_id must be a valid UUID string] PASSED [ 65%]
tests/models/test_setting.py::TestSettingModel::test_setting_field_type_and_value_errors[updated_at-None-Input should be a valid string] PASSED [ 65%]
tests/models/test_setting.py::TestSettingModel::test_setting_field_type_and_value_errors[updated_at-not-iso-format-updated_at must be a valid ISO datetime string] PASSED [ 65%]
tests/models/test_setting_manager.py::TestSettingManager::test_create_setting_valid PASSED [ 65%]
tests/models/test_setting_manager.py::TestSettingManager::test_create_setting_invalid_format[-must be exactly 6 characters] PASSED [ 66%]
tests/models/test_setting_manager.py::TestSettingManager::test_create_setting_invalid_format[ABC-must be exactly 6 characters] PASSED [ 66%]
tests/models/test_setting_manager.py::TestSettingManager::test_create_setting_invalid_format[ABCDEFG-must be exactly 6 characters] PASSED [ 66%]
tests/models/test_setting_manager.py::TestSettingManager::test_create_setting_invalid_format[ABCD\u20ac\u03a9-must be ASCII-only] PASSED [ 66%]
tests/models/test_setting_manager.py::TestSettingManager::test_update_existing_setting_with_new_value PASSED [ 66%]
tests/models/test_setting_manager.py::TestSettingManager::test_get_setting_by_type_and_entity PASSED [ 66%]
tests/models/test_setting_manager.py::TestSettingManager::test_get_setting_with_default PASSED [ 67%]
tests/models/test_setting_manager.py::TestSettingManager::test_get_setting_not_found PASSED [ 67%]
tests/models/test_setting_manager.py::TestSettingManager::test_list_settings_empty PASSED [ 67%]
tests/models/test_setting_manager.py::TestSettingManager::test_list_settings_populated PASSED [ 67%]
tests/models/test_setting_manager.py::TestSettingManager::test_update_setting_value PASSED [ 67%]
tests/models/test_setting_manager.py::TestSettingManager::test_history_tracking_on_create PASSED [ 68%]
tests/models/test_setting_manager.py::TestSettingManager::test_history_tracking_on_update PASSED [ 68%]
tests/models/test_setting_manager.py::TestSettingManager::test_history_tracking_on_delete PASSED [ 68%]
tests/models/test_setting_manager.py::TestSettingManager::test_delete_setting PASSED [ 68%]
tests/models/test_setting_manager.py::TestSettingManager::test_delete_nonexistent_setting PASSED [ 68%]
tests/models/test_setting_manager.py::TestSettingManager::test_delete_all_settings PASSED [ 69%]
tests/models/test_setting_manager.py::TestSettingManager::test_history_for_bulk_delete PASSED [ 69%]
tests/models/test_simple.py::test_simple PASSED                          [ 69%]
tests/models/test_snippet.py::test_snippet_model_validation_valid PASSED [ 69%]
tests/models/test_snippet.py::test_snippet_model_validation_invalid_name_empty PASSED [ 69%]
tests/models/test_snippet.py::test_snippet_model_validation_invalid_name_non_ascii PASSED [ 70%]
tests/models/test_snippet.py::test_snippet_ascii_name ERROR              [ 70%]
tests/models/test_snippet.py::test_snippet_model_validation_invalid_name_too_long PASSED [ 70%]
tests/models/test_snippet.py::test_snippet_name_length ERROR             [ 70%]
tests/models/test_snippet.py::test_snippet_model_validation_invalid_content_empty PASSED [ 70%]
tests/models/test_snippet.py::test_snippet_model_validation_invalid_category_id PASSED [ 71%]
tests/models/test_snippet.py::test_snippet_creation_validation[Alpha-Some content-True] ERROR [ 71%]
tests/models/test_snippet.py::test_snippet_creation_validation[-Some content-False] ERROR [ 71%]
tests/models/test_snippet.py::test_snippet_creation_validation[AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA-Content-False] ERROR [ 71%]
tests/models/test_snippet.py::test_snippet_creation_validation[NonAscii\xe9-Content-False] ERROR [ 71%]
tests/models/test_snippet.py::test_snippet_creation_validation[Alpha--False] ERROR [ 72%]
tests/models/test_snippet.py::test_snippet_name_uniqueness[Unique1-Unique2-True] ERROR [ 72%]
tests/models/test_snippet.py::test_snippet_name_uniqueness[DupName-DupName-False] ERROR [ 72%]
tests/models/test_snippet.py::test_snippet_creation_valid ERROR          [ 72%]
tests/models/test_snippet.py::test_get_nonexistent_snippet ERROR         [ 72%]
tests/models/test_snippet.py::test_list_snippets_empty ERROR             [ 73%]
tests/models/test_snippet.py::test_list_snippets_populated ERROR         [ 73%]
tests/models/test_snippet.py::test_snippet_edit ERROR                    [ 73%]
tests/models/test_snippet.py::test_snippet_update ERROR                  [ 73%]
tests/models/test_snippet.py::test_snippet_update_name_only ERROR        [ 73%]
tests/models/test_snippet.py::test_snippet_update_content_only ERROR     [ 74%]
tests/models/test_snippet.py::test_snippet_delete ERROR                  [ 74%]
tests/models/test_snippet.py::test_delete_nonexistent_snippet ERROR      [ 74%]
tests/models/test_snippet.py::test_edit_snippet_change_category ERROR    [ 74%]
tests/models/test_snippet.py::test_edit_snippet_invalid_category ERROR   [ 74%]
tests/models/test_snippet.py::test_snippet_sql_injection ERROR           [ 75%]
tests/models/test_snippet.py::test_snippet_sql_injection_in_content ERROR [ 75%]
tests/models/test_snippet.py::test_snippet_long_content ERROR            [ 75%]
tests/models/test_snippet.py::test_snippet_content_splitting_boundaries ERROR [ 75%]
tests/models/test_snippet.py::test_update_nonexistent_snippet ERROR      [ 75%]
tests/models/test_snippet.py::test_snippet_part_number_sequence ERROR    [ 76%]
tests/models/test_snippet.py::test_python_code_validation PASSED         [ 76%]
tests/models/test_snippet.py::test_snippet_operation_handling ERROR      [ 76%]
tests/models/test_snippet.py::test_delete_snippet ERROR                  [ 76%]
tests/models/test_snippet.py::test_create_snippet_with_nonexistent_category ERROR [ 76%]
tests/models/test_snippet.py::test_update_snippet_partial ERROR          [ 77%]
tests/models/test_snippet.py::test_update_snippet_no_changes ERROR       [ 77%]
tests/models/test_snippet.py::test_get_snippet_by_name ERROR             [ 77%]
tests/models/test_snippet.py::test_get_snippet_by_name_nonexistent ERROR [ 77%]
tests/models/test_snippet.py::test_get_snippet_by_name_multiple_categories ERROR [ 77%]
tests/models/test_snippet.py::test_search_snippets ERROR                 [ 77%]
tests/models/test_snippet.py::test_search_snippets_no_results ERROR      [ 78%]
tests/models/test_snippet.py::test_snippet_sql_injection_name_create ERROR [ 78%]
tests/models/test_snippet.py::test_snippet_sql_injection_content_create ERROR [ 78%]
tests/models/test_snippet.py::test_snippet_sql_injection_name_create_with_specific_error ERROR [ 78%]
tests/models/test_snippet.py::test_snippet_sql_injection_content_update ERROR [ 78%]
tests/models/test_snippet.py::test_snippet_sql_injection_name_update ERROR [ 79%]
tests/models/test_snippet.py::test_snippet_deletion_idempotency ERROR    [ 79%]
tests/models/test_snippet.py::test_snippet_manager_handles_db_errors_gracefully_on_create ERROR [ 79%]
tests/models/test_snippet.py::test_snippet_manager_handles_db_errors_gracefully_on_get ERROR [ 79%]
tests/models/test_snippet.py::test_snippet_manager_handles_db_errors_gracefully_on_update ERROR [ 79%]
tests/models/test_snippet.py::test_snippet_manager_handles_db_errors_gracefully_on_delete ERROR [ 80%]
tests/models/test_snippet.py::test_snippet_manager_handles_db_errors_gracefully_on_list ERROR [ 80%]
tests/models/test_snippet.py::test_snippet_manager_handles_db_errors_gracefully_on_search ERROR [ 80%]
tests/models/test_snippet.py::test_create_snippet_pydantic_validation_errors ERROR [ 80%]
tests/models/test_snippet_manager.py::TestCreateSnippet::test_create_snippet_happy_path PASSED [ 80%]
tests/models/test_snippet_manager.py::TestCreateSnippet::test_create_snippet_content_splitting PASSED [ 81%]
tests/models/test_snippet_manager.py::TestCreateSnippet::test_create_snippet_duplicate_name_in_category PASSED [ 81%]
tests/models/test_snippet_manager.py::TestCreateSnippet::test_create_snippet_duplicate_name_different_category PASSED [ 81%]
tests/models/test_snippet_manager.py::TestCreateSnippet::test_create_snippet_invalid_category_id_foreign_key PASSED [ 81%]
tests/models/test_snippet_manager.py::TestCreateSnippet::test_create_snippet_pydantic_validation_errors[-Valid Content-ValueError] PASSED [ 81%]
tests/models/test_snippet_manager.py::TestCreateSnippet::test_create_snippet_pydantic_validation_errors[ -Valid Content-ValueError] PASSED [ 82%]
tests/models/test_snippet_manager.py::TestCreateSnippet::test_create_snippet_pydantic_validation_errors[NNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN-Valid Content-ValueError] PASSED [ 82%]
tests/models/test_snippet_manager.py::TestCreateSnippet::test_create_snippet_pydantic_validation_errors[Invalid\xd1ame-Valid Content-ValueError] PASSED [ 82%]
tests/models/test_snippet_manager.py::TestCreateSnippet::test_create_snippet_pydantic_validation_errors[ValidName--ValueError] PASSED [ 82%]
tests/models/test_snippet_manager.py::TestCreateSnippet::test_create_snippet_pydantic_validation_errors[ValidName- -ValueError] PASSED [ 82%]
tests/models/test_snippet_manager.py::TestCreateSnippet::test_create_snippet_pydantic_validation_errors[ValidName-Invalid\xc7ontent-ValueError] PASSED [ 83%]
tests/models/test_snippet_manager.py::TestCreateSnippet::test_create_snippet_pydantic_validation_errors[DROP TABLE Users;-Content-ValueError] PASSED [ 83%]
tests/models/test_snippet_manager.py::TestCreateSnippet::test_create_snippet_pydantic_validation_errors[ValidName-SELECT * FROM Users; -- comment-ValueError] PASSED [ 83%]
tests/models/test_snippet_manager.py::TestCreateSnippet::test_create_snippet_internal_empty_content_check_unreachable_with_valid_pydantic_input PASSED [ 83%]
tests/models/test_snippet_manager.py::TestGetStartingIndex::test_get_starting_index_no_sessions PASSED [ 83%]
tests/models/test_snippet_manager.py::TestGetStartingIndex::test_get_starting_index_with_sessions PASSED [ 84%]
tests/models/test_snippet_manager.py::TestGetStartingIndex::test_get_starting_index_wraps_to_zero PASSED [ 84%]
tests/models/test_snippet_manager.py::TestGetStartingIndex::test_get_starting_index_greater_than_length PASSED [ 84%]
tests/models/test_snippet_manager.py::TestGetStartingIndex::test_get_starting_index_different_user_keyboard PASSED [ 84%]
tests/models/test_user.py::TestUserModel::test_create_user_with_minimal_fields PASSED [ 84%]
tests/models/test_user.py::TestUserModel::test_create_user_with_existing_id PASSED [ 85%]
tests/models/test_user.py::TestUserModel::test_valid_email_formats[test@example.com] PASSED [ 85%]
tests/models/test_user.py::TestUserModel::test_valid_email_formats[test.user@example.com] PASSED [ 85%]
tests/models/test_user.py::TestUserModel::test_valid_email_formats[test+user@example.com] PASSED [ 85%]
tests/models/test_user.py::TestUserModel::test_valid_email_formats[test.user+tag@example.co.uk] PASSED [ 85%]
tests/models/test_user.py::TestUserModel::test_valid_email_formats[test@subdomain.example.com] PASSED [ 86%]
tests/models/test_user.py::TestUserModel::test_valid_email_formats[test@123.123.123.123] PASSED [ 86%]
tests/models/test_user.py::TestUserModel::test_valid_email_formats[test@[123.123.123.123]] PASSED [ 86%]
tests/models/test_user.py::TestUserModel::test_invalid_email_formats[plainaddress] PASSED [ 86%]
tests/models/test_user.py::TestUserModel::test_invalid_email_formats[@missingusername.com] PASSED [ 86%]
tests/models/test_user.py::TestUserModel::test_invalid_email_formats[username@.com] PASSED [ 87%]
tests/models/test_user.py::TestUserModel::test_invalid_email_formats[.username@example.com] PASSED [ 87%]
tests/models/test_user.py::TestUserModel::test_invalid_email_formats[username@example..com] PASSED [ 87%]
tests/models/test_user.py::TestUserModel::test_invalid_email_formats[username@example.com.] PASSED [ 87%]
tests/models/test_user.py::TestUserModel::test_invalid_email_formats[username@.example.com] PASSED [ 87%]
tests/models/test_user.py::TestUserModel::test_invalid_email_formats[username@-example.com] PASSED [ 88%]
tests/models/test_user.py::TestUserModel::test_invalid_email_formats[username@example-.com] PASSED [ 88%]
tests/models/test_user.py::TestUserModel::test_invalid_email_formats[username@example.com-] PASSED [ 88%]
tests/models/test_user.py::TestUserModel::test_invalid_email_formats[username@example.c] PASSED [ 88%]
tests/models/test_user.py::TestUserModel::test_invalid_email_formats[username@example.com.1a] PASSED [ 88%]
tests/models/test_user.py::TestUserModel::test_invalid_email_formats[username@example.com.a] PASSED [ 88%]
tests/models/test_user.py::TestUserModel::test_invalid_email_formats[username@example.com.1] PASSED [ 89%]
tests/models/test_user.py::TestUserModel::test_invalid_email_formats[username@example.com.a1-] PASSED [ 89%]
tests/models/test_user.py::TestUserModel::test_invalid_email_formats[username@example.com.-a] PASSED [ 89%]
tests/models/test_user.py::TestUserModel::test_valid_name_formats[John] PASSED [ 89%]
tests/models/test_user.py::TestUserModel::test_valid_name_formats[Mary-Jane] PASSED [ 89%]
tests/models/test_user.py::TestUserModel::test_valid_name_formats[O'Reilly] PASSED [ 90%]
tests/models/test_user.py::TestUserModel::test_valid_name_formats[De La Cruz] PASSED [ 90%]
tests/models/test_user.py::TestUserModel::test_valid_name_formats[X] PASSED [ 90%]
tests/models/test_user.py::TestUserModel::test_valid_name_formats[AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA] PASSED [ 90%]
tests/models/test_user.py::TestUserModel::test_invalid_name_formats[] PASSED [ 90%]
tests/models/test_user.py::TestUserModel::test_invalid_name_formats[ ] PASSED [ 91%]
tests/models/test_user.py::TestUserModel::test_invalid_name_formats[\t] PASSED [ 91%]
tests/models/test_user.py::TestUserModel::test_invalid_name_formats[\n] PASSED [ 91%]
tests/models/test_user.py::TestUserModel::test_invalid_name_formats[AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA] PASSED [ 91%]
tests/models/test_user.py::TestUserModel::test_invalid_name_formats[John@Doe] PASSED [ 91%]
tests/models/test_user.py::TestUserModel::test_invalid_name_formats[John\nDoe] PASSED [ 92%]
tests/models/test_user.py::TestUserModel::test_invalid_name_formats[John\tDoe] PASSED [ 92%]
tests/models/test_user.py::TestUserModel::test_invalid_name_formats[John\rDoe] PASSED [ 92%]
tests/models/test_user.py::TestUserModel::test_invalid_name_formats[John\x0cDoe] PASSED [ 92%]
tests/models/test_user.py::TestUserModel::test_invalid_name_formats[John\x0bDoe] PASSED [ 92%]
tests/models/test_user.py::TestUserModel::test_whitespace_stripping PASSED [ 93%]
tests/models/test_user.py::TestUserModel::test_case_insensitive_email PASSED [ 93%]
tests/models/test_user.py::TestUserModel::test_to_dict PASSED            [ 93%]
tests/models/test_user.py::TestUserModel::test_from_dict PASSED          [ 93%]
tests/models/test_user.py::TestUserModel::test_from_dict_with_extra_fields PASSED [ 93%]
tests/models/test_user.py::TestUserModel::test_validate_user_id_empty PASSED [ 94%]
tests/models/test_user.py::TestUserModel::test_validate_user_id_invalid PASSED [ 94%]
tests/models/test_user.py::TestUserModel::test_ip_address_domain_variants PASSED [ 94%]
tests/models/test_user.py::TestUserModel::test_special_domain_validation PASSED [ 94%]
tests/models/test_user.py::TestUserModel::test_domain_edge_cases PASSED  [ 94%]
tests/models/test_user_manager.py::TestUserManager::test_create_and_retrieve_user PASSED [ 95%]
tests/models/test_user_manager.py::TestUserManager::test_update_user PASSED [ 95%]
tests/models/test_user_manager.py::TestUserManager::test_delete_user PASSED [ 95%]
tests/models/test_user_manager.py::TestUserManager::test_list_all_users PASSED [ 95%]
tests/models/test_user_manager.py::TestUserManager::test_email_uniqueness PASSED [ 95%]
tests/models/test_user_manager.py::TestUserManager::test_update_user_with_same_email PASSED [ 96%]
tests/models/test_user_manager.py::TestUserManager::test_nonexistent_user_retrieval PASSED [ 96%]
tests/models/test_user_manager.py::TestUserManager::test_case_insensitive_email_retrieval PASSED [ 96%]
tests/models/test_user_manager.py::TestUserManager::test_empty_database_operations PASSED [ 96%]
tests/models/test_user_manager_fixes.py::TestUserManagerDatabaseAccessFixes::test_list_all_users_with_results PASSED [ 96%]
tests/models/test_user_manager_fixes.py::TestUserManagerDatabaseAccessFixes::test_list_all_users_empty_database PASSED [ 97%]
tests/models/test_user_manager_fixes.py::TestUserManagerDatabaseAccessFixes::test_get_user_by_id_found PASSED [ 97%]
tests/models/test_user_manager_fixes.py::TestUserManagerDatabaseAccessFixes::test_get_user_by_id_not_found PASSED [ 97%]
tests/models/test_user_manager_fixes.py::TestUserManagerDatabaseAccessFixes::test_get_user_by_email_found PASSED [ 97%]
tests/models/test_user_manager_fixes.py::TestUserManagerDatabaseAccessFixes::test_get_user_by_email_not_found PASSED [ 97%]
tests/models/test_user_manager_fixes.py::TestUserManagerDatabaseAccessFixes::test_user_exists_true PASSED [ 98%]
tests/models/test_user_manager_fixes.py::TestUserManagerDatabaseAccessFixes::test_user_exists_false PASSED [ 98%]
tests/models/test_user_manager_fixes.py::TestUserManagerDatabaseAccessFixes::test_delete_user_by_id_exists PASSED [ 98%]
tests/models/test_user_manager_fixes.py::TestUserManagerDatabaseAccessFixes::test_delete_user_by_id_not_exists PASSED [ 98%]
tests/models/test_user_manager_fixes.py::TestUserManagerDatabaseAccessFixes::test_delete_all_users_with_users_dict_result PASSED [ 98%]
tests/models/test_user_manager_fixes.py::TestUserManagerDatabaseAccessFixes::test_delete_all_users_with_users_non_dict_result PASSED [ 99%]
tests/models/test_user_manager_fixes.py::TestUserManagerDatabaseAccessFixes::test_delete_all_users_no_users_dict_result PASSED [ 99%]
tests/models/test_user_manager_fixes.py::TestUserManagerDatabaseAccessFixes::test_delete_all_users_no_users_empty_result PASSED [ 99%]
tests/models/test_user_manager_fixes.py::TestUserManagerDatabaseAccessFixes::test_validate_email_uniqueness_unique PASSED [ 99%]
tests/models/test_user_manager_fixes.py::TestUserManagerDatabaseAccessFixes::test_validate_email_uniqueness_duplicate PASSED [ 99%]
tests/models/test_user_manager_fixes.py::TestUserManagerDatabaseAccessFixes::test_validate_email_uniqueness_update_same_user PASSED [100%]

=================================== ERRORS ====================================
_ ERROR at setup of TestNGramAnalyticsService.test_refresh_speed_summaries_basic _

self = <db.database_manager.DatabaseManager object at 0x000001FC34543230>
query = 'INSERT INTO snippets (snippet_id, category_id, title, content, difficulty_level) VALUES (?, ?, ?, ?, ?)'
params = ('snippet_1', 'cat_1', 'Snippet', 'content', 1)

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table snippets has no column named title

db\database_manager.py:509: OperationalError

The above exception was the direct cause of the following exception:

item = <Function test_refresh_speed_summaries_basic>

    @pytest.hookimpl(wrapper=True, tryfirst=True)
    def pytest_runtest_setup(item):
        """
        Hook called after before test setup starts, to start capturing exceptions
        as early as possible.
        """
        capture_enabled = _is_exception_capture_enabled(item)
        if capture_enabled:
            item.qt_exception_capture_manager = _QtExceptionCaptureManager()
            item.qt_exception_capture_manager.start()
>       result = yield
                 ^^^^^

.venv\Lib\site-packages\pytestqt\plugin.py:178: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:321: in ngram_speed_test_data
    db_with_tables.execute(
db\database_manager.py:524: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x000001FC34543230>
e = OperationalError('table snippets has no column named title')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table snippets has no column named title

db\database_manager.py:434: DatabaseError
---------------------------- Captured stdout setup ----------------------------
Exception during query: table snippets has no column named title. Rolling back transaction.
---------------------------- Captured stderr setup ----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 509, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table snippets has no column named title
_ ERROR at setup of TestSummarizeSessionNgrams.test_summarize_with_ngram_speed_only[1-1] _

self = <db.database_manager.DatabaseManager object at 0x000001FC344FA0B0>
query = '\n            INSERT INTO categories (category_id, category_name, description)\n            VALUES (?, ?, ?)\n            '
params = ('9bf1e3bd-f25d-48ff-922b-e8ddd62f36e2', 'Test Category', 'Test category for testing')

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table categories has no column named description

db\database_manager.py:509: OperationalError

The above exception was the direct cause of the following exception:

db_with_tables = <db.database_manager.DatabaseManager object at 0x000001FC344FA0B0>
test_user = User(user_id='56cd921c-8f8c-45a8-84db-406045375ab7', first_name='Test', surname='User', email_address='test.user.aca5e952-f0fa-4e5b-96a3-6221fdb85d34@example.com')
test_keyboard = Keyboard(keyboard_id='a9040799-be27-45d0-a6db-fca097b9d3fe', user_id='56cd921c-8f8c-45a8-84db-406045375ab7', keyboard_name='Test Keyboard', target_ms_per_keystroke=600)

    @pytest.fixture
    def test_data_setup(db_with_tables: DatabaseManager, test_user: User, test_keyboard: Keyboard) -> Dict[str, Any]:
        """Set up comprehensive test data for session analytics tests."""
        db = db_with_tables
    
        # Create category and snippet
>       category_id = TestSessionMethodsFixtures.create_category(db)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_ngram_analytics_service_session_methods.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:239: in create_category
    db.execute(
db\database_manager.py:524: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x000001FC344FA0B0>
e = OperationalError('table categories has no column named description')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table categories has no column named description

db\database_manager.py:434: DatabaseError
---------------------------- Captured stdout setup ----------------------------
Exception during query: table categories has no column named description. Rolling back transaction.
---------------------------- Captured stderr setup ----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 509, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table categories has no column named description
_ ERROR at setup of TestSummarizeSessionNgrams.test_summarize_with_ngram_speed_only[3-3] _

self = <db.database_manager.DatabaseManager object at 0x000001FC34B06AC0>
query = '\n            INSERT INTO categories (category_id, category_name, description)\n            VALUES (?, ?, ?)\n            '
params = ('64382967-c1e9-469f-ad29-721dd4bc4a11', 'Test Category', 'Test category for testing')

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table categories has no column named description

db\database_manager.py:509: OperationalError

The above exception was the direct cause of the following exception:

db_with_tables = <db.database_manager.DatabaseManager object at 0x000001FC34B06AC0>
test_user = User(user_id='02d0baab-ee88-4283-b1f6-d367b4dd632c', first_name='Test', surname='User', email_address='test.user.6ce893fd-2c68-4eed-b0e6-99fde28f2102@example.com')
test_keyboard = Keyboard(keyboard_id='11e84188-5d3e-456b-8f63-44e672837851', user_id='02d0baab-ee88-4283-b1f6-d367b4dd632c', keyboard_name='Test Keyboard', target_ms_per_keystroke=600)

    @pytest.fixture
    def test_data_setup(db_with_tables: DatabaseManager, test_user: User, test_keyboard: Keyboard) -> Dict[str, Any]:
        """Set up comprehensive test data for session analytics tests."""
        db = db_with_tables
    
        # Create category and snippet
>       category_id = TestSessionMethodsFixtures.create_category(db)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_ngram_analytics_service_session_methods.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:239: in create_category
    db.execute(
db\database_manager.py:524: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x000001FC34B06AC0>
e = OperationalError('table categories has no column named description')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table categories has no column named description

db\database_manager.py:434: DatabaseError
---------------------------- Captured stdout setup ----------------------------
Exception during query: table categories has no column named description. Rolling back transaction.
---------------------------- Captured stderr setup ----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 509, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table categories has no column named description
_ ERROR at setup of TestSummarizeSessionNgrams.test_summarize_with_ngram_errors_only[1-1] _

self = <db.database_manager.DatabaseManager object at 0x000001FC34B460B0>
query = '\n            INSERT INTO categories (category_id, category_name, description)\n            VALUES (?, ?, ?)\n            '
params = ('0c01d985-27a3-442c-89d9-1142da489963', 'Test Category', 'Test category for testing')

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table categories has no column named description

db\database_manager.py:509: OperationalError

The above exception was the direct cause of the following exception:

db_with_tables = <db.database_manager.DatabaseManager object at 0x000001FC34B460B0>
test_user = User(user_id='38910bf0-95d5-4156-ae99-c57203af944f', first_name='Test', surname='User', email_address='test.user.333ce03f-f71a-45a7-aa97-ed44d214daa5@example.com')
test_keyboard = Keyboard(keyboard_id='45b2e10b-7cca-4c26-b54d-9d48d1f5de3a', user_id='38910bf0-95d5-4156-ae99-c57203af944f', keyboard_name='Test Keyboard', target_ms_per_keystroke=600)

    @pytest.fixture
    def test_data_setup(db_with_tables: DatabaseManager, test_user: User, test_keyboard: Keyboard) -> Dict[str, Any]:
        """Set up comprehensive test data for session analytics tests."""
        db = db_with_tables
    
        # Create category and snippet
>       category_id = TestSessionMethodsFixtures.create_category(db)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_ngram_analytics_service_session_methods.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:239: in create_category
    db.execute(
db\database_manager.py:524: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x000001FC34B460B0>
e = OperationalError('table categories has no column named description')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table categories has no column named description

db\database_manager.py:434: DatabaseError
---------------------------- Captured stdout setup ----------------------------
Exception during query: table categories has no column named description. Rolling back transaction.
---------------------------- Captured stderr setup ----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 509, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table categories has no column named description
_ ERROR at setup of TestSummarizeSessionNgrams.test_summarize_with_ngram_errors_only[2-2] _

self = <db.database_manager.DatabaseManager object at 0x000001FC34C30830>
query = '\n            INSERT INTO categories (category_id, category_name, description)\n            VALUES (?, ?, ?)\n            '
params = ('e83acd0f-6b28-4f02-b72d-f9912be41e72', 'Test Category', 'Test category for testing')

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table categories has no column named description

db\database_manager.py:509: OperationalError

The above exception was the direct cause of the following exception:

db_with_tables = <db.database_manager.DatabaseManager object at 0x000001FC34C30830>
test_user = User(user_id='c938ce8a-b664-453f-8659-69dc678be5ed', first_name='Test', surname='User', email_address='test.user.e194a8d9-2fbc-4393-94b6-025e2a255766@example.com')
test_keyboard = Keyboard(keyboard_id='1957b4f6-1084-4f62-8769-672f49fca7b4', user_id='c938ce8a-b664-453f-8659-69dc678be5ed', keyboard_name='Test Keyboard', target_ms_per_keystroke=600)

    @pytest.fixture
    def test_data_setup(db_with_tables: DatabaseManager, test_user: User, test_keyboard: Keyboard) -> Dict[str, Any]:
        """Set up comprehensive test data for session analytics tests."""
        db = db_with_tables
    
        # Create category and snippet
>       category_id = TestSessionMethodsFixtures.create_category(db)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_ngram_analytics_service_session_methods.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:239: in create_category
    db.execute(
db\database_manager.py:524: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x000001FC34C30830>
e = OperationalError('table categories has no column named description')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table categories has no column named description

db\database_manager.py:434: DatabaseError
---------------------------- Captured stdout setup ----------------------------
Exception during query: table categories has no column named description. Rolling back transaction.
---------------------------- Captured stderr setup ----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 509, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table categories has no column named description
_ ERROR at setup of TestSummarizeSessionNgrams.test_summarize_with_speed_and_errors _

self = <db.database_manager.DatabaseManager object at 0x000001FC34C307C0>
query = '\n            INSERT INTO categories (category_id, category_name, description)\n            VALUES (?, ?, ?)\n            '
params = ('635c22ae-6a3e-43a9-9c9f-f97ef38bfcfe', 'Test Category', 'Test category for testing')

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table categories has no column named description

db\database_manager.py:509: OperationalError

The above exception was the direct cause of the following exception:

db_with_tables = <db.database_manager.DatabaseManager object at 0x000001FC34C307C0>
test_user = User(user_id='57a2ff39-8012-4a28-85c7-41d204e154fd', first_name='Test', surname='User', email_address='test.user.cfb2e6cf-83d8-411f-8a9f-e6f1b184634b@example.com')
test_keyboard = Keyboard(keyboard_id='d0e6b0be-4010-444b-9619-1621ad460787', user_id='57a2ff39-8012-4a28-85c7-41d204e154fd', keyboard_name='Test Keyboard', target_ms_per_keystroke=600)

    @pytest.fixture
    def test_data_setup(db_with_tables: DatabaseManager, test_user: User, test_keyboard: Keyboard) -> Dict[str, Any]:
        """Set up comprehensive test data for session analytics tests."""
        db = db_with_tables
    
        # Create category and snippet
>       category_id = TestSessionMethodsFixtures.create_category(db)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_ngram_analytics_service_session_methods.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:239: in create_category
    db.execute(
db\database_manager.py:524: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x000001FC34C307C0>
e = OperationalError('table categories has no column named description')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table categories has no column named description

db\database_manager.py:434: DatabaseError
---------------------------- Captured stdout setup ----------------------------
Exception during query: table categories has no column named description. Rolling back transaction.
---------------------------- Captured stderr setup ----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 509, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table categories has no column named description
_ ERROR at setup of TestSummarizeSessionNgrams.test_summarize_with_keystrokes[1-1] _

self = <db.database_manager.DatabaseManager object at 0x000001FC34C30280>
query = '\n            INSERT INTO categories (category_id, category_name, description)\n            VALUES (?, ?, ?)\n            '
params = ('034ef6b5-229e-40a1-97e4-09c84ca2cf74', 'Test Category', 'Test category for testing')

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table categories has no column named description

db\database_manager.py:509: OperationalError

The above exception was the direct cause of the following exception:

db_with_tables = <db.database_manager.DatabaseManager object at 0x000001FC34C30280>
test_user = User(user_id='eb47f1b3-e0bb-4e06-b3f9-e7136c0f4796', first_name='Test', surname='User', email_address='test.user.ec344853-fbf2-4e53-9c8b-b623f581ac2b@example.com')
test_keyboard = Keyboard(keyboard_id='a818f1ca-0a6d-4b5b-aa0b-e8b798e0b1de', user_id='eb47f1b3-e0bb-4e06-b3f9-e7136c0f4796', keyboard_name='Test Keyboard', target_ms_per_keystroke=600)

    @pytest.fixture
    def test_data_setup(db_with_tables: DatabaseManager, test_user: User, test_keyboard: Keyboard) -> Dict[str, Any]:
        """Set up comprehensive test data for session analytics tests."""
        db = db_with_tables
    
        # Create category and snippet
>       category_id = TestSessionMethodsFixtures.create_category(db)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_ngram_analytics_service_session_methods.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:239: in create_category
    db.execute(
db\database_manager.py:524: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x000001FC34C30280>
e = OperationalError('table categories has no column named description')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table categories has no column named description

db\database_manager.py:434: DatabaseError
---------------------------- Captured stdout setup ----------------------------
Exception during query: table categories has no column named description. Rolling back transaction.
---------------------------- Captured stderr setup ----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 509, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table categories has no column named description
_ ERROR at setup of TestSummarizeSessionNgrams.test_summarize_with_keystrokes[3-3] _

self = <db.database_manager.DatabaseManager object at 0x000001FC34C31C50>
query = '\n            INSERT INTO categories (category_id, category_name, description)\n            VALUES (?, ?, ?)\n            '
params = ('36dd7473-f190-4610-b4b2-c66464811531', 'Test Category', 'Test category for testing')

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table categories has no column named description

db\database_manager.py:509: OperationalError

The above exception was the direct cause of the following exception:

db_with_tables = <db.database_manager.DatabaseManager object at 0x000001FC34C31C50>
test_user = User(user_id='49ae0619-46ac-4027-a20a-5996d21bf9df', first_name='Test', surname='User', email_address='test.user.333d71ac-1e68-49dc-a261-10e8b074b112@example.com')
test_keyboard = Keyboard(keyboard_id='a4f6a96b-4cc6-497f-8e44-519597aa7331', user_id='49ae0619-46ac-4027-a20a-5996d21bf9df', keyboard_name='Test Keyboard', target_ms_per_keystroke=600)

    @pytest.fixture
    def test_data_setup(db_with_tables: DatabaseManager, test_user: User, test_keyboard: Keyboard) -> Dict[str, Any]:
        """Set up comprehensive test data for session analytics tests."""
        db = db_with_tables
    
        # Create category and snippet
>       category_id = TestSessionMethodsFixtures.create_category(db)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_ngram_analytics_service_session_methods.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:239: in create_category
    db.execute(
db\database_manager.py:524: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x000001FC34C31C50>
e = OperationalError('table categories has no column named description')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table categories has no column named description

db\database_manager.py:434: DatabaseError
---------------------------- Captured stdout setup ----------------------------
Exception during query: table categories has no column named description. Rolling back transaction.
---------------------------- Captured stderr setup ----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 509, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table categories has no column named description
____ ERROR at setup of TestSummarizeSessionNgrams.test_no_sessions_missing ____

self = <db.database_manager.DatabaseManager object at 0x000001FC34C33930>
query = '\n            INSERT INTO categories (category_id, category_name, description)\n            VALUES (?, ?, ?)\n            '
params = ('52eb396d-ef95-4024-84fe-db39ff79cb45', 'Test Category', 'Test category for testing')

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table categories has no column named description

db\database_manager.py:509: OperationalError

The above exception was the direct cause of the following exception:

db_with_tables = <db.database_manager.DatabaseManager object at 0x000001FC34C33930>
test_user = User(user_id='8629ac40-08ca-4cea-83e4-7e89e5050453', first_name='Test', surname='User', email_address='test.user.87a72a80-9f1b-4b71-9e2c-bf3d5eb8b100@example.com')
test_keyboard = Keyboard(keyboard_id='20428a25-1f4a-467e-934c-6e5625c529e5', user_id='8629ac40-08ca-4cea-83e4-7e89e5050453', keyboard_name='Test Keyboard', target_ms_per_keystroke=600)

    @pytest.fixture
    def test_data_setup(db_with_tables: DatabaseManager, test_user: User, test_keyboard: Keyboard) -> Dict[str, Any]:
        """Set up comprehensive test data for session analytics tests."""
        db = db_with_tables
    
        # Create category and snippet
>       category_id = TestSessionMethodsFixtures.create_category(db)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_ngram_analytics_service_session_methods.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:239: in create_category
    db.execute(
db\database_manager.py:524: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x000001FC34C33930>
e = OperationalError('table categories has no column named description')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table categories has no column named description

db\database_manager.py:434: DatabaseError
---------------------------- Captured stdout setup ----------------------------
Exception during query: table categories has no column named description. Rolling back transaction.
---------------------------- Captured stderr setup ----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 509, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table categories has no column named description
_ ERROR at setup of TestSummarizeSessionNgrams.test_sessions_missing_no_data __

self = <db.database_manager.DatabaseManager object at 0x000001FC34C30750>
query = '\n            INSERT INTO categories (category_id, category_name, description)\n            VALUES (?, ?, ?)\n            '
params = ('9cd39d9b-c5f2-4da7-b55f-1f0cebc19253', 'Test Category', 'Test category for testing')

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table categories has no column named description

db\database_manager.py:509: OperationalError

The above exception was the direct cause of the following exception:

db_with_tables = <db.database_manager.DatabaseManager object at 0x000001FC34C30750>
test_user = User(user_id='0cfc84c7-b509-4e25-b9bf-4352dc392397', first_name='Test', surname='User', email_address='test.user.e215d6db-d293-47f5-bb23-8cec9a85a036@example.com')
test_keyboard = Keyboard(keyboard_id='881971f0-77cd-4311-baa3-f4a89bbb5aec', user_id='0cfc84c7-b509-4e25-b9bf-4352dc392397', keyboard_name='Test Keyboard', target_ms_per_keystroke=600)

    @pytest.fixture
    def test_data_setup(db_with_tables: DatabaseManager, test_user: User, test_keyboard: Keyboard) -> Dict[str, Any]:
        """Set up comprehensive test data for session analytics tests."""
        db = db_with_tables
    
        # Create category and snippet
>       category_id = TestSessionMethodsFixtures.create_category(db)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_ngram_analytics_service_session_methods.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:239: in create_category
    db.execute(
db\database_manager.py:524: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x000001FC34C30750>
e = OperationalError('table categories has no column named description')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table categories has no column named description

db\database_manager.py:434: DatabaseError
---------------------------- Captured stdout setup ----------------------------
Exception during query: table categories has no column named description. Rolling back transaction.
---------------------------- Captured stderr setup ----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 509, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table categories has no column named description
_ ERROR at setup of TestAddSpeedSummaryForSession.test_single_session_processing _

self = <db.database_manager.DatabaseManager object at 0x000001FC34C30360>
query = '\n            INSERT INTO categories (category_id, category_name, description)\n            VALUES (?, ?, ?)\n            '
params = ('ca365c7c-1465-4b16-9492-5525f15ad33a', 'Test Category', 'Test category for testing')

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table categories has no column named description

db\database_manager.py:509: OperationalError

The above exception was the direct cause of the following exception:

db_with_tables = <db.database_manager.DatabaseManager object at 0x000001FC34C30360>
test_user = User(user_id='222b1616-adf5-4b2a-8677-3aedeca03db9', first_name='Test', surname='User', email_address='test.user.743802ba-ad97-4a52-a658-b12bdde69947@example.com')
test_keyboard = Keyboard(keyboard_id='bca289ee-9fe7-4c13-9a89-9c58fef00578', user_id='222b1616-adf5-4b2a-8677-3aedeca03db9', keyboard_name='Test Keyboard', target_ms_per_keystroke=600)

    @pytest.fixture
    def test_data_setup(db_with_tables: DatabaseManager, test_user: User, test_keyboard: Keyboard) -> Dict[str, Any]:
        """Set up comprehensive test data for session analytics tests."""
        db = db_with_tables
    
        # Create category and snippet
>       category_id = TestSessionMethodsFixtures.create_category(db)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_ngram_analytics_service_session_methods.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:239: in create_category
    db.execute(
db\database_manager.py:524: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x000001FC34C30360>
e = OperationalError('table categories has no column named description')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table categories has no column named description

db\database_manager.py:434: DatabaseError
---------------------------- Captured stdout setup ----------------------------
Exception during query: table categories has no column named description. Rolling back transaction.
---------------------------- Captured stderr setup ----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 509, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table categories has no column named description
_ ERROR at setup of TestAddSpeedSummaryForSession.test_multiple_ngrams_processing _

self = <db.database_manager.DatabaseManager object at 0x000001FC34BF9A90>
query = '\n            INSERT INTO categories (category_id, category_name, description)\n            VALUES (?, ?, ?)\n            '
params = ('6dc47ba5-3736-4f2c-b255-24a66e0bf1dd', 'Test Category', 'Test category for testing')

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table categories has no column named description

db\database_manager.py:509: OperationalError

The above exception was the direct cause of the following exception:

db_with_tables = <db.database_manager.DatabaseManager object at 0x000001FC34BF9A90>
test_user = User(user_id='79f48513-77d0-48eb-b1eb-890413540d73', first_name='Test', surname='User', email_address='test.user.f489821f-a752-43b4-a2bb-5893892bdc9d@example.com')
test_keyboard = Keyboard(keyboard_id='a441cb0b-e7da-4519-93e4-f506f4deb753', user_id='79f48513-77d0-48eb-b1eb-890413540d73', keyboard_name='Test Keyboard', target_ms_per_keystroke=600)

    @pytest.fixture
    def test_data_setup(db_with_tables: DatabaseManager, test_user: User, test_keyboard: Keyboard) -> Dict[str, Any]:
        """Set up comprehensive test data for session analytics tests."""
        db = db_with_tables
    
        # Create category and snippet
>       category_id = TestSessionMethodsFixtures.create_category(db)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_ngram_analytics_service_session_methods.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:239: in create_category
    db.execute(
db\database_manager.py:524: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x000001FC34BF9A90>
e = OperationalError('table categories has no column named description')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table categories has no column named description

db\database_manager.py:434: DatabaseError
---------------------------- Captured stdout setup ----------------------------
Exception during query: table categories has no column named description. Rolling back transaction.
---------------------------- Captured stderr setup ----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 509, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table categories has no column named description
____ ERROR at setup of TestCatchupSpeedSummary.test_single_session_catchup ____

self = <db.database_manager.DatabaseManager object at 0x000001FC34BFBB60>
query = '\n            INSERT INTO categories (category_id, category_name, description)\n            VALUES (?, ?, ?)\n            '
params = ('c43dfccb-7457-4355-8811-00d36c76d772', 'Test Category', 'Test category for testing')

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table categories has no column named description

db\database_manager.py:509: OperationalError

The above exception was the direct cause of the following exception:

db_with_tables = <db.database_manager.DatabaseManager object at 0x000001FC34BFBB60>
test_user = User(user_id='482133b0-ff46-458b-ad77-6f209c530d29', first_name='Test', surname='User', email_address='test.user.f954c98b-9136-463e-94ca-96d2cfe9cbd5@example.com')
test_keyboard = Keyboard(keyboard_id='42f76e0c-f317-40e8-b116-233128f2b556', user_id='482133b0-ff46-458b-ad77-6f209c530d29', keyboard_name='Test Keyboard', target_ms_per_keystroke=600)

    @pytest.fixture
    def test_data_setup(db_with_tables: DatabaseManager, test_user: User, test_keyboard: Keyboard) -> Dict[str, Any]:
        """Set up comprehensive test data for session analytics tests."""
        db = db_with_tables
    
        # Create category and snippet
>       category_id = TestSessionMethodsFixtures.create_category(db)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_ngram_analytics_service_session_methods.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:239: in create_category
    db.execute(
db\database_manager.py:524: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x000001FC34BFBB60>
e = OperationalError('table categories has no column named description')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table categories has no column named description

db\database_manager.py:434: DatabaseError
---------------------------- Captured stdout setup ----------------------------
Exception during query: table categories has no column named description. Rolling back transaction.
---------------------------- Captured stderr setup ----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 509, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table categories has no column named description
__ ERROR at setup of TestCatchupSpeedSummary.test_multiple_sessions_catchup ___

self = <db.database_manager.DatabaseManager object at 0x000001FC34BF89F0>
query = '\n            INSERT INTO categories (category_id, category_name, description)\n            VALUES (?, ?, ?)\n            '
params = ('7a76c6a6-79a4-4797-b1d9-2174472ba344', 'Test Category', 'Test category for testing')

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table categories has no column named description

db\database_manager.py:509: OperationalError

The above exception was the direct cause of the following exception:

db_with_tables = <db.database_manager.DatabaseManager object at 0x000001FC34BF89F0>
test_user = User(user_id='f719bd9d-e9ce-4cd7-8b2d-8384b5f04c3a', first_name='Test', surname='User', email_address='test.user.93e9a9df-945a-4610-8723-fa9c9d0bd254@example.com')
test_keyboard = Keyboard(keyboard_id='3ecd54ae-9160-47f7-96d9-cd02858af4d7', user_id='f719bd9d-e9ce-4cd7-8b2d-8384b5f04c3a', keyboard_name='Test Keyboard', target_ms_per_keystroke=600)

    @pytest.fixture
    def test_data_setup(db_with_tables: DatabaseManager, test_user: User, test_keyboard: Keyboard) -> Dict[str, Any]:
        """Set up comprehensive test data for session analytics tests."""
        db = db_with_tables
    
        # Create category and snippet
>       category_id = TestSessionMethodsFixtures.create_category(db)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_ngram_analytics_service_session_methods.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:239: in create_category
    db.execute(
db\database_manager.py:524: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x000001FC34BF89F0>
e = OperationalError('table categories has no column named description')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table categories has no column named description

db\database_manager.py:434: DatabaseError
---------------------------- Captured stdout setup ----------------------------
Exception during query: table categories has no column named description. Rolling back transaction.
---------------------------- Captured stderr setup ----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 509, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table categories has no column named description
_ ERROR at setup of TestCatchupSpeedSummary.test_catchup_with_session_errors __

self = <db.database_manager.DatabaseManager object at 0x000001FC34BFBEE0>
query = '\n            INSERT INTO categories (category_id, category_name, description)\n            VALUES (?, ?, ?)\n            '
params = ('791e19f4-f28c-43b5-a0a3-f41467b2a16c', 'Test Category', 'Test category for testing')

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table categories has no column named description

db\database_manager.py:509: OperationalError

The above exception was the direct cause of the following exception:

db_with_tables = <db.database_manager.DatabaseManager object at 0x000001FC34BFBEE0>
test_user = User(user_id='ae1a0063-763f-49d1-a71b-2be8b5fbb2ed', first_name='Test', surname='User', email_address='test.user.e26eb57c-4e35-44f7-bfef-45854facd2f6@example.com')
test_keyboard = Keyboard(keyboard_id='c0d43506-d100-4ff4-bc6d-23b09f02025e', user_id='ae1a0063-763f-49d1-a71b-2be8b5fbb2ed', keyboard_name='Test Keyboard', target_ms_per_keystroke=600)

    @pytest.fixture
    def test_data_setup(db_with_tables: DatabaseManager, test_user: User, test_keyboard: Keyboard) -> Dict[str, Any]:
        """Set up comprehensive test data for session analytics tests."""
        db = db_with_tables
    
        # Create category and snippet
>       category_id = TestSessionMethodsFixtures.create_category(db)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_ngram_analytics_service_session_methods.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:239: in create_category
    db.execute(
db\database_manager.py:524: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x000001FC34BFBEE0>
e = OperationalError('table categories has no column named description')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table categories has no column named description

db\database_manager.py:434: DatabaseError
---------------------------- Captured stdout setup ----------------------------
Exception during query: table categories has no column named description. Rolling back transaction.
---------------------------- Captured stderr setup ----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 509, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table categories has no column named description
__ ERROR at setup of TestIntegrationScenarios.test_full_workflow_integration __

self = <db.database_manager.DatabaseManager object at 0x000001FC34568600>
query = '\n            INSERT INTO categories (category_id, category_name, description)\n            VALUES (?, ?, ?)\n            '
params = ('6ccaf3f7-48c3-41f3-b512-ad7152dc231d', 'Test Category', 'Test category for testing')

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table categories has no column named description

db\database_manager.py:509: OperationalError

The above exception was the direct cause of the following exception:

db_with_tables = <db.database_manager.DatabaseManager object at 0x000001FC34568600>
test_user = User(user_id='164566e9-fd98-4399-b45f-bef2bda59393', first_name='Test', surname='User', email_address='test.user.4fdeb015-df28-4f51-955a-0e03edd9878c@example.com')
test_keyboard = Keyboard(keyboard_id='199fd704-0051-4bc4-a790-743e3a961c85', user_id='164566e9-fd98-4399-b45f-bef2bda59393', keyboard_name='Test Keyboard', target_ms_per_keystroke=600)

    @pytest.fixture
    def test_data_setup(db_with_tables: DatabaseManager, test_user: User, test_keyboard: Keyboard) -> Dict[str, Any]:
        """Set up comprehensive test data for session analytics tests."""
        db = db_with_tables
    
        # Create category and snippet
>       category_id = TestSessionMethodsFixtures.create_category(db)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_ngram_analytics_service_session_methods.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:239: in create_category
    db.execute(
db\database_manager.py:524: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x000001FC34568600>
e = OperationalError('table categories has no column named description')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table categories has no column named description

db\database_manager.py:434: DatabaseError
---------------------------- Captured stdout setup ----------------------------
Exception during query: table categories has no column named description. Rolling back transaction.
---------------------------- Captured stderr setup ----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 509, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table categories has no column named description
__________________ ERROR at setup of test_snippet_ascii_name __________________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 64
  def test_snippet_ascii_name(valid_snippet_data: Dict[str, str]) -> None:
E       fixture 'valid_snippet_data' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:64
_________________ ERROR at setup of test_snippet_name_length __________________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 86
  def test_snippet_name_length(valid_snippet_data: Dict[str, Union[str, str]]) -> None:
E       fixture 'valid_snippet_data' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:86
_ ERROR at setup of test_snippet_creation_validation[Alpha-Some content-True] _
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 117
  @pytest.mark.parametrize(
      "name,content,expect_success",
      [
          ("Alpha", "Some content", True),
          ("", "Some content", False),  # Validation for name
          ("A" * 129, "Content", False),  # Validation for name length
          ("NonAscii", "Content", False),  # Validation for name ASCII
          ("Alpha", "", False),  # Validation for content
      ],
  )
  def test_snippet_creation_validation(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:117
___ ERROR at setup of test_snippet_creation_validation[-Some content-False] ___
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 117
  @pytest.mark.parametrize(
      "name,content,expect_success",
      [
          ("Alpha", "Some content", True),
          ("", "Some content", False),  # Validation for name
          ("A" * 129, "Content", False),  # Validation for name length
          ("NonAscii", "Content", False),  # Validation for name ASCII
          ("Alpha", "", False),  # Validation for content
      ],
  )
  def test_snippet_creation_validation(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:117
_ ERROR at setup of test_snippet_creation_validation[AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA-Content-False] _
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 117
  @pytest.mark.parametrize(
      "name,content,expect_success",
      [
          ("Alpha", "Some content", True),
          ("", "Some content", False),  # Validation for name
          ("A" * 129, "Content", False),  # Validation for name length
          ("NonAscii", "Content", False),  # Validation for name ASCII
          ("Alpha", "", False),  # Validation for content
      ],
  )
  def test_snippet_creation_validation(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:117
_ ERROR at setup of test_snippet_creation_validation[NonAscii\xe9-Content-False] _
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 117
  @pytest.mark.parametrize(
      "name,content,expect_success",
      [
          ("Alpha", "Some content", True),
          ("", "Some content", False),  # Validation for name
          ("A" * 129, "Content", False),  # Validation for name length
          ("NonAscii", "Content", False),  # Validation for name ASCII
          ("Alpha", "", False),  # Validation for content
      ],
  )
  def test_snippet_creation_validation(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:117
______ ERROR at setup of test_snippet_creation_validation[Alpha--False] _______
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 117
  @pytest.mark.parametrize(
      "name,content,expect_success",
      [
          ("Alpha", "Some content", True),
          ("", "Some content", False),  # Validation for name
          ("A" * 129, "Content", False),  # Validation for name length
          ("NonAscii", "Content", False),  # Validation for name ASCII
          ("Alpha", "", False),  # Validation for content
      ],
  )
  def test_snippet_creation_validation(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:117
____ ERROR at setup of test_snippet_name_uniqueness[Unique1-Unique2-True] _____
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 150
  @pytest.mark.parametrize(
      "name1,name2,should_succeed",
      [
          ("Unique1", "Unique2", True),
          ("DupName", "DupName", False),
      ],
  )
  def test_snippet_name_uniqueness(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:150
____ ERROR at setup of test_snippet_name_uniqueness[DupName-DupName-False] ____
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 150
  @pytest.mark.parametrize(
      "name1,name2,should_succeed",
      [
          ("Unique1", "Unique2", True),
          ("DupName", "DupName", False),
      ],
  )
  def test_snippet_name_uniqueness(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:150
________________ ERROR at setup of test_snippet_creation_valid ________________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 175
  def test_snippet_creation_valid(
E       fixture 'snippet_manager' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:175
_______________ ERROR at setup of test_get_nonexistent_snippet ________________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 193
  def test_get_nonexistent_snippet(snippet_manager: SnippetManager) -> None:
E       fixture 'snippet_manager' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:193
_________________ ERROR at setup of test_list_snippets_empty __________________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 198
  def test_list_snippets_empty(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:198
_______________ ERROR at setup of test_list_snippets_populated ________________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 218
  def test_list_snippets_populated(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:218
_____________________ ERROR at setup of test_snippet_edit _____________________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 241
  def test_snippet_edit(
E       fixture 'snippet_manager' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:241
____________________ ERROR at setup of test_snippet_update ____________________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 260
  def test_snippet_update(snippet_category_fixture: str, snippet_manager: SnippetManager) -> None:
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:260
_______________ ERROR at setup of test_snippet_update_name_only _______________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 274
  def test_snippet_update_name_only(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:274
_____________ ERROR at setup of test_snippet_update_content_only ______________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 291
  def test_snippet_update_content_only(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:291
____________________ ERROR at setup of test_snippet_delete ____________________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 308
  def test_snippet_delete(snippet_category_fixture: str, snippet_manager: SnippetManager) -> None:
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:308
______________ ERROR at setup of test_delete_nonexistent_snippet ______________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 317
  def test_delete_nonexistent_snippet(snippet_manager: SnippetManager) -> None:
E       fixture 'snippet_manager' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:317
_____________ ERROR at setup of test_edit_snippet_change_category _____________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 328
  def test_edit_snippet_change_category(
E       fixture 'snippet_manager' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:328
____________ ERROR at setup of test_edit_snippet_invalid_category _____________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 351
  def test_edit_snippet_invalid_category(
E       fixture 'snippet_manager' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:351
________________ ERROR at setup of test_snippet_sql_injection _________________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 366
  def test_snippet_sql_injection(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:366
___________ ERROR at setup of test_snippet_sql_injection_in_content ___________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 375
  def test_snippet_sql_injection_in_content(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:375
_________________ ERROR at setup of test_snippet_long_content _________________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 384
  def test_snippet_long_content(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:384
_________ ERROR at setup of test_snippet_content_splitting_boundaries _________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 398
  def test_snippet_content_splitting_boundaries(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:398
______________ ERROR at setup of test_update_nonexistent_snippet ______________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 593
  def test_update_nonexistent_snippet(snippet_manager: SnippetManager) -> None:
E       fixture 'snippet_manager' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:593
_____________ ERROR at setup of test_snippet_part_number_sequence _____________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 432
  def test_snippet_part_number_sequence(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:432
______________ ERROR at setup of test_snippet_operation_handling ______________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 520
  def test_snippet_operation_handling(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:520
____________________ ERROR at setup of test_delete_snippet ____________________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 563
  def test_delete_snippet(snippet_category_fixture: str, snippet_manager: SnippetManager) -> None:
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:563
_______ ERROR at setup of test_create_snippet_with_nonexistent_category _______
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 580
  def test_create_snippet_with_nonexistent_category(snippet_manager: SnippetManager) -> None:
E       fixture 'snippet_manager' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:580
________________ ERROR at setup of test_update_snippet_partial ________________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 602
  def test_update_snippet_partial(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:602
______________ ERROR at setup of test_update_snippet_no_changes _______________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 637
  def test_update_snippet_no_changes(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:637
_________________ ERROR at setup of test_get_snippet_by_name __________________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 665
  def test_get_snippet_by_name(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:665
___________ ERROR at setup of test_get_snippet_by_name_nonexistent ____________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 685
  def test_get_snippet_by_name_nonexistent(
E       fixture 'snippet_manager' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:685
_______ ERROR at setup of test_get_snippet_by_name_multiple_categories ________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 692
  def test_get_snippet_by_name_multiple_categories(
E       fixture 'category_manager' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:692
___________________ ERROR at setup of test_search_snippets ____________________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 727
  def test_search_snippets(snippet_category_fixture: str, snippet_manager: SnippetManager) -> None:
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:727
______________ ERROR at setup of test_search_snippets_no_results ______________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 760
  def test_search_snippets_no_results(snippet_manager: SnippetManager) -> None:
E       fixture 'snippet_manager' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:760
__________ ERROR at setup of test_snippet_sql_injection_name_create ___________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 768
  def test_snippet_sql_injection_name_create(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:768
_________ ERROR at setup of test_snippet_sql_injection_content_create _________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 782
  def test_snippet_sql_injection_content_create(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:782
_ ERROR at setup of test_snippet_sql_injection_name_create_with_specific_error _
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 796
  def test_snippet_sql_injection_name_create_with_specific_error(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:796
_________ ERROR at setup of test_snippet_sql_injection_content_update _________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 810
  def test_snippet_sql_injection_content_update(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:810
__________ ERROR at setup of test_snippet_sql_injection_name_update ___________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 824
  def test_snippet_sql_injection_name_update(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:824
_____________ ERROR at setup of test_snippet_deletion_idempotency _____________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 838
  def test_snippet_deletion_idempotency(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:838
_ ERROR at setup of test_snippet_manager_handles_db_errors_gracefully_on_create _
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 854
  def test_snippet_manager_handles_db_errors_gracefully_on_create(
E       fixture 'snippet_manager' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:854
_ ERROR at setup of test_snippet_manager_handles_db_errors_gracefully_on_get __
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 871
  def test_snippet_manager_handles_db_errors_gracefully_on_get(
E       fixture 'snippet_manager' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:871
_ ERROR at setup of test_snippet_manager_handles_db_errors_gracefully_on_update _
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 883
  def test_snippet_manager_handles_db_errors_gracefully_on_update(
E       fixture 'snippet_manager' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:883
_ ERROR at setup of test_snippet_manager_handles_db_errors_gracefully_on_delete _
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 910
  def test_snippet_manager_handles_db_errors_gracefully_on_delete(
E       fixture 'snippet_manager' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:910
_ ERROR at setup of test_snippet_manager_handles_db_errors_gracefully_on_list _
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 948
  def test_snippet_manager_handles_db_errors_gracefully_on_list(
E       fixture 'snippet_manager' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:948
_ ERROR at setup of test_snippet_manager_handles_db_errors_gracefully_on_search _
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 960
  def test_snippet_manager_handles_db_errors_gracefully_on_search(
E       fixture 'snippet_manager' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:960
______ ERROR at setup of test_create_snippet_pydantic_validation_errors _______
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 972
  def test_create_snippet_pydantic_validation_errors(
E       fixture 'snippet_manager' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:972
================================== FAILURES ===================================
________________ TestNGramOnlyMode.test_generate_ngram_content ________________

self = <AITypingTrainer.tests.models.test_dynamic_content_manager.TestNGramOnlyMode object at 0x000001FC343F47D0>
basic_manager = <models.dynamic_content_manager.DynamicContentManager object at 0x000001FC348D3BD0>

    def test_generate_ngram_content(self, basic_manager: DynamicContentManager) -> None:
        """Test generating content with NGramOnly mode."""
        basic_manager.mode = ContentMode.NGRAM_ONLY
        content = basic_manager.generate_content()
    
        # Verify content format and constraints
        assert content, "Content should not be empty"
        assert len(content) <= basic_manager.practice_length, "Content should not exceed practice length"
    
        # Verify content only contains ngrams from focus list
        parts = content.split()
        for part in parts:
>           assert part in basic_manager.ngram_focus_list, f"Part '{part}' should be in ngram focus list"
E           AssertionError: Part 's' should be in ngram focus list
E           assert 's' in ['es', 'st', 'te']
E            +  where ['es', 'st', 'te'] = <models.dynamic_content_manager.DynamicContentManager object at 0x000001FC348D3BD0>.ngram_focus_list

tests\models\test_dynamic_content_manager.py:170: AssertionError
_______ TestNGramOnlyMode.test_ngram_content_filters_out_of_scope_chars _______

self = <AITypingTrainer.tests.models.test_dynamic_content_manager.TestNGramOnlyMode object at 0x000001FC33F3DF30>

    def test_ngram_content_filters_out_of_scope_chars(self) -> None:
        """Test that NGramOnly content filters out ngrams with out-of-scope characters."""
        manager = DynamicContentManager(
            in_scope_keys=["a", "b"],
            ngram_focus_list=["ab", "cd", "xy"],  # Only "ab" should be used
            mode=ContentMode.NGRAM_ONLY
        )
    
        content = manager.generate_content()
    
        # Content should only include "ab"
>       assert content == "ab" or content == "", "Content should only include ngrams with in-scope keys"
E       AssertionError: Content should only include ngrams with in-scope keys
E       assert ('ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab a' == 'ab'
E         
E         - ab
E         + ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab a or 'ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab a' == ''
E         
E         + ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab a)

tests\models\test_dynamic_content_manager.py:202: AssertionError
________________ TestMixedMode.test_mixed_content_has_variety _________________

self = <AITypingTrainer.tests.models.test_dynamic_content_manager.TestMixedMode object at 0x000001FC343F4E10>
basic_manager = <models.dynamic_content_manager.DynamicContentManager object at 0x000001FC34963250>

    def test_mixed_content_has_variety(self, basic_manager: DynamicContentManager) -> None:
        """Test that Mixed content includes both ngrams and words."""
        # This test is a bit tricky since the mixed content is randomized
        # We'll make multiple attempts and check statistics
    
        basic_manager.mode = ContentMode.MIXED
        basic_manager.ngram_focus_list = ["ab", "cd"]
    
        # Replace the mock LLM service with one that returns very distinct words
        with patch.object(basic_manager.llm_service, "get_words_with_ngrams",  # type: ignore
                         return_value="abcdef cdabef longerword"):
    
            # Make multiple generation attempts
            seen_ngrams = set()
            seen_longer = False
    
            for _ in range(10):  # Try multiple times due to randomization
                content = basic_manager.generate_content()
                parts = content.split()
    
                for part in parts:
                    if part in basic_manager.ngram_focus_list:
                        seen_ngrams.add(part)
                    elif len(part) > 3:  # Assume longer parts are "words" not ngrams
                        seen_longer = True
    
            # We should see both ngrams and longer words
>           assert seen_ngrams, "Mixed content should include some ngrams"
E           AssertionError: Mixed content should include some ngrams
E           assert set()

tests\models\test_dynamic_content_manager.py:306: AssertionError
---------------------------- Captured stdout call -----------------------------
Generating Text: Raw words: abcdef cdabef longerword
Skipping word: abcdef - bad characters
Skipping word: cdabef - bad characters
Skipping word: longerword - bad characters
Generating Text: Raw words: abcdef cdabef longerword
Skipping word: abcdef - bad characters
Skipping word: cdabef - bad characters
Skipping word: longerword - bad characters
Generating Text: Raw words: abcdef cdabef longerword
Skipping word: abcdef - bad characters
Skipping word: cdabef - bad characters
Skipping word: longerword - bad characters
Generating Text: Raw words: abcdef cdabef longerword
Skipping word: abcdef - bad characters
Skipping word: cdabef - bad characters
Skipping word: longerword - bad characters
Generating Text: Raw words: abcdef cdabef longerword
Skipping word: abcdef - bad characters
Skipping word: cdabef - bad characters
Skipping word: longerword - bad characters
Generating Text: Raw words: abcdef cdabef longerword
Skipping word: abcdef - bad characters
Skipping word: cdabef - bad characters
Skipping word: longerword - bad characters
Generating Text: Raw words: abcdef cdabef longerword
Skipping word: abcdef - bad characters
Skipping word: cdabef - bad characters
Skipping word: longerword - bad characters
Generating Text: Raw words: abcdef cdabef longerword
Skipping word: abcdef - bad characters
Skipping word: cdabef - bad characters
Skipping word: longerword - bad characters
Generating Text: Raw words: abcdef cdabef longerword
Skipping word: abcdef - bad characters
Skipping word: cdabef - bad characters
Skipping word: longerword - bad characters
Generating Text: Raw words: abcdef cdabef longerword
Skipping word: abcdef - bad characters
Skipping word: cdabef - bad characters
Skipping word: longerword - bad characters
_______ TestKeystrokeManagerSaveKeystrokes.test_save_keystrokes_success _______

self = <AITypingTrainer.tests.models.test_keystroke_manager.TestKeystrokeManagerSaveKeystrokes object at 0x000001FC343F6850>
manager_with_mock_db = <models.keystroke_manager.KeystrokeManager object at 0x000001FC348C1220>
sample_keystrokes = [Keystroke(session_id='save-test-session', keystroke_id='633172b5-22d9-4540-ac9b-9f9c5c5b758a', keystroke_time=datetim...=datetime.timezone.utc), keystroke_char='c', expected_char='c', is_error=False, time_since_previous=120, text_index=0)]

    def test_save_keystrokes_success(
        self, manager_with_mock_db: KeystrokeManager, sample_keystrokes: List[Keystroke]
    ) -> None:
        """Test successful saving of keystrokes."""
        manager_with_mock_db.keystroke_list = sample_keystrokes
    
        result = manager_with_mock_db.save_keystrokes()
    
        assert result is True
>       assert manager_with_mock_db.db_manager.execute.call_count == 3
E       AssertionError: assert 0 == 3
E        +  where 0 = <Mock name='mock.execute' id='2182721549184'>.call_count
E        +    where <Mock name='mock.execute' id='2182721549184'> = <Mock spec='DatabaseManager' id='2182721551872'>.execute
E        +      where <Mock spec='DatabaseManager' id='2182721551872'> = <models.keystroke_manager.KeystrokeManager object at 0x000001FC348C1220>.db_manager

tests\models\test_keystroke_manager.py:234: AssertionError
___ TestKeystrokeManagerSaveKeystrokes.test_save_keystrokes_database_error ____

self = <AITypingTrainer.tests.models.test_keystroke_manager.TestKeystrokeManagerSaveKeystrokes object at 0x000001FC33F3F6F0>
manager_with_mock_db = <models.keystroke_manager.KeystrokeManager object at 0x000001FC348D3A10>
sample_keystrokes = [Keystroke(session_id='save-test-session', keystroke_id='e54c4313-4663-4970-b143-e8891626b5d3', keystroke_time=datetim...=datetime.timezone.utc), keystroke_char='c', expected_char='c', is_error=False, time_since_previous=120, text_index=0)]

    def test_save_keystrokes_database_error(
        self, manager_with_mock_db: KeystrokeManager, sample_keystrokes: List[Keystroke]
    ) -> None:
        """Test handling of database errors during save."""
        manager_with_mock_db.keystroke_list = sample_keystrokes
        manager_with_mock_db.db_manager.execute.side_effect = Exception(
            "Database connection failed"
        )
    
        with patch("sys.stderr"), patch("traceback.print_exc"):
            result = manager_with_mock_db.save_keystrokes()
    
>       assert result is False
E       assert True is False

tests\models\test_keystroke_manager.py:277: AssertionError
_ TestKeystrokeManagerSaveKeystrokes.test_save_keystrokes_with_special_characters _

self = <AITypingTrainer.tests.models.test_keystroke_manager.TestKeystrokeManagerSaveKeystrokes object at 0x000001FC33F3F820>
manager_with_mock_db = <models.keystroke_manager.KeystrokeManager object at 0x000001FC34916CF0>

    def test_save_keystrokes_with_special_characters(
        self, manager_with_mock_db: KeystrokeManager
    ) -> None:
        """Test saving keystrokes with special characters."""
        import uuid
    
        special_chars = ["'", '"', "\\\\", "\\n", "\\t", "\u20ac", "\U0001f60a"]
        keystrokes = []
        for _i, char in enumerate(special_chars):
            keystroke = Keystroke(
                session_id="special-char-session",
                keystroke_id=str(uuid.uuid4()),
                keystroke_time=datetime.now(timezone.utc),
                keystroke_char=char,
                expected_char=char,
                is_error=False,
                time_since_previous=100,
            )
            keystrokes.append(keystroke)
        manager_with_mock_db.keystroke_list = keystrokes
        result = manager_with_mock_db.save_keystrokes()
        assert result is True
>       assert manager_with_mock_db.db_manager.execute.call_count == len(special_chars)
E       assert 0 == 7
E        +  where 0 = <Mock name='mock.execute' id='2182726406496'>.call_count
E        +    where <Mock name='mock.execute' id='2182726406496'> = <Mock spec='DatabaseManager' id='2182721549856'>.execute
E        +      where <Mock spec='DatabaseManager' id='2182721549856'> = <models.keystroke_manager.KeystrokeManager object at 0x000001FC34916CF0>.db_manager
E        +  and   7 = len(["'", '"', '\\', '\n', '\t', '\u20ac', '\U0001f60a'])

tests\models\test_keystroke_manager.py:301: AssertionError
_ TestKeystrokeManagerSaveKeystrokes.test_save_keystrokes_boolean_conversion __

self = <AITypingTrainer.tests.models.test_keystroke_manager.TestKeystrokeManagerSaveKeystrokes object at 0x000001FC34491010>
manager_with_mock_db = <models.keystroke_manager.KeystrokeManager object at 0x000001FC34A37860>

    def test_save_keystrokes_boolean_conversion(
        self, manager_with_mock_db: KeystrokeManager
    ) -> None:
        """Test that boolean is_error is properly converted to int."""
        import uuid
    
        keystroke = Keystroke(
            session_id="bool-test",
            keystroke_id=str(uuid.uuid4()),
            keystroke_time=datetime.now(timezone.utc),
            keystroke_char="a",
            expected_char="b",
            is_error=True,
            time_since_previous=50,
        )
        manager_with_mock_db.keystroke_list = [keystroke]
        result = manager_with_mock_db.save_keystrokes()
        assert result is True
        call_args = manager_with_mock_db.db_manager.execute.call_args
>       params = call_args[0][1]
                 ^^^^^^^^^^^^
E       TypeError: 'NoneType' object is not subscriptable

tests\models\test_keystroke_manager.py:322: TypeError
________ TestKeystrokeManagerIntegration.test_full_keystroke_workflow _________

self = <AITypingTrainer.tests.models.test_keystroke_manager.TestKeystrokeManagerIntegration object at 0x000001FC343F6FD0>
integration_manager = <models.keystroke_manager.KeystrokeManager object at 0x000001FC34A574D0>

    def test_full_keystroke_workflow(self, integration_manager: KeystrokeManager) -> None:
        """Test complete workflow: add, save, count, retrieve, delete."""
        import uuid
    
        session_id = str(uuid.uuid4())
        # Insert a matching session into the database
        db = integration_manager.db_manager
        db.init_tables()
        # Ensure session_keystrokes table is correct for UUID keystroke_id
        db.execute("DROP TABLE IF EXISTS session_keystrokes")
        db.execute(
            """
            CREATE TABLE session_keystrokes (
                keystroke_id TEXT PRIMARY KEY,
                session_id TEXT NOT NULL,
                keystroke_time TEXT NOT NULL,
                keystroke_char TEXT NOT NULL,
                expected_char TEXT NOT NULL,
                is_error INTEGER NOT NULL,
                time_since_previous INTEGER,
                FOREIGN KEY (session_id) REFERENCES practice_sessions(session_id) ON DELETE CASCADE
            )
            """
        )
        category_id = str(uuid.uuid4())
        # Insert a matching category into the database
        db.execute(
            """
            INSERT INTO categories (category_id, category_name) VALUES (?, ?)
            """,
            (category_id, "integration-category"),
        )
        snippet_id = str(uuid.uuid4())
        # Insert a matching snippet into the database
        db.execute(
            """
            INSERT INTO snippets (snippet_id, category_id, snippet_name) VALUES (?, ?, ?)
            """,
            (snippet_id, category_id, "integration-snippet"),
        )
        user_id = str(uuid.uuid4())
        keyboard_id = str(uuid.uuid4())
        db.execute(
            "INSERT INTO users (user_id, first_name, surname, email_address) VALUES (?, ?, ?, ?)",
            (user_id, "Test", "User", f"testuser_{user_id[:8]}@example.com"),
        )
        db.execute(
            "INSERT INTO keyboards (keyboard_id, user_id, keyboard_name) VALUES (?, ?, ?)",
            (keyboard_id, user_id, "Test Keyboard"),
        )
        db.execute(
            "INSERT INTO practice_sessions (session_id, snippet_id, user_id, keyboard_id, snippet_index_start, snippet_index_end, content, start_time, end_time, actual_chars, errors, ms_per_keystroke) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)",
            (
                session_id,
                snippet_id,
                user_id,
                keyboard_id,
                0,
                10,
                "abcde",
                "2025-06-10T12:00:00",
                "2025-06-10T12:01:00",
                5,
                0,
                100.0,
            ),
        )
        # Create test keystrokes
        keystrokes = []
        for i in range(5):
            keystroke = Keystroke(
                session_id=session_id,
                keystroke_id=str(uuid.uuid4()),
                keystroke_time=datetime.now(timezone.utc),
                keystroke_char=chr(97 + i),
                expected_char=chr(97 + i),
                is_error=i == 2,  # Make one an error
                time_since_previous=100 + i * 10,  # Always integer
            )
            keystrokes.append(keystroke)
            integration_manager.add_keystroke(keystroke)
        # Verify keystrokes are in memory
        assert len(integration_manager.keystroke_list) == 5
        # Save to database
        save_result = integration_manager.save_keystrokes()
>       assert save_result is True
E       assert False is True

tests\models\test_keystroke_manager.py:636: AssertionError
---------------------------- Captured stdout call -----------------------------
 Exception during execute_many: table session_keystrokes has no column named text_index. Rolling back transaction.
---------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 605, in execute_many
    return self._bulk_executemany(cursor, query, params_list)
           ~~~~~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 633, in _bulk_executemany
    cursor.executemany(query, params_list)
    ~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^
sqlite3.OperationalError: table session_keystrokes has no column named text_index
Error saving keystrokes: Database operation failed: table session_keystrokes has no column named text_index
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 605, in execute_many
    return self._bulk_executemany(cursor, query, params_list)
           ~~~~~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 633, in _bulk_executemany
    cursor.executemany(query, params_list)
    ~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^
sqlite3.OperationalError: table session_keystrokes has no column named text_index

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\models\keystroke_manager.py", line 63, in save_keystrokes
    self.db_manager.execute_many(query, params)  # type: ignore[attr-defined]
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 614, in execute_many
    self._translate_and_raise(e)
    ~~~~~~~~~~~~~~~~~~~~~~~~~^^^
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 434, in _translate_and_raise
    raise DatabaseError(f"Database operation failed: {e}") from e
db.exceptions.DatabaseError: Database operation failed: table session_keystrokes has no column named text_index
______ TestKeystrokeManagerEdgeCases.test_unicode_and_special_characters ______

self = <AITypingTrainer.tests.models.test_keystroke_manager.TestKeystrokeManagerEdgeCases object at 0x000001FC33F3FE10>
manager = <models.keystroke_manager.KeystrokeManager object at 0x000001FC34A66870>

    def test_unicode_and_special_characters(self, manager: KeystrokeManager) -> None:
        """Test handling of Unicode and special characters in keystrokes."""
        import uuid
    
        special_chars = [
            "\U0001f642",
            "\u6d4b\u8bd5",
            "caf",
            "\u03a9",
            "\n",
            "\t",
            "\\",
            "'",
            '"',
            "\0",
        ]
        for _i, char in enumerate(special_chars):
            keystroke = Keystroke(
                session_id="unicode-test",
                keystroke_id=str(uuid.uuid4()),
                keystroke_time=datetime.now(timezone.utc),
                keystroke_char=char,
                expected_char=char,
                is_error=False,
                time_since_previous=100,  # Always integer
            )
            manager.add_keystroke(keystroke)
        assert len(manager.keystroke_list) == len(special_chars)
        result = manager.save_keystrokes()
        assert result is True
>       assert manager.db_manager.execute.call_count == len(special_chars)
E       assert 0 == 10
E        +  where 0 = <Mock name='mock.execute' id='2182726414560'>.call_count
E        +    where <Mock name='mock.execute' id='2182726414560'> = <Mock spec='DatabaseManager' id='2182726415904'>.execute
E        +      where <Mock spec='DatabaseManager' id='2182726415904'> = <models.keystroke_manager.KeystrokeManager object at 0x000001FC34A66870>.db_manager
E        +  and   10 = len(['\U0001f642', '\u6d4b\u8bd5', 'caf\xe9', '\u03a9', '\n', '\t', '\\', "'", '"', '\x00'])

tests\models\test_keystroke_manager.py:829: AssertionError
_____ TestKeystrokeManagerErrorHandling.test_database_connection_failure ______

self = <AITypingTrainer.tests.models.test_keystroke_manager.TestKeystrokeManagerErrorHandling object at 0x000001FC343F74D0>
manager = <models.keystroke_manager.KeystrokeManager object at 0x000001FC34A237D0>

    def test_database_connection_failure(self, manager: KeystrokeManager) -> None:
        """Test handling of database connection failures."""
        import uuid
    
        manager.db_manager.execute.side_effect = Exception("Connection lost")
        keystroke = Keystroke(
            session_id="error-test",
            keystroke_id=str(uuid.uuid4()),
            keystroke_time=datetime.now(timezone.utc),
            keystroke_char="a",
            expected_char="a",
            is_error=False,
            time_since_previous=100,
        )
        manager.add_keystroke(keystroke)
        result = manager.save_keystrokes()
>       assert result is False
E       assert True is False

tests\models\test_keystroke_manager.py:878: AssertionError
_________ TestKeystrokeManagerErrorHandling.test_partial_save_failure _________

self = <AITypingTrainer.tests.models.test_keystroke_manager.TestKeystrokeManagerErrorHandling object at 0x000001FC344E0180>
manager = <models.keystroke_manager.KeystrokeManager object at 0x000001FC34A55790>

    def test_partial_save_failure(self, manager: KeystrokeManager) -> None:
        """Test handling when some keystrokes save successfully and others fail."""
        import uuid
    
        keystrokes = []
        for i in range(3):
            keystroke = Keystroke(
                session_id="partial-test",
                keystroke_id=str(uuid.uuid4()),
                keystroke_time=datetime.now(timezone.utc),
                keystroke_char=chr(97 + i),
                expected_char=chr(97 + i),
                is_error=False,
                time_since_previous=100,
            )
            keystrokes.append(keystroke)
        manager.keystroke_list = keystrokes
        manager.db_manager.execute.side_effect = [None, Exception("Save failed"), None]
        result = manager.save_keystrokes()
>       assert result is False
E       assert True is False

tests\models\test_keystroke_manager.py:919: AssertionError
______ TestKeystrokeManagerErrorHandling.test_network_timeout_simulation ______

self = <AITypingTrainer.tests.models.test_keystroke_manager.TestKeystrokeManagerErrorHandling object at 0x000001FC344E02B0>
manager = <models.keystroke_manager.KeystrokeManager object at 0x000001FC34A701D0>

    def test_network_timeout_simulation(self, manager: KeystrokeManager) -> None:
        """Test handling of network timeout-like errors."""
        import time
        import uuid
    
        def slow_execute(*args: object, **kwargs: object) -> object:
            time.sleep(0.1)  # Simulate slow operation
            raise TimeoutError("Database timeout")
    
        manager.db_manager.execute.side_effect = slow_execute
        keystroke = Keystroke(
            session_id="timeout-test",
            keystroke_id=str(uuid.uuid4()),
            keystroke_time=datetime.now(timezone.utc),
            keystroke_char="a",
            expected_char="a",
            is_error=False,
            time_since_previous=100,
        )
        manager.add_keystroke(keystroke)
        result = manager.save_keystrokes()
>       assert result is False
E       assert True is False

tests\models\test_keystroke_manager.py:942: AssertionError
____________________________ test_missing_api_key _____________________________

    def test_missing_api_key():
>       with pytest.raises(LLMMissingAPIKeyError):
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       Failed: DID NOT RAISE <class 'models.llm_ngram_service.LLMMissingAPIKeyError'>

tests\models\test_llm_ngram_service.py:8: Failed
________________ TestKeystroke.test_keystroke_nfc_single_char _________________

self = <AITypingTrainer.tests.models.test_ngram.TestKeystroke object at 0x000001FC343F7D90>

    def test_keystroke_nfc_single_char(self):
        # composed e + \u0301
        k = Keystroke(keystroke_time=ts(0), text_index=0, expected_char="e\u0301", keystroke_char="", is_error=False)
>       assert k.expected_char == ""
E       AssertionError: assert 'e\u0301' == '\xe9'
E         
E         - 
E         + e\u0301

tests\models\test_ngram.py:32: AssertionError
__ TestNGramAnalyticsService.test_dual_insert_creates_records_in_both_tables __

self = <AITypingTrainer.tests.models.test_ngram_analytics_service.TestNGramAnalyticsService object at 0x000001FC34499650>
temp_db = 'C:\\Users\\seanb\\AppData\\Local\\Temp\\tmp552ok292.db'
mock_sessions = [{'keyboard_id': 'keyboard_1', 'session_id': 'session_1', 'start_time': '2024-01-01 10:01:00', 'target_ms_per_keystrok...: 'keyboard_1', 'session_id': 'session_2', 'start_time': '2024-01-01 10:02:00', 'target_ms_per_keystroke': 170.0, ...}]
mock_ngram_data = [{'ms_per_keystroke': 100.0, 'ngram_size': 2, 'ngram_speed_id': 'ng_0', 'ngram_text': 'th', ...}, {'ms_per_keystroke':...ram_text': 'th', ...}, {'ms_per_keystroke': 107.5, 'ngram_size': 3, 'ngram_speed_id': 'ng_3', 'ngram_text': 'he', ...}]

    def test_dual_insert_creates_records_in_both_tables(
        self,
        temp_db: DatabaseManager,
        mock_sessions: List[MockSessionData],
        mock_ngram_data: List[MockNGramSpeedData],
    ) -> None:
        """
        Test objective: Verify dual-insert creates records in both current and history tables.
    
        Tests that when refresh_speed_summaries is called, records are created
        in both ngram_speed_summary_curr and ngram_speed_summary_hist tables.
        """
        ngram_manager = NGramManager(temp_db)
        service = NGramAnalyticsService(temp_db, ngram_manager)
    
        # Set up test data
        user_id = "user_1"
        keyboard_id = "keyboard_1"
    
        # Insert test session and keyboard data
        for session in mock_sessions:
>           temp_db.execute(
            ^^^^^^^^^^^^^^^
                """INSERT INTO practice_sessions
                (session_id, user_id, keyboard_id, snippet_id, snippet_index_start, snippet_index_end,
                 content, start_time, end_time, actual_chars, errors, ms_per_keystroke)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)""",
                (
                    session["session_id"],
                    session["user_id"],
                    session["keyboard_id"],
                    "test_snippet_1",
                    0,
                    10,
                    "test content",
                    session["start_time"],
                    session["start_time"],
                    "test",
                    0,
                    session["target_ms_per_keystroke"],
                ),
            )
E           AttributeError: 'str' object has no attribute 'execute'

tests\models\test_ngram_analytics_service.py:370: AttributeError
____ TestNGramAnalyticsService.test_history_table_accumulates_all_records _____

self = <AITypingTrainer.tests.models.test_ngram_analytics_service.TestNGramAnalyticsService object at 0x000001FC34499C50>
temp_db = 'C:\\Users\\seanb\\AppData\\Local\\Temp\\tmpigzoi43g.db'
mock_sessions = [{'keyboard_id': 'keyboard_1', 'session_id': 'session_1', 'start_time': '2024-01-01 10:01:00', 'target_ms_per_keystrok...: 'keyboard_1', 'session_id': 'session_2', 'start_time': '2024-01-01 10:02:00', 'target_ms_per_keystroke': 170.0, ...}]
mock_ngram_data = [{'ms_per_keystroke': 100.0, 'ngram_size': 2, 'ngram_speed_id': 'ng_0', 'ngram_text': 'th', ...}, {'ms_per_keystroke':...ram_text': 'th', ...}, {'ms_per_keystroke': 107.5, 'ngram_size': 3, 'ngram_speed_id': 'ng_3', 'ngram_text': 'he', ...}]

    def test_history_table_accumulates_all_records(
        self,
        temp_db: DatabaseManager,
        mock_sessions: List[MockSessionData],
        mock_ngram_data: List[MockNGramSpeedData],
    ) -> None:
        """
        Test objective: Verify history table contains all records over multiple refreshes.
    
        Tests that the history table accumulates all records from multiple
        refresh operations while current table only contains latest values.
        """
        ngram_manager = NGramManager(temp_db)
        service = NGramAnalyticsService(temp_db, ngram_manager)
    
        user_id = "user_1"
        keyboard_id = "keyboard_1"
    
        # Set up initial test data
        for session in mock_sessions:
>           temp_db.execute(
            ^^^^^^^^^^^^^^^
                """INSERT INTO practice_sessions
                (session_id, user_id, keyboard_id, snippet_id, snippet_index_start, snippet_index_end,
                 content, start_time, end_time, actual_chars, errors, ms_per_keystroke)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)""",
                (
                    session["session_id"],
                    session["user_id"],
                    session["keyboard_id"],
                    "test_snippet_1",
                    0,
                    10,
                    "test content",
                    session["start_time"],
                    session["start_time"],
                    "test",
                    0,
                    session["target_ms_per_keystroke"],
                ),
            )
E           AttributeError: 'str' object has no attribute 'execute'

tests\models\test_ngram_analytics_service.py:442: AttributeError
_________ TestNGramAnalyticsService.test_get_ngram_history_retrieval __________

self = <AITypingTrainer.tests.models.test_ngram_analytics_service.TestNGramAnalyticsService object at 0x000001FC3427EA80>
temp_db = 'C:\\Users\\seanb\\AppData\\Local\\Temp\\tmpmnsw_s6_.db'
mock_sessions = [{'keyboard_id': 'keyboard_1', 'session_id': 'session_1', 'start_time': '2024-01-01 10:01:00', 'target_ms_per_keystrok...: 'keyboard_1', 'session_id': 'session_2', 'start_time': '2024-01-01 10:02:00', 'target_ms_per_keystroke': 170.0, ...}]
mock_ngram_data = [{'ms_per_keystroke': 100.0, 'ngram_size': 2, 'ngram_speed_id': 'ng_0', 'ngram_text': 'th', ...}, {'ms_per_keystroke':...ram_text': 'th', ...}, {'ms_per_keystroke': 107.5, 'ngram_size': 3, 'ngram_speed_id': 'ng_3', 'ngram_text': 'he', ...}]

    def test_get_ngram_history_retrieval(
        self,
        temp_db: DatabaseManager,
        mock_sessions: List[MockSessionData],
        mock_ngram_data: List[MockNGramSpeedData],
    ) -> None:
        """
        Test objective: Verify history retrieval functionality.
    
        Tests that historical data can be retrieved properly with correct
        timestamps and performance metrics.
        """
        ngram_manager = NGramManager(temp_db)
        service = NGramAnalyticsService(temp_db, ngram_manager)
    
        user_id = "user_1"
        keyboard_id = "keyboard_1"
    
        # Set up test data and refresh
        for session in mock_sessions:
>           temp_db.execute(
            ^^^^^^^^^^^^^^^
                """INSERT INTO practice_sessions
                (session_id, user_id, keyboard_id, snippet_id, snippet_index_start, snippet_index_end,
                 content, start_time, end_time, actual_chars, errors, ms_per_keystroke)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)""",
                (
                    session["session_id"],
                    session["user_id"],
                    session["keyboard_id"],
                    "test_snippet_1",
                    0,
                    10,
                    "test content",
                    session["start_time"],
                    session["start_time"],
                    "test",
                    0,
                    session["target_ms_per_keystroke"],
                ),
            )
E           AttributeError: 'str' object has no attribute 'execute'

tests\models\test_ngram_analytics_service.py:552: AttributeError
______ TestNGramAnalyticsService.test_history_table_schema_compatibility ______

self = <AITypingTrainer.tests.models.test_ngram_analytics_service.TestNGramAnalyticsService object at 0x000001FC3427E8A0>
temp_db = 'C:\\Users\\seanb\\AppData\\Local\\Temp\\tmp8uvc9yhy.db'

    def test_history_table_schema_compatibility(
        self, temp_db: DatabaseManager
    ) -> None:
        """
        Test objective: Verify history table schema matches current table.
    
        Tests that the history table has the same essential columns as
        the current table plus additional history-specific fields.
        """
        ngram_manager = NGramManager(temp_db)
        service = NGramAnalyticsService(temp_db, ngram_manager)
    
        # Verify table schemas are compatible
>       current_schema = temp_db.fetchall("PRAGMA table_info(ngram_speed_summary_curr)")
                         ^^^^^^^^^^^^^^^^
E       AttributeError: 'str' object has no attribute 'fetchall'

tests\models\test_ngram_analytics_service.py:617: AttributeError
__________________ test_process_end_of_session_success_path ___________________

self = <db.database_manager.DatabaseManager object at 0x000001FC34569CC0>
query = '\n            INSERT INTO categories (category_id, category_name, description)\n            VALUES (?, ?, ?)\n            '
params = ('b7caa07d-338b-4c3a-bf57-7b3b0771e04b', 'Test Category', 'Test category for testing')

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table categories has no column named description

db\database_manager.py:509: OperationalError

The above exception was the direct cause of the following exception:

db_with_tables = <db.database_manager.DatabaseManager object at 0x000001FC34569CC0>
test_user = User(user_id='4d696e26-dedd-4473-b672-12dfac4ad772', first_name='Test', surname='User', email_address='test.user.9664603d-7333-4c01-bfed-ba35341d2f7f@example.com')
test_keyboard = Keyboard(keyboard_id='4fc20b77-e527-43f5-b90b-1587ca5483df', user_id='4d696e26-dedd-4473-b672-12dfac4ad772', keyboard_name='Test Keyboard', target_ms_per_keystroke=600)

    def test_process_end_of_session_success_path(db_with_tables, test_user, test_keyboard):
        # Arrange: create snippet (for FK completeness) and a new Session not yet in DB
        from tests.models.conftest import TestSessionMethodsFixtures
    
>       category_id = TestSessionMethodsFixtures.create_category(db_with_tables)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_ngram_orchestrator_process_end_of_session.py:40: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:239: in create_category
    db.execute(
db\database_manager.py:524: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x000001FC34569CC0>
e = OperationalError('table categories has no column named description')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table categories has no column named description

db\database_manager.py:434: DatabaseError
---------------------------- Captured stdout call -----------------------------
Exception during query: table categories has no column named description. Rolling back transaction.
---------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 509, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table categories has no column named description
______________ test_process_end_of_session_session_save_failure _______________

self = <db.database_manager.DatabaseManager object at 0x000001FC34BF8590>
query = '\n            INSERT INTO categories (category_id, category_name, description)\n            VALUES (?, ?, ?)\n            '
params = ('8eb47bcc-9e70-4179-be6a-86a0c2b5ffc0', 'Test Category', 'Test category for testing')

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table categories has no column named description

db\database_manager.py:509: OperationalError

The above exception was the direct cause of the following exception:

db_with_tables = <db.database_manager.DatabaseManager object at 0x000001FC34BF8590>
test_user = User(user_id='f0e910eb-c30d-4d30-97d1-cf4864ef92c8', first_name='Test', surname='User', email_address='test.user.ec260c4b-62a6-48f5-b9cc-0b22cd29c1a3@example.com')

    def test_process_end_of_session_session_save_failure(db_with_tables, test_user):
        """Fails at step 1: session save should raise due to FK violation (invalid keyboard_id)."""
        from tests.models.conftest import TestSessionMethodsFixtures
    
        # Valid snippet/category, but invalid keyboard_id to trigger FK failure on insert
>       category_id = TestSessionMethodsFixtures.create_category(db_with_tables)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_ngram_orchestrator_process_end_of_session.py:129: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:239: in create_category
    db.execute(
db\database_manager.py:524: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x000001FC34BF8590>
e = OperationalError('table categories has no column named description')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table categories has no column named description

db\database_manager.py:434: DatabaseError
---------------------------- Captured stdout call -----------------------------
Exception during query: table categories has no column named description. Rolling back transaction.
---------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 509, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table categories has no column named description
_____________ test_process_end_of_session_keystrokes_save_failure _____________

self = <db.database_manager.DatabaseManager object at 0x000001FC34C64C20>
query = '\n            INSERT INTO categories (category_id, category_name, description)\n            VALUES (?, ?, ?)\n            '
params = ('1cfe528c-760a-4261-bd77-1bb794316841', 'Test Category', 'Test category for testing')

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table categories has no column named description

db\database_manager.py:509: OperationalError

The above exception was the direct cause of the following exception:

db_with_tables = <db.database_manager.DatabaseManager object at 0x000001FC34C64C20>
test_user = User(user_id='2a57af60-9c22-4288-a09c-678726fecd02', first_name='Test', surname='User', email_address='test.user.25d17f03-0b75-4289-99d5-ed83724d34db@example.com')
test_keyboard = Keyboard(keyboard_id='cfcb37eb-3887-4739-96fc-32c970c227ef', user_id='2a57af60-9c22-4288-a09c-678726fecd02', keyboard_name='Test Keyboard', target_ms_per_keystroke=600)

    def test_process_end_of_session_keystrokes_save_failure(db_with_tables, test_user, test_keyboard):
        """Fails at step 2: keystrokes save should return False due to invalid keystroke session_id."""
        from tests.models.conftest import TestSessionMethodsFixtures
    
>       category_id = TestSessionMethodsFixtures.create_category(db_with_tables)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_ngram_orchestrator_process_end_of_session.py:170: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:239: in create_category
    db.execute(
db\database_manager.py:524: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x000001FC34C64C20>
e = OperationalError('table categories has no column named description')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table categories has no column named description

db\database_manager.py:434: DatabaseError
---------------------------- Captured stdout call -----------------------------
Exception during query: table categories has no column named description. Rolling back transaction.
---------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 509, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table categories has no column named description
______________ test_process_end_of_session_summarization_failure ______________

self = <db.database_manager.DatabaseManager object at 0x000001FC34C656A0>
query = '\n            INSERT INTO categories (category_id, category_name, description)\n            VALUES (?, ?, ?)\n            '
params = ('6f7f789f-49c1-464a-867c-9ed92a4842ce', 'Test Category', 'Test category for testing')

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table categories has no column named description

db\database_manager.py:509: OperationalError

The above exception was the direct cause of the following exception:

db_with_tables = <db.database_manager.DatabaseManager object at 0x000001FC34C656A0>
test_user = User(user_id='fde95085-8b8d-47fb-a480-41b0cc81af9c', first_name='Test', surname='User', email_address='test.user.d60f2023-a36b-4ff8-b8f3-4514c389b53f@example.com')
test_keyboard = Keyboard(keyboard_id='d0940e66-9a4b-4249-babb-8b2121c6cf58', user_id='fde95085-8b8d-47fb-a480-41b0cc81af9c', keyboard_name='Test Keyboard', target_ms_per_keystroke=600)

    def test_process_end_of_session_summarization_failure(db_with_tables, test_user, test_keyboard):
        """Fails at step 4: drop summary table to force summarization SQL to fail after n-grams."""
        from tests.models.conftest import TestSessionMethodsFixtures
    
>       category_id = TestSessionMethodsFixtures.create_category(db_with_tables)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_ngram_orchestrator_process_end_of_session.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:239: in create_category
    db.execute(
db\database_manager.py:524: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x000001FC34C656A0>
e = OperationalError('table categories has no column named description')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table categories has no column named description

db\database_manager.py:434: DatabaseError
---------------------------- Captured stdout call -----------------------------
Exception during query: table categories has no column named description. Rolling back transaction.
---------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 509, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table categories has no column named description
============================== warnings summary ===============================
tests/models/test_session.py::test_to_dict_and_from_dict
  D:\SeanDevLocal\AITypingTrainer\models\session.py:108: PydanticDeprecatedSince20: The `dict` method is deprecated; use `model_dump` instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.11/migration/
    return self.dict()

tests/models/test_user.py::TestUserModel::test_to_dict
  D:\SeanDevLocal\AITypingTrainer\models\user.py:202: PydanticDeprecatedSince20: The `dict` method is deprecated; use `model_dump` instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.11/migration/
    return self.dict()

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=========================== short test summary info ===========================
FAILED tests/models/test_dynamic_content_manager.py::TestNGramOnlyMode::test_generate_ngram_content - AssertionError: Part 's' should be in ngram focus list
assert 's' in ['es', 'st', 'te']
 +  where ['es', 'st', 'te'] = <models.dynamic_content_manager.DynamicContentManager object at 0x000001FC348D3BD0>.ngram_focus_list
FAILED tests/models/test_dynamic_content_manager.py::TestNGramOnlyMode::test_ngram_content_filters_out_of_scope_chars - AssertionError: Content should only include ngrams with in-scope keys
assert ('ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab a' == 'ab'
  
  - ab
  + ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab a or 'ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab a' == ''
  
  + ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab a)
FAILED tests/models/test_dynamic_content_manager.py::TestMixedMode::test_mixed_content_has_variety - AssertionError: Mixed content should include some ngrams
assert set()
FAILED tests/models/test_keystroke_manager.py::TestKeystrokeManagerSaveKeystrokes::test_save_keystrokes_success - AssertionError: assert 0 == 3
 +  where 0 = <Mock name='mock.execute' id='2182721549184'>.call_count
 +    where <Mock name='mock.execute' id='2182721549184'> = <Mock spec='DatabaseManager' id='2182721551872'>.execute
 +      where <Mock spec='DatabaseManager' id='2182721551872'> = <models.keystroke_manager.KeystrokeManager object at 0x000001FC348C1220>.db_manager
FAILED tests/models/test_keystroke_manager.py::TestKeystrokeManagerSaveKeystrokes::test_save_keystrokes_database_error - assert True is False
FAILED tests/models/test_keystroke_manager.py::TestKeystrokeManagerSaveKeystrokes::test_save_keystrokes_with_special_characters - assert 0 == 7
 +  where 0 = <Mock name='mock.execute' id='2182726406496'>.call_count
 +    where <Mock name='mock.execute' id='2182726406496'> = <Mock spec='DatabaseManager' id='2182721549856'>.execute
 +      where <Mock spec='DatabaseManager' id='2182721549856'> = <models.keystroke_manager.KeystrokeManager object at 0x000001FC34916CF0>.db_manager
 +  and   7 = len(["'", '"', '\\', '\n', '\t', '\u20ac', '\U0001f60a'])
FAILED tests/models/test_keystroke_manager.py::TestKeystrokeManagerSaveKeystrokes::test_save_keystrokes_boolean_conversion - TypeError: 'NoneType' object is not subscriptable
FAILED tests/models/test_keystroke_manager.py::TestKeystrokeManagerIntegration::test_full_keystroke_workflow - assert False is True
FAILED tests/models/test_keystroke_manager.py::TestKeystrokeManagerEdgeCases::test_unicode_and_special_characters - assert 0 == 10
 +  where 0 = <Mock name='mock.execute' id='2182726414560'>.call_count
 +    where <Mock name='mock.execute' id='2182726414560'> = <Mock spec='DatabaseManager' id='2182726415904'>.execute
 +      where <Mock spec='DatabaseManager' id='2182726415904'> = <models.keystroke_manager.KeystrokeManager object at 0x000001FC34A66870>.db_manager
 +  and   10 = len(['\U0001f642', '\u6d4b\u8bd5', 'caf\xe9', '\u03a9', '\n', '\t', '\\', "'", '"', '\x00'])
FAILED tests/models/test_keystroke_manager.py::TestKeystrokeManagerErrorHandling::test_database_connection_failure - assert True is False
FAILED tests/models/test_keystroke_manager.py::TestKeystrokeManagerErrorHandling::test_partial_save_failure - assert True is False
FAILED tests/models/test_keystroke_manager.py::TestKeystrokeManagerErrorHandling::test_network_timeout_simulation - assert True is False
FAILED tests/models/test_llm_ngram_service.py::test_missing_api_key - Failed: DID NOT RAISE <class 'models.llm_ngram_service.LLMMissingAPIKeyError'>
FAILED tests/models/test_ngram.py::TestKeystroke::test_keystroke_nfc_single_char - AssertionError: assert 'e\\u0301' == '\\xe9'\n  \n  - \xe9\n  + e\u0301
FAILED tests/models/test_ngram_analytics_service.py::TestNGramAnalyticsService::test_dual_insert_creates_records_in_both_tables - AttributeError: 'str' object has no attribute 'execute'
FAILED tests/models/test_ngram_analytics_service.py::TestNGramAnalyticsService::test_history_table_accumulates_all_records - AttributeError: 'str' object has no attribute 'execute'
FAILED tests/models/test_ngram_analytics_service.py::TestNGramAnalyticsService::test_get_ngram_history_retrieval - AttributeError: 'str' object has no attribute 'execute'
FAILED tests/models/test_ngram_analytics_service.py::TestNGramAnalyticsService::test_history_table_schema_compatibility - AttributeError: 'str' object has no attribute 'fetchall'
FAILED tests/models/test_ngram_orchestrator_process_end_of_session.py::test_process_end_of_session_success_path - db.exceptions.DatabaseError: Database operation failed: table categories has no column named description
FAILED tests/models/test_ngram_orchestrator_process_end_of_session.py::test_process_end_of_session_session_save_failure - db.exceptions.DatabaseError: Database operation failed: table categories has no column named description
FAILED tests/models/test_ngram_orchestrator_process_end_of_session.py::test_process_end_of_session_keystrokes_save_failure - db.exceptions.DatabaseError: Database operation failed: table categories has no column named description
FAILED tests/models/test_ngram_orchestrator_process_end_of_session.py::test_process_end_of_session_summarization_failure - db.exceptions.DatabaseError: Database operation failed: table categories has no column named description
ERROR tests/models/test_ngram_analytics_service.py::TestNGramAnalyticsService::test_refresh_speed_summaries_basic - db.exceptions.DatabaseError: Database operation failed: table snippets has no column named title
ERROR tests/models/test_ngram_analytics_service_session_methods.py::TestSummarizeSessionNgrams::test_summarize_with_ngram_speed_only[1-1] - db.exceptions.DatabaseError: Database operation failed: table categories has no column named description
ERROR tests/models/test_ngram_analytics_service_session_methods.py::TestSummarizeSessionNgrams::test_summarize_with_ngram_speed_only[3-3] - db.exceptions.DatabaseError: Database operation failed: table categories has no column named description
ERROR tests/models/test_ngram_analytics_service_session_methods.py::TestSummarizeSessionNgrams::test_summarize_with_ngram_errors_only[1-1] - db.exceptions.DatabaseError: Database operation failed: table categories has no column named description
ERROR tests/models/test_ngram_analytics_service_session_methods.py::TestSummarizeSessionNgrams::test_summarize_with_ngram_errors_only[2-2] - db.exceptions.DatabaseError: Database operation failed: table categories has no column named description
ERROR tests/models/test_ngram_analytics_service_session_methods.py::TestSummarizeSessionNgrams::test_summarize_with_speed_and_errors - db.exceptions.DatabaseError: Database operation failed: table categories has no column named description
ERROR tests/models/test_ngram_analytics_service_session_methods.py::TestSummarizeSessionNgrams::test_summarize_with_keystrokes[1-1] - db.exceptions.DatabaseError: Database operation failed: table categories has no column named description
ERROR tests/models/test_ngram_analytics_service_session_methods.py::TestSummarizeSessionNgrams::test_summarize_with_keystrokes[3-3] - db.exceptions.DatabaseError: Database operation failed: table categories has no column named description
ERROR tests/models/test_ngram_analytics_service_session_methods.py::TestSummarizeSessionNgrams::test_no_sessions_missing - db.exceptions.DatabaseError: Database operation failed: table categories has no column named description
ERROR tests/models/test_ngram_analytics_service_session_methods.py::TestSummarizeSessionNgrams::test_sessions_missing_no_data - db.exceptions.DatabaseError: Database operation failed: table categories has no column named description
ERROR tests/models/test_ngram_analytics_service_session_methods.py::TestAddSpeedSummaryForSession::test_single_session_processing - db.exceptions.DatabaseError: Database operation failed: table categories has no column named description
ERROR tests/models/test_ngram_analytics_service_session_methods.py::TestAddSpeedSummaryForSession::test_multiple_ngrams_processing - db.exceptions.DatabaseError: Database operation failed: table categories has no column named description
ERROR tests/models/test_ngram_analytics_service_session_methods.py::TestCatchupSpeedSummary::test_single_session_catchup - db.exceptions.DatabaseError: Database operation failed: table categories has no column named description
ERROR tests/models/test_ngram_analytics_service_session_methods.py::TestCatchupSpeedSummary::test_multiple_sessions_catchup - db.exceptions.DatabaseError: Database operation failed: table categories has no column named description
ERROR tests/models/test_ngram_analytics_service_session_methods.py::TestCatchupSpeedSummary::test_catchup_with_session_errors - db.exceptions.DatabaseError: Database operation failed: table categories has no column named description
ERROR tests/models/test_ngram_analytics_service_session_methods.py::TestIntegrationScenarios::test_full_workflow_integration - db.exceptions.DatabaseError: Database operation failed: table categories has no column named description
ERROR tests/models/test_snippet.py::test_snippet_ascii_name
ERROR tests/models/test_snippet.py::test_snippet_name_length
ERROR tests/models/test_snippet.py::test_snippet_creation_validation[Alpha-Some content-True]
ERROR tests/models/test_snippet.py::test_snippet_creation_validation[-Some content-False]
ERROR tests/models/test_snippet.py::test_snippet_creation_validation[AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA-Content-False]
ERROR tests/models/test_snippet.py::test_snippet_creation_validation[NonAscii\xe9-Content-False]
ERROR tests/models/test_snippet.py::test_snippet_creation_validation[Alpha--False]
ERROR tests/models/test_snippet.py::test_snippet_name_uniqueness[Unique1-Unique2-True]
ERROR tests/models/test_snippet.py::test_snippet_name_uniqueness[DupName-DupName-False]
ERROR tests/models/test_snippet.py::test_snippet_creation_valid
ERROR tests/models/test_snippet.py::test_get_nonexistent_snippet
ERROR tests/models/test_snippet.py::test_list_snippets_empty
ERROR tests/models/test_snippet.py::test_list_snippets_populated
ERROR tests/models/test_snippet.py::test_snippet_edit
ERROR tests/models/test_snippet.py::test_snippet_update
ERROR tests/models/test_snippet.py::test_snippet_update_name_only
ERROR tests/models/test_snippet.py::test_snippet_update_content_only
ERROR tests/models/test_snippet.py::test_snippet_delete
ERROR tests/models/test_snippet.py::test_delete_nonexistent_snippet
ERROR tests/models/test_snippet.py::test_edit_snippet_change_category
ERROR tests/models/test_snippet.py::test_edit_snippet_invalid_category
ERROR tests/models/test_snippet.py::test_snippet_sql_injection
ERROR tests/models/test_snippet.py::test_snippet_sql_injection_in_content
ERROR tests/models/test_snippet.py::test_snippet_long_content
ERROR tests/models/test_snippet.py::test_snippet_content_splitting_boundaries
ERROR tests/models/test_snippet.py::test_update_nonexistent_snippet
ERROR tests/models/test_snippet.py::test_snippet_part_number_sequence
ERROR tests/models/test_snippet.py::test_snippet_operation_handling
ERROR tests/models/test_snippet.py::test_delete_snippet
ERROR tests/models/test_snippet.py::test_create_snippet_with_nonexistent_category
ERROR tests/models/test_snippet.py::test_update_snippet_partial
ERROR tests/models/test_snippet.py::test_update_snippet_no_changes
ERROR tests/models/test_snippet.py::test_get_snippet_by_name
ERROR tests/models/test_snippet.py::test_get_snippet_by_name_nonexistent
ERROR tests/models/test_snippet.py::test_get_snippet_by_name_multiple_categories
ERROR tests/models/test_snippet.py::test_search_snippets
ERROR tests/models/test_snippet.py::test_search_snippets_no_results
ERROR tests/models/test_snippet.py::test_snippet_sql_injection_name_create
ERROR tests/models/test_snippet.py::test_snippet_sql_injection_content_create
ERROR tests/models/test_snippet.py::test_snippet_sql_injection_name_create_with_specific_error
ERROR tests/models/test_snippet.py::test_snippet_sql_injection_content_update
ERROR tests/models/test_snippet.py::test_snippet_sql_injection_name_update
ERROR tests/models/test_snippet.py::test_snippet_deletion_idempotency
ERROR tests/models/test_snippet.py::test_snippet_manager_handles_db_errors_gracefully_on_create
ERROR tests/models/test_snippet.py::test_snippet_manager_handles_db_errors_gracefully_on_get
ERROR tests/models/test_snippet.py::test_snippet_manager_handles_db_errors_gracefully_on_update
ERROR tests/models/test_snippet.py::test_snippet_manager_handles_db_errors_gracefully_on_delete
ERROR tests/models/test_snippet.py::test_snippet_manager_handles_db_errors_gracefully_on_list
ERROR tests/models/test_snippet.py::test_snippet_manager_handles_db_errors_gracefully_on_search
ERROR tests/models/test_snippet.py::test_create_snippet_pydantic_validation_errors
====== 22 failed, 417 passed, 4 skipped, 2 warnings, 66 errors in 33.04s ======
============================= test session starts =============================
platform win32 -- Python 3.13.2, pytest-8.4.1, pluggy-1.6.0
PySide6 6.9.1 -- Qt runtime 6.9.1 -- Qt compiled 6.9.1
rootdir: D:\SeanDevLocal\AITypingTrainer
configfile: pytest.ini
plugins: anyio-4.10.0, cov-6.2.1, mock-3.14.1, qt-4.5.0
collected 509 items

tests\models\test_category.py .................                          [  3%]
tests\models\test_category_manager.py .............................      [  9%]
tests\models\test_dynamic_content_manager.py ............F..F....F       [ 13%]
tests\models\test_keyboard.py ........                                   [ 14%]
tests\models\test_keyboard_manager.py .....                              [ 15%]
tests\models\test_keystroke.py ......................................... [ 23%]
...................................                                      [ 30%]
tests\models\test_keystroke_manager.py ..........F.FFF..............F... [ 37%]
F.F.FF....                                                               [ 39%]
tests\models\test_llm_ngram_service.py F...                              [ 39%]
tests\models\test_next_session_position.py .....                         [ 40%]
tests\models\test_ngram.py .F............                                [ 43%]
tests\models\test_ngram_analytics_service.py ......EssssFFFF...          [ 47%]
tests\models\test_ngram_analytics_service_session_methods.py EEEEEEEEEE. [ 49%]
E.EEEE                                                                   [ 50%]
tests\models\test_ngram_manager.py .....                                 [ 51%]
tests\models\test_ngram_orchestrator_process_end_of_session.py FFFF      [ 52%]
tests\models\test_session.py ..........................................  [ 60%]
tests\models\test_session_manager.py ........                            [ 62%]
tests\models\test_setting.py ..................                          [ 65%]
tests\models\test_setting_manager.py ...................                 [ 69%]
tests\models\test_simple.py .                                            [ 69%]
tests\models\test_snippet.py ...E.E..EEEEEEEEEEEEEEEEEEEEEEEEE.EEEEEEEEE [ 77%]
EEEEEEEEEEEEEE                                                           [ 80%]
tests\models\test_snippet_manager.py ....................                [ 84%]
tests\models\test_user.py .............................................. [ 93%]
......                                                                   [ 94%]
tests\models\test_user_manager.py .........                              [ 96%]
tests\models\test_user_manager_fixes.py .................                [100%]

=================================== ERRORS ====================================
_ ERROR at setup of TestNGramAnalyticsService.test_refresh_speed_summaries_basic _

self = <db.database_manager.DatabaseManager object at 0x000002CA817D8E50>
query = 'INSERT INTO snippets (snippet_id, category_id, title, content, difficulty_level) VALUES (?, ?, ?, ?, ?)'
params = ('snippet_1', 'cat_1', 'Snippet', 'content', 1)

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table snippets has no column named title

db\database_manager.py:509: OperationalError

The above exception was the direct cause of the following exception:

item = <Function test_refresh_speed_summaries_basic>

    @pytest.hookimpl(wrapper=True, tryfirst=True)
    def pytest_runtest_setup(item):
        """
        Hook called after before test setup starts, to start capturing exceptions
        as early as possible.
        """
        capture_enabled = _is_exception_capture_enabled(item)
        if capture_enabled:
            item.qt_exception_capture_manager = _QtExceptionCaptureManager()
            item.qt_exception_capture_manager.start()
>       result = yield
                 ^^^^^

.venv\Lib\site-packages\pytestqt\plugin.py:178: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:321: in ngram_speed_test_data
    db_with_tables.execute(
db\database_manager.py:524: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x000002CA817D8E50>
e = OperationalError('table snippets has no column named title')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table snippets has no column named title

db\database_manager.py:434: DatabaseError
---------------------------- Captured stdout setup ----------------------------
Exception during query: table snippets has no column named title. Rolling back transaction.
---------------------------- Captured stderr setup ----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 509, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table snippets has no column named title
_ ERROR at setup of TestSummarizeSessionNgrams.test_summarize_with_ngram_speed_only[1-1] _

self = <db.database_manager.DatabaseManager object at 0x000002CA82E15320>
query = '\n            INSERT INTO categories (category_id, category_name, description)\n            VALUES (?, ?, ?)\n            '
params = ('fd53a74f-57c5-4d4d-96c0-5e82d1998ca4', 'Test Category', 'Test category for testing')

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table categories has no column named description

db\database_manager.py:509: OperationalError

The above exception was the direct cause of the following exception:

db_with_tables = <db.database_manager.DatabaseManager object at 0x000002CA82E15320>
test_user = User(user_id='4208a9d7-80b5-404c-bb45-8fe7752db1f6', first_name='Test', surname='User', email_address='test.user.1df68ab9-f925-4826-bddf-609ffd44374a@example.com')
test_keyboard = Keyboard(keyboard_id='9b1325db-1f01-4ab8-b0d1-ce16a2fced43', user_id='4208a9d7-80b5-404c-bb45-8fe7752db1f6', keyboard_name='Test Keyboard', target_ms_per_keystroke=600)

    @pytest.fixture
    def test_data_setup(db_with_tables: DatabaseManager, test_user: User, test_keyboard: Keyboard) -> Dict[str, Any]:
        """Set up comprehensive test data for session analytics tests."""
        db = db_with_tables
    
        # Create category and snippet
>       category_id = TestSessionMethodsFixtures.create_category(db)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_ngram_analytics_service_session_methods.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:239: in create_category
    db.execute(
db\database_manager.py:524: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x000002CA82E15320>
e = OperationalError('table categories has no column named description')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table categories has no column named description

db\database_manager.py:434: DatabaseError
---------------------------- Captured stdout setup ----------------------------
Exception during query: table categories has no column named description. Rolling back transaction.
---------------------------- Captured stderr setup ----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 509, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table categories has no column named description
_ ERROR at setup of TestSummarizeSessionNgrams.test_summarize_with_ngram_speed_only[3-3] _

self = <db.database_manager.DatabaseManager object at 0x000002CA817D8E50>
query = '\n            INSERT INTO categories (category_id, category_name, description)\n            VALUES (?, ?, ?)\n            '
params = ('a2c37326-cd11-4e58-9963-2dfb7d92278a', 'Test Category', 'Test category for testing')

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table categories has no column named description

db\database_manager.py:509: OperationalError

The above exception was the direct cause of the following exception:

db_with_tables = <db.database_manager.DatabaseManager object at 0x000002CA817D8E50>
test_user = User(user_id='6f11f112-1c1f-43cf-9894-004eace02161', first_name='Test', surname='User', email_address='test.user.e20fede8-27d7-4d37-bd06-ae08673f9222@example.com')
test_keyboard = Keyboard(keyboard_id='c666a17f-985d-491c-890f-782cd27b766d', user_id='6f11f112-1c1f-43cf-9894-004eace02161', keyboard_name='Test Keyboard', target_ms_per_keystroke=600)

    @pytest.fixture
    def test_data_setup(db_with_tables: DatabaseManager, test_user: User, test_keyboard: Keyboard) -> Dict[str, Any]:
        """Set up comprehensive test data for session analytics tests."""
        db = db_with_tables
    
        # Create category and snippet
>       category_id = TestSessionMethodsFixtures.create_category(db)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_ngram_analytics_service_session_methods.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:239: in create_category
    db.execute(
db\database_manager.py:524: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x000002CA817D8E50>
e = OperationalError('table categories has no column named description')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table categories has no column named description

db\database_manager.py:434: DatabaseError
---------------------------- Captured stdout setup ----------------------------
Exception during query: table categories has no column named description. Rolling back transaction.
---------------------------- Captured stderr setup ----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 509, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table categories has no column named description
_ ERROR at setup of TestSummarizeSessionNgrams.test_summarize_with_ngram_errors_only[1-1] _

self = <db.database_manager.DatabaseManager object at 0x000002CA82EB3230>
query = '\n            INSERT INTO categories (category_id, category_name, description)\n            VALUES (?, ?, ?)\n            '
params = ('a8ccc305-60f8-4eb4-a0ce-b09831e8c49e', 'Test Category', 'Test category for testing')

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table categories has no column named description

db\database_manager.py:509: OperationalError

The above exception was the direct cause of the following exception:

db_with_tables = <db.database_manager.DatabaseManager object at 0x000002CA82EB3230>
test_user = User(user_id='61c164fd-797d-4491-90db-cb80d8f243c6', first_name='Test', surname='User', email_address='test.user.96a45b90-8cfb-4003-b11f-33c7b61aa91c@example.com')
test_keyboard = Keyboard(keyboard_id='96d05725-1ac4-4bcd-a31f-b725f80e9555', user_id='61c164fd-797d-4491-90db-cb80d8f243c6', keyboard_name='Test Keyboard', target_ms_per_keystroke=600)

    @pytest.fixture
    def test_data_setup(db_with_tables: DatabaseManager, test_user: User, test_keyboard: Keyboard) -> Dict[str, Any]:
        """Set up comprehensive test data for session analytics tests."""
        db = db_with_tables
    
        # Create category and snippet
>       category_id = TestSessionMethodsFixtures.create_category(db)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_ngram_analytics_service_session_methods.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:239: in create_category
    db.execute(
db\database_manager.py:524: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x000002CA82EB3230>
e = OperationalError('table categories has no column named description')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table categories has no column named description

db\database_manager.py:434: DatabaseError
---------------------------- Captured stdout setup ----------------------------
Exception during query: table categories has no column named description. Rolling back transaction.
---------------------------- Captured stderr setup ----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 509, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table categories has no column named description
_ ERROR at setup of TestSummarizeSessionNgrams.test_summarize_with_ngram_errors_only[2-2] _

self = <db.database_manager.DatabaseManager object at 0x000002CA82EB2660>
query = '\n            INSERT INTO categories (category_id, category_name, description)\n            VALUES (?, ?, ?)\n            '
params = ('57545b01-28ac-45d8-a6f6-5e2991e5a535', 'Test Category', 'Test category for testing')

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table categories has no column named description

db\database_manager.py:509: OperationalError

The above exception was the direct cause of the following exception:

db_with_tables = <db.database_manager.DatabaseManager object at 0x000002CA82EB2660>
test_user = User(user_id='1128b8dd-8d60-465e-9675-abe3067d5555', first_name='Test', surname='User', email_address='test.user.e3e69349-2dec-409e-861b-7112beab9d86@example.com')
test_keyboard = Keyboard(keyboard_id='4c2c526c-c1ba-4a32-962f-892eb49758d7', user_id='1128b8dd-8d60-465e-9675-abe3067d5555', keyboard_name='Test Keyboard', target_ms_per_keystroke=600)

    @pytest.fixture
    def test_data_setup(db_with_tables: DatabaseManager, test_user: User, test_keyboard: Keyboard) -> Dict[str, Any]:
        """Set up comprehensive test data for session analytics tests."""
        db = db_with_tables
    
        # Create category and snippet
>       category_id = TestSessionMethodsFixtures.create_category(db)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_ngram_analytics_service_session_methods.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:239: in create_category
    db.execute(
db\database_manager.py:524: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x000002CA82EB2660>
e = OperationalError('table categories has no column named description')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table categories has no column named description

db\database_manager.py:434: DatabaseError
---------------------------- Captured stdout setup ----------------------------
Exception during query: table categories has no column named description. Rolling back transaction.
---------------------------- Captured stderr setup ----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 509, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table categories has no column named description
_ ERROR at setup of TestSummarizeSessionNgrams.test_summarize_with_speed_and_errors _

self = <db.database_manager.DatabaseManager object at 0x000002CA82EB3B60>
query = '\n            INSERT INTO categories (category_id, category_name, description)\n            VALUES (?, ?, ?)\n            '
params = ('43b5f66a-d2e8-41d7-ad43-712d8124b17c', 'Test Category', 'Test category for testing')

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table categories has no column named description

db\database_manager.py:509: OperationalError

The above exception was the direct cause of the following exception:

db_with_tables = <db.database_manager.DatabaseManager object at 0x000002CA82EB3B60>
test_user = User(user_id='90925fd1-0fb1-4451-9b4f-12356ecc1777', first_name='Test', surname='User', email_address='test.user.75319b03-fc43-4cd1-8361-7c74846c9bd8@example.com')
test_keyboard = Keyboard(keyboard_id='d0e5daf7-5799-4a87-9587-b2429646558e', user_id='90925fd1-0fb1-4451-9b4f-12356ecc1777', keyboard_name='Test Keyboard', target_ms_per_keystroke=600)

    @pytest.fixture
    def test_data_setup(db_with_tables: DatabaseManager, test_user: User, test_keyboard: Keyboard) -> Dict[str, Any]:
        """Set up comprehensive test data for session analytics tests."""
        db = db_with_tables
    
        # Create category and snippet
>       category_id = TestSessionMethodsFixtures.create_category(db)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_ngram_analytics_service_session_methods.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:239: in create_category
    db.execute(
db\database_manager.py:524: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x000002CA82EB3B60>
e = OperationalError('table categories has no column named description')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table categories has no column named description

db\database_manager.py:434: DatabaseError
---------------------------- Captured stdout setup ----------------------------
Exception during query: table categories has no column named description. Rolling back transaction.
---------------------------- Captured stderr setup ----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 509, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table categories has no column named description
_ ERROR at setup of TestSummarizeSessionNgrams.test_summarize_with_keystrokes[1-1] _

self = <db.database_manager.DatabaseManager object at 0x000002CA82F10AD0>
query = '\n            INSERT INTO categories (category_id, category_name, description)\n            VALUES (?, ?, ?)\n            '
params = ('0a4c677c-c172-483e-ba7f-17ac4ddcbd9c', 'Test Category', 'Test category for testing')

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table categories has no column named description

db\database_manager.py:509: OperationalError

The above exception was the direct cause of the following exception:

db_with_tables = <db.database_manager.DatabaseManager object at 0x000002CA82F10AD0>
test_user = User(user_id='be793dea-d215-4d56-b89f-6b502c17df06', first_name='Test', surname='User', email_address='test.user.54cec84c-b4cb-44d5-a639-665185189e7f@example.com')
test_keyboard = Keyboard(keyboard_id='6193fe80-43e9-45dd-916b-8fa66ab9ecf1', user_id='be793dea-d215-4d56-b89f-6b502c17df06', keyboard_name='Test Keyboard', target_ms_per_keystroke=600)

    @pytest.fixture
    def test_data_setup(db_with_tables: DatabaseManager, test_user: User, test_keyboard: Keyboard) -> Dict[str, Any]:
        """Set up comprehensive test data for session analytics tests."""
        db = db_with_tables
    
        # Create category and snippet
>       category_id = TestSessionMethodsFixtures.create_category(db)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_ngram_analytics_service_session_methods.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:239: in create_category
    db.execute(
db\database_manager.py:524: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x000002CA82F10AD0>
e = OperationalError('table categories has no column named description')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table categories has no column named description

db\database_manager.py:434: DatabaseError
---------------------------- Captured stdout setup ----------------------------
Exception during query: table categories has no column named description. Rolling back transaction.
---------------------------- Captured stderr setup ----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 509, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table categories has no column named description
_ ERROR at setup of TestSummarizeSessionNgrams.test_summarize_with_keystrokes[3-3] _

self = <db.database_manager.DatabaseManager object at 0x000002CA82F12C10>
query = '\n            INSERT INTO categories (category_id, category_name, description)\n            VALUES (?, ?, ?)\n            '
params = ('955f4660-44f4-44a0-91c2-39859c731da0', 'Test Category', 'Test category for testing')

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table categories has no column named description

db\database_manager.py:509: OperationalError

The above exception was the direct cause of the following exception:

db_with_tables = <db.database_manager.DatabaseManager object at 0x000002CA82F12C10>
test_user = User(user_id='2e4a88f8-0467-43bf-a936-b4201f5c9ab0', first_name='Test', surname='User', email_address='test.user.cfb31039-ef0e-4035-aeb5-19f67e9183d3@example.com')
test_keyboard = Keyboard(keyboard_id='19a2b7ed-09d3-4162-97a1-abb59708be41', user_id='2e4a88f8-0467-43bf-a936-b4201f5c9ab0', keyboard_name='Test Keyboard', target_ms_per_keystroke=600)

    @pytest.fixture
    def test_data_setup(db_with_tables: DatabaseManager, test_user: User, test_keyboard: Keyboard) -> Dict[str, Any]:
        """Set up comprehensive test data for session analytics tests."""
        db = db_with_tables
    
        # Create category and snippet
>       category_id = TestSessionMethodsFixtures.create_category(db)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_ngram_analytics_service_session_methods.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:239: in create_category
    db.execute(
db\database_manager.py:524: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x000002CA82F12C10>
e = OperationalError('table categories has no column named description')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table categories has no column named description

db\database_manager.py:434: DatabaseError
---------------------------- Captured stdout setup ----------------------------
Exception during query: table categories has no column named description. Rolling back transaction.
---------------------------- Captured stderr setup ----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 509, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table categories has no column named description
____ ERROR at setup of TestSummarizeSessionNgrams.test_no_sessions_missing ____

self = <db.database_manager.DatabaseManager object at 0x000002CA82EB3F50>
query = '\n            INSERT INTO categories (category_id, category_name, description)\n            VALUES (?, ?, ?)\n            '
params = ('60293fdb-d048-47ee-8964-65e4c1de7c64', 'Test Category', 'Test category for testing')

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table categories has no column named description

db\database_manager.py:509: OperationalError

The above exception was the direct cause of the following exception:

db_with_tables = <db.database_manager.DatabaseManager object at 0x000002CA82EB3F50>
test_user = User(user_id='cc308faa-1d03-48e4-ad78-3ba7d3084bd6', first_name='Test', surname='User', email_address='test.user.66c755bc-a770-467e-b813-e18c6f95aad3@example.com')
test_keyboard = Keyboard(keyboard_id='b69499fa-bb33-4508-ab48-b21d1c3c86a7', user_id='cc308faa-1d03-48e4-ad78-3ba7d3084bd6', keyboard_name='Test Keyboard', target_ms_per_keystroke=600)

    @pytest.fixture
    def test_data_setup(db_with_tables: DatabaseManager, test_user: User, test_keyboard: Keyboard) -> Dict[str, Any]:
        """Set up comprehensive test data for session analytics tests."""
        db = db_with_tables
    
        # Create category and snippet
>       category_id = TestSessionMethodsFixtures.create_category(db)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_ngram_analytics_service_session_methods.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:239: in create_category
    db.execute(
db\database_manager.py:524: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x000002CA82EB3F50>
e = OperationalError('table categories has no column named description')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table categories has no column named description

db\database_manager.py:434: DatabaseError
---------------------------- Captured stdout setup ----------------------------
Exception during query: table categories has no column named description. Rolling back transaction.
---------------------------- Captured stderr setup ----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 509, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table categories has no column named description
_ ERROR at setup of TestSummarizeSessionNgrams.test_sessions_missing_no_data __

self = <db.database_manager.DatabaseManager object at 0x000002CA82F10D70>
query = '\n            INSERT INTO categories (category_id, category_name, description)\n            VALUES (?, ?, ?)\n            '
params = ('6f7b614a-074a-4a2b-be36-dd1250819df4', 'Test Category', 'Test category for testing')

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table categories has no column named description

db\database_manager.py:509: OperationalError

The above exception was the direct cause of the following exception:

db_with_tables = <db.database_manager.DatabaseManager object at 0x000002CA82F10D70>
test_user = User(user_id='90a10799-b1ae-4c4d-b9b2-59071078b459', first_name='Test', surname='User', email_address='test.user.206d4075-4c4f-4e9a-93ea-fdbcc185171f@example.com')
test_keyboard = Keyboard(keyboard_id='49542e30-ddf0-494c-9eef-d3b79434a0b2', user_id='90a10799-b1ae-4c4d-b9b2-59071078b459', keyboard_name='Test Keyboard', target_ms_per_keystroke=600)

    @pytest.fixture
    def test_data_setup(db_with_tables: DatabaseManager, test_user: User, test_keyboard: Keyboard) -> Dict[str, Any]:
        """Set up comprehensive test data for session analytics tests."""
        db = db_with_tables
    
        # Create category and snippet
>       category_id = TestSessionMethodsFixtures.create_category(db)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_ngram_analytics_service_session_methods.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:239: in create_category
    db.execute(
db\database_manager.py:524: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x000002CA82F10D70>
e = OperationalError('table categories has no column named description')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table categories has no column named description

db\database_manager.py:434: DatabaseError
---------------------------- Captured stdout setup ----------------------------
Exception during query: table categories has no column named description. Rolling back transaction.
---------------------------- Captured stderr setup ----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 509, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table categories has no column named description
_ ERROR at setup of TestAddSpeedSummaryForSession.test_single_session_processing _

self = <db.database_manager.DatabaseManager object at 0x000002CA82F13C40>
query = '\n            INSERT INTO categories (category_id, category_name, description)\n            VALUES (?, ?, ?)\n            '
params = ('cbb5223b-58fe-42b0-b9bb-3a90c01d7501', 'Test Category', 'Test category for testing')

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table categories has no column named description

db\database_manager.py:509: OperationalError

The above exception was the direct cause of the following exception:

db_with_tables = <db.database_manager.DatabaseManager object at 0x000002CA82F13C40>
test_user = User(user_id='58511842-1450-41b8-9e00-bf89849185f5', first_name='Test', surname='User', email_address='test.user.441e9c13-c993-4a91-985d-5f2ac06fbcda@example.com')
test_keyboard = Keyboard(keyboard_id='e36c6d16-0b68-4455-b80c-56048fa70530', user_id='58511842-1450-41b8-9e00-bf89849185f5', keyboard_name='Test Keyboard', target_ms_per_keystroke=600)

    @pytest.fixture
    def test_data_setup(db_with_tables: DatabaseManager, test_user: User, test_keyboard: Keyboard) -> Dict[str, Any]:
        """Set up comprehensive test data for session analytics tests."""
        db = db_with_tables
    
        # Create category and snippet
>       category_id = TestSessionMethodsFixtures.create_category(db)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_ngram_analytics_service_session_methods.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:239: in create_category
    db.execute(
db\database_manager.py:524: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x000002CA82F13C40>
e = OperationalError('table categories has no column named description')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table categories has no column named description

db\database_manager.py:434: DatabaseError
---------------------------- Captured stdout setup ----------------------------
Exception during query: table categories has no column named description. Rolling back transaction.
---------------------------- Captured stderr setup ----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 509, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table categories has no column named description
_ ERROR at setup of TestAddSpeedSummaryForSession.test_multiple_ngrams_processing _

self = <db.database_manager.DatabaseManager object at 0x000002CA82F134D0>
query = '\n            INSERT INTO categories (category_id, category_name, description)\n            VALUES (?, ?, ?)\n            '
params = ('df048a53-dda5-4990-bd67-6ce7de184dce', 'Test Category', 'Test category for testing')

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table categories has no column named description

db\database_manager.py:509: OperationalError

The above exception was the direct cause of the following exception:

db_with_tables = <db.database_manager.DatabaseManager object at 0x000002CA82F134D0>
test_user = User(user_id='c14812e8-5c50-434d-a1ea-3e4066fb8f29', first_name='Test', surname='User', email_address='test.user.3dae5bf7-c0ae-456c-95c0-73d56b3cc278@example.com')
test_keyboard = Keyboard(keyboard_id='35947289-a1a3-4b1a-9b9f-1a58d57432a9', user_id='c14812e8-5c50-434d-a1ea-3e4066fb8f29', keyboard_name='Test Keyboard', target_ms_per_keystroke=600)

    @pytest.fixture
    def test_data_setup(db_with_tables: DatabaseManager, test_user: User, test_keyboard: Keyboard) -> Dict[str, Any]:
        """Set up comprehensive test data for session analytics tests."""
        db = db_with_tables
    
        # Create category and snippet
>       category_id = TestSessionMethodsFixtures.create_category(db)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_ngram_analytics_service_session_methods.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:239: in create_category
    db.execute(
db\database_manager.py:524: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x000002CA82F134D0>
e = OperationalError('table categories has no column named description')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table categories has no column named description

db\database_manager.py:434: DatabaseError
---------------------------- Captured stdout setup ----------------------------
Exception during query: table categories has no column named description. Rolling back transaction.
---------------------------- Captured stderr setup ----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 509, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table categories has no column named description
____ ERROR at setup of TestCatchupSpeedSummary.test_single_session_catchup ____

self = <db.database_manager.DatabaseManager object at 0x000002CA82F11D30>
query = '\n            INSERT INTO categories (category_id, category_name, description)\n            VALUES (?, ?, ?)\n            '
params = ('01954958-54fb-481c-9e6b-e6352c4b2ff5', 'Test Category', 'Test category for testing')

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table categories has no column named description

db\database_manager.py:509: OperationalError

The above exception was the direct cause of the following exception:

db_with_tables = <db.database_manager.DatabaseManager object at 0x000002CA82F11D30>
test_user = User(user_id='94e6d955-e9c4-4a94-90df-b450f7a18376', first_name='Test', surname='User', email_address='test.user.6b3a0fca-694d-4d75-bd0d-fa3a10e1575d@example.com')
test_keyboard = Keyboard(keyboard_id='aa85fb74-7ef7-4601-97c3-238e1a0aec98', user_id='94e6d955-e9c4-4a94-90df-b450f7a18376', keyboard_name='Test Keyboard', target_ms_per_keystroke=600)

    @pytest.fixture
    def test_data_setup(db_with_tables: DatabaseManager, test_user: User, test_keyboard: Keyboard) -> Dict[str, Any]:
        """Set up comprehensive test data for session analytics tests."""
        db = db_with_tables
    
        # Create category and snippet
>       category_id = TestSessionMethodsFixtures.create_category(db)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_ngram_analytics_service_session_methods.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:239: in create_category
    db.execute(
db\database_manager.py:524: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x000002CA82F11D30>
e = OperationalError('table categories has no column named description')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table categories has no column named description

db\database_manager.py:434: DatabaseError
---------------------------- Captured stdout setup ----------------------------
Exception during query: table categories has no column named description. Rolling back transaction.
---------------------------- Captured stderr setup ----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 509, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table categories has no column named description
__ ERROR at setup of TestCatchupSpeedSummary.test_multiple_sessions_catchup ___

self = <db.database_manager.DatabaseManager object at 0x000002CA82F5C050>
query = '\n            INSERT INTO categories (category_id, category_name, description)\n            VALUES (?, ?, ?)\n            '
params = ('7c62d0fa-a056-4f6f-bd6b-240351998746', 'Test Category', 'Test category for testing')

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table categories has no column named description

db\database_manager.py:509: OperationalError

The above exception was the direct cause of the following exception:

db_with_tables = <db.database_manager.DatabaseManager object at 0x000002CA82F5C050>
test_user = User(user_id='04dd2bb0-b868-40fd-9009-8961745e3b83', first_name='Test', surname='User', email_address='test.user.330923e9-84e0-4fc5-b033-cc1949961735@example.com')
test_keyboard = Keyboard(keyboard_id='9222da63-67e3-46bc-b6c5-d7102cc60948', user_id='04dd2bb0-b868-40fd-9009-8961745e3b83', keyboard_name='Test Keyboard', target_ms_per_keystroke=600)

    @pytest.fixture
    def test_data_setup(db_with_tables: DatabaseManager, test_user: User, test_keyboard: Keyboard) -> Dict[str, Any]:
        """Set up comprehensive test data for session analytics tests."""
        db = db_with_tables
    
        # Create category and snippet
>       category_id = TestSessionMethodsFixtures.create_category(db)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_ngram_analytics_service_session_methods.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:239: in create_category
    db.execute(
db\database_manager.py:524: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x000002CA82F5C050>
e = OperationalError('table categories has no column named description')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table categories has no column named description

db\database_manager.py:434: DatabaseError
---------------------------- Captured stdout setup ----------------------------
Exception during query: table categories has no column named description. Rolling back transaction.
---------------------------- Captured stderr setup ----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 509, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table categories has no column named description
_ ERROR at setup of TestCatchupSpeedSummary.test_catchup_with_session_errors __

self = <db.database_manager.DatabaseManager object at 0x000002CA82F13C40>
query = '\n            INSERT INTO categories (category_id, category_name, description)\n            VALUES (?, ?, ?)\n            '
params = ('ed7806ba-2404-4bf1-81c1-52181ff4c5b5', 'Test Category', 'Test category for testing')

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table categories has no column named description

db\database_manager.py:509: OperationalError

The above exception was the direct cause of the following exception:

db_with_tables = <db.database_manager.DatabaseManager object at 0x000002CA82F13C40>
test_user = User(user_id='162fb2a4-9b1f-4553-90a4-ec45fd7cd60e', first_name='Test', surname='User', email_address='test.user.88fe794b-6b05-4674-8ef8-c6c00516b8e1@example.com')
test_keyboard = Keyboard(keyboard_id='11e0e20f-c2a0-4e90-8042-2ac0afef0dce', user_id='162fb2a4-9b1f-4553-90a4-ec45fd7cd60e', keyboard_name='Test Keyboard', target_ms_per_keystroke=600)

    @pytest.fixture
    def test_data_setup(db_with_tables: DatabaseManager, test_user: User, test_keyboard: Keyboard) -> Dict[str, Any]:
        """Set up comprehensive test data for session analytics tests."""
        db = db_with_tables
    
        # Create category and snippet
>       category_id = TestSessionMethodsFixtures.create_category(db)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_ngram_analytics_service_session_methods.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:239: in create_category
    db.execute(
db\database_manager.py:524: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x000002CA82F13C40>
e = OperationalError('table categories has no column named description')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table categories has no column named description

db\database_manager.py:434: DatabaseError
---------------------------- Captured stdout setup ----------------------------
Exception during query: table categories has no column named description. Rolling back transaction.
---------------------------- Captured stderr setup ----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 509, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table categories has no column named description
__ ERROR at setup of TestIntegrationScenarios.test_full_workflow_integration __

self = <db.database_manager.DatabaseManager object at 0x000002CA82F11710>
query = '\n            INSERT INTO categories (category_id, category_name, description)\n            VALUES (?, ?, ?)\n            '
params = ('f3d253c2-687a-43ab-815a-5f1fb28e5810', 'Test Category', 'Test category for testing')

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table categories has no column named description

db\database_manager.py:509: OperationalError

The above exception was the direct cause of the following exception:

db_with_tables = <db.database_manager.DatabaseManager object at 0x000002CA82F11710>
test_user = User(user_id='5a2fe52c-082a-4e8d-bfa8-b2ceaf0fdba3', first_name='Test', surname='User', email_address='test.user.9f4503e1-1e9c-4916-828d-26df138a1d10@example.com')
test_keyboard = Keyboard(keyboard_id='75fc79be-841a-4aeb-9969-45481723168f', user_id='5a2fe52c-082a-4e8d-bfa8-b2ceaf0fdba3', keyboard_name='Test Keyboard', target_ms_per_keystroke=600)

    @pytest.fixture
    def test_data_setup(db_with_tables: DatabaseManager, test_user: User, test_keyboard: Keyboard) -> Dict[str, Any]:
        """Set up comprehensive test data for session analytics tests."""
        db = db_with_tables
    
        # Create category and snippet
>       category_id = TestSessionMethodsFixtures.create_category(db)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_ngram_analytics_service_session_methods.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:239: in create_category
    db.execute(
db\database_manager.py:524: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x000002CA82F11710>
e = OperationalError('table categories has no column named description')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table categories has no column named description

db\database_manager.py:434: DatabaseError
---------------------------- Captured stdout setup ----------------------------
Exception during query: table categories has no column named description. Rolling back transaction.
---------------------------- Captured stderr setup ----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 509, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table categories has no column named description
__________________ ERROR at setup of test_snippet_ascii_name __________________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 64
  def test_snippet_ascii_name(valid_snippet_data: Dict[str, str]) -> None:
E       fixture 'valid_snippet_data' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:64
_________________ ERROR at setup of test_snippet_name_length __________________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 86
  def test_snippet_name_length(valid_snippet_data: Dict[str, Union[str, str]]) -> None:
E       fixture 'valid_snippet_data' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:86
_ ERROR at setup of test_snippet_creation_validation[Alpha-Some content-True] _
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 117
  @pytest.mark.parametrize(
      "name,content,expect_success",
      [
          ("Alpha", "Some content", True),
          ("", "Some content", False),  # Validation for name
          ("A" * 129, "Content", False),  # Validation for name length
          ("NonAscii", "Content", False),  # Validation for name ASCII
          ("Alpha", "", False),  # Validation for content
      ],
  )
  def test_snippet_creation_validation(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:117
___ ERROR at setup of test_snippet_creation_validation[-Some content-False] ___
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 117
  @pytest.mark.parametrize(
      "name,content,expect_success",
      [
          ("Alpha", "Some content", True),
          ("", "Some content", False),  # Validation for name
          ("A" * 129, "Content", False),  # Validation for name length
          ("NonAscii", "Content", False),  # Validation for name ASCII
          ("Alpha", "", False),  # Validation for content
      ],
  )
  def test_snippet_creation_validation(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:117
_ ERROR at setup of test_snippet_creation_validation[AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA-Content-False] _
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 117
  @pytest.mark.parametrize(
      "name,content,expect_success",
      [
          ("Alpha", "Some content", True),
          ("", "Some content", False),  # Validation for name
          ("A" * 129, "Content", False),  # Validation for name length
          ("NonAscii", "Content", False),  # Validation for name ASCII
          ("Alpha", "", False),  # Validation for content
      ],
  )
  def test_snippet_creation_validation(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:117
_ ERROR at setup of test_snippet_creation_validation[NonAscii\xe9-Content-False] _
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 117
  @pytest.mark.parametrize(
      "name,content,expect_success",
      [
          ("Alpha", "Some content", True),
          ("", "Some content", False),  # Validation for name
          ("A" * 129, "Content", False),  # Validation for name length
          ("NonAscii", "Content", False),  # Validation for name ASCII
          ("Alpha", "", False),  # Validation for content
      ],
  )
  def test_snippet_creation_validation(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:117
______ ERROR at setup of test_snippet_creation_validation[Alpha--False] _______
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 117
  @pytest.mark.parametrize(
      "name,content,expect_success",
      [
          ("Alpha", "Some content", True),
          ("", "Some content", False),  # Validation for name
          ("A" * 129, "Content", False),  # Validation for name length
          ("NonAscii", "Content", False),  # Validation for name ASCII
          ("Alpha", "", False),  # Validation for content
      ],
  )
  def test_snippet_creation_validation(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:117
____ ERROR at setup of test_snippet_name_uniqueness[Unique1-Unique2-True] _____
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 150
  @pytest.mark.parametrize(
      "name1,name2,should_succeed",
      [
          ("Unique1", "Unique2", True),
          ("DupName", "DupName", False),
      ],
  )
  def test_snippet_name_uniqueness(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:150
____ ERROR at setup of test_snippet_name_uniqueness[DupName-DupName-False] ____
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 150
  @pytest.mark.parametrize(
      "name1,name2,should_succeed",
      [
          ("Unique1", "Unique2", True),
          ("DupName", "DupName", False),
      ],
  )
  def test_snippet_name_uniqueness(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:150
________________ ERROR at setup of test_snippet_creation_valid ________________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 175
  def test_snippet_creation_valid(
E       fixture 'snippet_manager' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:175
_______________ ERROR at setup of test_get_nonexistent_snippet ________________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 193
  def test_get_nonexistent_snippet(snippet_manager: SnippetManager) -> None:
E       fixture 'snippet_manager' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:193
_________________ ERROR at setup of test_list_snippets_empty __________________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 198
  def test_list_snippets_empty(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:198
_______________ ERROR at setup of test_list_snippets_populated ________________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 218
  def test_list_snippets_populated(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:218
_____________________ ERROR at setup of test_snippet_edit _____________________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 241
  def test_snippet_edit(
E       fixture 'snippet_manager' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:241
____________________ ERROR at setup of test_snippet_update ____________________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 260
  def test_snippet_update(snippet_category_fixture: str, snippet_manager: SnippetManager) -> None:
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:260
_______________ ERROR at setup of test_snippet_update_name_only _______________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 274
  def test_snippet_update_name_only(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:274
_____________ ERROR at setup of test_snippet_update_content_only ______________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 291
  def test_snippet_update_content_only(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:291
____________________ ERROR at setup of test_snippet_delete ____________________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 308
  def test_snippet_delete(snippet_category_fixture: str, snippet_manager: SnippetManager) -> None:
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:308
______________ ERROR at setup of test_delete_nonexistent_snippet ______________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 317
  def test_delete_nonexistent_snippet(snippet_manager: SnippetManager) -> None:
E       fixture 'snippet_manager' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:317
_____________ ERROR at setup of test_edit_snippet_change_category _____________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 328
  def test_edit_snippet_change_category(
E       fixture 'snippet_manager' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:328
____________ ERROR at setup of test_edit_snippet_invalid_category _____________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 351
  def test_edit_snippet_invalid_category(
E       fixture 'snippet_manager' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:351
________________ ERROR at setup of test_snippet_sql_injection _________________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 366
  def test_snippet_sql_injection(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:366
___________ ERROR at setup of test_snippet_sql_injection_in_content ___________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 375
  def test_snippet_sql_injection_in_content(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:375
_________________ ERROR at setup of test_snippet_long_content _________________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 384
  def test_snippet_long_content(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:384
_________ ERROR at setup of test_snippet_content_splitting_boundaries _________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 398
  def test_snippet_content_splitting_boundaries(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:398
______________ ERROR at setup of test_update_nonexistent_snippet ______________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 593
  def test_update_nonexistent_snippet(snippet_manager: SnippetManager) -> None:
E       fixture 'snippet_manager' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:593
_____________ ERROR at setup of test_snippet_part_number_sequence _____________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 432
  def test_snippet_part_number_sequence(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:432
______________ ERROR at setup of test_snippet_operation_handling ______________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 520
  def test_snippet_operation_handling(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:520
____________________ ERROR at setup of test_delete_snippet ____________________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 563
  def test_delete_snippet(snippet_category_fixture: str, snippet_manager: SnippetManager) -> None:
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:563
_______ ERROR at setup of test_create_snippet_with_nonexistent_category _______
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 580
  def test_create_snippet_with_nonexistent_category(snippet_manager: SnippetManager) -> None:
E       fixture 'snippet_manager' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:580
________________ ERROR at setup of test_update_snippet_partial ________________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 602
  def test_update_snippet_partial(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:602
______________ ERROR at setup of test_update_snippet_no_changes _______________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 637
  def test_update_snippet_no_changes(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:637
_________________ ERROR at setup of test_get_snippet_by_name __________________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 665
  def test_get_snippet_by_name(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:665
___________ ERROR at setup of test_get_snippet_by_name_nonexistent ____________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 685
  def test_get_snippet_by_name_nonexistent(
E       fixture 'snippet_manager' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:685
_______ ERROR at setup of test_get_snippet_by_name_multiple_categories ________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 692
  def test_get_snippet_by_name_multiple_categories(
E       fixture 'category_manager' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:692
___________________ ERROR at setup of test_search_snippets ____________________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 727
  def test_search_snippets(snippet_category_fixture: str, snippet_manager: SnippetManager) -> None:
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:727
______________ ERROR at setup of test_search_snippets_no_results ______________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 760
  def test_search_snippets_no_results(snippet_manager: SnippetManager) -> None:
E       fixture 'snippet_manager' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:760
__________ ERROR at setup of test_snippet_sql_injection_name_create ___________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 768
  def test_snippet_sql_injection_name_create(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:768
_________ ERROR at setup of test_snippet_sql_injection_content_create _________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 782
  def test_snippet_sql_injection_content_create(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:782
_ ERROR at setup of test_snippet_sql_injection_name_create_with_specific_error _
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 796
  def test_snippet_sql_injection_name_create_with_specific_error(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:796
_________ ERROR at setup of test_snippet_sql_injection_content_update _________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 810
  def test_snippet_sql_injection_content_update(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:810
__________ ERROR at setup of test_snippet_sql_injection_name_update ___________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 824
  def test_snippet_sql_injection_name_update(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:824
_____________ ERROR at setup of test_snippet_deletion_idempotency _____________
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 838
  def test_snippet_deletion_idempotency(
E       fixture 'snippet_category_fixture' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:838
_ ERROR at setup of test_snippet_manager_handles_db_errors_gracefully_on_create _
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 854
  def test_snippet_manager_handles_db_errors_gracefully_on_create(
E       fixture 'snippet_manager' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:854
_ ERROR at setup of test_snippet_manager_handles_db_errors_gracefully_on_get __
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 871
  def test_snippet_manager_handles_db_errors_gracefully_on_get(
E       fixture 'snippet_manager' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:871
_ ERROR at setup of test_snippet_manager_handles_db_errors_gracefully_on_update _
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 883
  def test_snippet_manager_handles_db_errors_gracefully_on_update(
E       fixture 'snippet_manager' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:883
_ ERROR at setup of test_snippet_manager_handles_db_errors_gracefully_on_delete _
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 910
  def test_snippet_manager_handles_db_errors_gracefully_on_delete(
E       fixture 'snippet_manager' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:910
_ ERROR at setup of test_snippet_manager_handles_db_errors_gracefully_on_list _
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 948
  def test_snippet_manager_handles_db_errors_gracefully_on_list(
E       fixture 'snippet_manager' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:948
_ ERROR at setup of test_snippet_manager_handles_db_errors_gracefully_on_search _
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 960
  def test_snippet_manager_handles_db_errors_gracefully_on_search(
E       fixture 'snippet_manager' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:960
______ ERROR at setup of test_create_snippet_pydantic_validation_errors _______
file d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py, line 972
  def test_create_snippet_pydantic_validation_errors(
E       fixture 'snippet_manager' not found
>       available fixtures: analytics_service, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, db_manager, db_with_tables, doctest_namespace, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, mock_ngram_data, mock_sessions, mocker, module_mocker, monkeypatch, ngram_speed_test_data, no_cover, package_mocker, pytestconfig, qapp, qapp_args, qapp_cls, qtbot, qtlog, qtmodeltester, random_id, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, temp_db, test_keyboard, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

d:\SeanDevLocal\AITypingTrainer\tests\models\test_snippet.py:972
================================== FAILURES ===================================
________________ TestNGramOnlyMode.test_generate_ngram_content ________________

self = <AITypingTrainer.tests.models.test_dynamic_content_manager.TestNGramOnlyMode object at 0x000002CA81232AD0>
basic_manager = <models.dynamic_content_manager.DynamicContentManager object at 0x000002CA81CBC210>

    def test_generate_ngram_content(self, basic_manager: DynamicContentManager) -> None:
        """Test generating content with NGramOnly mode."""
        basic_manager.mode = ContentMode.NGRAM_ONLY
        content = basic_manager.generate_content()
    
        # Verify content format and constraints
        assert content, "Content should not be empty"
        assert len(content) <= basic_manager.practice_length, "Content should not exceed practice length"
    
        # Verify content only contains ngrams from focus list
        parts = content.split()
        for part in parts:
>           assert part in basic_manager.ngram_focus_list, f"Part '{part}' should be in ngram focus list"
E           AssertionError: Part 's' should be in ngram focus list
E           assert 's' in ['es', 'st', 'te']
E            +  where ['es', 'st', 'te'] = <models.dynamic_content_manager.DynamicContentManager object at 0x000002CA81CBC210>.ngram_focus_list

tests\models\test_dynamic_content_manager.py:170: AssertionError
_______ TestNGramOnlyMode.test_ngram_content_filters_out_of_scope_chars _______

self = <AITypingTrainer.tests.models.test_dynamic_content_manager.TestNGramOnlyMode object at 0x000002CA8113E8B0>

    def test_ngram_content_filters_out_of_scope_chars(self) -> None:
        """Test that NGramOnly content filters out ngrams with out-of-scope characters."""
        manager = DynamicContentManager(
            in_scope_keys=["a", "b"],
            ngram_focus_list=["ab", "cd", "xy"],  # Only "ab" should be used
            mode=ContentMode.NGRAM_ONLY
        )
    
        content = manager.generate_content()
    
        # Content should only include "ab"
>       assert content == "ab" or content == "", "Content should only include ngrams with in-scope keys"
E       AssertionError: Content should only include ngrams with in-scope keys
E       assert ('ab ab ab ab ...ab ab ab ab a' == 'ab'
E         
E         - ab
E         + ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab a or 'ab ab ab ab ...ab ab ab ab a' == ''
E         
E         + ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab a)

tests\models\test_dynamic_content_manager.py:202: AssertionError
________________ TestMixedMode.test_mixed_content_has_variety _________________

self = <AITypingTrainer.tests.models.test_dynamic_content_manager.TestMixedMode object at 0x000002CA81233110>
basic_manager = <models.dynamic_content_manager.DynamicContentManager object at 0x000002CA82CCE850>

    def test_mixed_content_has_variety(self, basic_manager: DynamicContentManager) -> None:
        """Test that Mixed content includes both ngrams and words."""
        # This test is a bit tricky since the mixed content is randomized
        # We'll make multiple attempts and check statistics
    
        basic_manager.mode = ContentMode.MIXED
        basic_manager.ngram_focus_list = ["ab", "cd"]
    
        # Replace the mock LLM service with one that returns very distinct words
        with patch.object(basic_manager.llm_service, "get_words_with_ngrams",  # type: ignore
                         return_value="abcdef cdabef longerword"):
    
            # Make multiple generation attempts
            seen_ngrams = set()
            seen_longer = False
    
            for _ in range(10):  # Try multiple times due to randomization
                content = basic_manager.generate_content()
                parts = content.split()
    
                for part in parts:
                    if part in basic_manager.ngram_focus_list:
                        seen_ngrams.add(part)
                    elif len(part) > 3:  # Assume longer parts are "words" not ngrams
                        seen_longer = True
    
            # We should see both ngrams and longer words
>           assert seen_ngrams, "Mixed content should include some ngrams"
E           AssertionError: Mixed content should include some ngrams
E           assert set()

tests\models\test_dynamic_content_manager.py:306: AssertionError
---------------------------- Captured stdout call -----------------------------
Generating Text: Raw words: abcdef cdabef longerword
Skipping word: abcdef - bad characters
Skipping word: cdabef - bad characters
Skipping word: longerword - bad characters
Generating Text: Raw words: abcdef cdabef longerword
Skipping word: abcdef - bad characters
Skipping word: cdabef - bad characters
Skipping word: longerword - bad characters
Generating Text: Raw words: abcdef cdabef longerword
Skipping word: abcdef - bad characters
Skipping word: cdabef - bad characters
Skipping word: longerword - bad characters
Generating Text: Raw words: abcdef cdabef longerword
Skipping word: abcdef - bad characters
Skipping word: cdabef - bad characters
Skipping word: longerword - bad characters
Generating Text: Raw words: abcdef cdabef longerword
Skipping word: abcdef - bad characters
Skipping word: cdabef - bad characters
Skipping word: longerword - bad characters
Generating Text: Raw words: abcdef cdabef longerword
Skipping word: abcdef - bad characters
Skipping word: cdabef - bad characters
Skipping word: longerword - bad characters
Generating Text: Raw words: abcdef cdabef longerword
Skipping word: abcdef - bad characters
Skipping word: cdabef - bad characters
Skipping word: longerword - bad characters
Generating Text: Raw words: abcdef cdabef longerword
Skipping word: abcdef - bad characters
Skipping word: cdabef - bad characters
Skipping word: longerword - bad characters
Generating Text: Raw words: abcdef cdabef longerword
Skipping word: abcdef - bad characters
Skipping word: cdabef - bad characters
Skipping word: longerword - bad characters
Generating Text: Raw words: abcdef cdabef longerword
Skipping word: abcdef - bad characters
Skipping word: cdabef - bad characters
Skipping word: longerword - bad characters
_______ TestKeystrokeManagerSaveKeystrokes.test_save_keystrokes_success _______

self = <AITypingTrainer.tests.models.test_keystroke_manager.TestKeystrokeManagerSaveKeystrokes object at 0x000002CA81798B90>
manager_with_mock_db = <models.keystroke_manager.KeystrokeManager object at 0x000002CA82D148C0>
sample_keystrokes = [Keystroke(session_id='save-test-session', keystroke_id='f8cb16a1-5a66-4ae3-aecc-841e29ecdf4e', keystroke_time=datetim...=datetime.timezone.utc), keystroke_char='c', expected_char='c', is_error=False, time_since_previous=120, text_index=0)]

    def test_save_keystrokes_success(
        self, manager_with_mock_db: KeystrokeManager, sample_keystrokes: List[Keystroke]
    ) -> None:
        """Test successful saving of keystrokes."""
        manager_with_mock_db.keystroke_list = sample_keystrokes
    
        result = manager_with_mock_db.save_keystrokes()
    
        assert result is True
>       assert manager_with_mock_db.db_manager.execute.call_count == 3
E       AssertionError: assert 0 == 3
E        +  where 0 = <Mock name='mock.execute' id='3068783276592'>.call_count
E        +    where <Mock name='mock.execute' id='3068783276592'> = <Mock spec='DatabaseManager' id='3068783278608'>.execute
E        +      where <Mock spec='DatabaseManager' id='3068783278608'> = <models.keystroke_manager.KeystrokeManager object at 0x000002CA82D148C0>.db_manager

tests\models\test_keystroke_manager.py:234: AssertionError
___ TestKeystrokeManagerSaveKeystrokes.test_save_keystrokes_database_error ____

self = <AITypingTrainer.tests.models.test_keystroke_manager.TestKeystrokeManagerSaveKeystrokes object at 0x000002CA817DC2B0>
manager_with_mock_db = <models.keystroke_manager.KeystrokeManager object at 0x000002CA81CBF690>
sample_keystrokes = [Keystroke(session_id='save-test-session', keystroke_id='6df81f58-41ac-4984-b99d-f949416fd108', keystroke_time=datetim...=datetime.timezone.utc), keystroke_char='c', expected_char='c', is_error=False, time_since_previous=120, text_index=0)]

    def test_save_keystrokes_database_error(
        self, manager_with_mock_db: KeystrokeManager, sample_keystrokes: List[Keystroke]
    ) -> None:
        """Test handling of database errors during save."""
        manager_with_mock_db.keystroke_list = sample_keystrokes
        manager_with_mock_db.db_manager.execute.side_effect = Exception(
            "Database connection failed"
        )
    
        with patch("sys.stderr"), patch("traceback.print_exc"):
            result = manager_with_mock_db.save_keystrokes()
    
>       assert result is False
E       assert True is False

tests\models\test_keystroke_manager.py:277: AssertionError
_ TestKeystrokeManagerSaveKeystrokes.test_save_keystrokes_with_special_characters _

self = <AITypingTrainer.tests.models.test_keystroke_manager.TestKeystrokeManagerSaveKeystrokes object at 0x000002CA817DC3E0>
manager_with_mock_db = <models.keystroke_manager.KeystrokeManager object at 0x000002CA82E44E50>

    def test_save_keystrokes_with_special_characters(
        self, manager_with_mock_db: KeystrokeManager
    ) -> None:
        """Test saving keystrokes with special characters."""
        import uuid
    
        special_chars = ["'", '"', "\\\\", "\\n", "\\t", "\u20ac", "\U0001f60a"]
        keystrokes = []
        for _i, char in enumerate(special_chars):
            keystroke = Keystroke(
                session_id="special-char-session",
                keystroke_id=str(uuid.uuid4()),
                keystroke_time=datetime.now(timezone.utc),
                keystroke_char=char,
                expected_char=char,
                is_error=False,
                time_since_previous=100,
            )
            keystrokes.append(keystroke)
        manager_with_mock_db.keystroke_list = keystrokes
        result = manager_with_mock_db.save_keystrokes()
        assert result is True
>       assert manager_with_mock_db.db_manager.execute.call_count == len(special_chars)
E       assert 0 == 7
E        +  where 0 = <Mock name='mock.execute' id='3068801996784'>.call_count
E        +    where <Mock name='mock.execute' id='3068801996784'> = <Mock spec='DatabaseManager' id='3068783276256'>.execute
E        +      where <Mock spec='DatabaseManager' id='3068783276256'> = <models.keystroke_manager.KeystrokeManager object at 0x000002CA82E44E50>.db_manager
E        +  and   7 = len(["'", '"', '\\', '\n', '\t', '', ...])

tests\models\test_keystroke_manager.py:301: AssertionError
_ TestKeystrokeManagerSaveKeystrokes.test_save_keystrokes_boolean_conversion __

self = <AITypingTrainer.tests.models.test_keystroke_manager.TestKeystrokeManagerSaveKeystrokes object at 0x000002CA817D5910>
manager_with_mock_db = <models.keystroke_manager.KeystrokeManager object at 0x000002CA82DC2270>

    def test_save_keystrokes_boolean_conversion(
        self, manager_with_mock_db: KeystrokeManager
    ) -> None:
        """Test that boolean is_error is properly converted to int."""
        import uuid
    
        keystroke = Keystroke(
            session_id="bool-test",
            keystroke_id=str(uuid.uuid4()),
            keystroke_time=datetime.now(timezone.utc),
            keystroke_char="a",
            expected_char="b",
            is_error=True,
            time_since_previous=50,
        )
        manager_with_mock_db.keystroke_list = [keystroke]
        result = manager_with_mock_db.save_keystrokes()
        assert result is True
        call_args = manager_with_mock_db.db_manager.execute.call_args
>       params = call_args[0][1]
                 ^^^^^^^^^^^^
E       TypeError: 'NoneType' object is not subscriptable

tests\models\test_keystroke_manager.py:322: TypeError
________ TestKeystrokeManagerIntegration.test_full_keystroke_workflow _________

self = <AITypingTrainer.tests.models.test_keystroke_manager.TestKeystrokeManagerIntegration object at 0x000002CA81799310>
integration_manager = <models.keystroke_manager.KeystrokeManager object at 0x000002CA82E43FB0>

    def test_full_keystroke_workflow(self, integration_manager: KeystrokeManager) -> None:
        """Test complete workflow: add, save, count, retrieve, delete."""
        import uuid
    
        session_id = str(uuid.uuid4())
        # Insert a matching session into the database
        db = integration_manager.db_manager
        db.init_tables()
        # Ensure session_keystrokes table is correct for UUID keystroke_id
        db.execute("DROP TABLE IF EXISTS session_keystrokes")
        db.execute(
            """
            CREATE TABLE session_keystrokes (
                keystroke_id TEXT PRIMARY KEY,
                session_id TEXT NOT NULL,
                keystroke_time TEXT NOT NULL,
                keystroke_char TEXT NOT NULL,
                expected_char TEXT NOT NULL,
                is_error INTEGER NOT NULL,
                time_since_previous INTEGER,
                FOREIGN KEY (session_id) REFERENCES practice_sessions(session_id) ON DELETE CASCADE
            )
            """
        )
        category_id = str(uuid.uuid4())
        # Insert a matching category into the database
        db.execute(
            """
            INSERT INTO categories (category_id, category_name) VALUES (?, ?)
            """,
            (category_id, "integration-category"),
        )
        snippet_id = str(uuid.uuid4())
        # Insert a matching snippet into the database
        db.execute(
            """
            INSERT INTO snippets (snippet_id, category_id, snippet_name) VALUES (?, ?, ?)
            """,
            (snippet_id, category_id, "integration-snippet"),
        )
        user_id = str(uuid.uuid4())
        keyboard_id = str(uuid.uuid4())
        db.execute(
            "INSERT INTO users (user_id, first_name, surname, email_address) VALUES (?, ?, ?, ?)",
            (user_id, "Test", "User", f"testuser_{user_id[:8]}@example.com"),
        )
        db.execute(
            "INSERT INTO keyboards (keyboard_id, user_id, keyboard_name) VALUES (?, ?, ?)",
            (keyboard_id, user_id, "Test Keyboard"),
        )
        db.execute(
            "INSERT INTO practice_sessions (session_id, snippet_id, user_id, keyboard_id, snippet_index_start, snippet_index_end, content, start_time, end_time, actual_chars, errors, ms_per_keystroke) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)",
            (
                session_id,
                snippet_id,
                user_id,
                keyboard_id,
                0,
                10,
                "abcde",
                "2025-06-10T12:00:00",
                "2025-06-10T12:01:00",
                5,
                0,
                100.0,
            ),
        )
        # Create test keystrokes
        keystrokes = []
        for i in range(5):
            keystroke = Keystroke(
                session_id=session_id,
                keystroke_id=str(uuid.uuid4()),
                keystroke_time=datetime.now(timezone.utc),
                keystroke_char=chr(97 + i),
                expected_char=chr(97 + i),
                is_error=i == 2,  # Make one an error
                time_since_previous=100 + i * 10,  # Always integer
            )
            keystrokes.append(keystroke)
            integration_manager.add_keystroke(keystroke)
        # Verify keystrokes are in memory
        assert len(integration_manager.keystroke_list) == 5
        # Save to database
        save_result = integration_manager.save_keystrokes()
>       assert save_result is True
E       assert False is True

tests\models\test_keystroke_manager.py:636: AssertionError
---------------------------- Captured stdout call -----------------------------
 Exception during execute_many: table session_keystrokes has no column named text_index. Rolling back transaction.
---------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 605, in execute_many
    return self._bulk_executemany(cursor, query, params_list)
           ~~~~~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 633, in _bulk_executemany
    cursor.executemany(query, params_list)
    ~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^
sqlite3.OperationalError: table session_keystrokes has no column named text_index
Error saving keystrokes: Database operation failed: table session_keystrokes has no column named text_index
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 605, in execute_many
    return self._bulk_executemany(cursor, query, params_list)
           ~~~~~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 633, in _bulk_executemany
    cursor.executemany(query, params_list)
    ~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^
sqlite3.OperationalError: table session_keystrokes has no column named text_index

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\models\keystroke_manager.py", line 63, in save_keystrokes
    self.db_manager.execute_many(query, params)  # type: ignore[attr-defined]
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 614, in execute_many
    self._translate_and_raise(e)
    ~~~~~~~~~~~~~~~~~~~~~~~~~^^^
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 434, in _translate_and_raise
    raise DatabaseError(f"Database operation failed: {e}") from e
db.exceptions.DatabaseError: Database operation failed: table session_keystrokes has no column named text_index
______ TestKeystrokeManagerEdgeCases.test_unicode_and_special_characters ______

self = <AITypingTrainer.tests.models.test_keystroke_manager.TestKeystrokeManagerEdgeCases object at 0x000002CA817DC9D0>
manager = <models.keystroke_manager.KeystrokeManager object at 0x000002CA82E19CD0>

    def test_unicode_and_special_characters(self, manager: KeystrokeManager) -> None:
        """Test handling of Unicode and special characters in keystrokes."""
        import uuid
    
        special_chars = [
            "\U0001f642",
            "\u6d4b\u8bd5",
            "caf",
            "\u03a9",
            "\n",
            "\t",
            "\\",
            "'",
            '"',
            "\0",
        ]
        for _i, char in enumerate(special_chars):
            keystroke = Keystroke(
                session_id="unicode-test",
                keystroke_id=str(uuid.uuid4()),
                keystroke_time=datetime.now(timezone.utc),
                keystroke_char=char,
                expected_char=char,
                is_error=False,
                time_since_previous=100,  # Always integer
            )
            manager.add_keystroke(keystroke)
        assert len(manager.keystroke_list) == len(special_chars)
        result = manager.save_keystrokes()
        assert result is True
>       assert manager.db_manager.execute.call_count == len(special_chars)
E       AssertionError: assert 0 == 10
E        +  where 0 = <Mock name='mock.execute' id='3068802002160'>.call_count
E        +    where <Mock name='mock.execute' id='3068802002160'> = <Mock spec='DatabaseManager' id='3068802003504'>.execute
E        +      where <Mock spec='DatabaseManager' id='3068802003504'> = <models.keystroke_manager.KeystrokeManager object at 0x000002CA82E19CD0>.db_manager
E        +  and   10 = len(['\U0001f642', '\u6d4b\u8bd5', 'caf\xe9', '\u03a9', '\\n', '\\t', ...])

tests\models\test_keystroke_manager.py:829: AssertionError
_____ TestKeystrokeManagerErrorHandling.test_database_connection_failure ______

self = <AITypingTrainer.tests.models.test_keystroke_manager.TestKeystrokeManagerErrorHandling object at 0x000002CA81799810>
manager = <models.keystroke_manager.KeystrokeManager object at 0x000002CA82DC5550>

    def test_database_connection_failure(self, manager: KeystrokeManager) -> None:
        """Test handling of database connection failures."""
        import uuid
    
        manager.db_manager.execute.side_effect = Exception("Connection lost")
        keystroke = Keystroke(
            session_id="error-test",
            keystroke_id=str(uuid.uuid4()),
            keystroke_time=datetime.now(timezone.utc),
            keystroke_char="a",
            expected_char="a",
            is_error=False,
            time_since_previous=100,
        )
        manager.add_keystroke(keystroke)
        result = manager.save_keystrokes()
>       assert result is False
E       assert True is False

tests\models\test_keystroke_manager.py:878: AssertionError
_________ TestKeystrokeManagerErrorHandling.test_partial_save_failure _________

self = <AITypingTrainer.tests.models.test_keystroke_manager.TestKeystrokeManagerErrorHandling object at 0x000002CA817DCC30>
manager = <models.keystroke_manager.KeystrokeManager object at 0x000002CA82E19490>

    def test_partial_save_failure(self, manager: KeystrokeManager) -> None:
        """Test handling when some keystrokes save successfully and others fail."""
        import uuid
    
        keystrokes = []
        for i in range(3):
            keystroke = Keystroke(
                session_id="partial-test",
                keystroke_id=str(uuid.uuid4()),
                keystroke_time=datetime.now(timezone.utc),
                keystroke_char=chr(97 + i),
                expected_char=chr(97 + i),
                is_error=False,
                time_since_previous=100,
            )
            keystrokes.append(keystroke)
        manager.keystroke_list = keystrokes
        manager.db_manager.execute.side_effect = [None, Exception("Save failed"), None]
        result = manager.save_keystrokes()
>       assert result is False
E       assert True is False

tests\models\test_keystroke_manager.py:919: AssertionError
______ TestKeystrokeManagerErrorHandling.test_network_timeout_simulation ______

self = <AITypingTrainer.tests.models.test_keystroke_manager.TestKeystrokeManagerErrorHandling object at 0x000002CA817DCD60>
manager = <models.keystroke_manager.KeystrokeManager object at 0x000002CA82D9DA30>

    def test_network_timeout_simulation(self, manager: KeystrokeManager) -> None:
        """Test handling of network timeout-like errors."""
        import time
        import uuid
    
        def slow_execute(*args: object, **kwargs: object) -> object:
            time.sleep(0.1)  # Simulate slow operation
            raise TimeoutError("Database timeout")
    
        manager.db_manager.execute.side_effect = slow_execute
        keystroke = Keystroke(
            session_id="timeout-test",
            keystroke_id=str(uuid.uuid4()),
            keystroke_time=datetime.now(timezone.utc),
            keystroke_char="a",
            expected_char="a",
            is_error=False,
            time_since_previous=100,
        )
        manager.add_keystroke(keystroke)
        result = manager.save_keystrokes()
>       assert result is False
E       assert True is False

tests\models\test_keystroke_manager.py:942: AssertionError
____________________________ test_missing_api_key _____________________________

    def test_missing_api_key():
>       with pytest.raises(LLMMissingAPIKeyError):
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       Failed: DID NOT RAISE <class 'models.llm_ngram_service.LLMMissingAPIKeyError'>

tests\models\test_llm_ngram_service.py:8: Failed
________________ TestKeystroke.test_keystroke_nfc_single_char _________________

self = <AITypingTrainer.tests.models.test_ngram.TestKeystroke object at 0x000002CA8179A0D0>

    def test_keystroke_nfc_single_char(self):
        # composed e + \u0301
        k = Keystroke(keystroke_time=ts(0), text_index=0, expected_char="e\u0301", keystroke_char="", is_error=False)
>       assert k.expected_char == ""
E       AssertionError: assert 'e\u0301' == '\xe9'
E         
E         - 
E         + e\u0301

tests\models\test_ngram.py:32: AssertionError
__ TestNGramAnalyticsService.test_dual_insert_creates_records_in_both_tables __

self = <AITypingTrainer.tests.models.test_ngram_analytics_service.TestNGramAnalyticsService object at 0x000002CA817A5850>
temp_db = 'C:\\Users\\seanb\\AppData\\Local\\Temp\\tmpv3gqrac7.db'
mock_sessions = [{'keyboard_id': 'keyboard_1', 'session_id': 'session_1', 'start_time': '2024-01-01 10:01:00', 'target_ms_per_keystrok...: 'keyboard_1', 'session_id': 'session_2', 'start_time': '2024-01-01 10:02:00', 'target_ms_per_keystroke': 170.0, ...}]
mock_ngram_data = [{'ms_per_keystroke': 100.0, 'ngram_size': 2, 'ngram_speed_id': 'ng_0', 'ngram_text': 'th', ...}, {'ms_per_keystroke':...ram_text': 'th', ...}, {'ms_per_keystroke': 107.5, 'ngram_size': 3, 'ngram_speed_id': 'ng_3', 'ngram_text': 'he', ...}]

    def test_dual_insert_creates_records_in_both_tables(
        self,
        temp_db: DatabaseManager,
        mock_sessions: List[MockSessionData],
        mock_ngram_data: List[MockNGramSpeedData],
    ) -> None:
        """
        Test objective: Verify dual-insert creates records in both current and history tables.
    
        Tests that when refresh_speed_summaries is called, records are created
        in both ngram_speed_summary_curr and ngram_speed_summary_hist tables.
        """
        ngram_manager = NGramManager(temp_db)
        service = NGramAnalyticsService(temp_db, ngram_manager)
    
        # Set up test data
        user_id = "user_1"
        keyboard_id = "keyboard_1"
    
        # Insert test session and keyboard data
        for session in mock_sessions:
>           temp_db.execute(
            ^^^^^^^^^^^^^^^
                """INSERT INTO practice_sessions
                (session_id, user_id, keyboard_id, snippet_id, snippet_index_start, snippet_index_end,
                 content, start_time, end_time, actual_chars, errors, ms_per_keystroke)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)""",
                (
                    session["session_id"],
                    session["user_id"],
                    session["keyboard_id"],
                    "test_snippet_1",
                    0,
                    10,
                    "test content",
                    session["start_time"],
                    session["start_time"],
                    "test",
                    0,
                    session["target_ms_per_keystroke"],
                ),
            )
E           AttributeError: 'str' object has no attribute 'execute'

tests\models\test_ngram_analytics_service.py:370: AttributeError
____ TestNGramAnalyticsService.test_history_table_accumulates_all_records _____

self = <AITypingTrainer.tests.models.test_ngram_analytics_service.TestNGramAnalyticsService object at 0x000002CA817A5A50>
temp_db = 'C:\\Users\\seanb\\AppData\\Local\\Temp\\tmp3pslo9yz.db'
mock_sessions = [{'keyboard_id': 'keyboard_1', 'session_id': 'session_1', 'start_time': '2024-01-01 10:01:00', 'target_ms_per_keystrok...: 'keyboard_1', 'session_id': 'session_2', 'start_time': '2024-01-01 10:02:00', 'target_ms_per_keystroke': 170.0, ...}]
mock_ngram_data = [{'ms_per_keystroke': 100.0, 'ngram_size': 2, 'ngram_speed_id': 'ng_0', 'ngram_text': 'th', ...}, {'ms_per_keystroke':...ram_text': 'th', ...}, {'ms_per_keystroke': 107.5, 'ngram_size': 3, 'ngram_speed_id': 'ng_3', 'ngram_text': 'he', ...}]

    def test_history_table_accumulates_all_records(
        self,
        temp_db: DatabaseManager,
        mock_sessions: List[MockSessionData],
        mock_ngram_data: List[MockNGramSpeedData],
    ) -> None:
        """
        Test objective: Verify history table contains all records over multiple refreshes.
    
        Tests that the history table accumulates all records from multiple
        refresh operations while current table only contains latest values.
        """
        ngram_manager = NGramManager(temp_db)
        service = NGramAnalyticsService(temp_db, ngram_manager)
    
        user_id = "user_1"
        keyboard_id = "keyboard_1"
    
        # Set up initial test data
        for session in mock_sessions:
>           temp_db.execute(
            ^^^^^^^^^^^^^^^
                """INSERT INTO practice_sessions
                (session_id, user_id, keyboard_id, snippet_id, snippet_index_start, snippet_index_end,
                 content, start_time, end_time, actual_chars, errors, ms_per_keystroke)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)""",
                (
                    session["session_id"],
                    session["user_id"],
                    session["keyboard_id"],
                    "test_snippet_1",
                    0,
                    10,
                    "test content",
                    session["start_time"],
                    session["start_time"],
                    "test",
                    0,
                    session["target_ms_per_keystroke"],
                ),
            )
E           AttributeError: 'str' object has no attribute 'execute'

tests\models\test_ngram_analytics_service.py:442: AttributeError
_________ TestNGramAnalyticsService.test_get_ngram_history_retrieval __________

self = <AITypingTrainer.tests.models.test_ngram_analytics_service.TestNGramAnalyticsService object at 0x000002CA81553980>
temp_db = 'C:\\Users\\seanb\\AppData\\Local\\Temp\\tmpqh7zzgpu.db'
mock_sessions = [{'keyboard_id': 'keyboard_1', 'session_id': 'session_1', 'start_time': '2024-01-01 10:01:00', 'target_ms_per_keystrok...: 'keyboard_1', 'session_id': 'session_2', 'start_time': '2024-01-01 10:02:00', 'target_ms_per_keystroke': 170.0, ...}]
mock_ngram_data = [{'ms_per_keystroke': 100.0, 'ngram_size': 2, 'ngram_speed_id': 'ng_0', 'ngram_text': 'th', ...}, {'ms_per_keystroke':...ram_text': 'th', ...}, {'ms_per_keystroke': 107.5, 'ngram_size': 3, 'ngram_speed_id': 'ng_3', 'ngram_text': 'he', ...}]

    def test_get_ngram_history_retrieval(
        self,
        temp_db: DatabaseManager,
        mock_sessions: List[MockSessionData],
        mock_ngram_data: List[MockNGramSpeedData],
    ) -> None:
        """
        Test objective: Verify history retrieval functionality.
    
        Tests that historical data can be retrieved properly with correct
        timestamps and performance metrics.
        """
        ngram_manager = NGramManager(temp_db)
        service = NGramAnalyticsService(temp_db, ngram_manager)
    
        user_id = "user_1"
        keyboard_id = "keyboard_1"
    
        # Set up test data and refresh
        for session in mock_sessions:
>           temp_db.execute(
            ^^^^^^^^^^^^^^^
                """INSERT INTO practice_sessions
                (session_id, user_id, keyboard_id, snippet_id, snippet_index_start, snippet_index_end,
                 content, start_time, end_time, actual_chars, errors, ms_per_keystroke)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)""",
                (
                    session["session_id"],
                    session["user_id"],
                    session["keyboard_id"],
                    "test_snippet_1",
                    0,
                    10,
                    "test content",
                    session["start_time"],
                    session["start_time"],
                    "test",
                    0,
                    session["target_ms_per_keystroke"],
                ),
            )
E           AttributeError: 'str' object has no attribute 'execute'

tests\models\test_ngram_analytics_service.py:552: AttributeError
______ TestNGramAnalyticsService.test_history_table_schema_compatibility ______

self = <AITypingTrainer.tests.models.test_ngram_analytics_service.TestNGramAnalyticsService object at 0x000002CA81553B60>
temp_db = 'C:\\Users\\seanb\\AppData\\Local\\Temp\\tmpmki9f42t.db'

    def test_history_table_schema_compatibility(
        self, temp_db: DatabaseManager
    ) -> None:
        """
        Test objective: Verify history table schema matches current table.
    
        Tests that the history table has the same essential columns as
        the current table plus additional history-specific fields.
        """
        ngram_manager = NGramManager(temp_db)
        service = NGramAnalyticsService(temp_db, ngram_manager)
    
        # Verify table schemas are compatible
>       current_schema = temp_db.fetchall("PRAGMA table_info(ngram_speed_summary_curr)")
                         ^^^^^^^^^^^^^^^^
E       AttributeError: 'str' object has no attribute 'fetchall'

tests\models\test_ngram_analytics_service.py:617: AttributeError
__________________ test_process_end_of_session_success_path ___________________

self = <db.database_manager.DatabaseManager object at 0x000002CA82F10FA0>
query = '\n            INSERT INTO categories (category_id, category_name, description)\n            VALUES (?, ?, ?)\n            '
params = ('97d56abb-43d5-437e-922a-a0ba9a96c135', 'Test Category', 'Test category for testing')

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table categories has no column named description

db\database_manager.py:509: OperationalError

The above exception was the direct cause of the following exception:

db_with_tables = <db.database_manager.DatabaseManager object at 0x000002CA82F10FA0>
test_user = User(user_id='ae996b79-8bff-4d43-b211-8ed2711e0e09', first_name='Test', surname='User', email_address='test.user.922cb660-1fbc-450c-ad1b-350b0ee7ebfa@example.com')
test_keyboard = Keyboard(keyboard_id='e1b26f91-119f-45d0-8233-01ec7523d87b', user_id='ae996b79-8bff-4d43-b211-8ed2711e0e09', keyboard_name='Test Keyboard', target_ms_per_keystroke=600)

    def test_process_end_of_session_success_path(db_with_tables, test_user, test_keyboard):
        # Arrange: create snippet (for FK completeness) and a new Session not yet in DB
        from tests.models.conftest import TestSessionMethodsFixtures
    
>       category_id = TestSessionMethodsFixtures.create_category(db_with_tables)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_ngram_orchestrator_process_end_of_session.py:40: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:239: in create_category
    db.execute(
db\database_manager.py:524: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x000002CA82F10FA0>
e = OperationalError('table categories has no column named description')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table categories has no column named description

db\database_manager.py:434: DatabaseError
---------------------------- Captured stdout call -----------------------------
Exception during query: table categories has no column named description. Rolling back transaction.
---------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 509, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table categories has no column named description
______________ test_process_end_of_session_session_save_failure _______________

self = <db.database_manager.DatabaseManager object at 0x000002CA82F5FAF0>
query = '\n            INSERT INTO categories (category_id, category_name, description)\n            VALUES (?, ?, ?)\n            '
params = ('46012cf2-186b-4c71-af23-49dbe44a36fa', 'Test Category', 'Test category for testing')

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table categories has no column named description

db\database_manager.py:509: OperationalError

The above exception was the direct cause of the following exception:

db_with_tables = <db.database_manager.DatabaseManager object at 0x000002CA82F5FAF0>
test_user = User(user_id='d094d8db-51bd-4737-a7ba-e652a617324c', first_name='Test', surname='User', email_address='test.user.2bf96a9a-e2b1-48c2-a084-bb0ef4ba5252@example.com')

    def test_process_end_of_session_session_save_failure(db_with_tables, test_user):
        """Fails at step 1: session save should raise due to FK violation (invalid keyboard_id)."""
        from tests.models.conftest import TestSessionMethodsFixtures
    
        # Valid snippet/category, but invalid keyboard_id to trigger FK failure on insert
>       category_id = TestSessionMethodsFixtures.create_category(db_with_tables)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_ngram_orchestrator_process_end_of_session.py:129: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:239: in create_category
    db.execute(
db\database_manager.py:524: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x000002CA82F5FAF0>
e = OperationalError('table categories has no column named description')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table categories has no column named description

db\database_manager.py:434: DatabaseError
---------------------------- Captured stdout call -----------------------------
Exception during query: table categories has no column named description. Rolling back transaction.
---------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 509, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table categories has no column named description
_____________ test_process_end_of_session_keystrokes_save_failure _____________

self = <db.database_manager.DatabaseManager object at 0x000002CA82F5F850>
query = '\n            INSERT INTO categories (category_id, category_name, description)\n            VALUES (?, ?, ?)\n            '
params = ('5c28d769-ecc9-4707-948c-8ceb5a06a4f8', 'Test Category', 'Test category for testing')

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table categories has no column named description

db\database_manager.py:509: OperationalError

The above exception was the direct cause of the following exception:

db_with_tables = <db.database_manager.DatabaseManager object at 0x000002CA82F5F850>
test_user = User(user_id='700e825e-5dc0-4cf5-911a-1a5b460cdd79', first_name='Test', surname='User', email_address='test.user.1bb50848-8e05-45ed-bf22-e4b639e01ab2@example.com')
test_keyboard = Keyboard(keyboard_id='23494c7c-cef1-4a92-8469-62a8cb1fffd9', user_id='700e825e-5dc0-4cf5-911a-1a5b460cdd79', keyboard_name='Test Keyboard', target_ms_per_keystroke=600)

    def test_process_end_of_session_keystrokes_save_failure(db_with_tables, test_user, test_keyboard):
        """Fails at step 2: keystrokes save should return False due to invalid keystroke session_id."""
        from tests.models.conftest import TestSessionMethodsFixtures
    
>       category_id = TestSessionMethodsFixtures.create_category(db_with_tables)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_ngram_orchestrator_process_end_of_session.py:170: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:239: in create_category
    db.execute(
db\database_manager.py:524: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x000002CA82F5F850>
e = OperationalError('table categories has no column named description')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table categories has no column named description

db\database_manager.py:434: DatabaseError
---------------------------- Captured stdout call -----------------------------
Exception during query: table categories has no column named description. Rolling back transaction.
---------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 509, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table categories has no column named description
______________ test_process_end_of_session_summarization_failure ______________

self = <db.database_manager.DatabaseManager object at 0x000002CA82F5F4D0>
query = '\n            INSERT INTO categories (category_id, category_name, description)\n            VALUES (?, ?, ?)\n            '
params = ('e008f02a-16a4-4737-ac17-42f1f42ca93e', 'Test Category', 'Test category for testing')

    def execute(self, query: str, params: Tuple[object, ...] = ()) -> CursorProtocol:
        """
        Execute a SQL query with parameters and commit immediately.
    
        Args:
            query: SQL query string (parameterized)
            params: Query parameters
    
        Returns:
            Database cursor object
    
        Raises:
            DBConnectionError, TableNotFoundError, SchemaError, DatabaseError,
            ForeignKeyError, ConstraintError, IntegrityError, DatabaseTypeError
        """
        try:
            cursor: CursorProtocol = self._get_cursor()
    
            if self.is_postgres:
                query = self._qualify_schema_in_query(query)
                # Debug the final SQL being executed on Postgres
                try:
                    dbg_sql = query.replace("\n", " ").strip()
                    self._debug_message(f"Executing SQL (PG): {dbg_sql}; params={params}")
                except Exception:
                    pass
    
            # Execute the query
>           cursor.execute(query, params)
E           sqlite3.OperationalError: table categories has no column named description

db\database_manager.py:509: OperationalError

The above exception was the direct cause of the following exception:

db_with_tables = <db.database_manager.DatabaseManager object at 0x000002CA82F5F4D0>
test_user = User(user_id='ef1ad7b8-4d1d-4d9d-9cee-5e9f0ae465eb', first_name='Test', surname='User', email_address='test.user.32647490-a4bc-4605-992f-be02f2c09502@example.com')
test_keyboard = Keyboard(keyboard_id='fa26b19d-bf26-46a1-b679-7e5f5088fb4e', user_id='ef1ad7b8-4d1d-4d9d-9cee-5e9f0ae465eb', keyboard_name='Test Keyboard', target_ms_per_keystroke=600)

    def test_process_end_of_session_summarization_failure(db_with_tables, test_user, test_keyboard):
        """Fails at step 4: drop summary table to force summarization SQL to fail after n-grams."""
        from tests.models.conftest import TestSessionMethodsFixtures
    
>       category_id = TestSessionMethodsFixtures.create_category(db_with_tables)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\models\test_ngram_orchestrator_process_end_of_session.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\models\conftest.py:239: in create_category
    db.execute(
db\database_manager.py:524: in execute
    self._translate_and_raise(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <db.database_manager.DatabaseManager object at 0x000002CA82F5F4D0>
e = OperationalError('table categories has no column named description')

    def _translate_and_raise(self, e: Exception) -> NoReturn:
        """Translate backend-specific exceptions to our custom exceptions and raise.
    
        Always raises; does not return.
        """
        # SQLite mapping
        if isinstance(e, sqlite3.OperationalError):
            error_msg: str = str(e).lower()
            if "unable to open database" in error_msg:
                raise DBConnectionError(f"Failed to connect to database at {self.db_path}") from e
            if "no such table" in error_msg:
                raise TableNotFoundError(f"Table not found: {e}") from e
            if "no such column" in error_msg:
                raise SchemaError(f"Schema error: {e}") from e
>           raise DatabaseError(f"Database operation failed: {e}") from e
E           db.exceptions.DatabaseError: Database operation failed: table categories has no column named description

db\database_manager.py:434: DatabaseError
---------------------------- Captured stdout call -----------------------------
Exception during query: table categories has no column named description. Rolling back transaction.
---------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "D:\SeanDevLocal\AITypingTrainer\db\database_manager.py", line 509, in execute
    cursor.execute(query, params)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
sqlite3.OperationalError: table categories has no column named description
============================== warnings summary ===============================
tests/models/test_category_manager.py::TestCategoryManager::test_list_all_categories_populated
  C:\Python\Python313\Lib\inspect.py:445: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002CA81BDF1F0>
    def isasyncgenfunction(obj):
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_category_manager.py::TestCategoryManager::test_list_all_categories_populated
  C:\Python\Python313\Lib\inspect.py:445: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002CA81C109A0>
    def isasyncgenfunction(obj):
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_category_manager.py::TestCategoryManager::test_list_all_categories_populated
  C:\Python\Python313\Lib\inspect.py:445: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002CA81C10F40>
    def isasyncgenfunction(obj):
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_category_manager.py::TestCategoryManager::test_list_all_categories_populated
  C:\Python\Python313\Lib\inspect.py:445: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002CA81C11030>
    def isasyncgenfunction(obj):
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_category_manager.py::TestCategoryManager::test_list_all_categories_populated
  C:\Python\Python313\Lib\inspect.py:445: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002CA81C11300>
    def isasyncgenfunction(obj):
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_category_manager.py::TestCategoryManager::test_list_all_categories_populated
  C:\Python\Python313\Lib\inspect.py:445: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002CA81C11120>
    def isasyncgenfunction(obj):
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_category_manager.py::TestCategoryManager::test_list_all_categories_populated
  C:\Python\Python313\Lib\inspect.py:445: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002CA81C10D60>
    def isasyncgenfunction(obj):
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_category_manager.py::TestCategoryManager::test_list_all_categories_populated
  C:\Python\Python313\Lib\inspect.py:445: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002CA81C10B80>
    def isasyncgenfunction(obj):
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_category_manager.py::TestCategoryManager::test_list_all_categories_populated
  C:\Python\Python313\Lib\inspect.py:445: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002CA81C11210>
    def isasyncgenfunction(obj):
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_category_manager.py::TestCategoryManager::test_save_category_unexpected_db_error
  D:\SeanDevLocal\AITypingTrainer\.venv\Lib\site-packages\_pytest\raises.py:437: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002CA81BDDA80>
    def _parse_exc(
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_category_manager.py::TestCategoryManager::test_save_category_unexpected_db_error
  D:\SeanDevLocal\AITypingTrainer\.venv\Lib\site-packages\_pytest\raises.py:437: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002CA81C10220>
    def _parse_exc(
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_category_manager.py::TestCategoryManager::test_save_category_unexpected_db_error
  D:\SeanDevLocal\AITypingTrainer\.venv\Lib\site-packages\_pytest\raises.py:437: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002CA81C124D0>
    def _parse_exc(
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_category_manager.py::TestCategoryManager::test_save_category_unexpected_db_error
  D:\SeanDevLocal\AITypingTrainer\.venv\Lib\site-packages\_pytest\raises.py:437: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002CA81C12A70>
    def _parse_exc(
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_category_manager.py::TestCategoryManager::test_save_category_unexpected_db_error
  D:\SeanDevLocal\AITypingTrainer\.venv\Lib\site-packages\_pytest\raises.py:437: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002CA81C12B60>
    def _parse_exc(
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_category_manager.py::TestCategoryManager::test_save_category_unexpected_db_error
  D:\SeanDevLocal\AITypingTrainer\.venv\Lib\site-packages\_pytest\raises.py:437: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002CA81C12C50>
    def _parse_exc(
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_category_manager.py::TestCategoryManager::test_save_category_unexpected_db_error
  D:\SeanDevLocal\AITypingTrainer\.venv\Lib\site-packages\_pytest\raises.py:437: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002CA81C12D40>
    def _parse_exc(
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_category_manager.py::TestCategoryManager::test_save_category_unexpected_db_error
  D:\SeanDevLocal\AITypingTrainer\.venv\Lib\site-packages\_pytest\raises.py:437: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002CA81C12E30>
    def _parse_exc(
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_category_manager.py::TestCategoryManager::test_save_category_unexpected_db_error
  D:\SeanDevLocal\AITypingTrainer\.venv\Lib\site-packages\_pytest\raises.py:437: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002CA81C12F20>
    def _parse_exc(
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_category_manager.py::TestCategoryManager::test_save_category_unexpected_db_error
  D:\SeanDevLocal\AITypingTrainer\.venv\Lib\site-packages\_pytest\raises.py:437: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002CA81C13010>
    def _parse_exc(
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_category_manager.py::TestCategoryManager::test_save_category_unexpected_db_error
  D:\SeanDevLocal\AITypingTrainer\.venv\Lib\site-packages\_pytest\raises.py:437: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002CA81C13100>
    def _parse_exc(
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_category_manager.py::TestCategoryManager::test_save_category_unexpected_db_error
  D:\SeanDevLocal\AITypingTrainer\.venv\Lib\site-packages\_pytest\raises.py:437: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002CA81C131F0>
    def _parse_exc(
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_keystroke.py::TestKeystrokeClassMethods::test_get_for_session_empty_result
  C:\Python\Python313\Lib\unittest\mock.py:502: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002CA82D15030>
    _safe_super(NonCallableMock, self).__init__(
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_keystroke.py::TestKeystrokeClassMethods::test_get_for_session_empty_result
  C:\Python\Python313\Lib\unittest\mock.py:502: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002CA82D15300>
    _safe_super(NonCallableMock, self).__init__(
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_keystroke.py::TestKeystrokeClassMethods::test_get_for_session_empty_result
  C:\Python\Python313\Lib\unittest\mock.py:502: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002CA82D153F0>
    _safe_super(NonCallableMock, self).__init__(
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_keystroke.py::TestKeystrokeClassMethods::test_get_for_session_empty_result
  C:\Python\Python313\Lib\unittest\mock.py:502: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002CA82D154E0>
    _safe_super(NonCallableMock, self).__init__(
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_keystroke.py::TestKeystrokeClassMethods::test_get_for_session_empty_result
  C:\Python\Python313\Lib\unittest\mock.py:502: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002CA82D155D0>
    _safe_super(NonCallableMock, self).__init__(
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_keystroke_manager.py::TestKeystrokeManagerGetKeystrokesForSession::test_get_keystrokes_with_uuid_session_id
  C:\Python\Python313\Lib\unittest\mock.py:2245: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002CA82D158A0>
    def __init__(self, name, parent):
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_keystroke_manager.py::TestKeystrokeManagerGetKeystrokesForSession::test_get_keystrokes_with_uuid_session_id
  C:\Python\Python313\Lib\unittest\mock.py:2245: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002CA82D15990>
    def __init__(self, name, parent):
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_keystroke_manager.py::TestKeystrokeManagerEdgeCases::test_memory_management_large_list
  C:\Python\Python313\Lib\uuid.py:174: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002CA82E78040>
    if [hex, bytes, bytes_le, fields, int].count(None) != 4:
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_ngram_orchestrator_process_end_of_session.py::test_process_end_of_session_summarization_failure
  D:\SeanDevLocal\AITypingTrainer\.venv\Lib\site-packages\pydantic\main.py:1204: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002CA82E7B1F0>
    def __repr_args__(self) -> _repr.ReprArgs:
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_ngram_orchestrator_process_end_of_session.py::test_process_end_of_session_summarization_failure
  D:\SeanDevLocal\AITypingTrainer\.venv\Lib\site-packages\pydantic\main.py:1204: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002CA82E7B100>
    def __repr_args__(self) -> _repr.ReprArgs:
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_ngram_orchestrator_process_end_of_session.py::test_process_end_of_session_summarization_failure
  D:\SeanDevLocal\AITypingTrainer\.venv\Lib\site-packages\pydantic\main.py:1204: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002CA82D172E0>
    def __repr_args__(self) -> _repr.ReprArgs:
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_ngram_orchestrator_process_end_of_session.py::test_process_end_of_session_summarization_failure
  D:\SeanDevLocal\AITypingTrainer\.venv\Lib\site-packages\pydantic\main.py:1204: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002CA82D16B60>
    def __repr_args__(self) -> _repr.ReprArgs:
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_ngram_orchestrator_process_end_of_session.py::test_process_end_of_session_summarization_failure
  D:\SeanDevLocal\AITypingTrainer\.venv\Lib\site-packages\pydantic\main.py:1204: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002CA82F2B880>
    def __repr_args__(self) -> _repr.ReprArgs:
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_ngram_orchestrator_process_end_of_session.py::test_process_end_of_session_summarization_failure
  D:\SeanDevLocal\AITypingTrainer\.venv\Lib\site-packages\pydantic\main.py:1204: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002CA82F2AB60>
    def __repr_args__(self) -> _repr.ReprArgs:
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_ngram_orchestrator_process_end_of_session.py::test_process_end_of_session_summarization_failure
  D:\SeanDevLocal\AITypingTrainer\.venv\Lib\site-packages\pydantic\main.py:1204: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002CA82F28D60>
    def __repr_args__(self) -> _repr.ReprArgs:
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_session.py::test_to_dict_and_from_dict
  D:\SeanDevLocal\AITypingTrainer\models\session.py:108: PydanticDeprecatedSince20: The `dict` method is deprecated; use `model_dump` instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.11/migration/
    return self.dict()

tests/models/test_setting.py::TestSettingModel::test_setting_to_dict
  C:\Python\Python313\Lib\uuid.py:174: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002CA82E7B3D0>
    if [hex, bytes, bytes_le, fields, int].count(None) != 4:
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_setting.py::TestSettingModel::test_setting_to_dict
  C:\Python\Python313\Lib\uuid.py:174: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002CA82E7BB50>
    if [hex, bytes, bytes_le, fields, int].count(None) != 4:
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_setting.py::TestSettingModel::test_setting_to_dict
  C:\Python\Python313\Lib\uuid.py:174: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002CA82E7BC40>
    if [hex, bytes, bytes_le, fields, int].count(None) != 4:
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_setting.py::TestSettingModel::test_setting_to_dict
  C:\Python\Python313\Lib\uuid.py:174: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002CA82E7BE20>
    if [hex, bytes, bytes_le, fields, int].count(None) != 4:
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_setting.py::TestSettingModel::test_setting_to_dict
  C:\Python\Python313\Lib\uuid.py:174: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002CA82E7BA60>
    if [hex, bytes, bytes_le, fields, int].count(None) != 4:
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_setting.py::TestSettingModel::test_setting_to_dict
  C:\Python\Python313\Lib\uuid.py:174: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002CA82E7A5C0>
    if [hex, bytes, bytes_le, fields, int].count(None) != 4:
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_setting.py::TestSettingModel::test_setting_to_dict
  C:\Python\Python313\Lib\uuid.py:174: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002CA82E7B5B0>
    if [hex, bytes, bytes_le, fields, int].count(None) != 4:
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_setting.py::TestSettingModel::test_setting_to_dict
  C:\Python\Python313\Lib\uuid.py:174: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002CAFC3827A0>
    if [hex, bytes, bytes_le, fields, int].count(None) != 4:
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_setting_manager.py::TestSettingManager::test_list_settings_populated
  D:\SeanDevLocal\AITypingTrainer\db\database_manager.py:374: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002CA83906A70>
    cursor.execute(query)
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_setting_manager.py::TestSettingManager::test_list_settings_populated
  D:\SeanDevLocal\AITypingTrainer\db\database_manager.py:374: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002CA8392C310>
    cursor.execute(query)
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_setting_manager.py::TestSettingManager::test_list_settings_populated
  D:\SeanDevLocal\AITypingTrainer\db\database_manager.py:374: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002CA8392C4F0>
    cursor.execute(query)
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_setting_manager.py::TestSettingManager::test_list_settings_populated
  D:\SeanDevLocal\AITypingTrainer\db\database_manager.py:374: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002CA8392C5E0>
    cursor.execute(query)
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_setting_manager.py::TestSettingManager::test_list_settings_populated
  D:\SeanDevLocal\AITypingTrainer\db\database_manager.py:374: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002CA8392C6D0>
    cursor.execute(query)
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_setting_manager.py::TestSettingManager::test_list_settings_populated
  D:\SeanDevLocal\AITypingTrainer\db\database_manager.py:374: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002CA8392C8B0>
    cursor.execute(query)
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_snippet.py::test_list_snippets_empty
  <frozen abc>:117: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002CA83905A80>
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_snippet.py::test_list_snippets_empty
  <frozen abc>:117: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002CA83905990>
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_snippet.py::test_list_snippets_empty
  <frozen abc>:117: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002CA83905030>
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_snippet.py::test_list_snippets_empty
  <frozen abc>:117: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002CA839049A0>
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_snippet.py::test_list_snippets_empty
  <frozen abc>:117: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002CA83905120>
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_snippet.py::test_list_snippets_empty
  <frozen abc>:117: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002CA83904A90>
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_snippet.py::test_list_snippets_empty
  <frozen abc>:117: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002CA83904400>
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_snippet.py::test_list_snippets_empty
  <frozen abc>:117: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002CA83904130>
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_snippet.py::test_update_snippet_no_changes
  D:\SeanDevLocal\AITypingTrainer\.venv\Lib\site-packages\_pytest\reports.py:346: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002CA838D1E40>
    keywords = {x: 1 for x in item.keywords}
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_snippet_manager.py::TestCreateSnippet::test_create_snippet_duplicate_name_in_category
  C:\Python\Python313\Lib\functools.py:53: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002CA838D34C0>
    value = getattr(wrapped, attr)
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_snippet_manager.py::TestCreateSnippet::test_create_snippet_duplicate_name_in_category
  C:\Python\Python313\Lib\functools.py:53: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002CA838D0040>
    value = getattr(wrapped, attr)
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_user.py::TestUserModel::test_invalid_email_formats[username@example.com-]
  D:\SeanDevLocal\AITypingTrainer\.venv\Lib\site-packages\_pytest\raises.py:348: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002CA83907B50>
    if not isinstance(
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_user.py::TestUserModel::test_invalid_email_formats[username@example.com-]
  D:\SeanDevLocal\AITypingTrainer\.venv\Lib\site-packages\_pytest\raises.py:348: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002CA839053F0>
    if not isinstance(
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_user.py::TestUserModel::test_invalid_email_formats[username@example.com-]
  D:\SeanDevLocal\AITypingTrainer\.venv\Lib\site-packages\_pytest\raises.py:348: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002CA83907970>
    if not isinstance(
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_user.py::TestUserModel::test_invalid_email_formats[username@example.com-]
  D:\SeanDevLocal\AITypingTrainer\.venv\Lib\site-packages\_pytest\raises.py:348: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002CA83907E20>
    if not isinstance(
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_user.py::TestUserModel::test_invalid_email_formats[username@example.com-]
  D:\SeanDevLocal\AITypingTrainer\.venv\Lib\site-packages\_pytest\raises.py:348: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002CA83905210>
    if not isinstance(
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_user.py::TestUserModel::test_invalid_email_formats[username@example.com-]
  D:\SeanDevLocal\AITypingTrainer\.venv\Lib\site-packages\_pytest\raises.py:348: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002CA83907880>
    if not isinstance(
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_user.py::TestUserModel::test_invalid_email_formats[username@example.com-]
  D:\SeanDevLocal\AITypingTrainer\.venv\Lib\site-packages\_pytest\raises.py:348: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002CA8392FC40>
    if not isinstance(
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_user.py::TestUserModel::test_invalid_email_formats[username@example.com-]
  D:\SeanDevLocal\AITypingTrainer\.venv\Lib\site-packages\_pytest\raises.py:348: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002CA8392E890>
    if not isinstance(
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_user.py::TestUserModel::test_invalid_email_formats[username@example.com-]
  D:\SeanDevLocal\AITypingTrainer\.venv\Lib\site-packages\_pytest\raises.py:348: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002CA8392F2E0>
    if not isinstance(
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_user.py::TestUserModel::test_invalid_email_formats[username@example.com-]
  D:\SeanDevLocal\AITypingTrainer\.venv\Lib\site-packages\_pytest\raises.py:348: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002CA8392FD30>
    if not isinstance(
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_user.py::TestUserModel::test_invalid_email_formats[username@example.com-]
  D:\SeanDevLocal\AITypingTrainer\.venv\Lib\site-packages\_pytest\raises.py:348: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002CA8392F3D0>
    if not isinstance(
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_user.py::TestUserModel::test_invalid_email_formats[username@example.com-]
  D:\SeanDevLocal\AITypingTrainer\.venv\Lib\site-packages\_pytest\raises.py:348: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002CA8392F1F0>
    if not isinstance(
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_user.py::TestUserModel::test_invalid_email_formats[username@example.com-]
  D:\SeanDevLocal\AITypingTrainer\.venv\Lib\site-packages\_pytest\raises.py:348: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002CA8392ED40>
    if not isinstance(
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_user.py::TestUserModel::test_invalid_email_formats[username@example.com-]
  D:\SeanDevLocal\AITypingTrainer\.venv\Lib\site-packages\_pytest\raises.py:348: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002CA8392E2F0>
    if not isinstance(
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_user.py::TestUserModel::test_invalid_email_formats[username@example.com-]
  D:\SeanDevLocal\AITypingTrainer\.venv\Lib\site-packages\_pytest\raises.py:348: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002CA8392E980>
    if not isinstance(
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_user.py::TestUserModel::test_invalid_email_formats[username@example.com-]
  D:\SeanDevLocal\AITypingTrainer\.venv\Lib\site-packages\_pytest\raises.py:348: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002CA8392FB50>
    if not isinstance(
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_user.py::TestUserModel::test_invalid_email_formats[username@example.com-]
  D:\SeanDevLocal\AITypingTrainer\.venv\Lib\site-packages\_pytest\raises.py:348: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002CA8392FA60>
    if not isinstance(
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_user.py::TestUserModel::test_to_dict
  D:\SeanDevLocal\AITypingTrainer\models\user.py:202: PydanticDeprecatedSince20: The `dict` method is deprecated; use `model_dump` instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.11/migration/
    return self.dict()

tests/models/test_user_manager_fixes.py::TestUserManagerDatabaseAccessFixes::test_get_user_by_id_not_found
  C:\Python\Python313\Lib\re\_parser.py:239: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002CA8392D8A0>
    def __next(self):
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_user_manager_fixes.py::TestUserManagerDatabaseAccessFixes::test_get_user_by_id_not_found
  C:\Python\Python313\Lib\re\_parser.py:239: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002CA8392EA70>
    def __next(self):
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_user_manager_fixes.py::TestUserManagerDatabaseAccessFixes::test_get_user_by_id_not_found
  C:\Python\Python313\Lib\re\_parser.py:239: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002CA8392E5C0>
    def __next(self):
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_user_manager_fixes.py::TestUserManagerDatabaseAccessFixes::test_get_user_by_id_not_found
  C:\Python\Python313\Lib\re\_parser.py:239: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002CA8392DB70>
    def __next(self):
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_user_manager_fixes.py::TestUserManagerDatabaseAccessFixes::test_get_user_by_id_not_found
  C:\Python\Python313\Lib\re\_parser.py:239: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002CA8392D6C0>
    def __next(self):
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_user_manager_fixes.py::TestUserManagerDatabaseAccessFixes::test_get_user_by_id_not_found
  C:\Python\Python313\Lib\re\_parser.py:239: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002CA8392D120>
    def __next(self):
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_user_manager_fixes.py::TestUserManagerDatabaseAccessFixes::test_get_user_by_id_not_found
  C:\Python\Python313\Lib\re\_parser.py:239: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002CA8392C130>
    def __next(self):
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_user_manager_fixes.py::TestUserManagerDatabaseAccessFixes::test_get_user_by_id_not_found
  C:\Python\Python313\Lib\re\_parser.py:239: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002CA8392C400>
    def __next(self):
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/models/test_user_manager_fixes.py::TestUserManagerDatabaseAccessFixes::test_get_user_by_id_not_found
  C:\Python\Python313\Lib\re\_parser.py:239: ResourceWarning: unclosed database in <sqlite3.Connection object at 0x000002CA8392D990>
    def __next(self):
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=============================== tests coverage ================================
_______________ coverage: platform win32, python 3.13.2-final-0 _______________

Name                                Stmts   Miss  Cover   Missing
-----------------------------------------------------------------
models\__init__.py                      1      0   100%
models\category.py                     45      1    98%   67
models\category_manager.py             70      8    89%   219-229
models\dynamic_content_manager.py     129      7    95%   84, 100, 123, 148, 172, 189, 242
models\dynamic_content_service.py     144    144     0%   7-308
models\keyboard.py                     66     16    76%   38, 40, 47, 49, 67, 70-71, 78, 81-82, 86, 90-94
models\keyboard_manager.py             57      7    88%   60-69, 89, 133, 144-146
models\keystroke.py                    89      5    94%   40, 72-73, 83-84
models\keystroke_manager.py            62      4    94%   65-66, 142-143
models\library.py                      72     72     0%   7-161
models\llm_ngram_service.py           146     86    41%   9-11, 43, 54-59, 100-101, 105-118, 122-140, 144-184, 188-219, 235-236
models\ngram.py                        83      0   100%
models\ngram_analytics_service.py     391    279    29%   69, 75, 216-292, 310-319, 335-394, 419-498, 502-529, 548-655, 686-753, 782-845, 860-1013, 1043-1247, 1283-1346, 1359-1376, 1385-1398
models\ngram_manager.py               126     41    67%   68, 76, 84, 96-97, 173, 193, 244-275, 286-304, 308, 337-344
models\session.py                      88      2    98%   74, 86
models\session_manager.py             110     44    60%   62-75, 108-121, 139-150, 220-231, 254-258, 263-282, 289-335
models\setting.py                      74      3    96%   87, 107, 119
models\setting_manager.py              68     10    85%   43-50, 179-182, 294
models\snippet.py                      87     20    77%   84-94, 129, 153, 157, 161-171
models\snippet_manager.py             179    117    35%   46, 48, 78-82, 90, 118, 135-138, 142-151, 168-198, 215-250, 267-303, 309-321, 342-380, 392
models\user.py                        101     11    89%   64, 70, 82, 87, 95, 101, 104, 124-125, 143, 156
models\user_manager.py                 68      0   100%
-----------------------------------------------------------------
TOTAL                                2256    877    61%
=========================== short test summary info ===========================
FAILED tests/models/test_dynamic_content_manager.py::TestNGramOnlyMode::test_generate_ngram_content
FAILED tests/models/test_dynamic_content_manager.py::TestNGramOnlyMode::test_ngram_content_filters_out_of_scope_chars
FAILED tests/models/test_dynamic_content_manager.py::TestMixedMode::test_mixed_content_has_variety
FAILED tests/models/test_keystroke_manager.py::TestKeystrokeManagerSaveKeystrokes::test_save_keystrokes_success
FAILED tests/models/test_keystroke_manager.py::TestKeystrokeManagerSaveKeystrokes::test_save_keystrokes_database_error
FAILED tests/models/test_keystroke_manager.py::TestKeystrokeManagerSaveKeystrokes::test_save_keystrokes_with_special_characters
FAILED tests/models/test_keystroke_manager.py::TestKeystrokeManagerSaveKeystrokes::test_save_keystrokes_boolean_conversion
FAILED tests/models/test_keystroke_manager.py::TestKeystrokeManagerIntegration::test_full_keystroke_workflow
FAILED tests/models/test_keystroke_manager.py::TestKeystrokeManagerEdgeCases::test_unicode_and_special_characters
FAILED tests/models/test_keystroke_manager.py::TestKeystrokeManagerErrorHandling::test_database_connection_failure
FAILED tests/models/test_keystroke_manager.py::TestKeystrokeManagerErrorHandling::test_partial_save_failure
FAILED tests/models/test_keystroke_manager.py::TestKeystrokeManagerErrorHandling::test_network_timeout_simulation
FAILED tests/models/test_llm_ngram_service.py::test_missing_api_key - Failed:...
FAILED tests/models/test_ngram.py::TestKeystroke::test_keystroke_nfc_single_char
FAILED tests/models/test_ngram_analytics_service.py::TestNGramAnalyticsService::test_dual_insert_creates_records_in_both_tables
FAILED tests/models/test_ngram_analytics_service.py::TestNGramAnalyticsService::test_history_table_accumulates_all_records
FAILED tests/models/test_ngram_analytics_service.py::TestNGramAnalyticsService::test_get_ngram_history_retrieval
FAILED tests/models/test_ngram_analytics_service.py::TestNGramAnalyticsService::test_history_table_schema_compatibility
FAILED tests/models/test_ngram_orchestrator_process_end_of_session.py::test_process_end_of_session_success_path
FAILED tests/models/test_ngram_orchestrator_process_end_of_session.py::test_process_end_of_session_session_save_failure
FAILED tests/models/test_ngram_orchestrator_process_end_of_session.py::test_process_end_of_session_keystrokes_save_failure
FAILED tests/models/test_ngram_orchestrator_process_end_of_session.py::test_process_end_of_session_summarization_failure
ERROR tests/models/test_ngram_analytics_service.py::TestNGramAnalyticsService::test_refresh_speed_summaries_basic
ERROR tests/models/test_ngram_analytics_service_session_methods.py::TestSummarizeSessionNgrams::test_summarize_with_ngram_speed_only[1-1]
ERROR tests/models/test_ngram_analytics_service_session_methods.py::TestSummarizeSessionNgrams::test_summarize_with_ngram_speed_only[3-3]
ERROR tests/models/test_ngram_analytics_service_session_methods.py::TestSummarizeSessionNgrams::test_summarize_with_ngram_errors_only[1-1]
ERROR tests/models/test_ngram_analytics_service_session_methods.py::TestSummarizeSessionNgrams::test_summarize_with_ngram_errors_only[2-2]
ERROR tests/models/test_ngram_analytics_service_session_methods.py::TestSummarizeSessionNgrams::test_summarize_with_speed_and_errors
ERROR tests/models/test_ngram_analytics_service_session_methods.py::TestSummarizeSessionNgrams::test_summarize_with_keystrokes[1-1]
ERROR tests/models/test_ngram_analytics_service_session_methods.py::TestSummarizeSessionNgrams::test_summarize_with_keystrokes[3-3]
ERROR tests/models/test_ngram_analytics_service_session_methods.py::TestSummarizeSessionNgrams::test_no_sessions_missing
ERROR tests/models/test_ngram_analytics_service_session_methods.py::TestSummarizeSessionNgrams::test_sessions_missing_no_data
ERROR tests/models/test_ngram_analytics_service_session_methods.py::TestAddSpeedSummaryForSession::test_single_session_processing
ERROR tests/models/test_ngram_analytics_service_session_methods.py::TestAddSpeedSummaryForSession::test_multiple_ngrams_processing
ERROR tests/models/test_ngram_analytics_service_session_methods.py::TestCatchupSpeedSummary::test_single_session_catchup
ERROR tests/models/test_ngram_analytics_service_session_methods.py::TestCatchupSpeedSummary::test_multiple_sessions_catchup
ERROR tests/models/test_ngram_analytics_service_session_methods.py::TestCatchupSpeedSummary::test_catchup_with_session_errors
ERROR tests/models/test_ngram_analytics_service_session_methods.py::TestIntegrationScenarios::test_full_workflow_integration
ERROR tests/models/test_snippet.py::test_snippet_ascii_name
ERROR tests/models/test_snippet.py::test_snippet_name_length
ERROR tests/models/test_snippet.py::test_snippet_creation_validation[Alpha-Some content-True]
ERROR tests/models/test_snippet.py::test_snippet_creation_validation[-Some content-False]
ERROR tests/models/test_snippet.py::test_snippet_creation_validation[AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA-Content-False]
ERROR tests/models/test_snippet.py::test_snippet_creation_validation[NonAscii\xe9-Content-False]
ERROR tests/models/test_snippet.py::test_snippet_creation_validation[Alpha--False]
ERROR tests/models/test_snippet.py::test_snippet_name_uniqueness[Unique1-Unique2-True]
ERROR tests/models/test_snippet.py::test_snippet_name_uniqueness[DupName-DupName-False]
ERROR tests/models/test_snippet.py::test_snippet_creation_valid
ERROR tests/models/test_snippet.py::test_get_nonexistent_snippet
ERROR tests/models/test_snippet.py::test_list_snippets_empty
ERROR tests/models/test_snippet.py::test_list_snippets_populated
ERROR tests/models/test_snippet.py::test_snippet_edit
ERROR tests/models/test_snippet.py::test_snippet_update
ERROR tests/models/test_snippet.py::test_snippet_update_name_only
ERROR tests/models/test_snippet.py::test_snippet_update_content_only
ERROR tests/models/test_snippet.py::test_snippet_delete
ERROR tests/models/test_snippet.py::test_delete_nonexistent_snippet
ERROR tests/models/test_snippet.py::test_edit_snippet_change_category
ERROR tests/models/test_snippet.py::test_edit_snippet_invalid_category
ERROR tests/models/test_snippet.py::test_snippet_sql_injection
ERROR tests/models/test_snippet.py::test_snippet_sql_injection_in_content
ERROR tests/models/test_snippet.py::test_snippet_long_content
ERROR tests/models/test_snippet.py::test_snippet_content_splitting_boundaries
ERROR tests/models/test_snippet.py::test_update_nonexistent_snippet
ERROR tests/models/test_snippet.py::test_snippet_part_number_sequence
ERROR tests/models/test_snippet.py::test_snippet_operation_handling
ERROR tests/models/test_snippet.py::test_delete_snippet
ERROR tests/models/test_snippet.py::test_create_snippet_with_nonexistent_category
ERROR tests/models/test_snippet.py::test_update_snippet_partial
ERROR tests/models/test_snippet.py::test_update_snippet_no_changes
ERROR tests/models/test_snippet.py::test_get_snippet_by_name
ERROR tests/models/test_snippet.py::test_get_snippet_by_name_nonexistent
ERROR tests/models/test_snippet.py::test_get_snippet_by_name_multiple_categories
ERROR tests/models/test_snippet.py::test_search_snippets
ERROR tests/models/test_snippet.py::test_search_snippets_no_results
ERROR tests/models/test_snippet.py::test_snippet_sql_injection_name_create
ERROR tests/models/test_snippet.py::test_snippet_sql_injection_content_create
ERROR tests/models/test_snippet.py::test_snippet_sql_injection_name_create_with_specific_error
ERROR tests/models/test_snippet.py::test_snippet_sql_injection_content_update
ERROR tests/models/test_snippet.py::test_snippet_sql_injection_name_update
ERROR tests/models/test_snippet.py::test_snippet_deletion_idempotency
ERROR tests/models/test_snippet.py::test_snippet_manager_handles_db_errors_gracefully_on_create
ERROR tests/models/test_snippet.py::test_snippet_manager_handles_db_errors_gracefully_on_get
ERROR tests/models/test_snippet.py::test_snippet_manager_handles_db_errors_gracefully_on_update
ERROR tests/models/test_snippet.py::test_snippet_manager_handles_db_errors_gracefully_on_delete
ERROR tests/models/test_snippet.py::test_snippet_manager_handles_db_errors_gracefully_on_list
ERROR tests/models/test_snippet.py::test_snippet_manager_handles_db_errors_gracefully_on_search
ERROR tests/models/test_snippet.py::test_create_snippet_pydantic_validation_errors
===== 22 failed, 417 passed, 4 skipped, 89 warnings, 66 errors in 37.23s ======
