models\category.py: error: Source file found twice under different module names: "AITypingTrainer.models.category" and "models.category"
models\category.py: note: See https://mypy.readthedocs.io/en/stable/running_mypy.html#mapping-file-paths-to-modules for more info
models\category.py: note: Common resolutions include: a) adding `__init__.py` somewhere, b) using `--explicit-package-bases` or adjusting MYPYPATH
Found 1 error in 1 file (errors prevented further checking)
models\llm_ngram_service.py:69:89: E501 Line too long (92 > 88)
   |
67 |             # Fill in the template with parameters
68 |             prompt: str = prompt_template.format(
69 |                 ngrams=ngram_str, allowed_chars=allowed_chars_str, max_length=max_length * 2
   |                                                                                         ^^^^ E501
70 |             )
71 |         except (FileNotFoundError, IOError) as e:
   |

models\llm_ngram_service.py:83:89: E501 Line too long (105 > 88)
   |
81 |                 {
82 |                     "role": "system",
83 |                     "content": "You are an expert in English lexicography and touch typing instruction.",
   |                                                                                         ^^^^^^^^^^^^^^^^^ E501
84 |                 },
85 |                 {"role": "user", "content": prompt},
   |

models\ngram_manager.py:95:89: E501 Line too long (92 > 88)
   |
94 |         if ngram_sizes is None:
95 |             ngram_sizes = list(range(MIN_NGRAM_SIZE, MAX_NGRAM_SIZE + 1))  # Default to 2-10
   |                                                                                         ^^^^ E501
96 |
97 |         if not ngram_sizes:
   |

models\ngram_manager.py:140:89: E501 Line too long (97 > 88)
    |
138 |                 avg_speed=row["avg_time_ms"] if row["avg_time_ms"] > 0 else 0,
139 |                 total_occurrences=row["occurrences"],
140 |                 last_used=datetime.fromisoformat(row["last_used"]) if row["last_used"] else None,
    |                                                                                         ^^^^^^^^^ E501
141 |                 ngram_score=row["avg_time_ms"] * log(row["occurrences"]),
142 |             )
    |

models\ngram_manager.py:173:89: E501 Line too long (92 > 88)
    |
172 |         if ngram_sizes is None:
173 |             ngram_sizes = list(range(MIN_NGRAM_SIZE, MAX_NGRAM_SIZE + 1))  # Default to 2-10
    |                                                                                         ^^^^ E501
174 |
175 |         if not ngram_sizes:
    |

models\ngram_manager.py:213:89: E501 Line too long (97 > 88)
    |
211 |                 avg_speed=0,  # Not applicable for error count
212 |                 total_occurrences=row["error_count"],
213 |                 last_used=datetime.fromisoformat(row["last_used"]) if row["last_used"] else None,
    |                                                                                         ^^^^^^^^^ E501
214 |                 ngram_score=0,
215 |             )
    |

models\ngram_manager.py:261:89: E501 Line too long (96 > 88)
    |
259 |         # Helper functions to handle different Keystroke field naming conventions
260 |         def get_expected_char(k: object) -> str:
261 |             """Get expected character, supporting both 'expected' and 'expected_char' fields."""
    |                                                                                         ^^^^^^^^ E501
262 |             return getattr(k, "expected", getattr(k, "expected_char", ""))
    |

models\ngram_manager.py:265:89: E501 Line too long (91 > 88)
    |
264 |         def get_actual_char(k: object) -> str:
265 |             """Get actual character, supporting both 'char' and 'keystroke_char' fields."""
    |                                                                                         ^^^ E501
266 |             return getattr(k, "char", getattr(k, "keystroke_char", ""))
    |

models\ngram_manager.py:269:89: E501 Line too long (89 > 88)
    |
268 |         def get_time(k: object) -> Optional[datetime]:
269 |             """Get timestamp, supporting both 'timestamp' and 'keystroke_time' fields."""
    |                                                                                         ^ E501
270 |             return getattr(k, "timestamp", getattr(k, "keystroke_time", None))
    |

models\ngram_manager.py:274:89: E501 Line too long (100 > 88)
    |
272 |         for i in range(len(keystrokes) - ngram_size + 1):
273 |             current_keystroke_sequence = keystrokes[i : i + ngram_size]
274 |             # Filtering: skip n-grams containing space, backspace, newline, or tab in expected chars
    |                                                                                         ^^^^^^^^^^^^ E501
275 |             if any(
276 |                 (
    |

models\ngram_manager.py:294:89: E501 Line too long (123 > 88)
    |
292 |             if ngram_size > 1 and total_time_ms == 0.0:
293 |                 continue
294 |             # Additional filtering: skip if any consecutive keystrokes have the same timestamp (zero duration for any part)
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
295 |             has_zero_part = any(
296 |                 get_time(current_keystroke_sequence[j])
    |

models\ngram_manager.py:304:89: E501 Line too long (94 > 88)
    |
303 |             errors_in_sequence = [
304 |                 get_actual_char(k) != get_expected_char(k) for k in current_keystroke_sequence
    |                                                                                         ^^^^^^ E501
305 |             ]
306 |             err_not_at_end = any(errors_in_sequence[:-1])
    |

models\ngram_manager.py:309:89: E501 Line too long (94 > 88)
    |
307 |             # Clean: all chars correct, no space/backspace, time>0
308 |             is_clean_ngram = all(
309 |                 get_actual_char(k) == get_expected_char(k) for k in current_keystroke_sequence
    |                                                                                         ^^^^^^ E501
310 |             )
311 |             # Error: only last char is error, all others correct, no space/backspace, time>0
    |

models\ngram_manager.py:311:89: E501 Line too long (92 > 88)
    |
309 |                 get_actual_char(k) == get_expected_char(k) for k in current_keystroke_sequence
310 |             )
311 |             # Error: only last char is error, all others correct, no space/backspace, time>0
    |                                                                                         ^^^^ E501
312 |             ngram_is_error_flag = (not any(errors_in_sequence[:-1])) and errors_in_sequence[-1]
313 |             # Valid: not error in non-last, no space/backspace, time>0
    |

models\ngram_manager.py:312:89: E501 Line too long (95 > 88)
    |
310 |             )
311 |             # Error: only last char is error, all others correct, no space/backspace, time>0
312 |             ngram_is_error_flag = (not any(errors_in_sequence[:-1])) and errors_in_sequence[-1]
    |                                                                                         ^^^^^^^ E501
313 |             # Valid: not error in non-last, no space/backspace, time>0
314 |             is_valid_ngram = not err_not_at_end
    |

models\ngram_manager.py:338:89: E501 Line too long (99 > 88)
    |
336 |         Per specification in ngram.md:
337 |         - Clean ngrams go to the session_ngram_speed table
338 |         - Ngrams with error flag (error only in last position) go to the session_ngram_errors table
    |                                                                                         ^^^^^^^^^^^ E501
339 |         - Only ngrams of size 2-10 are saved
    |

models\ngram_manager.py:355:89: E501 Line too long (120 > 88)
    |
353 |         if ngram.size < MIN_NGRAM_SIZE or ngram.size > MAX_NGRAM_SIZE:
354 |             logger.debug(
355 |                 f"Skipping ngram '{ngram.text}' as size {ngram.size} is outside range {MIN_NGRAM_SIZE}-{MAX_NGRAM_SIZE}"
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
356 |             )
357 |             return True  # Not an error, just skipping
    |

models\session.py:129:89: E501 Line too long (91 > 88)
    |
127 |             return cls.model_validate(data)
128 |         except ValueError as e:
129 |             # Re-raise with a more specific message while preserving the original exception
    |                                                                                         ^^^ E501
130 |             raise ValueError(f"Invalid session data: {str(e)}") from e
    |

models\session_manager.py:34:89: E501 Line too long (108 > 88)
   |
32 |             row = self.db_manager.execute(
33 |                 """
34 |                 SELECT session_id, snippet_id, user_id, keyboard_id, snippet_index_start, snippet_index_end,
   |                                                                                         ^^^^^^^^^^^^^^^^^^^^ E501
35 |                        content, start_time, end_time, actual_chars, errors
36 |                 FROM practice_sessions WHERE session_id = ?
   |

models\session_manager.py:76:89: E501 Line too long (96 > 88)
   |
74 |             rows = self.db_manager.execute(
75 |                 (
76 |                     "SELECT session_id, snippet_id, user_id, keyboard_id, snippet_index_start, "
   |                                                                                         ^^^^^^^^ E501
77 |                     "snippet_index_end, content, start_time, end_time, actual_chars, errors "
78 |                     "FROM practice_sessions WHERE snippet_id = ? "
   |

models\session_manager.py:77:89: E501 Line too long (93 > 88)
   |
75 |                 (
76 |                     "SELECT session_id, snippet_id, user_id, keyboard_id, snippet_index_start, "
77 |                     "snippet_index_end, content, start_time, end_time, actual_chars, errors "
   |                                                                                         ^^^^^ E501
78 |                     "FROM practice_sessions WHERE snippet_id = ? "
79 |                     "ORDER BY end_time DESC"
   |

models\session_manager.py:150:89: E501 Line too long (101 > 88)
    |
148 |             """
149 |             INSERT INTO practice_sessions (
150 |                 session_id, snippet_id, user_id, keyboard_id, snippet_index_start, snippet_index_end,
    |                                                                                         ^^^^^^^^^^^^^ E501
151 |                 content, start_time, end_time, actual_chars, errors, ms_per_keystroke
152 |             ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    |

models\setting.py:19:89: E501 Line too long (90 > 88)
   |
18 |     This exception is raised for validation errors such as invalid format
19 |     or if a setting type ID that is not unique for a given entity is attempted to be used.
   |                                                                                         ^^ E501
20 |     """
   |

models\setting.py:46:89: E501 Line too long (93 > 88)
   |
44 |         setting_type_id: 6-character key identifying the setting type.
45 |         setting_value: The setting value stored as text.
46 |         related_entity_id: UUID string identifying the related entity (user, keyboard, etc.).
   |                                                                                         ^^^^^ E501
47 |         updated_at: ISO datetime indicating when the setting was last updated.
48 |     """
   |

models\setting_manager.py:43:89: E501 Line too long (92 > 88)
   |
41 |             SettingValidationError: If the combination is not unique.
42 |         """
43 |         query = "SELECT 1 FROM settings WHERE setting_type_id = ? AND related_entity_id = ?"
   |                                                                                         ^^^^ E501
44 |         params = [setting_type_id, related_entity_id]
45 |         if setting_id is not None:
   |

models\setting_manager.py:63:89: E501 Line too long (109 > 88)
   |
61 |         """
62 |         Retrieve a single setting by type ID and related entity ID.
63 |         If the setting doesn't exist and a default value is provided, returns a new setting with the default.
   |                                                                                         ^^^^^^^^^^^^^^^^^^^^^ E501
64 |
65 |         Args:
   |

models\setting_manager.py:74:89: E501 Line too long (100 > 88)
   |
73 |         Raises:
74 |             SettingNotFound: If no setting exists with the specified IDs and no default is provided.
   |                                                                                         ^^^^^^^^^^^^ E501
75 |         """
76 |         row = self.db_manager.execute(
   |

models\setting_manager.py:78:89: E501 Line too long (92 > 88)
   |
76 |         row = self.db_manager.execute(
77 |             """
78 |             SELECT setting_id, setting_type_id, setting_value, related_entity_id, updated_at
   |                                                                                         ^^^^ E501
79 |             FROM settings
80 |             WHERE setting_type_id = ? AND related_entity_id = ?
   |

models\setting_manager.py:102:89: E501 Line too long (90 > 88)
    |
100 |                 updated_at=datetime.datetime.now().isoformat(),
101 |             )
102 |             # We don't save it to the database yet - that would be handled by save_setting
    |                                                                                         ^^ E501
103 |             return new_setting
104 |         else:
    |

models\setting_manager.py:106:89: E501 Line too long (101 > 88)
    |
104 |         else:
105 |             raise SettingNotFound(
106 |                 f"Setting with type '{setting_type_id}' for entity '{related_entity_id}' not found. "
    |                                                                                         ^^^^^^^^^^^^^ E501
107 |                 "Please ensure the setting exists or provide a default value."
108 |             )
    |

models\setting_manager.py:122:89: E501 Line too long (92 > 88)
    |
120 |         rows = self.db_manager.execute(
121 |             """
122 |             SELECT setting_id, setting_type_id, setting_value, related_entity_id, updated_at
    |                                                                                         ^^^^ E501
123 |             FROM settings
124 |             WHERE related_entity_id = ?
    |

models\setting_manager.py:160:89: E501 Line too long (98 > 88)
    |
158 |         # Check if a setting with this type and entity already exists
159 |         existing_setting_row = self.db_manager.execute(
160 |             "SELECT setting_id FROM settings WHERE setting_type_id = ? AND related_entity_id = ?",
    |                                                                                         ^^^^^^^^^^ E501
161 |             (setting.setting_type_id, setting.related_entity_id)
162 |         ).fetchone()
    |

models\setting_manager.py:195:89: E501 Line too long (99 > 88)
    |
193 |             """
194 |             INSERT INTO settings_history
195 |             (history_id, setting_id, setting_type_id, setting_value, related_entity_id, updated_at)
    |                                                                                         ^^^^^^^^^^^ E501
196 |             VALUES (?, ?, ?, ?, ?, ?)
197 |             """,
    |

models\setting_manager.py:234:89: E501 Line too long (93 > 88)
    |
232 |             """
233 |             UPDATE settings
234 |             SET setting_type_id = ?, setting_value = ?, related_entity_id = ?, updated_at = ?
    |                                                                                         ^^^^^ E501
235 |             WHERE setting_id = ?
236 |             """,
    |

models\setting_manager.py:273:89: E501 Line too long (91 > 88)
    |
271 |             # Now delete the setting
272 |             self.db_manager.execute(
273 |                 "DELETE FROM settings WHERE setting_type_id = ? AND related_entity_id = ?",
    |                                                                                         ^^^ E501
274 |                 (setting_type_id, related_entity_id),
275 |             )
    |

models\snippet.py:33:89: E501 Line too long (93 > 88)
   |
31 |     Args:
32 |         value: The string to check
33 |         is_content: Whether this is snippet content (code/text) that may legitimately contain
   |                                                                                         ^^^^^ E501
34 |                     quotes and equals signs
35 |     """
   |

models\snippet.py:45:89: E501 Line too long (95 > 88)
   |
43 |         ("INSERT INTO", r"INSERT\s+INTO"),
44 |         ("UPDATE SET", r"UPDATE\s+.*\s+SET"),
45 |         ("SELECT FROM", r"SELECT\s+.*\s+FROM"),  # Catches SELECT * FROM, SELECT col FROM, etc.
   |                                                                                         ^^^^^^^ E501
46 |         ("OR 1=1", r"OR\s+1\s*=\s*1"),
47 |         ("' OR '", r"'\s*OR\s*'"),
   |

models\snippet.py:61:89: E501 Line too long (90 > 88)
   |
59 |     for pattern_name, pattern_regex in core_patterns:
60 |         if re.search(pattern_regex, value, re.IGNORECASE):
61 |             raise ValueError(f"Value contains potentially unsafe pattern: {pattern_name}")
   |                                                                                         ^^ E501
62 |
63 |     # Only check extended patterns if not validating content (code/text)
   |

models\snippet.py:67:89: E501 Line too long (89 > 88)
   |
65 |         for pattern in extended_patterns:
66 |             if pattern.lower() in value.lower():
67 |                 raise ValueError(f"Value contains potentially unsafe pattern: {pattern}")
   |                                                                                         ^ E501
68 |
69 |     return value
   |

models\snippet.py:76:89: E501 Line too long (92 > 88)
   |
75 |     Args:
76 |         value: The value to validate, which can be an int or string representation of an int
   |                                                                                         ^^^^ E501
77 |
78 |     Returns:
   |

models\snippet.py:87:89: E501 Line too long (99 > 88)
   |
85 |         if isinstance(value, str):
86 |             # Ensure string is a valid representation of an integer
87 |             if not value.strip().isdigit() and not (value.startswith("-") and value[1:].isdigit()):
   |                                                                                         ^^^^^^^^^^^ E501
88 |                 raise ValueError("String must represent a valid integer")
89 |             return int(value)
   |

models\snippet.py:167:89: E501 Line too long (90 > 88)
    |
166 |             errors = [
167 |                 ErrorWrapper(ValueError(f"Extra field not permitted: {field}"), loc=field)
    |                                                                                         ^^ E501
168 |                 for field in extra
169 |             ]
    |

models\snippet_manager.py:76:89: E501 Line too long (93 > 88)
   |
74 |         if exists:
75 |             self.db.execute(
76 |                 "UPDATE snippets SET category_id = ?, snippet_name = ? WHERE snippet_id = ?",
   |                                                                                         ^^^^^ E501
77 |                 (snippet.category_id, snippet.snippet_name, snippet.snippet_id),
78 |             )
   |

models\snippet_manager.py:79:89: E501 Line too long (100 > 88)
   |
77 |                 (snippet.category_id, snippet.snippet_name, snippet.snippet_id),
78 |             )
79 |             self.db.execute("DELETE FROM snippet_parts WHERE snippet_id = ?", (snippet.snippet_id,))
   |                                                                                         ^^^^^^^^^^^^ E501
80 |         else:
81 |             self.db.execute(
   |

models\snippet_manager.py:82:89: E501 Line too long (96 > 88)
   |
80 |         else:
81 |             self.db.execute(
82 |                 "INSERT INTO snippets (snippet_id, category_id, snippet_name) VALUES (?, ?, ?)",
   |                                                                                         ^^^^^^^^ E501
83 |                 (snippet.snippet_id, snippet.category_id, snippet.snippet_name),
84 |             )
   |

models\snippet_manager.py:91:89: E501 Line too long (108 > 88)
   |
89 |             part_id = str(uuid.uuid4())
90 |             self.db.execute(
91 |                 "INSERT INTO snippet_parts (part_id, snippet_id, part_number, content) VALUES (?, ?, ?, ?)",
   |                                                                                         ^^^^^^^^^^^^^^^^^^^^ E501
92 |                 (part_id, snippet.snippet_id, i, part_content),
93 |             )
   |

models\snippet_manager.py:110:89: E501 Line too long (98 > 88)
    |
108 |         try:
109 |             cursor = self.db.execute(
110 |                 "SELECT snippet_id, category_id, snippet_name FROM snippets WHERE snippet_id = ?",
    |                                                                                         ^^^^^^^^^^ E501
111 |                 (snippet_id,),
112 |             )
    |

models\snippet_manager.py:123:89: E501 Line too long (94 > 88)
    |
122 |             parts_cursor = self.db.execute(
123 |                 "SELECT content FROM snippet_parts WHERE snippet_id = ? ORDER BY part_number",
    |                                                                                         ^^^^^^ E501
124 |                 (snippet_id,),
125 |             )
    |

models\snippet_manager.py:132:89: E501 Line too long (102 > 88)
    |
130 |             # Check for empty content and provide a default if empty
131 |             if not full_content or not full_content.strip():
132 |                 logging.warning(f"Empty content found for snippet ID {snippet_id}, using placeholder")
    |                                                                                         ^^^^^^^^^^^^^^ E501
133 |                 full_content = "[Content was empty. Generate new content to practice.]"
    |

models\snippet_manager.py:143:89: E501 Line too long (93 > 88)
    |
141 |             logging.error(f"Unexpected error retrieving snippet ID {snippet_id}: {e}")
142 |             raise DatabaseError(
143 |                 f"An unexpected error occurred while retrieving snippet ID {snippet_id}: {e}"
    |                                                                                         ^^^^^ E501
144 |             ) from e
    |

models\snippet_manager.py:146:89: E501 Line too long (92 > 88)
    |
144 |             ) from e
145 |
146 |     def get_snippet_by_name(self, snippet_name: str, category_id: str) -> Optional[Snippet]:
    |                                                                                         ^^^^ E501
147 |         """Retrieves a snippet by its name and category UUID.
    |

models\snippet_manager.py:161:89: E501 Line too long (93 > 88)
    |
159 |         try:
160 |             cursor = self.db.execute(
161 |                 "SELECT snippet_id FROM snippets WHERE snippet_name = ? AND category_id = ?",
    |                                                                                         ^^^^^ E501
162 |                 (snippet_name, category_id),
163 |             )
    |

models\snippet_manager.py:215:89: E501 Line too long (98 > 88)
    |
214 |                 parts_cursor = self.db.execute(
215 |                     "SELECT content FROM snippet_parts WHERE snippet_id = ? ORDER BY part_number",
    |                                                                                         ^^^^^^^^^^ E501
216 |                     (current_snippet_id,),
217 |                 )
    |

models\snippet_manager.py:225:89: E501 Line too long (91 > 88)
    |
223 |             return snippets
224 |         except DatabaseError as e:
225 |             logging.error(f"Database error listing snippets for cat ID {category_id}: {e}")
    |                                                                                         ^^^ E501
226 |             raise
227 |         except Exception as e:
    |

models\snippet_manager.py:228:89: E501 Line too long (93 > 88)
    |
226 |             raise
227 |         except Exception as e:
228 |             logging.error(f"Unexpected error listing snippets for cat ID {category_id}: {e}")
    |                                                                                         ^^^^^ E501
229 |             raise DatabaseError(
230 |                 f"An unexpected error occurred while listing snippets for cat ID {category_id}: {e}"
    |

models\snippet_manager.py:230:89: E501 Line too long (100 > 88)
    |
228 |             logging.error(f"Unexpected error listing snippets for cat ID {category_id}: {e}")
229 |             raise DatabaseError(
230 |                 f"An unexpected error occurred while listing snippets for cat ID {category_id}: {e}"
    |                                                                                         ^^^^^^^^^^^^ E501
231 |             ) from e
    |

models\snippet_manager.py:233:89: E501 Line too long (94 > 88)
    |
231 |             ) from e
232 |
233 |     def search_snippets(self, query: str, category_id: Optional[int] = None) -> List[Snippet]:
    |                                                                                         ^^^^^^ E501
234 |         """Searches for snippets by a query string in their name or content.
    |

models\snippet_manager.py:265:89: E501 Line too long (99 > 88)
    |
263 |             rows = cursor.fetchall()
264 |
265 |             snippet_ids = [row[0] if isinstance(row, tuple) else row["snippet_id"] for row in rows]
    |                                                                                         ^^^^^^^^^^^ E501
266 |
267 |             snippets: List[Snippet] = []
    |

models\snippet_manager.py:274:89: E501 Line too long (89 > 88)
    |
272 |             return snippets
273 |         except DatabaseError as e:
274 |             logging.error(f"Database error searching snippets with query '{query}': {e}")
    |                                                                                         ^ E501
275 |             raise
276 |         except Exception as e:
    |

models\snippet_manager.py:277:89: E501 Line too long (91 > 88)
    |
275 |             raise
276 |         except Exception as e:
277 |             logging.error(f"Unexpected error searching snippets with query '{query}': {e}")
    |                                                                                         ^^^ E501
278 |             raise DatabaseError(
279 |                 f"An unexpected error occurred while searching snippets: {e}"
    |

models\snippet_manager.py:296:89: E501 Line too long (89 > 88)
    |
294 |         """
295 |         if not self.get_snippet_by_id(snippet_id):
296 |             raise ValueError(f"Snippet ID {snippet_id} not exist and cannot be deleted.")
    |                                                                                         ^ E501
297 |
298 |         try:
    |

models\snippet_manager.py:299:89: E501 Line too long (92 > 88)
    |
298 |         try:
299 |             self.db.execute("DELETE FROM snippet_parts WHERE snippet_id = ?", (snippet_id,))
    |                                                                                         ^^^^ E501
300 |             self.db.execute("DELETE FROM snippets WHERE snippet_id = ?", (snippet_id,))
301 |             return True
    |

models\snippet_manager.py:312:89: E501 Line too long (91 > 88)
    |
311 |     def snippet_exists(
312 |         self, category_id: str, snippet_name: str, exclude_snippet_id: Optional[str] = None
    |                                                                                         ^^^ E501
313 |     ) -> bool:
314 |         """Checks if a snippet with the given name already exists in the category (by UUID).
    |

models\snippet_manager.py:314:89: E501 Line too long (92 > 88)
    |
312 |         self, category_id: str, snippet_name: str, exclude_snippet_id: Optional[str] = None
313 |     ) -> bool:
314 |         """Checks if a snippet with the given name already exists in the category (by UUID).
    |                                                                                         ^^^^ E501
315 |
316 |         Args:
    |

models\snippet_manager.py:319:89: E501 Line too long (93 > 88)
    |
317 |             category_id: The UUID of the category to check within.
318 |             snippet_name: The name of the snippet to check for.
319 |             exclude_snippet_id: Optional. If provided, exclude this snippet ID from the check
    |                                                                                         ^^^^^ E501
320 |                                 (used when updating an existing snippet's name).
    |

models\snippet_manager.py:351:89: E501 Line too long (92 > 88)
    |
350 |         Returns:
351 |             A list of dictionaries, each with 'snippet_id', 'snippet_name', 'category_name'.
    |                                                                                         ^^^^ E501
352 |
353 |         Raises:
    |

models\snippet_manager.py:371:89: E501 Line too long (90 > 88)
    |
369 |             logging.error(f"Unexpected error retrieving all snippets summary: {e}")
370 |             raise DatabaseError(
371 |                 f"An unexpected error occurred while retrieving all snippets summary: {e}"
    |                                                                                         ^^ E501
372 |             ) from e
    |

models\snippet_manager.py:377:89: E501 Line too long (93 > 88)
    |
375 |         """Lists all snippets in the database with full content."""
376 |         try:
377 |             cursor = self.db.execute("SELECT snippet_id FROM snippets ORDER BY snippet_name")
    |                                                                                         ^^^^^ E501
378 |             rows = cursor.fetchall()
379 |             snippets = []
    |

models\snippet_manager.py:406:89: E501 Line too long (94 > 88)
    |
404 |         """
405 |         if not self.get_snippet_by_id(snippet_id):
406 |             raise ValueError(f"Snippet ID {snippet_id} does not exist and cannot be deleted.")
    |                                                                                         ^^^^^^ E501
407 |
408 |         try:
    |

models\snippet_manager.py:409:89: E501 Line too long (92 > 88)
    |
408 |         try:
409 |             self.db.execute("DELETE FROM snippet_parts WHERE snippet_id = ?", (snippet_id,))
    |                                                                                         ^^^^ E501
410 |             self.db.execute("DELETE FROM snippets WHERE snippet_id = ?", (snippet_id,))
411 |         except DatabaseError as e:
    |

models\snippet_manager.py:417:89: E501 Line too long (91 > 88)
    |
415 |             logging.error(f"Unexpected error deleting snippet ID {snippet_id}: {e}")
416 |             raise DatabaseError(
417 |                 f"An unexpected error occurred while deleting snippet ID {snippet_id}: {e}"
    |                                                                                         ^^^ E501
418 |             ) from e
    |

models\snippet_manager.py:440:89: E501 Line too long (89 > 88)
    |
438 |         )
439 |
440 |     def get_starting_index(self, snippet_id: str, user_id: str, keyboard_id: str) -> int:
    |                                                                                         ^ E501
441 |         """
442 |         Returns the next starting index for a snippet for a given user and keyboard.
    |

models\snippet_manager.py:458:89: E501 Line too long (111 > 88)
    |
456 |                     session_id,
457 |                     snippet_index_end as end_index,
458 |                     rank() over (partition by snippet_id, user_id, keyboard_id order by start_time desc) as rnk
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^ E501
459 |                 from practice_sessions
460 |                 where
    |

models\user.py:76:89: E501 Line too long (95 > 88)
   |
74 |             raise ValueError("Name contains invalid control characters.")
75 |
76 |         # Check for invalid characters (only letters, spaces, hyphens, and apostrophes allowed)
   |                                                                                         ^^^^^^^ E501
77 |         if not all(c.isalpha() or c.isspace() or c in "-.'" for c in stripped_v):
78 |             raise ValueError("Name contains invalid characters.")
   |

models\user.py:82:89: E501 Line too long (93 > 88)
   |
80 |         # Check for leading/trailing spaces, hyphens, or apostrophes
81 |         if stripped_v[0] in " -'" or stripped_v[-1] in " -'":
82 |             raise ValueError("Name cannot start or end with a space, hyphen, or apostrophe.")
   |                                                                                         ^^^^^ E501
83 |
84 |         # Check for consecutive spaces, hyphens, or apostrophes
   |

models\user.py:87:89: E501 Line too long (100 > 88)
   |
85 |         for i in range(len(stripped_v) - 1):
86 |             if stripped_v[i] in " -'" and stripped_v[i + 1] in " -'":
87 |                 raise ValueError("Name cannot contain consecutive spaces, hyphens, or apostrophes.")
   |                                                                                         ^^^^^^^^^^^^ E501
88 |
89 |         return stripped_v
   |

models\user.py:147:89: E501 Line too long (89 > 88)
    |
145 |                 # Check for invalid characters in domain parts
146 |                 if not all(c.isalnum() or c == "-" for c in part):
147 |                     raise ValueError(f"Domain part '{part}' contains invalid characters")
    |                                                                                         ^ E501
148 |
149 |                 # Check for parts starting or ending with a hyphen
    |

models\user.py:161:89: E501 Line too long (90 > 88)
    |
159 |             if len(tld) < 2 or not tld.isalpha():
160 |                 raise ValueError(
161 |                     "Top-level domain must be at least 2 letters and contain only letters"
    |                                                                                         ^^ E501
162 |                 )
    |

models\user_manager.py:28:89: E501 Line too long (100 > 88)
   |
26 |         self.db_manager: DatabaseManager = db_manager
27 |
28 |     def _validate_email_uniqueness(self, email_address: str, user_id: Optional[str] = None) -> None:
   |                                                                                         ^^^^^^^^^^^^ E501
29 |         # Always use lowercase for email comparisons
30 |         email_address_lower = email_address.lower()
   |

models\user_manager.py:37:89: E501 Line too long (89 > 88)
   |
35 |             params.append(user_id)
36 |         if self.db_manager.execute(query, tuple(params)).fetchone():
37 |             raise UserValidationError(f"Email address '{email_address}' must be unique.")
   |                                                                                         ^ E501
38 |
39 |     def get_user_by_id(self, user_id: str) -> User:
   |

models\user_manager.py:41:89: E501 Line too long (94 > 88)
   |
39 |     def get_user_by_id(self, user_id: str) -> User:
40 |         row = self.db_manager.execute(
41 |             "SELECT user_id, first_name, surname, email_address FROM users WHERE user_id = ?",
   |                                                                                         ^^^^^^ E501
42 |             (user_id,),
43 |         ).fetchone()
   |

models\user_manager.py:46:89: E501 Line too long (92 > 88)
   |
44 |         if not row:
45 |             raise UserNotFound(f"User with ID {user_id} not found.")
46 |         return User(user_id=row[0], first_name=row[1], surname=row[2], email_address=row[3])
   |                                                                                         ^^^^ E501
47 |
48 |     def get_user_by_email(self, email_address: str) -> User:
   |

models\user_manager.py:51:89: E501 Line too long (114 > 88)
   |
49 |         # Use case-insensitive comparison for email retrieval
50 |         row = self.db_manager.execute(
51 |             "SELECT user_id, first_name, surname, email_address FROM users WHERE LOWER(email_address) = LOWER(?)",
   |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
52 |             (email_address.lower(),),
53 |         ).fetchone()
   |

models\user_manager.py:56:89: E501 Line too long (92 > 88)
   |
54 |         if not row:
55 |             raise UserNotFound(f"User with email '{email_address}' not found.")
56 |         return User(user_id=row[0], first_name=row[1], surname=row[2], email_address=row[3])
   |                                                                                         ^^^^ E501
57 |
58 |     def list_all_users(self) -> List[User]:
   |

models\user_manager.py:60:89: E501 Line too long (104 > 88)
   |
58 |     def list_all_users(self) -> List[User]:
59 |         rows = self.db_manager.execute(
60 |             "SELECT user_id, first_name, surname, email_address FROM users ORDER BY surname, first_name"
   |                                                                                         ^^^^^^^^^^^^^^^^ E501
61 |         ).fetchall()
62 |         return [
   |

models\user_manager.py:63:89: E501 Line too long (89 > 88)
   |
61 |         ).fetchall()
62 |         return [
63 |             User(user_id=row[0], first_name=row[1], surname=row[2], email_address=row[3])
   |                                                                                         ^ E501
64 |             for row in rows
65 |         ]
   |

models\user_manager.py:82:89: E501 Line too long (98 > 88)
   |
80 |     def __insert_user(self, user: User) -> bool:
81 |         self.db_manager.execute(
82 |             "INSERT INTO users (user_id, first_name, surname, email_address) VALUES (?, ?, ?, ?)",
   |                                                                                         ^^^^^^^^^^ E501
83 |             (user.user_id, user.first_name, user.surname, user.email_address.lower()),
84 |         )
   |

models\user_manager.py:89:89: E501 Line too long (96 > 88)
   |
87 |     def __update_user(self, user: User) -> bool:
88 |         self.db_manager.execute(
89 |             "UPDATE users SET first_name = ?, surname = ?, email_address = ? WHERE user_id = ?",
   |                                                                                         ^^^^^^^^ E501
90 |             (user.first_name, user.surname, user.email_address.lower(), user.user_id),
91 |         )
   |

Found 88 errors.
************* Module AITypingTrainer.models
models\__init__.py:10:4: E0603: Undefined variable name 'NGramManager' in __all__ (undefined-all-variable)
************* Module AITypingTrainer.models.category
models\category.py:57:4: C0116: Missing function or method docstring (missing-function-docstring)
************* Module AITypingTrainer.models.category_manager
models\category_manager.py:8:0: E0401: Unable to import 'db.database_manager' (import-error)
models\category_manager.py:9:0: E0401: Unable to import 'models.category' (import-error)
models\category_manager.py:138:8: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
************* Module AITypingTrainer.models.dynamic_content_manager
models\dynamic_content_manager.py:11:0: E0401: Unable to import 'models.llm_ngram_service' (import-error)
models\dynamic_content_manager.py:33:4: R0913: Too many arguments (6/5) (too-many-arguments)
models\dynamic_content_manager.py:33:4: R0917: Too many positional arguments (6/5) (too-many-positional-arguments)
models\dynamic_content_manager.py:256:8: R1705: Unnecessary "elif" after "return", remove the leading "el" from "elif" (no-else-return)
************* Module AITypingTrainer.models.keyboard
models\keyboard.py:35:4: C0116: Missing function or method docstring (missing-function-docstring)
models\keyboard.py:47:4: C0116: Missing function or method docstring (missing-function-docstring)
models\keyboard.py:60:4: C0116: Missing function or method docstring (missing-function-docstring)
models\keyboard.py:67:4: C0116: Missing function or method docstring (missing-function-docstring)
models\keyboard.py:78:4: C0116: Missing function or method docstring (missing-function-docstring)
models\keyboard.py:87:4: C0116: Missing function or method docstring (missing-function-docstring)
models\keyboard.py:91:4: C0116: Missing function or method docstring (missing-function-docstring)
************* Module AITypingTrainer.models.keyboard_manager
models\keyboard_manager.py:8:0: E0401: Unable to import 'db.database_manager' (import-error)
models\keyboard_manager.py:9:0: E0401: Unable to import 'models.keyboard' (import-error)
models\keyboard_manager.py:12:0: C0115: Missing class docstring (missing-class-docstring)
models\keyboard_manager.py:18:0: C0115: Missing class docstring (missing-class-docstring)
models\keyboard_manager.py:24:0: C0115: Missing class docstring (missing-class-docstring)
models\keyboard_manager.py:41:4: C0116: Missing function or method docstring (missing-function-docstring)
models\keyboard_manager.py:59:4: C0116: Missing function or method docstring (missing-function-docstring)
models\keyboard_manager.py:78:4: C0116: Missing function or method docstring (missing-function-docstring)
models\keyboard_manager.py:82:8: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
models\keyboard_manager.py:128:4: C0116: Missing function or method docstring (missing-function-docstring)
models\keyboard_manager.py:140:4: C0116: Missing function or method docstring (missing-function-docstring)
models\keyboard_manager.py:143:4: C0116: Missing function or method docstring (missing-function-docstring)
************* Module AITypingTrainer.models.keystroke
models\keystroke.py:12:0: E0401: Unable to import 'db.database_manager' (import-error)
models\keystroke.py:89:31: E1101: Instance of 'FieldInfo' has no 'isoformat' member (no-member)
models\keystroke.py:152:15: W0718: Catching too general exception Exception (broad-exception-caught)
************* Module AITypingTrainer.models.keystroke_manager
models\keystroke_manager.py:1:0: C0114: Missing module docstring (missing-module-docstring)
models\keystroke_manager.py:3:0: E0401: Unable to import 'db.database_manager' (import-error)
models\keystroke_manager.py:4:0: E0401: Unable to import 'models.keystroke' (import-error)
models\keystroke_manager.py:54:15: W0718: Catching too general exception Exception (broad-exception-caught)
models\keystroke_manager.py:55:12: C0415: Import outside toplevel (sys) (import-outside-toplevel)
models\keystroke_manager.py:58:12: C0415: Import outside toplevel (traceback) (import-outside-toplevel)
models\keystroke_manager.py:78:15: W0718: Catching too general exception Exception (broad-exception-caught)
models\keystroke_manager.py:79:12: C0415: Import outside toplevel (sys) (import-outside-toplevel)
models\keystroke_manager.py:84:12: C0415: Import outside toplevel (traceback) (import-outside-toplevel)
models\keystroke_manager.py:97:15: W0718: Catching too general exception Exception (broad-exception-caught)
models\keystroke_manager.py:131:15: W0718: Catching too general exception Exception (broad-exception-caught)
models\keystroke_manager.py:128:23: W0718: Catching too general exception Exception (broad-exception-caught)
************* Module AITypingTrainer.models.library
models\library.py:12:0: E0401: Unable to import 'db.database_manager' (import-error)
models\library.py:13:0: E0401: Unable to import 'models.category' (import-error)
models\library.py:14:0: E0401: Unable to import 'models.category_manager' (import-error)
models\library.py:19:0: E0401: Unable to import 'models.snippet' (import-error)
models\library.py:20:0: E0401: Unable to import 'models.snippet_manager' (import-error)
models\library.py:60:4: C0116: Missing function or method docstring (missing-function-docstring)
models\library.py:65:8: W0706: The except handler raises immediately (try-except-raise)
models\library.py:68:4: C0116: Missing function or method docstring (missing-function-docstring)
models\library.py:71:8: W0706: The except handler raises immediately (try-except-raise)
models\library.py:75:4: C0116: Missing function or method docstring (missing-function-docstring)
models\library.py:111:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
models\library.py:114:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
models\library.py:159:15: W0718: Catching too general exception Exception (broad-exception-caught)
models\library.py:160:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
************* Module AITypingTrainer.models.llm_ngram_service
models\llm_ngram_service.py:83:0: C0301: Line too long (105/100) (line-too-long)
models\llm_ngram_service.py:1:0: C0114: Missing module docstring (missing-module-docstring)
models\llm_ngram_service.py:10:0: C0115: Missing class docstring (missing-class-docstring)
models\llm_ngram_service.py:30:4: R0914: Too many local variables (17/15) (too-many-locals)
models\llm_ngram_service.py:54:25: C2801: Unnecessarily calls dunder method __repr__. Use repr built-in function. (unnecessary-dunder-call)
models\llm_ngram_service.py:55:33: C2801: Unnecessarily calls dunder method __repr__. Use repr built-in function. (unnecessary-dunder-call)
models\llm_ngram_service.py:14:0: R0903: Too few public methods (1/2) (too-few-public-methods)
************* Module AITypingTrainer.models.ngram
models\ngram.py:13:0: C0115: Missing class docstring (missing-class-docstring)
models\ngram.py:26:4: C0116: Missing function or method docstring (missing-function-docstring)
models\ngram.py:41:4: C0116: Missing function or method docstring (missing-function-docstring)
models\ngram.py:48:4: C0116: Missing function or method docstring (missing-function-docstring)
************* Module AITypingTrainer.models.ngram_manager
models\ngram_manager.py:294:0: C0301: Line too long (123/100) (line-too-long)
models\ngram_manager.py:355:0: C0301: Line too long (120/100) (line-too-long)
models\ngram_manager.py:22:0: E0401: Unable to import 'models.ngram' (import-error)
models\ngram_manager.py:22:0: C0413: Import "from models.ngram import NGram" should be placed at the top of the module (wrong-import-position)
models\ngram_manager.py:43:0: C0115: Missing class docstring (missing-class-docstring)
models\ngram_manager.py:49:4: C0116: Missing function or method docstring (missing-function-docstring)
models\ngram_manager.py:70:4: R0913: Too many arguments (6/5) (too-many-arguments)
models\ngram_manager.py:70:4: R0917: Too many positional arguments (6/5) (too-many-positional-arguments)
models\ngram_manager.py:148:4: R0913: Too many arguments (6/5) (too-many-arguments)
models\ngram_manager.py:148:4: R0917: Too many positional arguments (6/5) (too-many-positional-arguments)
models\ngram_manager.py:241:4: R0914: Too many local variables (20/15) (too-many-locals)
models\ngram_manager.py:354:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
************* Module AITypingTrainer.models.session
models\session.py:42:4: C0116: Missing function or method docstring (missing-function-docstring)
models\session.py:48:4: C0116: Missing function or method docstring (missing-function-docstring)
models\session.py:54:4: C0116: Missing function or method docstring (missing-function-docstring)
models\session.py:64:4: C0116: Missing function or method docstring (missing-function-docstring)
models\session.py:68:4: C0116: Missing function or method docstring (missing-function-docstring)
models\session.py:72:4: C0116: Missing function or method docstring (missing-function-docstring)
models\session.py:78:4: C0116: Missing function or method docstring (missing-function-docstring)
models\session.py:84:4: C0116: Missing function or method docstring (missing-function-docstring)
models\session.py:90:4: C0116: Missing function or method docstring (missing-function-docstring)
models\session.py:96:4: C0116: Missing function or method docstring (missing-function-docstring)
models\session.py:102:4: C0116: Missing function or method docstring (missing-function-docstring)
models\session.py:107:4: C0116: Missing function or method docstring (missing-function-docstring)
models\session.py:111:4: C0116: Missing function or method docstring (missing-function-docstring)
************* Module AITypingTrainer.models.session_manager
models\session_manager.py:34:0: C0301: Line too long (108/100) (line-too-long)
models\session_manager.py:150:0: C0301: Line too long (101/100) (line-too-long)
models\session_manager.py:1:0: C0114: Missing module docstring (missing-module-docstring)
models\session_manager.py:6:0: E0401: Unable to import 'db.database_manager' (import-error)
models\session_manager.py:7:0: E0401: Unable to import 'db.exceptions' (import-error)
models\session_manager.py:16:0: E0401: Unable to import 'models.session' (import-error)
models\session_manager.py:30:4: C0116: Missing function or method docstring (missing-function-docstring)
models\session_manager.py:69:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
models\session_manager.py:72:4: C0116: Missing function or method docstring (missing-function-docstring)
models\session_manager.py:113:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
models\session_manager.py:142:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
models\session_manager.py:223:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
models\session_manager.py:232:8: E0401: Unable to import 'models.keystroke_manager' (import-error)
models\session_manager.py:232:8: C0415: Import outside toplevel (models.keystroke_manager.KeystrokeManager) (import-outside-toplevel)
models\session_manager.py:233:8: E0401: Unable to import 'models.ngram_manager' (import-error)
models\session_manager.py:233:8: C0415: Import outside toplevel (models.ngram_manager.NGramManager) (import-outside-toplevel)
models\session_manager.py:254:15: W0718: Catching too general exception Exception (broad-exception-caught)
models\session_manager.py:245:12: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
models\session_manager.py:249:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
models\session_manager.py:265:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
models\session_manager.py:281:8: E0401: Unable to import 'models.snippet_manager' (import-error)
models\session_manager.py:281:8: C0415: Import outside toplevel (models.snippet_manager.SnippetManager) (import-outside-toplevel)
************* Module AITypingTrainer.models.setting_manager
models\setting_manager.py:63:0: C0301: Line too long (109/100) (line-too-long)
models\setting_manager.py:106:0: C0301: Line too long (101/100) (line-too-long)
models\setting_manager.py:10:0: E0401: Unable to import 'db.database_manager' (import-error)
models\setting_manager.py:11:0: E0401: Unable to import 'models.setting' (import-error)
models\setting_manager.py:85:8: R1705: Unnecessary "elif" after "return", remove the leading "el" from "elif" (no-else-return)
models\setting_manager.py:164:8: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
************* Module AITypingTrainer.models.snippet
models\snippet.py:142:0: C0325: Unnecessary parens after 'not' keyword (superfluous-parens)
models\snippet.py:152:0: C0325: Unnecessary parens after 'not' keyword (superfluous-parens)
models\snippet.py:36:4: C0415: Import outside toplevel (re) (import-outside-toplevel)
models\snippet.py:120:4: C0116: Missing function or method docstring (missing-function-docstring)
models\snippet.py:127:4: C0116: Missing function or method docstring (missing-function-docstring)
models\snippet.py:138:4: C0116: Missing function or method docstring (missing-function-docstring)
models\snippet.py:148:4: C0116: Missing function or method docstring (missing-function-docstring)
models\snippet.py:156:4: C0116: Missing function or method docstring (missing-function-docstring)
models\snippet.py:160:4: C0116: Missing function or method docstring (missing-function-docstring)
models\snippet.py:164:12: C0415: Import outside toplevel (pydantic.ErrorWrapper, pydantic.ValidationError) (import-outside-toplevel)
models\snippet.py:164:12: E0611: No name 'ErrorWrapper' in module 'pydantic' (no-name-in-module)
************* Module AITypingTrainer.models.snippet_manager
models\snippet_manager.py:91:0: C0301: Line too long (108/100) (line-too-long)
models\snippet_manager.py:129:0: C0303: Trailing whitespace (trailing-whitespace)
models\snippet_manager.py:132:0: C0301: Line too long (102/100) (line-too-long)
models\snippet_manager.py:134:0: C0303: Trailing whitespace (trailing-whitespace)
models\snippet_manager.py:458:0: C0301: Line too long (111/100) (line-too-long)
models\snippet_manager.py:11:0: E0401: Unable to import 'db.database_manager' (import-error)
models\snippet_manager.py:12:0: E0401: Unable to import 'db.exceptions' (import-error)
models\snippet_manager.py:13:0: E0401: Unable to import 'models.snippet' (import-error)
models\snippet_manager.py:132:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
models\snippet_manager.py:138:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
models\snippet_manager.py:141:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
models\snippet_manager.py:171:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
models\snippet_manager.py:177:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
models\snippet_manager.py:225:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
models\snippet_manager.py:228:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
models\snippet_manager.py:274:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
models\snippet_manager.py:277:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
models\snippet_manager.py:303:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
models\snippet_manager.py:306:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
models\snippet_manager.py:338:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
models\snippet_manager.py:341:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
models\snippet_manager.py:366:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
models\snippet_manager.py:369:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
models\snippet_manager.py:387:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
models\snippet_manager.py:390:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
models\snippet_manager.py:412:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
models\snippet_manager.py:415:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
models\snippet_manager.py:426:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
models\snippet_manager.py:429:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
models\snippet_manager.py:436:15: E1101: Instance of 'SnippetManager' has no 'create_snippet' member (no-member)
************* Module AITypingTrainer.models.user
models\user.py:11:0: E0401: Unable to import 'email_validator' (import-error)
models\user.py:93:4: C0116: Missing function or method docstring (missing-function-docstring)
models\user.py:93:4: R0912: Too many branches (15/12) (too-many-branches)
models\user.py:183:4: C0116: Missing function or method docstring (missing-function-docstring)
models\user.py:192:4: C0116: Missing function or method docstring (missing-function-docstring)
models\user.py:201:4: C0116: Missing function or method docstring (missing-function-docstring)
models\user.py:205:4: C0116: Missing function or method docstring (missing-function-docstring)
************* Module AITypingTrainer.models.user_manager
models\user_manager.py:51:0: C0301: Line too long (114/100) (line-too-long)
models\user_manager.py:60:0: C0301: Line too long (104/100) (line-too-long)
models\user_manager.py:8:0: E0401: Unable to import 'db.database_manager' (import-error)
models\user_manager.py:9:0: E0401: Unable to import 'models.user' (import-error)
models\user_manager.py:12:0: C0115: Missing class docstring (missing-class-docstring)
models\user_manager.py:18:0: C0115: Missing class docstring (missing-class-docstring)
models\user_manager.py:24:0: C0115: Missing class docstring (missing-class-docstring)
models\user_manager.py:39:4: C0116: Missing function or method docstring (missing-function-docstring)
models\user_manager.py:48:4: C0116: Missing function or method docstring (missing-function-docstring)
models\user_manager.py:58:4: C0116: Missing function or method docstring (missing-function-docstring)
models\user_manager.py:67:4: C0116: Missing function or method docstring (missing-function-docstring)
models\user_manager.py:69:8: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
models\user_manager.py:94:4: C0116: Missing function or method docstring (missing-function-docstring)
models\user_manager.py:106:4: C0116: Missing function or method docstring (missing-function-docstring)
models\user_manager.py:109:4: C0116: Missing function or method docstring (missing-function-docstring)
models\user_manager.py:1:0: R0801: Similar lines in 2 files
==AITypingTrainer.models.keyboard:[78:96]
==AITypingTrainer.models.user:[192:210]
        if not v:
            raise ValueError("user_id must not be empty")
        try:
            UUID(v)
        except Exception as err:
            raise ValueError("user_id must be a valid UUID string") from err
        return v

    def to_dict(self) -> Dict[str, Any]:
        return self.dict()

    @classmethod
    def from_dict(cls, d: Dict[str, Any]) -> "User":
        allowed = set(cls.model_fields.keys())
        extra = set(d.keys()) - allowed
        if extra:
            raise ValueError(f"Extra fields not permitted: {extra}")
        return cls(**d) (duplicate-code)
models\user_manager.py:1:0: R0801: Similar lines in 2 files
==AITypingTrainer.models.setting:[146:151]
==AITypingTrainer.models.user:[205:210]
        allowed = set(cls.model_fields.keys())
        extra = set(d.keys()) - allowed
        if extra:
            raise ValueError(f"Extra fields not permitted: {extra}")
        return cls(**d) (duplicate-code)
models\user_manager.py:1:0: R0801: Similar lines in 2 files
==AITypingTrainer.models.category:[95:100]
==AITypingTrainer.models.keyboard:[91:96]
        allowed = set(cls.model_fields.keys())
        extra = set(d.keys()) - allowed
        if extra:
            raise ValueError(f"Extra fields not permitted: {extra}")
        return cls(**d) (duplicate-code)

------------------------------------------------------------------
Your code has been rated at 7.83/10 (previous run: 7.82/10, +0.00)

============================= test session starts =============================
platform win32 -- Python 3.13.2, pytest-8.3.5, pluggy-1.5.0
PySide6 6.9.1 -- Qt runtime 6.9.1 -- Qt compiled 6.9.1
rootdir: D:\SeanDevLocal\AITypingTrainer
configfile: pytest.ini
plugins: anyio-4.9.0, mock-3.14.0, qt-4.4.0, timeout-2.4.0
collected 516 items / 3 errors

=================================== ERRORS ====================================
________ ERROR collecting tests/desktop_ui/test_users_and_keyboards.py ________
ImportError while importing test module 'D:\SeanDevLocal\AITypingTrainer\tests\desktop_ui\test_users_and_keyboards.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
C:\Python\Python313\Lib\importlib\__init__.py:88: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
tests\desktop_ui\test_users_and_keyboards.py:14: in <module>
    from desktop_ui.users_and_keyboards import UsersAndKeyboards
desktop_ui\users_and_keyboards.py:29: in <module>
    from models.user import User
models\user.py:11: in <module>
    from email_validator import EmailNotValidError, validate_email
E   ModuleNotFoundError: No module named 'email_validator'
_________________ ERROR collecting tests/models/test_user.py __________________
ImportError while importing test module 'D:\SeanDevLocal\AITypingTrainer\tests\models\test_user.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
C:\Python\Python313\Lib\importlib\__init__.py:88: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
tests\models\test_user.py:7: in <module>
    from models.user import User
models\user.py:11: in <module>
    from email_validator import EmailNotValidError, validate_email
E   ModuleNotFoundError: No module named 'email_validator'
_____________ ERROR collecting tests/models/test_user_manager.py ______________
ImportError while importing test module 'D:\SeanDevLocal\AITypingTrainer\tests\models\test_user_manager.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
C:\Python\Python313\Lib\importlib\__init__.py:88: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
tests\models\test_user_manager.py:9: in <module>
    from models.user import User
models\user.py:11: in <module>
    from email_validator import EmailNotValidError, validate_email
E   ModuleNotFoundError: No module named 'email_validator'
=========================== short test summary info ===========================
ERROR tests/desktop_ui/test_users_and_keyboards.py
ERROR tests/models/test_user.py
ERROR tests/models/test_user_manager.py
!!!!!!!!!!!!!!!!!!! Interrupted: 3 errors during collection !!!!!!!!!!!!!!!!!!!
============================== 3 errors in 1.81s ==============================
