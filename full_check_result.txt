models\category.py: error: Source file found twice under different module names: "AITypingTrainer.models.category" and "models.category"
models\category.py: note: See https://mypy.readthedocs.io/en/stable/running_mypy.html#mapping-file-paths-to-modules for more info
models\category.py: note: Common resolutions include: a) adding `__init__.py` somewhere, b) using `--explicit-package-bases` or adjusting MYPYPATH
Found 1 error in 1 file (errors prevented further checking)
services\library_service.py:1: error: Cannot find implementation or library stub for module named "sqlalchemy"  [import-not-found]
services\library_service.py:9: error: Cannot find implementation or library stub for module named "sqlalchemy.orm"  [import-not-found]
services\library_service.py:9: note: See https://mypy.readthedocs.io/en/stable/running_mypy.html#missing-imports
services\library_service.py:23: error: Variable "AITypingTrainer.services.library_service.Base" is not valid as a type  [valid-type]
services\library_service.py:23: note: See https://mypy.readthedocs.io/en/stable/common_issues.html#variables-vs-type-aliases
services\library_service.py:23: error: Invalid base class "Base"  [misc]
services\library_service.py:32: error: Variable "AITypingTrainer.services.library_service.Base" is not valid as a type  [valid-type]
services\library_service.py:32: note: See https://mypy.readthedocs.io/en/stable/common_issues.html#variables-vs-type-aliases
services\library_service.py:32: error: Invalid base class "Base"  [misc]
services\library_service.py:47: error: Function is missing a type annotation  [no-untyped-def]
services\library_service.py:51: error: Function is missing a type annotation  [no-untyped-def]
services\library_service.py:60: error: Function is missing a return type annotation  [no-untyped-def]
services\library_service.py:63: error: Function is missing a type annotation  [no-untyped-def]
services\library_service.py:78: error: Function is missing a type annotation  [no-untyped-def]
services\library_service.py:85: error: Function is missing a type annotation  [no-untyped-def]
services\library_service.py:100: error: Function is missing a type annotation  [no-untyped-def]
services\library_service.py:103: error: Function is missing a type annotation  [no-untyped-def]
services\library_service.py:129: error: Function is missing a type annotation  [no-untyped-def]
models\snippet.py:97: error: Class cannot subclass "BaseModel" (has type "Any")  [misc]
models\snippet.py:118: error: Untyped decorator makes function "ensure_snippet_id" untyped  [misc]
models\snippet.py:120: error: Missing type parameters for generic type "dict"  [type-arg]
models\snippet.py:125: error: Untyped decorator makes function "validate_ids" untyped  [misc]
models\snippet.py:136: error: Untyped decorator makes function "validate_snippet_name" untyped  [misc]
models\snippet.py:146: error: Untyped decorator makes function "validate_content" untyped  [misc]
models\snippet.py:157: error: Returning Any from function declared to return "dict[str, Any]"  [no-any-return]
models\ngram.py:13: error: Class cannot subclass "BaseModel" (has type "Any")  [misc]
models\ngram.py:45: error: Returning Any from function declared to return "dict[str, Any]"  [no-any-return]
models\session.py:17: error: Class cannot subclass "BaseModel" (has type "Any")  [misc]
models\session.py:40: error: Untyped decorator makes function "validate_uuid" untyped  [misc]
models\session.py:46: error: Untyped decorator makes function "validate_indices" untyped  [misc]
models\session.py:53: error: Untyped decorator makes function "check_indices_and_times" untyped  [misc]
models\session.py:108: error: Returning Any from function declared to return "dict[str, Any]"  [no-any-return]
models\session.py:127: error: Returning Any from function declared to return "Session"  [no-any-return]
db\database_manager.py:17: error: Cannot find implementation or library stub for module named "boto3"  [import-not-found]
db\database_manager.py:18: error: Library stubs not installed for "psycopg2"  [import-untyped]
db\database_manager.py:19: error: Library stubs not installed for "psycopg2.extensions"  [import-untyped]
db\database_manager.py:19: note: Hint: "python3 -m pip install types-psycopg2"
db\database_manager.py:19: note: (or run "mypy --install-types" to install all missing stub packages)
db\database_manager.py:26: error: Name "PostgresConnection" already defined (possibly by an import)  [no-redef]
db\database_manager.py:26: note: Error code "no-redef" not covered by "type: ignore" comment
db\database_manager.py:26: error: Unused "type: ignore" comment  [unused-ignore]
models\keystroke.py:17: error: Class cannot subclass "BaseModel" (has type "Any")  [misc]
models\ngram_manager.py:42: error: Class cannot subclass "BaseModel" (has type "Any")  [misc]
models\snippet_manager.py:438: error: Returning Any from function declared to return "Snippet"  [no-any-return]
models\snippet_manager.py:438: error: "SnippetManager" has no attribute "create_snippet"; maybe "delete_snippet", "create_dynamic_snippet", or "save_snippet"?  [attr-defined]
models\snippet_manager.py:479: error: Returning Any from function declared to return "int"  [no-any-return]
services\database_viewer_service.py:37: error: Class cannot subclass "BaseModel" (has type "Any")  [misc]
services\database_viewer_service.py:291: error: Incompatible types in assignment (expression has type "TextIO", variable has type "TextIOWrapper[_WrappedBuffer]")  [assignment]
models\keystroke_manager.py:127: error: Incompatible return value type (got "str", expected "int")  [return-value]
models\session_manager.py:212: error: Returning Any from function declared to return "bool"  [no-any-return]
Found 44 errors in 11 files (checked 4 source files)
helpers\error_utils.py:11: error: Cannot find implementation or library stub for module named "PyQt5.QtWidgets"  [import-not-found]
helpers\error_utils.py:11: note: See https://mypy.readthedocs.io/en/stable/running_mypy.html#missing-imports
helpers\error_utils.py:17: error: Function is missing a type annotation for one or more arguments  [no-untyped-def]
Found 2 errors in 1 file (checked 2 source files)
desktop_ui\dialogs\keyboard_dialog.py:7: error: Cannot find implementation or library stub for module named "PySide6.QtCore"  [import-not-found]
desktop_ui\dialogs\keyboard_dialog.py:7: note: See https://mypy.readthedocs.io/en/stable/running_mypy.html#missing-imports
desktop_ui\dialogs\keyboard_dialog.py:8: error: Cannot find implementation or library stub for module named "PySide6.QtWidgets"  [import-not-found]
desktop_ui\dialogs\user_dialog.py:7: error: Cannot find implementation or library stub for module named "PySide6.QtWidgets"  [import-not-found]
desktop_ui\api_key_dialog.py:22: error: Cannot find implementation or library stub for module named "PySide6.QtCore"  [import-not-found]
desktop_ui\api_key_dialog.py:23: error: Cannot find implementation or library stub for module named "PySide6.QtWidgets"  [import-not-found]
desktop_ui\api_key_dialog.py:35: error: Cannot find implementation or library stub for module named "cryptography.fernet"  [import-not-found]
desktop_ui\api_key_dialog.py:36: error: Cannot find implementation or library stub for module named "cryptography.hazmat.primitives"  [import-not-found]
desktop_ui\api_key_dialog.py:37: error: Cannot find implementation or library stub for module named "cryptography.hazmat.primitives.kdf.pbkdf2"  [import-not-found]
desktop_ui\api_key_dialog.py:142: error: Library stubs not installed for "requests"  [import-untyped]
desktop_ui\api_key_dialog.py:143: error: Library stubs not installed for "requests.exceptions"  [import-untyped]
desktop_ui\api_key_dialog.py:143: note: Hint: "python3 -m pip install types-requests"
desktop_ui\api_key_dialog.py:143: note: (or run "mypy --install-types" to install all missing stub packages)
desktop_ui\api_server_manager.py:14: error: Library stubs not installed for "requests"  [import-untyped]
desktop_ui\category_model_tester.py:21: error: Cannot find implementation or library stub for module named "PySide6.QtWidgets"  [import-not-found]
desktop_ui\db_viewer_dialog.py:9: error: Cannot find implementation or library stub for module named "PySide6"  [import-not-found]
desktop_ui\db_viewer_dialog.py:10: error: Cannot find implementation or library stub for module named "PySide6.QtWidgets"  [import-not-found]
desktop_ui\drill_config.py:14: error: Cannot find implementation or library stub for module named "PySide6.QtWidgets"  [import-not-found]
desktop_ui\typing_drill.py: error: Source file found twice under different module names: "AITypingTrainer.desktop_ui.typing_drill" and "desktop_ui.typing_drill"
desktop_ui\typing_drill.py: note: See https://mypy.readthedocs.io/en/stable/running_mypy.html#mapping-file-paths-to-modules for more info
desktop_ui\typing_drill.py: note: Common resolutions include: a) adding `__init__.py` somewhere, b) using `--explicit-package-bases` or adjusting MYPYPATH
Found 16 errors in 8 files (errors prevented further checking)
models\snippet.py:97: error: Class cannot subclass "BaseModel" (has type "Any")  [misc]
models\snippet.py:118: error: Untyped decorator makes function "ensure_snippet_id" untyped  [misc]
models\snippet.py:120: error: Missing type parameters for generic type "dict"  [type-arg]
models\snippet.py:125: error: Untyped decorator makes function "validate_ids" untyped  [misc]
models\snippet.py:136: error: Untyped decorator makes function "validate_snippet_name" untyped  [misc]
models\snippet.py:146: error: Untyped decorator makes function "validate_content" untyped  [misc]
models\snippet.py:157: error: Returning Any from function declared to return "dict[str, Any]"  [no-any-return]
models\category.py:14: error: Class cannot subclass "BaseModel" (has type "Any")  [misc]
models\category.py:30: error: Untyped decorator makes function "validate_name_format" untyped  [misc]
models\category.py:55: error: Untyped decorator makes function "ensure_category_id" untyped  [misc]
models\category.py:57: error: Missing type parameters for generic type "dict"  [type-arg]
models\category.py:62: error: Untyped decorator makes function "validate_category_id" untyped  [misc]
models\ngram.py:13: error: Class cannot subclass "BaseModel" (has type "Any")  [misc]
models\ngram.py:45: error: Returning Any from function declared to return "dict[str, Any]"  [no-any-return]
models\session.py:17: error: Class cannot subclass "BaseModel" (has type "Any")  [misc]
models\session.py:40: error: Untyped decorator makes function "validate_uuid" untyped  [misc]
models\session.py:46: error: Untyped decorator makes function "validate_indices" untyped  [misc]
models\session.py:53: error: Untyped decorator makes function "check_indices_and_times" untyped  [misc]
models\session.py:108: error: Returning Any from function declared to return "dict[str, Any]"  [no-any-return]
models\session.py:127: error: Returning Any from function declared to return "Session"  [no-any-return]
api\category_graphql.py:13: error: Cannot find implementation or library stub for module named "graphene"  [import-not-found]
api\category_graphql.py:14: error: Cannot find implementation or library stub for module named "flask"  [import-not-found]
api\category_graphql.py:18: error: Module "models.category" has no attribute "CategoryManager"  [attr-defined]
api\category_graphql.py:18: error: Module "models.category" has no attribute "CategoryNotFound"  [attr-defined]
api\category_graphql.py:18: error: Module "models.category" has no attribute "CategoryValidationError"  [attr-defined]
api\category_graphql.py:55: error: Returning Any from function declared to return "list[Category]"  [no-any-return]
api\category_graphql.py:69: error: Returning Any from function declared to return "Category | None"  [no-any-return]
api\category_graphql.py:198: error: Untyped decorator makes function "graphql_api" untyped  [misc]
db\database_manager.py:17: error: Cannot find implementation or library stub for module named "boto3"  [import-not-found]
db\database_manager.py:18: error: Library stubs not installed for "psycopg2"  [import-untyped]
db\database_manager.py:19: error: Library stubs not installed for "psycopg2.extensions"  [import-untyped]
db\database_manager.py:19: note: Hint: "python3 -m pip install types-psycopg2"
db\database_manager.py:19: note: (or run "mypy --install-types" to install all missing stub packages)
db\database_manager.py:26: error: Name "PostgresConnection" already defined (possibly by an import)  [no-redef]
db\database_manager.py:26: note: Error code "no-redef" not covered by "type: ignore" comment
db\database_manager.py:26: error: Unused "type: ignore" comment  [unused-ignore]
api\session_api.py:1: error: Cannot find implementation or library stub for module named "flask"  [import-not-found]
api\session_api.py:9: error: Class cannot subclass "BaseModel" (has type "Any")  [misc]
api\session_api.py:16: error: Function is missing a return type annotation  [no-untyped-def]
api\session_api.py:34: error: Function is missing a return type annotation  [no-untyped-def]
api\session_api.py:48: error: Function is missing a type annotation  [no-untyped-def]
api\session_api.py:56: error: Function is missing a type annotation  [no-untyped-def]
models\ngram_manager.py:42: error: Class cannot subclass "BaseModel" (has type "Any")  [misc]
models\snippet_manager.py:438: error: Returning Any from function declared to return "Snippet"  [no-any-return]
models\snippet_manager.py:438: error: "SnippetManager" has no attribute "create_snippet"; maybe "delete_snippet", "create_dynamic_snippet", or "save_snippet"?  [attr-defined]
models\snippet_manager.py:479: error: Returning Any from function declared to return "int"  [no-any-return]
models\category_manager.py:201: error: Returning Any from function declared to return "bool"  [no-any-return]
models\keystroke.py:17: error: Class cannot subclass "BaseModel" (has type "Any")  [misc]
services\database_viewer_service.py:37: error: Class cannot subclass "BaseModel" (has type "Any")  [misc]
services\database_viewer_service.py:291: error: Incompatible types in assignment (expression has type "TextIO", variable has type "TextIOWrapper[_WrappedBuffer]")  [assignment]
api\unified_graphql.py:21: error: Cannot find implementation or library stub for module named "graphene"  [import-not-found]
api\unified_graphql.py:22: error: Cannot find implementation or library stub for module named "flask"  [import-not-found]
api\unified_graphql.py:26: error: Module "models.category" has no attribute "CategoryManager"  [attr-defined]
api\unified_graphql.py:26: error: Module "models.category" has no attribute "CategoryNotFound"  [attr-defined]
api\unified_graphql.py:26: error: Module "models.category" has no attribute "CategoryValidationError"  [attr-defined]
api\unified_graphql.py:34: error: Module "models.snippet" has no attribute "SnippetManager"  [attr-defined]
api\unified_graphql.py:34: error: Module "models.snippet" has no attribute "SnippetModel"  [attr-defined]
api\unified_graphql.py:66: error: Returning Any from function declared to return "DatabaseManager"  [no-any-return]
api\unified_graphql.py:68: error: Returning Any from function declared to return "DatabaseManager"  [no-any-return]
api\unified_graphql.py:365: error: Returning Any from function declared to return "list[Any]"  [no-any-return]
api\unified_graphql.py:379: error: Returning Any from function declared to return "list[Category]"  [no-any-return]
api\unified_graphql.py:386: error: Returning Any from function declared to return "Category | None"  [no-any-return]
api\unified_graphql.py:416: error: Untyped decorator makes function "graphql_api" untyped  [misc]
api\snippet_api.py:9: error: Cannot find implementation or library stub for module named "flask"  [import-not-found]
api\snippet_api.py:12: error: Cannot find implementation or library stub for module named "models.practice_generator"  [import-not-found]
api\snippet_api.py:13: error: Module "models.snippet" has no attribute "SnippetManager"  [attr-defined]
api\snippet_api.py:13: error: Module "models.snippet" has no attribute "SnippetModel"  [attr-defined]
api\snippet_api.py:18: error: Untyped decorator makes function "get_snippet" untyped  [misc]
api\snippet_api.py:19: error: Function is missing a return type annotation  [no-untyped-def]
api\snippet_api.py:50: error: Function is missing a return type annotation  [no-untyped-def]
api\snippet_api.py:87: error: Function is missing a return type annotation  [no-untyped-def]
api\snippet_api.py:107: error: Function is missing a return type annotation  [no-untyped-def]
api\snippet_api.py:199: error: Untyped decorator makes function "edit_snippet" untyped  [misc]
api\snippet_api.py:200: error: Function is missing a return type annotation  [no-untyped-def]
api\snippet_api.py:252: error: Untyped decorator makes function "delete_snippet" untyped  [misc]
api\snippet_api.py:253: error: Function is missing a return type annotation  [no-untyped-def]
api\category_api.py:3: error: Cannot find implementation or library stub for module named "flask"  [import-not-found]
api\category_api.py:3: note: See https://mypy.readthedocs.io/en/stable/running_mypy.html#missing-imports
api\category_api.py:7: error: Module "models.category" has no attribute "CategoryManager"  [attr-defined]
api\category_api.py:10: error: Class cannot subclass "BaseModel" (has type "Any")  [misc]
api\category_api.py:14: error: Class cannot subclass "BaseModel" (has type "Any")  [misc]
api\category_api.py:21: error: Untyped decorator makes function "list_categories_api" untyped  [misc]
api\category_api.py:23: error: "type[DatabaseManager]" has no attribute "get_instance"  [attr-defined]
api\category_api.py:27: error: Untyped decorator makes function "add_category_api" untyped  [misc]
api\category_api.py:32: error: "type[DatabaseManager]" has no attribute "get_instance"  [attr-defined]
api\category_api.py:42: error: Untyped decorator makes function "delete_category_api" untyped  [misc]
api\category_api.py:45: error: "type[DatabaseManager]" has no attribute "get_instance"  [attr-defined]
api\category_api.py:56: error: Untyped decorator makes function "rename_category_api" untyped  [misc]
api\category_api.py:61: error: "type[DatabaseManager]" has no attribute "get_instance"  [attr-defined]
models\keystroke_manager.py:127: error: Incompatible return value type (got "str", expected "int")  [return-value]
api\keystroke_api.py:1: error: Cannot find implementation or library stub for module named "flask"  [import-not-found]
api\keystroke_api.py:11: error: Class cannot subclass "BaseModel" (has type "Any")  [misc]
api\keystroke_api.py:22: error: Function is missing a return type annotation  [no-untyped-def]
api\keystroke_api.py:71: error: Function is missing a return type annotation  [no-untyped-def]
api\dbviewer_api.py:13: error: Cannot find implementation or library stub for module named "flask"  [import-not-found]
api\dbviewer_api.py:34: error: Function is missing a return type annotation  [no-untyped-def]
api\dbviewer_api.py:52: error: Function is missing a return type annotation  [no-untyped-def]
api\dbviewer_api.py:101: error: Function is missing a return type annotation  [no-untyped-def]
models\session_manager.py:212: error: Returning Any from function declared to return "bool"  [no-any-return]
api\run_library_api.py:8: error: Cannot find implementation or library stub for module named "flask"  [import-not-found]
api\run_library_api.py:14: error: Cannot find implementation or library stub for module named "library_graphql"  [import-not-found]
api\run_library_api.py:26: error: Function is missing a return type annotation  [no-untyped-def]
api\run_library_api.py:26: note: Use "-> None" if function does not return a value
api\run_library_api.py:59: error: Call to untyped function "init_db" in typed context  [no-untyped-call]
api\library_graphql.py:6: error: Cannot find implementation or library stub for module named "graphene"  [import-not-found]
api\library_graphql.py:7: error: Cannot find implementation or library stub for module named "flask"  [import-not-found]
api\library_graphql.py:18: error: Function is missing a return type annotation  [no-untyped-def]
api\library_graphql.py:26: error: Class cannot subclass "ObjectType" (has type "Any")  [misc]
api\library_graphql.py:31: error: Class cannot subclass "ObjectType" (has type "Any")  [misc]
api\library_graphql.py:38: error: Class cannot subclass "ObjectType" (has type "Any")  [misc]
api\library_graphql.py:46: error: Class cannot subclass "ObjectType" (has type "Any")  [misc]
api\library_graphql.py:52: error: Function is missing a type annotation  [no-untyped-def]
api\library_graphql.py:53: error: Call to untyped function "get_library_manager" in typed context  [no-untyped-call]
api\library_graphql.py:56: error: Function is missing a type annotation  [no-untyped-def]
api\library_graphql.py:57: error: Call to untyped function "get_library_manager" in typed context  [no-untyped-call]
api\library_graphql.py:60: error: Function is missing a type annotation  [no-untyped-def]
api\library_graphql.py:61: error: Call to untyped function "get_library_manager" in typed context  [no-untyped-call]
api\library_graphql.py:68: error: Function is missing a type annotation  [no-untyped-def]
api\library_graphql.py:69: error: Call to untyped function "get_library_manager" in typed context  [no-untyped-call]
api\library_graphql.py:74: error: Class cannot subclass "Mutation" (has type "Any")  [misc]
api\library_graphql.py:82: error: Function is missing a type annotation  [no-untyped-def]
api\library_graphql.py:83: error: Call to untyped function "get_library_manager" in typed context  [no-untyped-call]
api\library_graphql.py:93: error: Class cannot subclass "Mutation" (has type "Any")  [misc]
api\library_graphql.py:101: error: Function is missing a type annotation  [no-untyped-def]
api\library_graphql.py:102: error: Call to untyped function "get_library_manager" in typed context  [no-untyped-call]
api\library_graphql.py:110: error: Class cannot subclass "Mutation" (has type "Any")  [misc]
api\library_graphql.py:117: error: Function is missing a type annotation  [no-untyped-def]
api\library_graphql.py:118: error: Call to untyped function "get_library_manager" in typed context  [no-untyped-call]
api\library_graphql.py:126: error: Class cannot subclass "Mutation" (has type "Any")  [misc]
api\library_graphql.py:136: error: Function is missing a type annotation  [no-untyped-def]
api\library_graphql.py:137: error: Call to untyped function "get_library_manager" in typed context  [no-untyped-call]
api\library_graphql.py:147: error: Class cannot subclass "Mutation" (has type "Any")  [misc]
api\library_graphql.py:157: error: Function is missing a type annotation  [no-untyped-def]
api\library_graphql.py:158: error: Call to untyped function "get_library_manager" in typed context  [no-untyped-call]
api\library_graphql.py:166: error: Class cannot subclass "Mutation" (has type "Any")  [misc]
api\library_graphql.py:173: error: Function is missing a type annotation  [no-untyped-def]
api\library_graphql.py:174: error: Call to untyped function "get_library_manager" in typed context  [no-untyped-call]
api\library_graphql.py:182: error: Name "Mutation" already defined (possibly by an import)  [no-redef]
api\library_graphql.py:182: error: Class cannot subclass "ObjectType" (has type "Any")  [misc]
api\library_graphql.py:195: error: Function is missing a return type annotation  [no-untyped-def]
Found 135 errors in 21 files (checked 10 source files)
tests\helpers\db_helpers.py: error: Source file found twice under different module names: "AITypingTrainer.tests.helpers.db_helpers" and "tests.helpers.db_helpers"
tests\helpers\db_helpers.py: note: See https://mypy.readthedocs.io/en/stable/running_mypy.html#mapping-file-paths-to-modules for more info
tests\helpers\db_helpers.py: note: Common resolutions include: a) adding `__init__.py` somewhere, b) using `--explicit-package-bases` or adjusting MYPYPATH
Found 1 error in 1 file (errors prevented further checking)
models\llm_ngram_service.py:69:89: E501 Line too long (92 > 88)
   |
67 |             # Fill in the template with parameters
68 |             prompt: str = prompt_template.format(
69 |                 ngrams=ngram_str, allowed_chars=allowed_chars_str, max_length=max_length * 2
   |                                                                                         ^^^^ E501
70 |             )
71 |         except (FileNotFoundError, IOError) as e:
   |

models\llm_ngram_service.py:84:89: E501 Line too long (97 > 88)
   |
82 |                     "role": "system",
83 |                     "content": (
84 |                         "You are an expert in English lexicography and touch typing instruction."
   |                                                                                         ^^^^^^^^^ E501
85 |                     ),
86 |                 },
   |

models\ngram_analytics_service.py:45:89: E501 Line too long (99 > 88)
   |
43 |         self.max_samples = max_samples
44 |
45 |     def calculate_decaying_average(self, values: List[float], timestamps: List[datetime]) -> float:
   |                                                                                         ^^^^^^^^^^^ E501
46 |         """
47 |         Calculate decaying average with exponential weighting.
   |

models\ngram_analytics_service.py:66:89: E501 Line too long (100 > 88)
   |
65 |         # Sort by timestamp descending and take only the most recent max_samples
66 |         recent_data = sorted(zip(timestamps, values, strict=True), reverse=True)[: self.max_samples]
   |                                                                                         ^^^^^^^^^^^^ E501
67 |
68 |         if not recent_data:
   |

models\ngram_analytics_service.py:246:89: E501 Line too long (95 > 88)
    |
244 |                 )
245 |
246 |             logger.info(f"Retrieved {len(history_data)} historical records for user {user_id}")
    |                                                                                         ^^^^^^^ E501
247 |             return history_data
    |

models\ngram_analytics_service.py:356:31: ANN001 Missing type annotation for function argument `dt_value`
    |
354 |             return []
355 |
356 |     def _parse_datetime(self, dt_value) -> Optional[datetime]:
    |                               ^^^^^^^^ ANN001
357 |         """Parse datetime from various possible formats."""
358 |         if dt_value is None:
    |

models\ngram_analytics_service.py:452:89: E501 Line too long (99 > 88)
    |
450 | ΓÇª                     SUM(
451 | ΓÇª                         nd.ngram_time_ms * 
452 | ΓÇª                         POWER(0.9, JULIANDAY(ts.date_val) - JULIANDAY(nd.session_date))
    |                                                                               ^^^^^^^^^^^ E501
453 | ΓÇª                     ) / SUM(
454 | ΓÇª                         POWER(0.9, JULIANDAY(ts.date_val) - JULIANDAY(nd.session_date))
    |

models\ngram_analytics_service.py:454:89: E501 Line too long (99 > 88)
    |
452 | ΓÇª                             POWER(0.9, JULIANDAY(ts.date_val) - JULIANDAY(nd.session_date))
453 | ΓÇª                         ) / SUM(
454 | ΓÇª                             POWER(0.9, JULIANDAY(ts.date_val) - JULIANDAY(nd.session_date))
    |                                                                                   ^^^^^^^^^^^ E501
455 | ΓÇª                         )
456 | ΓÇª                     ELSE 0
    |

models\ngram_analytics_service.py:460:89: E501 Line too long (90 > 88)
    |
458 |                     FROM time_series ts
459 |                     LEFT JOIN ngram_data nd ON nd.session_date <= ts.date_val
460 |                         AND nd.recency_rank <= 20  -- Only consider most recent 20 samples
    |                                                                                         ^^ E501
461 |                     GROUP BY ts.date_val, nd.ngram_text, nd.ngram_size
462 |                     HAVING COUNT(nd.ngram_time_ms) > 0  -- Only include dates with data
    |

models\ngram_analytics_service.py:502:89: E501 Line too long (102 > 88)
    |
501 |             logger.info(
502 |                 f"Retrieved performance trends for {len(trends)} n-grams over {time_window_days} days"
    |                                                                                         ^^^^^^^^^^^^^^ E501
503 |             )
504 |             return trends
    |

models\ngram_analytics_service.py:554:89: E501 Line too long (104 > 88)
    |
552 |         key_filter_params = []
553 |         if included_keys:
554 |             # Use a simpler approach: filter n-grams by checking if they contain only allowed characters
    |                                                                                         ^^^^^^^^^^^^^^^^ E501
555 |             # We'll do this filtering after the SQL query in Python code
556 |             key_filter_condition = ""  # Will filter in Python instead
    |

models\ngram_analytics_service.py:556:13: F841 Local variable `key_filter_condition` is assigned to but never used
    |
554 |             # Use a simpler approach: filter n-grams by checking if they contain only allowed characters
555 |             # We'll do this filtering after the SQL query in Python code
556 |             key_filter_condition = ""  # Will filter in Python instead
    |             ^^^^^^^^^^^^^^^^^^^^ F841
557 |             key_filter_params = []
    |
    = help: Remove assignment to unused variable `key_filter_condition`

models\ngram_analytics_service.py:557:13: F841 Local variable `key_filter_params` is assigned to but never used
    |
555 |             # We'll do this filtering after the SQL query in Python code
556 |             key_filter_condition = ""  # Will filter in Python instead
557 |             key_filter_params = []
    |             ^^^^^^^^^^^^^^^^^ F841
558 |
559 |         # Build the query with proper parameterization
    |
    = help: Remove assignment to unused variable `key_filter_params`

models\ngram_analytics_service.py:605:89: E501 Line too long (99 > 88)
    |
603 |             allowed_chars = set(included_keys)
604 |             return_val = [
605 |                 stats for stats in return_val if all(char in allowed_chars for char in stats.ngram)
    |                                                                                         ^^^^^^^^^^^ E501
606 |             ]
    |

models\ngram_analytics_service.py:682:89: E501 Line too long (99 > 88)
    |
681 |         params = (
682 |             [keyboard_id, user_id, lookback_distance] + list(ngram_sizes) + key_filter_params + [n]
    |                                                                                         ^^^^^^^^^^^ E501
683 |         )
    |

models\ngram_analytics_service.py:693:89: E501 Line too long (97 > 88)
    |
691 |                 avg_speed=0,  # Not applicable for error count
692 |                 total_occurrences=row["error_count"],
693 |                 last_used=datetime.fromisoformat(row["last_used"]) if row["last_used"] else None,
    |                                                                                         ^^^^^^^^^ E501
694 |                 ngram_score=0,
695 |             )
    |

models\ngram_analytics_service.py:703:89: E501 Line too long (99 > 88)
    |
701 |             allowed_chars = set(included_keys)
702 |             return_val = [
703 |                 stats for stats in return_val if all(char in allowed_chars for char in stats.ngram)
    |                                                                                         ^^^^^^^^^^^ E501
704 |             ]
    |

models\ngram_analytics_service.py:710:89: E501 Line too long (94 > 88)
    |
708 |     def summarize_session_ngrams(self) -> int:
709 |         """
710 |         Summarize session ngram performance for all sessions not yet in session_ngram_summary.
    |                                                                                         ^^^^^^ E501
711 |
712 |         Uses complex CTEs to aggregate data from session_ngram_speed, session_ngram_errors,
    |

models\ngram_analytics_service.py:712:89: E501 Line too long (91 > 88)
    |
710 |         Summarize session ngram performance for all sessions not yet in session_ngram_summary.
711 |
712 |         Uses complex CTEs to aggregate data from session_ngram_speed, session_ngram_errors,
    |                                                                                         ^^^ E501
713 |         and session_keystrokes tables, then inserts the results into session_ngram_summary.
    |

models\ngram_analytics_service.py:713:89: E501 Line too long (91 > 88)
    |
712 |         Uses complex CTEs to aggregate data from session_ngram_speed, session_ngram_errors,
713 |         and session_keystrokes tables, then inserts the results into session_ngram_summary.
    |                                                                                         ^^^ E501
714 |
715 |         Returns:
    |

models\ngram_analytics_service.py:754:89: E501 Line too long (129 > 88)
    |
752 |             FROM MissingSessions ms
753 |             INNER JOIN session_ngram_speed sns ON ms.session_id = sns.session_id
754 |             GROUP BY ms.session_id, ms.user_id, ms.keyboard_id, ms.target_speed_ms, ms.updated_dt, sns.ngram_text, sns.ngram_size
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
755 |         ),
756 |         AddErrors AS (
    |

models\ngram_analytics_service.py:769:89: E501 Line too long (107 > 88)
    |
767 |                 sss.speed_instance_count,
768 |                 COALESCE(COUNT(sne.ngram_error_id), 0) as error_count,
769 |                 (sss.speed_instance_count + COALESCE(COUNT(sne.ngram_error_id), 0)) as total_instance_count
    |                                                                                         ^^^^^^^^^^^^^^^^^^^ E501
770 |             FROM SessionSpeedSummary sss
771 |             LEFT OUTER JOIN session_ngram_errors sne ON (
    |

models\ngram_analytics_service.py:776:89: E501 Line too long (104 > 88)
    |
774 |                 AND sss.ngram_size = sne.ngram_size
775 |             )
776 |             GROUP BY sss.session_id, sss.user_id, sss.keyboard_id, sss.target_speed_ms, sss.updated_dt, 
    |                                                                                         ^^^^^^^^^^^^^^^^ E501
777 |                      sss.ngram_text, sss.ngram_size, sss.avg_ms_per_keystroke, sss.speed_instance_count
778 |         ),
    |

models\ngram_analytics_service.py:777:89: E501 Line too long (103 > 88)
    |
775 |             )
776 |             GROUP BY sss.session_id, sss.user_id, sss.keyboard_id, sss.target_speed_ms, sss.updated_dt, 
777 |                      sss.ngram_text, sss.ngram_size, sss.avg_ms_per_keystroke, sss.speed_instance_count
    |                                                                                         ^^^^^^^^^^^^^^^ E501
778 |         ),
779 |         AddKeys AS (
    |

models\ngram_analytics_service.py:795:89: E501 Line too long (115 > 88)
    |
793 |             INNER JOIN session_keystrokes sk ON ms.session_id = sk.session_id
794 |             WHERE sk.time_since_previous IS NOT NULL
795 |             GROUP BY ms.session_id, ms.user_id, ms.keyboard_id, ms.target_speed_ms, ms.updated_dt, sk.expected_char
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
796 |         ),
797 |         AllNgrams AS (
    |

models\ngram_analytics_service.py:831:89: E501 Line too long (90 > 88)
    |
829 |         INSERT INTO session_ngram_summary (
830 |             session_id, ngram_text, user_id, keyboard_id, ngram_size,
831 |             avg_ms_per_keystroke, target_speed_ms, instance_count, error_count, updated_dt
    |                                                                                         ^^ E501
832 |         )
833 |         SELECT 
    |

models\ngram_analytics_service.py:835:89: E501 Line too long (90 > 88)
    |
833 |         SELECT 
834 |             session_id, ngram_text, user_id, keyboard_id, ngram_size,
835 |             avg_ms_per_keystroke, target_speed_ms, instance_count, error_count, updated_dt
    |                                                                                         ^^ E501
836 |         FROM ReadyToInsert;
837 |         """
    |

models\ngram_analytics_service.py:844:89: E501 Line too long (100 > 88)
    |
842 |             rows_affected = cursor.rowcount if cursor.rowcount is not None else 0
843 |
844 |             logger.info(f"Successfully inserted {rows_affected} records into session_ngram_summary")
    |                                                                                         ^^^^^^^^^^^^ E501
845 |
846 |             # Log summary statistics
    |

models\ngram_analytics_service.py:848:89: E501 Line too long (124 > 88)
    |
846 |             # Log summary statistics
847 |             summary_stats = self.db.fetchone(
848 |                 "SELECT COUNT(*) as total_records, COUNT(DISTINCT session_id) as unique_sessions FROM session_ngram_summary"
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
849 |             )
    |

models\ngram_analytics_service.py:853:89: E501 Line too long (95 > 88)
    |
851 |             if summary_stats:
852 |                 logger.info(
853 |                     f"Total records in session_ngram_summary: {summary_stats['total_records']}"
    |                                                                                         ^^^^^^^ E501
854 |                 )
855 |                 logger.info(
    |

models\ngram_analytics_service.py:856:89: E501 Line too long (99 > 88)
    |
854 |                 )
855 |                 logger.info(
856 |                     f"Unique sessions in session_ngram_summary: {summary_stats['unique_sessions']}"
    |                                                                                         ^^^^^^^^^^^ E501
857 |                 )
    |

models\ngram_analytics_service.py:867:89: E501 Line too long (93 > 88)
    |
865 |     def add_speed_summary_for_session(self, session_id: str) -> dict:
866 |         """
867 |         Update performance summary for a specific session using decaying average calculation.
    |                                                                                         ^^^^^ E501
868 |
869 |         Uses the last 20 sessions (including the given session) to calculate decaying averages
    |

models\ngram_analytics_service.py:869:89: E501 Line too long (94 > 88)
    |
867 |         Update performance summary for a specific session using decaying average calculation.
868 |
869 |         Uses the last 20 sessions (including the given session) to calculate decaying averages
    |                                                                                         ^^^^^^ E501
870 |         and updates both ngram_speed_summary_curr (merge) and ngram_speed_summary_hist (insert).
    |

models\ngram_analytics_service.py:870:89: E501 Line too long (96 > 88)
    |
869 |         Uses the last 20 sessions (including the given session) to calculate decaying averages
870 |         and updates both ngram_speed_summary_curr (merge) and ngram_speed_summary_hist (insert).
    |                                                                                         ^^^^^^^^ E501
871 |
872 |         Args:
    |

models\ngram_analytics_service.py:885:89: E501 Line too long (98 > 88)
    |
883 |         # Get session info for logging
884 |         session_info = self.db.fetchone(
885 |             "SELECT start_time, user_id, keyboard_id FROM practice_sessions WHERE session_id = ?",
    |                                                                                         ^^^^^^^^^^ E501
886 |             (session_id,),
887 |         )
    |

models\ngram_analytics_service.py:893:89: E501 Line too long (89 > 88)
    |
891 |             raise ValueError(f"Session {session_id} not found")
892 |
893 |         logger.info(f"Processing session {session_id} from {session_info['start_time']}")
    |                                                                                         ^ E501
894 |
895 |         # Insert into history table first
    |

models\ngram_analytics_service.py:915:89: E501 Line too long (101 > 88)
    |
913 |                     ROW_NUMBER() OVER (ORDER BY ps.start_time DESC) as session_rank
914 |                 FROM practice_sessions ps
915 |                 JOIN SessionContext sc ON ps.user_id = sc.user_id AND ps.keyboard_id = sc.keyboard_id
    |                                                                                         ^^^^^^^^^^^^^ E501
916 |                 WHERE ps.start_time <= sc.start_time
917 |                 ORDER BY ps.start_time DESC
    |

models\ngram_analytics_service.py:934:89: E501 Line too long (90 > 88)
    |
932 |                     CASE
933 |                         WHEN sc.start_time >= ps.start_time
934 |                         THEN EXTRACT(EPOCH FROM (sc.start_time - ps.start_time)) / 86400.0
    |                                                                                         ^^ E501
935 |                         ELSE 0
936 |                     END AS days_ago
    |

models\ngram_analytics_service.py:951:89: E501 Line too long (90 > 88)
    |
949 |                     target_speed_ms,
950 |                     SUM(avg_ms_per_keystroke * instance_count * POWER(0.9, days_ago)) / 
951 |                         SUM(instance_count * POWER(0.9, days_ago)) as decaying_average_ms,
    |                                                                                         ^^ E501
952 |                     SUM(instance_count) as total_sample_count,
953 |                     MAX(start_time) as last_measured
    |

models\ngram_analytics_service.py:955:89: E501 Line too long (98 > 88)
    |
953 |                     MAX(start_time) as last_measured
954 |                 FROM NgramPerformanceData
955 |                 GROUP BY user_id, keyboard_id, session_id, ngram_text, ngram_size, target_speed_ms
    |                                                                                         ^^^^^^^^^^ E501
956 |             )
957 |             SELECT 
    |

models\ngram_analytics_service.py:1066:89: E501 Line too long (91 > 88)
     |
1064 |             logger.info("Inserting into ngram_speed_summary_hist")
1065 |             hist_cursor = self.db.execute(history_insert_query, (session_id,))
1066 |             hist_inserted = hist_cursor.rowcount if hist_cursor.rowcount is not None else 0
     |                                                                                         ^^^ E501
1067 |
1068 |             # Execute current table merge
     |

models\ngram_analytics_service.py:1071:89: E501 Line too long (90 > 88)
     |
1069 |             logger.info("Updating ngram_speed_summary_curr")
1070 |             curr_cursor = self.db.execute(merge_query, (session_id,))
1071 |             curr_updated = curr_cursor.rowcount if curr_cursor.rowcount is not None else 0
     |                                                                                         ^^ E501
1072 |
1073 |             result = {
     |

models\ngram_analytics_service.py:1080:89: E501 Line too long (166 > 88)
     |
1079 | ΓÇª
1080 | ΓÇªnserted into temp, {hist_inserted} records inserted into hist, {curr_updated} records updated in curr"
     |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
1081 | ΓÇª
     |

models\ngram_analytics_service.py:1089:89: E501 Line too long (98 > 88)
     |
1088 |         except Exception as e:
1089 |             logger.error(f"Error in AddSpeedSummaryForSession for session {session_id}: {str(e)}")
     |                                                                                         ^^^^^^^^^^ E501
1090 |             raise
     |

models\ngram_analytics_service.py:1124:89: E501 Line too long (91 > 88)
     |
1122 |         if not sessions:
1123 |             logger.info("No sessions found to process")
1124 |             return {"total_sessions": 0, "total_hist_inserted": 0, "total_curr_updated": 0}
     |                                                                                         ^^^ E501
1125 |
1126 |         logger.info(f"Found {len(sessions)} sessions to process")
     |

models\ngram_analytics_service.py:1139:89: E501 Line too long (104 > 88)
     |
1137 |             # Debug message with session info
1138 |             print(
1139 |                 f"Processing session {session_id}, avg speed: {avg_speed:.2f}ms, datetime: {start_time}"
     |                                                                                         ^^^^^^^^^^^^^^^^ E501
1140 |             )
1141 |             logger.info(
     |

models\ngram_analytics_service.py:1142:89: E501 Line too long (104 > 88)
     |
1140 |             )
1141 |             logger.info(
1142 |                 f"Processing session {session_id}, avg speed: {avg_speed:.2f}ms, datetime: {start_time}"
     |                                                                                         ^^^^^^^^^^^^^^^^ E501
1143 |             )
     |

models\ngram_analytics_service.py:1154:89: E501 Line too long (100 > 88)
     |
1152 |                 # Indented debug message with record counts
1153 |                 print(
1154 |                     f"    Records: {curr_updated} updated in curr, {hist_inserted} inserted in hist"
     |                                                                                         ^^^^^^^^^^^^ E501
1155 |                 )
1156 |                 logger.info(
     |

models\ngram_analytics_service.py:1157:89: E501 Line too long (100 > 88)
     |
1155 |                 )
1156 |                 logger.info(
1157 |                     f"    Records: {curr_updated} updated in curr, {hist_inserted} inserted in hist"
     |                                                                                         ^^^^^^^^^^^^ E501
1158 |                 )
     |

models\ngram_analytics_service.py:1178:89: E501 Line too long (103 > 88)
     |
1177 |         logger.info(
1178 |             f"CatchupSpeedSummary completed: {processed_sessions}/{len(sessions)} sessions processed, "
     |                                                                                         ^^^^^^^^^^^^^^^ E501
1179 |             f"{total_curr_updated} total curr updates, {total_hist_inserted} total hist inserts"
1180 |         )
     |

models\ngram_analytics_service.py:1179:89: E501 Line too long (96 > 88)
     |
1177 |         logger.info(
1178 |             f"CatchupSpeedSummary completed: {processed_sessions}/{len(sessions)} sessions processed, "
1179 |             f"{total_curr_updated} total curr updates, {total_hist_inserted} total hist inserts"
     |                                                                                         ^^^^^^^^ E501
1180 |         )
     |

models\ngram_analytics_service.py:1182:89: E501 Line too long (94 > 88)
     |
1180 |         )
1181 |
1182 |         print(f"\nCatchup completed: {processed_sessions}/{len(sessions)} sessions processed")
     |                                                                                         ^^^^^^ E501
1183 |         print(f"Total records updated in curr: {total_curr_updated}")
1184 |         print(f"Total records inserted in hist: {total_hist_inserted}")
     |

models\ngram_manager.py:111:89: E501 Line too long (96 > 88)
    |
109 |         # Helper functions to handle different Keystroke field naming conventions
110 |         def get_expected_char(k: object) -> str:
111 |             """Get expected character, supporting both 'expected' and 'expected_char' fields."""
    |                                                                                         ^^^^^^^^ E501
112 |             return getattr(k, "expected", getattr(k, "expected_char", ""))
    |

models\ngram_manager.py:115:89: E501 Line too long (91 > 88)
    |
114 |         def get_actual_char(k: object) -> str:
115 |             """Get actual character, supporting both 'char' and 'keystroke_char' fields."""
    |                                                                                         ^^^ E501
116 |             return getattr(k, "char", getattr(k, "keystroke_char", ""))
    |

models\ngram_manager.py:119:89: E501 Line too long (89 > 88)
    |
118 |         def get_time(k: object) -> Optional[datetime]:
119 |             """Get timestamp, supporting both 'timestamp' and 'keystroke_time' fields."""
    |                                                                                         ^ E501
120 |             return getattr(k, "timestamp", getattr(k, "keystroke_time", None))
    |

models\ngram_manager.py:124:89: E501 Line too long (100 > 88)
    |
122 |         for i in range(len(keystrokes) - ngram_size + 1):
123 |             current_keystroke_sequence = keystrokes[i : i + ngram_size]
124 |             # Filtering: skip n-grams containing space, backspace, newline, or tab in expected chars
    |                                                                                         ^^^^^^^^^^^^ E501
125 |             if any(
126 |                 (
    |

models\ngram_manager.py:144:89: E501 Line too long (123 > 88)
    |
142 |             if ngram_size > 1 and total_time_ms == 0.0:
143 |                 continue
144 |             # Additional filtering: skip if any consecutive keystrokes have the same timestamp (zero duration for any part)
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
145 |             has_zero_part = any(
146 |                 get_time(current_keystroke_sequence[j])
    |

models\ngram_manager.py:154:89: E501 Line too long (94 > 88)
    |
153 |             errors_in_sequence = [
154 |                 get_actual_char(k) != get_expected_char(k) for k in current_keystroke_sequence
    |                                                                                         ^^^^^^ E501
155 |             ]
156 |             err_not_at_end = any(errors_in_sequence[:-1])
    |

models\ngram_manager.py:159:89: E501 Line too long (94 > 88)
    |
157 |             # Clean: all chars correct, no space/backspace, time>0
158 |             is_clean_ngram = all(
159 |                 get_actual_char(k) == get_expected_char(k) for k in current_keystroke_sequence
    |                                                                                         ^^^^^^ E501
160 |             )
161 |             # Error: only last char is error, all others correct, no space/backspace, time>0
    |

models\ngram_manager.py:161:89: E501 Line too long (92 > 88)
    |
159 |                 get_actual_char(k) == get_expected_char(k) for k in current_keystroke_sequence
160 |             )
161 |             # Error: only last char is error, all others correct, no space/backspace, time>0
    |                                                                                         ^^^^ E501
162 |             ngram_is_error_flag = (not any(errors_in_sequence[:-1])) and errors_in_sequence[-1]
163 |             # Valid: not error in non-last, no space/backspace, time>0
    |

models\ngram_manager.py:162:89: E501 Line too long (95 > 88)
    |
160 |             )
161 |             # Error: only last char is error, all others correct, no space/backspace, time>0
162 |             ngram_is_error_flag = (not any(errors_in_sequence[:-1])) and errors_in_sequence[-1]
    |                                                                                         ^^^^^^^ E501
163 |             # Valid: not error in non-last, no space/backspace, time>0
164 |             is_valid_ngram = not err_not_at_end
    |

models\ngram_manager.py:188:89: E501 Line too long (99 > 88)
    |
186 |         Per specification in ngram.md:
187 |         - Clean ngrams go to the session_ngram_speed table
188 |         - Ngrams with error flag (error only in last position) go to the session_ngram_errors table
    |                                                                                         ^^^^^^^^^^^ E501
189 |         - Only ngrams of size 2-10 are saved
    |

models\ngram_manager.py:205:89: E501 Line too long (120 > 88)
    |
203 |         if ngram.size < MIN_NGRAM_SIZE or ngram.size > MAX_NGRAM_SIZE:
204 |             logger.debug(
205 |                 f"Skipping ngram '{ngram.text}' as size {ngram.size} is outside range {MIN_NGRAM_SIZE}-{MAX_NGRAM_SIZE}"
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
206 |             )
207 |             return True  # Not an error, just skipping
    |

models\session.py:129:89: E501 Line too long (91 > 88)
    |
127 |             return cls.model_validate(data)
128 |         except ValueError as e:
129 |             # Re-raise with a more specific message while preserving the original exception
    |                                                                                         ^^^ E501
130 |             raise ValueError(f"Invalid session data: {str(e)}") from e
    |

models\session_manager.py:34:89: E501 Line too long (108 > 88)
   |
32 |             row = self.db_manager.execute(
33 |                 """
34 |                 SELECT session_id, snippet_id, user_id, keyboard_id, snippet_index_start, snippet_index_end,
   |                                                                                         ^^^^^^^^^^^^^^^^^^^^ E501
35 |                        content, start_time, end_time, actual_chars, errors
36 |                 FROM practice_sessions WHERE session_id = ?
   |

models\session_manager.py:76:89: E501 Line too long (96 > 88)
   |
74 |             rows = self.db_manager.execute(
75 |                 (
76 |                     "SELECT session_id, snippet_id, user_id, keyboard_id, snippet_index_start, "
   |                                                                                         ^^^^^^^^ E501
77 |                     "snippet_index_end, content, start_time, end_time, actual_chars, errors "
78 |                     "FROM practice_sessions WHERE snippet_id = ? "
   |

models\session_manager.py:77:89: E501 Line too long (93 > 88)
   |
75 |                 (
76 |                     "SELECT session_id, snippet_id, user_id, keyboard_id, snippet_index_start, "
77 |                     "snippet_index_end, content, start_time, end_time, actual_chars, errors "
   |                                                                                         ^^^^^ E501
78 |                     "FROM practice_sessions WHERE snippet_id = ? "
79 |                     "ORDER BY end_time DESC"
   |

models\session_manager.py:150:89: E501 Line too long (101 > 88)
    |
148 |             """
149 |             INSERT INTO practice_sessions (
150 |                 session_id, snippet_id, user_id, keyboard_id, snippet_index_start, snippet_index_end,
    |                                                                                         ^^^^^^^^^^^^^ E501
151 |                 content, start_time, end_time, actual_chars, errors, ms_per_keystroke
152 |             ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    |

models\setting.py:19:89: E501 Line too long (90 > 88)
   |
18 |     This exception is raised for validation errors such as invalid format
19 |     or if a setting type ID that is not unique for a given entity is attempted to be used.
   |                                                                                         ^^ E501
20 |     """
   |

models\setting.py:46:89: E501 Line too long (93 > 88)
   |
44 |         setting_type_id: 6-character key identifying the setting type.
45 |         setting_value: The setting value stored as text.
46 |         related_entity_id: UUID string identifying the related entity (user, keyboard, etc.).
   |                                                                                         ^^^^^ E501
47 |         updated_at: ISO datetime indicating when the setting was last updated.
48 |     """
   |

models\setting_manager.py:43:89: E501 Line too long (92 > 88)
   |
41 |             SettingValidationError: If the combination is not unique.
42 |         """
43 |         query = "SELECT 1 FROM settings WHERE setting_type_id = ? AND related_entity_id = ?"
   |                                                                                         ^^^^ E501
44 |         params = [setting_type_id, related_entity_id]
45 |         if setting_id is not None:
   |

models\setting_manager.py:63:89: E501 Line too long (109 > 88)
   |
61 |         """
62 |         Retrieve a single setting by type ID and related entity ID.
63 |         If the setting doesn't exist and a default value is provided, returns a new setting with the default.
   |                                                                                         ^^^^^^^^^^^^^^^^^^^^^ E501
64 |
65 |         Args:
   |

models\setting_manager.py:74:89: E501 Line too long (100 > 88)
   |
73 |         Raises:
74 |             SettingNotFound: If no setting exists with the specified IDs and no default is provided.
   |                                                                                         ^^^^^^^^^^^^ E501
75 |         """
76 |         row = self.db_manager.execute(
   |

models\setting_manager.py:78:89: E501 Line too long (92 > 88)
   |
76 |         row = self.db_manager.execute(
77 |             """
78 |             SELECT setting_id, setting_type_id, setting_value, related_entity_id, updated_at
   |                                                                                         ^^^^ E501
79 |             FROM settings
80 |             WHERE setting_type_id = ? AND related_entity_id = ?
   |

models\setting_manager.py:102:89: E501 Line too long (90 > 88)
    |
100 |                 updated_at=datetime.datetime.now().isoformat(),
101 |             )
102 |             # We don't save it to the database yet - that would be handled by save_setting
    |                                                                                         ^^ E501
103 |             return new_setting
104 |         else:
    |

models\setting_manager.py:106:89: E501 Line too long (101 > 88)
    |
104 |         else:
105 |             raise SettingNotFound(
106 |                 f"Setting with type '{setting_type_id}' for entity '{related_entity_id}' not found. "
    |                                                                                         ^^^^^^^^^^^^^ E501
107 |                 "Please ensure the setting exists or provide a default value."
108 |             )
    |

models\setting_manager.py:122:89: E501 Line too long (92 > 88)
    |
120 |         rows = self.db_manager.execute(
121 |             """
122 |             SELECT setting_id, setting_type_id, setting_value, related_entity_id, updated_at
    |                                                                                         ^^^^ E501
123 |             FROM settings
124 |             WHERE related_entity_id = ?
    |

models\setting_manager.py:160:89: E501 Line too long (98 > 88)
    |
158 |         # Check if a setting with this type and entity already exists
159 |         existing_setting_row = self.db_manager.execute(
160 |             "SELECT setting_id FROM settings WHERE setting_type_id = ? AND related_entity_id = ?",
    |                                                                                         ^^^^^^^^^^ E501
161 |             (setting.setting_type_id, setting.related_entity_id)
162 |         ).fetchone()
    |

models\setting_manager.py:195:89: E501 Line too long (99 > 88)
    |
193 |             """
194 |             INSERT INTO settings_history
195 |             (history_id, setting_id, setting_type_id, setting_value, related_entity_id, updated_at)
    |                                                                                         ^^^^^^^^^^^ E501
196 |             VALUES (?, ?, ?, ?, ?, ?)
197 |             """,
    |

models\setting_manager.py:234:89: E501 Line too long (93 > 88)
    |
232 |             """
233 |             UPDATE settings
234 |             SET setting_type_id = ?, setting_value = ?, related_entity_id = ?, updated_at = ?
    |                                                                                         ^^^^^ E501
235 |             WHERE setting_id = ?
236 |             """,
    |

models\setting_manager.py:273:89: E501 Line too long (91 > 88)
    |
271 |             # Now delete the setting
272 |             self.db_manager.execute(
273 |                 "DELETE FROM settings WHERE setting_type_id = ? AND related_entity_id = ?",
    |                                                                                         ^^^ E501
274 |                 (setting_type_id, related_entity_id),
275 |             )
    |

models\snippet.py:33:89: E501 Line too long (93 > 88)
   |
31 |     Args:
32 |         value: The string to check
33 |         is_content: Whether this is snippet content (code/text) that may legitimately contain
   |                                                                                         ^^^^^ E501
34 |                     quotes and equals signs
35 |     """
   |

models\snippet.py:45:89: E501 Line too long (95 > 88)
   |
43 |         ("INSERT INTO", r"INSERT\s+INTO"),
44 |         ("UPDATE SET", r"UPDATE\s+.*\s+SET"),
45 |         ("SELECT FROM", r"SELECT\s+.*\s+FROM"),  # Catches SELECT * FROM, SELECT col FROM, etc.
   |                                                                                         ^^^^^^^ E501
46 |         ("OR 1=1", r"OR\s+1\s*=\s*1"),
47 |         ("' OR '", r"'\s*OR\s*'"),
   |

models\snippet.py:61:89: E501 Line too long (90 > 88)
   |
59 |     for pattern_name, pattern_regex in core_patterns:
60 |         if re.search(pattern_regex, value, re.IGNORECASE):
61 |             raise ValueError(f"Value contains potentially unsafe pattern: {pattern_name}")
   |                                                                                         ^^ E501
62 |
63 |     # Only check extended patterns if not validating content (code/text)
   |

models\snippet.py:67:89: E501 Line too long (89 > 88)
   |
65 |         for pattern in extended_patterns:
66 |             if pattern.lower() in value.lower():
67 |                 raise ValueError(f"Value contains potentially unsafe pattern: {pattern}")
   |                                                                                         ^ E501
68 |
69 |     return value
   |

models\snippet.py:76:89: E501 Line too long (92 > 88)
   |
75 |     Args:
76 |         value: The value to validate, which can be an int or string representation of an int
   |                                                                                         ^^^^ E501
77 |
78 |     Returns:
   |

models\snippet.py:87:89: E501 Line too long (99 > 88)
   |
85 |         if isinstance(value, str):
86 |             # Ensure string is a valid representation of an integer
87 |             if not value.strip().isdigit() and not (value.startswith("-") and value[1:].isdigit()):
   |                                                                                         ^^^^^^^^^^^ E501
88 |                 raise ValueError("String must represent a valid integer")
89 |             return int(value)
   |

models\snippet.py:167:89: E501 Line too long (90 > 88)
    |
166 |             errors = [
167 |                 ErrorWrapper(ValueError(f"Extra field not permitted: {field}"), loc=field)
    |                                                                                         ^^ E501
168 |                 for field in extra
169 |             ]
    |

models\snippet_manager.py:76:89: E501 Line too long (93 > 88)
   |
74 |         if exists:
75 |             self.db.execute(
76 |                 "UPDATE snippets SET category_id = ?, snippet_name = ? WHERE snippet_id = ?",
   |                                                                                         ^^^^^ E501
77 |                 (snippet.category_id, snippet.snippet_name, snippet.snippet_id),
78 |             )
   |

models\snippet_manager.py:79:89: E501 Line too long (100 > 88)
   |
77 |                 (snippet.category_id, snippet.snippet_name, snippet.snippet_id),
78 |             )
79 |             self.db.execute("DELETE FROM snippet_parts WHERE snippet_id = ?", (snippet.snippet_id,))
   |                                                                                         ^^^^^^^^^^^^ E501
80 |         else:
81 |             self.db.execute(
   |

models\snippet_manager.py:82:89: E501 Line too long (96 > 88)
   |
80 |         else:
81 |             self.db.execute(
82 |                 "INSERT INTO snippets (snippet_id, category_id, snippet_name) VALUES (?, ?, ?)",
   |                                                                                         ^^^^^^^^ E501
83 |                 (snippet.snippet_id, snippet.category_id, snippet.snippet_name),
84 |             )
   |

models\snippet_manager.py:91:89: E501 Line too long (108 > 88)
   |
89 |             part_id = str(uuid.uuid4())
90 |             self.db.execute(
91 |                 "INSERT INTO snippet_parts (part_id, snippet_id, part_number, content) VALUES (?, ?, ?, ?)",
   |                                                                                         ^^^^^^^^^^^^^^^^^^^^ E501
92 |                 (part_id, snippet.snippet_id, i, part_content),
93 |             )
   |

models\snippet_manager.py:110:89: E501 Line too long (98 > 88)
    |
108 |         try:
109 |             cursor = self.db.execute(
110 |                 "SELECT snippet_id, category_id, snippet_name FROM snippets WHERE snippet_id = ?",
    |                                                                                         ^^^^^^^^^^ E501
111 |                 (snippet_id,),
112 |             )
    |

models\snippet_manager.py:123:89: E501 Line too long (94 > 88)
    |
122 |             parts_cursor = self.db.execute(
123 |                 "SELECT content FROM snippet_parts WHERE snippet_id = ? ORDER BY part_number",
    |                                                                                         ^^^^^^ E501
124 |                 (snippet_id,),
125 |             )
    |

models\snippet_manager.py:133:89: E501 Line too long (89 > 88)
    |
131 |             if not full_content or not full_content.strip():
132 |                 logging.warning(
133 |                     f"Empty content found for snippet ID {snippet_id}, using placeholder"
    |                                                                                         ^ E501
134 |                 )
135 |                 full_content = "[Content was empty. Generate new content to practice.]"
    |

models\snippet_manager.py:145:89: E501 Line too long (93 > 88)
    |
143 |             logging.error(f"Unexpected error retrieving snippet ID {snippet_id}: {e}")
144 |             raise DatabaseError(
145 |                 f"An unexpected error occurred while retrieving snippet ID {snippet_id}: {e}"
    |                                                                                         ^^^^^ E501
146 |             ) from e
    |

models\snippet_manager.py:148:89: E501 Line too long (92 > 88)
    |
146 |             ) from e
147 |
148 |     def get_snippet_by_name(self, snippet_name: str, category_id: str) -> Optional[Snippet]:
    |                                                                                         ^^^^ E501
149 |         """Retrieves a snippet by its name and category UUID.
    |

models\snippet_manager.py:163:89: E501 Line too long (93 > 88)
    |
161 |         try:
162 |             cursor = self.db.execute(
163 |                 "SELECT snippet_id FROM snippets WHERE snippet_name = ? AND category_id = ?",
    |                                                                                         ^^^^^ E501
164 |                 (snippet_name, category_id),
165 |             )
    |

models\snippet_manager.py:217:89: E501 Line too long (98 > 88)
    |
216 |                 parts_cursor = self.db.execute(
217 |                     "SELECT content FROM snippet_parts WHERE snippet_id = ? ORDER BY part_number",
    |                                                                                         ^^^^^^^^^^ E501
218 |                     (current_snippet_id,),
219 |                 )
    |

models\snippet_manager.py:227:89: E501 Line too long (91 > 88)
    |
225 |             return snippets
226 |         except DatabaseError as e:
227 |             logging.error(f"Database error listing snippets for cat ID {category_id}: {e}")
    |                                                                                         ^^^ E501
228 |             raise
229 |         except Exception as e:
    |

models\snippet_manager.py:230:89: E501 Line too long (93 > 88)
    |
228 |             raise
229 |         except Exception as e:
230 |             logging.error(f"Unexpected error listing snippets for cat ID {category_id}: {e}")
    |                                                                                         ^^^^^ E501
231 |             raise DatabaseError(
232 |                 f"An unexpected error occurred while listing snippets for cat ID {category_id}: {e}"
    |

models\snippet_manager.py:232:89: E501 Line too long (100 > 88)
    |
230 |             logging.error(f"Unexpected error listing snippets for cat ID {category_id}: {e}")
231 |             raise DatabaseError(
232 |                 f"An unexpected error occurred while listing snippets for cat ID {category_id}: {e}"
    |                                                                                         ^^^^^^^^^^^^ E501
233 |             ) from e
    |

models\snippet_manager.py:235:89: E501 Line too long (94 > 88)
    |
233 |             ) from e
234 |
235 |     def search_snippets(self, query: str, category_id: Optional[int] = None) -> List[Snippet]:
    |                                                                                         ^^^^^^ E501
236 |         """Searches for snippets by a query string in their name or content.
    |

models\snippet_manager.py:267:89: E501 Line too long (99 > 88)
    |
265 |             rows = cursor.fetchall()
266 |
267 |             snippet_ids = [row[0] if isinstance(row, tuple) else row["snippet_id"] for row in rows]
    |                                                                                         ^^^^^^^^^^^ E501
268 |
269 |             snippets: List[Snippet] = []
    |

models\snippet_manager.py:276:89: E501 Line too long (89 > 88)
    |
274 |             return snippets
275 |         except DatabaseError as e:
276 |             logging.error(f"Database error searching snippets with query '{query}': {e}")
    |                                                                                         ^ E501
277 |             raise
278 |         except Exception as e:
    |

models\snippet_manager.py:279:89: E501 Line too long (91 > 88)
    |
277 |             raise
278 |         except Exception as e:
279 |             logging.error(f"Unexpected error searching snippets with query '{query}': {e}")
    |                                                                                         ^^^ E501
280 |             raise DatabaseError(
281 |                 f"An unexpected error occurred while searching snippets: {e}"
    |

models\snippet_manager.py:298:89: E501 Line too long (89 > 88)
    |
296 |         """
297 |         if not self.get_snippet_by_id(snippet_id):
298 |             raise ValueError(f"Snippet ID {snippet_id} not exist and cannot be deleted.")
    |                                                                                         ^ E501
299 |
300 |         try:
    |

models\snippet_manager.py:301:89: E501 Line too long (92 > 88)
    |
300 |         try:
301 |             self.db.execute("DELETE FROM snippet_parts WHERE snippet_id = ?", (snippet_id,))
    |                                                                                         ^^^^ E501
302 |             self.db.execute("DELETE FROM snippets WHERE snippet_id = ?", (snippet_id,))
303 |             return True
    |

models\snippet_manager.py:314:89: E501 Line too long (91 > 88)
    |
313 |     def snippet_exists(
314 |         self, category_id: str, snippet_name: str, exclude_snippet_id: Optional[str] = None
    |                                                                                         ^^^ E501
315 |     ) -> bool:
316 |         """Checks if a snippet with the given name already exists in the category (by UUID).
    |

models\snippet_manager.py:316:89: E501 Line too long (92 > 88)
    |
314 |         self, category_id: str, snippet_name: str, exclude_snippet_id: Optional[str] = None
315 |     ) -> bool:
316 |         """Checks if a snippet with the given name already exists in the category (by UUID).
    |                                                                                         ^^^^ E501
317 |
318 |         Args:
    |

models\snippet_manager.py:321:89: E501 Line too long (93 > 88)
    |
319 |             category_id: The UUID of the category to check within.
320 |             snippet_name: The name of the snippet to check for.
321 |             exclude_snippet_id: Optional. If provided, exclude this snippet ID from the check
    |                                                                                         ^^^^^ E501
322 |                                 (used when updating an existing snippet's name).
    |

models\snippet_manager.py:353:89: E501 Line too long (92 > 88)
    |
352 |         Returns:
353 |             A list of dictionaries, each with 'snippet_id', 'snippet_name', 'category_name'.
    |                                                                                         ^^^^ E501
354 |
355 |         Raises:
    |

models\snippet_manager.py:373:89: E501 Line too long (90 > 88)
    |
371 |             logging.error(f"Unexpected error retrieving all snippets summary: {e}")
372 |             raise DatabaseError(
373 |                 f"An unexpected error occurred while retrieving all snippets summary: {e}"
    |                                                                                         ^^ E501
374 |             ) from e
    |

models\snippet_manager.py:379:89: E501 Line too long (93 > 88)
    |
377 |         """Lists all snippets in the database with full content."""
378 |         try:
379 |             cursor = self.db.execute("SELECT snippet_id FROM snippets ORDER BY snippet_name")
    |                                                                                         ^^^^^ E501
380 |             rows = cursor.fetchall()
381 |             snippets = []
    |

models\snippet_manager.py:408:89: E501 Line too long (94 > 88)
    |
406 |         """
407 |         if not self.get_snippet_by_id(snippet_id):
408 |             raise ValueError(f"Snippet ID {snippet_id} does not exist and cannot be deleted.")
    |                                                                                         ^^^^^^ E501
409 |
410 |         try:
    |

models\snippet_manager.py:411:89: E501 Line too long (92 > 88)
    |
410 |         try:
411 |             self.db.execute("DELETE FROM snippet_parts WHERE snippet_id = ?", (snippet_id,))
    |                                                                                         ^^^^ E501
412 |             self.db.execute("DELETE FROM snippets WHERE snippet_id = ?", (snippet_id,))
413 |         except DatabaseError as e:
    |

models\snippet_manager.py:419:89: E501 Line too long (91 > 88)
    |
417 |             logging.error(f"Unexpected error deleting snippet ID {snippet_id}: {e}")
418 |             raise DatabaseError(
419 |                 f"An unexpected error occurred while deleting snippet ID {snippet_id}: {e}"
    |                                                                                         ^^^ E501
420 |             ) from e
    |

models\snippet_manager.py:442:89: E501 Line too long (89 > 88)
    |
440 |         )
441 |
442 |     def get_starting_index(self, snippet_id: str, user_id: str, keyboard_id: str) -> int:
    |                                                                                         ^ E501
443 |         """
444 |         Returns the next starting index for a snippet for a given user and keyboard.
    |

models\snippet_manager.py:460:89: E501 Line too long (111 > 88)
    |
458 |                     session_id,
459 |                     snippet_index_end as end_index,
460 |                     rank() over (partition by snippet_id, user_id, keyboard_id order by start_time desc) as rnk
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^ E501
461 |                 from practice_sessions
462 |                 where
    |

models\user.py:76:89: E501 Line too long (95 > 88)
   |
74 |             raise ValueError("Name contains invalid control characters.")
75 |
76 |         # Check for invalid characters (only letters, spaces, hyphens, and apostrophes allowed)
   |                                                                                         ^^^^^^^ E501
77 |         if not all(c.isalpha() or c.isspace() or c in "-.'" for c in stripped_v):
78 |             raise ValueError("Name contains invalid characters.")
   |

models\user.py:82:89: E501 Line too long (93 > 88)
   |
80 |         # Check for leading/trailing spaces, hyphens, or apostrophes
81 |         if stripped_v[0] in " -'" or stripped_v[-1] in " -'":
82 |             raise ValueError("Name cannot start or end with a space, hyphen, or apostrophe.")
   |                                                                                         ^^^^^ E501
83 |
84 |         # Check for consecutive spaces, hyphens, or apostrophes
   |

models\user.py:87:89: E501 Line too long (100 > 88)
   |
85 |         for i in range(len(stripped_v) - 1):
86 |             if stripped_v[i] in " -'" and stripped_v[i + 1] in " -'":
87 |                 raise ValueError("Name cannot contain consecutive spaces, hyphens, or apostrophes.")
   |                                                                                         ^^^^^^^^^^^^ E501
88 |
89 |         return stripped_v
   |

models\user.py:147:89: E501 Line too long (89 > 88)
    |
145 |                 # Check for invalid characters in domain parts
146 |                 if not all(c.isalnum() or c == "-" for c in part):
147 |                     raise ValueError(f"Domain part '{part}' contains invalid characters")
    |                                                                                         ^ E501
148 |
149 |                 # Check for parts starting or ending with a hyphen
    |

models\user.py:161:89: E501 Line too long (90 > 88)
    |
159 |             if len(tld) < 2 or not tld.isalpha():
160 |                 raise ValueError(
161 |                     "Top-level domain must be at least 2 letters and contain only letters"
    |                                                                                         ^^ E501
162 |                 )
    |

models\user_manager.py:28:89: E501 Line too long (100 > 88)
   |
26 |         self.db_manager: DatabaseManager = db_manager
27 |
28 |     def _validate_email_uniqueness(self, email_address: str, user_id: Optional[str] = None) -> None:
   |                                                                                         ^^^^^^^^^^^^ E501
29 |         # Always use lowercase for email comparisons
30 |         email_address_lower = email_address.lower()
   |

models\user_manager.py:37:89: E501 Line too long (89 > 88)
   |
35 |             params.append(user_id)
36 |         if self.db_manager.fetchone(query, tuple(params)):
37 |             raise UserValidationError(f"Email address '{email_address}' must be unique.")
   |                                                                                         ^ E501
38 |
39 |     def get_user_by_id(self, user_id: str) -> User:
   |

models\user_manager.py:41:89: E501 Line too long (94 > 88)
   |
39 |     def get_user_by_id(self, user_id: str) -> User:
40 |         row = self.db_manager.fetchone(
41 |             "SELECT user_id, first_name, surname, email_address FROM users WHERE user_id = ?",
   |                                                                                         ^^^^^^ E501
42 |             (user_id,),
43 |         )
   |

models\user_manager.py:100:89: E501 Line too long (98 > 88)
    |
 98 |     def __insert_user(self, user: User) -> bool:
 99 |         self.db_manager.execute(
100 |             "INSERT INTO users (user_id, first_name, surname, email_address) VALUES (?, ?, ?, ?)",
    |                                                                                         ^^^^^^^^^^ E501
101 |             (user.user_id, user.first_name, user.surname, user.email_address.lower()),
102 |         )
    |

models\user_manager.py:107:89: E501 Line too long (96 > 88)
    |
105 |     def __update_user(self, user: User) -> bool:
106 |         self.db_manager.execute(
107 |             "UPDATE users SET first_name = ?, surname = ?, email_address = ? WHERE user_id = ?",
    |                                                                                         ^^^^^^^^ E501
108 |             (user.first_name, user.surname, user.email_address.lower(), user.user_id),
109 |         )
    |

Found 129 errors.
No fixes available (2 hidden fixes can be enabled with the `--unsafe-fixes` option).
services\__init__.py:44:89: E501 Line too long (94 > 88)
   |
42 |         db_manager.close()
43 |         raise ImportError(
44 |             "Failed to initialize services. Please ensure all required modules are available."
   |                                                                                         ^^^^^^ E501
45 |         ) from e
   |

services\database_viewer_service.py:54:89: E501 Line too long (94 > 88)
   |
52 |     sorting, filtering), and export to CSV.
53 |
54 |     This service provides a read-only interface to inspect database tables and their contents.
   |                                                                                         ^^^^^^ E501
55 |     It handles pagination, sorting, and filtering of data, as well as exporting to CSV format.
56 |     All operations are performed in a secure, read-only manner with proper input validation.
   |

services\database_viewer_service.py:55:89: E501 Line too long (94 > 88)
   |
54 |     This service provides a read-only interface to inspect database tables and their contents.
55 |     It handles pagination, sorting, and filtering of data, as well as exporting to CSV format.
   |                                                                                         ^^^^^^ E501
56 |     All operations are performed in a secure, read-only manner with proper input validation.
57 |     """
   |

services\database_viewer_service.py:56:89: E501 Line too long (92 > 88)
   |
54 |     This service provides a read-only interface to inspect database tables and their contents.
55 |     It handles pagination, sorting, and filtering of data, as well as exporting to CSV format.
56 |     All operations are performed in a secure, read-only manner with proper input validation.
   |                                                                                         ^^^^ E501
57 |     """
   |

services\database_viewer_service.py:59:9: ANN204 Missing return type annotation for special method `__init__`
   |
57 |     """
58 |
59 |     def __init__(self, db_manager: DatabaseManager):
   |         ^^^^^^^^ ANN204
60 |         """
61 |         Initialize the DatabaseViewerService with a database manager.
   |
   = help: Add return type annotation: `None`

services\database_viewer_service.py:92:89: E501 Line too long (111 > 88)
   |
90 |             # Use information_schema.columns for Postgres
91 |             schema_query = (
92 |                 "SELECT column_name AS name, data_type AS type, is_nullable, column_default, ordinal_position "
   |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^ E501
93 |                 "FROM information_schema.columns "
94 |                 "WHERE table_schema = %s AND table_name = %s "
   |

services\library_service.py:47:9: ANN204 Missing return type annotation for special method `__init__`
   |
45 |     metadata = metadata
46 |
47 |     def __init__(self, session):
   |         ^^^^^^^^ ANN204
48 |         self.session = session
   |
   = help: Add return type annotation: `None`

services\library_service.py:47:24: ANN001 Missing type annotation for function argument `session`
   |
45 |     metadata = metadata
46 |
47 |     def __init__(self, session):
   |                        ^^^^^^^ ANN001
48 |         self.session = session
   |

services\library_service.py:51:9: ANN201 Missing return type annotation for public function `add_category`
   |
50 |     # Category methods
51 |     def add_category(self, name):
   |         ^^^^^^^^^^^^ ANN201
52 |         if not name or len(name) > 50 or not name.isascii():
53 |             raise ValidationError("Invalid category name")
   |
   = help: Add return type annotation

services\library_service.py:51:28: ANN001 Missing type annotation for function argument `name`
   |
50 |     # Category methods
51 |     def add_category(self, name):
   |                            ^^^^ ANN001
52 |         if not name or len(name) > 50 or not name.isascii():
53 |             raise ValidationError("Invalid category name")
   |

services\library_service.py:60:9: ANN201 Missing return type annotation for public function `get_categories`
   |
58 |         return cat
59 |
60 |     def get_categories(self):
   |         ^^^^^^^^^^^^^^ ANN201
61 |         return self.session.query(Category).all()
   |
   = help: Add return type annotation

services\library_service.py:63:9: ANN201 Missing return type annotation for public function `edit_category`
   |
61 |         return self.session.query(Category).all()
62 |
63 |     def edit_category(self, category_id, new_name):
   |         ^^^^^^^^^^^^^ ANN201
64 |         if not new_name or len(new_name) > 50 or not new_name.isascii():
65 |             raise ValidationError("Invalid category name")
   |
   = help: Add return type annotation

services\library_service.py:63:29: ANN001 Missing type annotation for function argument `category_id`
   |
61 |         return self.session.query(Category).all()
62 |
63 |     def edit_category(self, category_id, new_name):
   |                             ^^^^^^^^^^^ ANN001
64 |         if not new_name or len(new_name) > 50 or not new_name.isascii():
65 |             raise ValidationError("Invalid category name")
   |

services\library_service.py:63:42: ANN001 Missing type annotation for function argument `new_name`
   |
61 |         return self.session.query(Category).all()
62 |
63 |     def edit_category(self, category_id, new_name):
   |                                          ^^^^^^^^ ANN001
64 |         if not new_name or len(new_name) > 50 or not new_name.isascii():
65 |             raise ValidationError("Invalid category name")
   |

services\library_service.py:78:9: ANN201 Missing return type annotation for public function `delete_category`
   |
76 |         return cat
77 |
78 |     def delete_category(self, category_id):
   |         ^^^^^^^^^^^^^^^ ANN201
79 |         cat = self.session.query(Category).filter_by(category_id=category_id).first()
80 |         if not cat:
   |
   = help: Add return type annotation: `None`

services\library_service.py:78:31: ANN001 Missing type annotation for function argument `category_id`
   |
76 |         return cat
77 |
78 |     def delete_category(self, category_id):
   |                               ^^^^^^^^^^^ ANN001
79 |         cat = self.session.query(Category).filter_by(category_id=category_id).first()
80 |         if not cat:
   |

services\library_service.py:85:9: ANN201 Missing return type annotation for public function `add_snippet`
   |
84 |     # Snippet methods
85 |     def add_snippet(self, category_id, name, content):
   |         ^^^^^^^^^^^ ANN201
86 |         if not name or len(name) > 50 or not name.isascii():
87 |             raise ValidationError("Invalid snippet name")
   |
   = help: Add return type annotation

services\library_service.py:85:27: ANN001 Missing type annotation for function argument `category_id`
   |
84 |     # Snippet methods
85 |     def add_snippet(self, category_id, name, content):
   |                           ^^^^^^^^^^^ ANN001
86 |         if not name or len(name) > 50 or not name.isascii():
87 |             raise ValidationError("Invalid snippet name")
   |

services\library_service.py:85:40: ANN001 Missing type annotation for function argument `name`
   |
84 |     # Snippet methods
85 |     def add_snippet(self, category_id, name, content):
   |                                        ^^^^ ANN001
86 |         if not name or len(name) > 50 or not name.isascii():
87 |             raise ValidationError("Invalid snippet name")
   |

services\library_service.py:85:46: ANN001 Missing type annotation for function argument `content`
   |
84 |     # Snippet methods
85 |     def add_snippet(self, category_id, name, content):
   |                                              ^^^^^^^ ANN001
86 |         if not name or len(name) > 50 or not name.isascii():
87 |             raise ValidationError("Invalid snippet name")
   |

services\library_service.py:100:9: ANN201 Missing return type annotation for public function `get_snippets`
    |
 98 |         return snip
 99 |
100 |     def get_snippets(self, category_id):
    |         ^^^^^^^^^^^^ ANN201
101 |         return self.session.query(Snippet).filter_by(category_id=category_id).all()
    |
    = help: Add return type annotation

services\library_service.py:100:28: ANN001 Missing type annotation for function argument `category_id`
    |
 98 |         return snip
 99 |
100 |     def get_snippets(self, category_id):
    |                            ^^^^^^^^^^^ ANN001
101 |         return self.session.query(Snippet).filter_by(category_id=category_id).all()
    |

services\library_service.py:103:9: ANN201 Missing return type annotation for public function `edit_snippet`
    |
101 |         return self.session.query(Snippet).filter_by(category_id=category_id).all()
102 |
103 |     def edit_snippet(self, snippet_id, new_name, new_content, new_category_id=None):
    |         ^^^^^^^^^^^^ ANN201
104 |         if not new_name or len(new_name) > 50 or not new_name.isascii():
105 |             raise ValidationError("Invalid snippet name")
    |
    = help: Add return type annotation

services\library_service.py:103:28: ANN001 Missing type annotation for function argument `snippet_id`
    |
101 |         return self.session.query(Snippet).filter_by(category_id=category_id).all()
102 |
103 |     def edit_snippet(self, snippet_id, new_name, new_content, new_category_id=None):
    |                            ^^^^^^^^^^ ANN001
104 |         if not new_name or len(new_name) > 50 or not new_name.isascii():
105 |             raise ValidationError("Invalid snippet name")
    |

services\library_service.py:103:40: ANN001 Missing type annotation for function argument `new_name`
    |
101 |         return self.session.query(Snippet).filter_by(category_id=category_id).all()
102 |
103 |     def edit_snippet(self, snippet_id, new_name, new_content, new_category_id=None):
    |                                        ^^^^^^^^ ANN001
104 |         if not new_name or len(new_name) > 50 or not new_name.isascii():
105 |             raise ValidationError("Invalid snippet name")
    |

services\library_service.py:103:50: ANN001 Missing type annotation for function argument `new_content`
    |
101 |         return self.session.query(Snippet).filter_by(category_id=category_id).all()
102 |
103 |     def edit_snippet(self, snippet_id, new_name, new_content, new_category_id=None):
    |                                                  ^^^^^^^^^^^ ANN001
104 |         if not new_name or len(new_name) > 50 or not new_name.isascii():
105 |             raise ValidationError("Invalid snippet name")
    |

services\library_service.py:103:63: ANN001 Missing type annotation for function argument `new_category_id`
    |
101 |         return self.session.query(Snippet).filter_by(category_id=category_id).all()
102 |
103 |     def edit_snippet(self, snippet_id, new_name, new_content, new_category_id=None):
    |                                                               ^^^^^^^^^^^^^^^ ANN001
104 |         if not new_name or len(new_name) > 50 or not new_name.isascii():
105 |             raise ValidationError("Invalid snippet name")
    |

services\library_service.py:129:9: ANN201 Missing return type annotation for public function `delete_snippet`
    |
127 |         return snip
128 |
129 |     def delete_snippet(self, snippet_id):
    |         ^^^^^^^^^^^^^^ ANN201
130 |         snip = self.session.query(Snippet).filter_by(snippet_id=snippet_id).first()
131 |         if not snip:
    |
    = help: Add return type annotation: `None`

services\library_service.py:129:30: ANN001 Missing type annotation for function argument `snippet_id`
    |
127 |         return snip
128 |
129 |     def delete_snippet(self, snippet_id):
    |                              ^^^^^^^^^^ ANN001
130 |         snip = self.session.query(Snippet).filter_by(snippet_id=snippet_id).first()
131 |         if not snip:
    |

Found 29 errors.
No fixes available (4 hidden fixes can be enabled with the `--unsafe-fixes` option).
helpers\error_utils.py:21:5: ANN001 Missing type annotation for function argument `parent`
   |
19 |     title: str = "Error",
20 |     details: Optional[str] = None,
21 |     parent=None
   |     ^^^^^^ ANN001
22 | ) -> None:
23 |     """Display an error message box with the given error information.
   |

Found 1 error.
desktop_ui\api_key_dialog.py:61:89: E501 Line too long (92 > 88)
   |
59 |         self.setWindowTitle("API Key Configuration")
60 |         self.setMinimumWidth(500)
61 |         self.setWindowFlags(self.windowFlags() & ~Qt.WindowType.WindowContextHelpButtonHint)
   |                                                                                         ^^^^ E501
62 |
63 |         self.api_keys: Dict[str, str] = {}
   |

desktop_ui\api_key_dialog.py:104:89: E501 Line too long (89 > 88)
    |
102 |         api_info_label = QLabel(
103 |             "Your API key is required for word generation features.\n"
104 |             "The key is stored securely and never transmitted except to OpenAI services."
    |                                                                                         ^ E501
105 |         )
106 |         api_info_label.setWordWrap(True)
    |

desktop_ui\api_key_dialog.py:133:89: E501 Line too long (96 > 88)
    |
132 |     def _verify_api_key(self) -> None:
133 |         """Verify that the API key is valid by making a test API call to the models endpoint."""
    |                                                                                         ^^^^^^^^ E501
134 |         api_key = self.openai_key_input.text().strip()
    |

desktop_ui\api_key_dialog.py:137:89: E501 Line too long (94 > 88)
    |
136 |         if not api_key:
137 |             QMessageBox.warning(self, "Missing API Key", "Please enter an API key to verify.")
    |                                                                                         ^^^^^^ E501
138 |             return
    |

desktop_ui\api_key_dialog.py:145:89: E501 Line too long (92 > 88)
    |
143 |             from requests.exceptions import RequestException
144 |
145 |             # Make a simple API call to list models (lightweight and doesn't consume tokens)
    |                                                                                         ^^^^ E501
146 |             headers = {"Authorization": f"Bearer {api_key}"}
147 |             response = requests.get(
    |

desktop_ui\api_key_dialog.py:163:89: E501 Line too long (92 > 88)
    |
161 |                     self,
162 |                     "Invalid API Key",
163 |                     "This API key appears to be invalid or revoked. Please check your key.",
    |                                                                                         ^^^^ E501
164 |                 )
165 |             elif response.status_code == 429:
    |

desktop_ui\api_key_dialog.py:197:89: E501 Line too long (100 > 88)
    |
195 |             )
196 |         except Exception as e:
197 |             QMessageBox.critical(self, "Verification Failed", f"Failed to verify API key: {str(e)}")
    |                                                                                         ^^^^^^^^^^^^ E501
198 |
199 |     def get_user_env_var(self, var_name: str) -> Optional[str]:
    |

desktop_ui\api_key_dialog.py:213:89: E501 Line too long (98 > 88)
    |
212 |         try:
213 |             reg_key = winreg.OpenKey(winreg.HKEY_CURRENT_USER, r"Environment", 0, winreg.KEY_READ)
    |                                                                                         ^^^^^^^^^^ E501
214 |
215 |             value, _ = winreg.QueryValueEx(reg_key, var_name)
    |

desktop_ui\api_key_dialog.py:241:89: E501 Line too long (89 > 88)
    |
239 |                 return
240 |         except Exception as e:
241 |             logging.warning(f"Error loading API key from environment variable: {str(e)}")
    |                                                                                         ^ E501
242 |             # Continue to try encrypted file
    |

desktop_ui\api_key_dialog.py:249:89: E501 Line too long (98 > 88)
    |
247 |                 self,
248 |                 "Security Library Missing",
249 |                 "The cryptography library is not installed. API keys will not be securely stored."
    |                                                                                         ^^^^^^^^^^ E501
250 |                 "\n\nPlease run: pip install cryptography",
251 |             )
    |

desktop_ui\api_key_dialog.py:280:89: E501 Line too long (90 > 88)
    |
279 |     def _save_api_keys(self) -> None:
280 |         """Save API keys to both environment variable (permanently) and secure storage."""
    |                                                                                         ^^ E501
281 |         # Get the API key
282 |         openai_key = self.openai_key_input.text().strip()
    |

desktop_ui\api_key_dialog.py:284:89: E501 Line too long (91 > 88)
    |
282 |         openai_key = self.openai_key_input.text().strip()
283 |         if not openai_key:
284 |             QMessageBox.warning(self, "Missing API Key", "Please enter an OpenAI API key.")
    |                                                                                         ^^^ E501
285 |             return
    |

desktop_ui\api_key_dialog.py:303:89: E501 Line too long (113 > 88)
    |
301 |                 self,
302 |                 "Limited Security",
303 |                 "Your API key has been set as an environment variable, but secure file storage is not available."
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^ E501
304 |                 "\n\nThe cryptography library is needed for secure file storage."
305 |                 "\nPlease run: pip install cryptography",
    |

desktop_ui\api_key_dialog.py:324:89: E501 Line too long (89 > 88)
    |
322 |                 self,
323 |                 "Success",
324 |                 "API key saved successfully to environment variable and secure storage!",
    |                                                                                         ^ E501
325 |             )
326 |             self.accept()
    |

desktop_ui\api_key_dialog.py:337:16: B025 try-except block with duplicate exception `Exception`
    |
335 |             self.accept()
336 |
337 |         except Exception as e:
    |                ^^^^^^^^^ B025
338 |             QMessageBox.critical(self, "Save Error", f"Failed to save API key: {str(e)}")
    |

desktop_ui\api_key_dialog.py:338:89: E501 Line too long (89 > 88)
    |
337 |         except Exception as e:
338 |             QMessageBox.critical(self, "Save Error", f"Failed to save API key: {str(e)}")
    |                                                                                         ^ E501
339 |
340 |     def _get_encryption_key(self) -> bytes:
    |

desktop_ui\api_key_dialog.py:367:89: E501 Line too long (89 > 88)
    |
365 |         # Get machine-specific data
366 |         # This creates a unique identifier for the current machine
367 |         # While not foolproof, it helps ensure keys can only be decrypted on this machine
    |                                                                                         ^ E501
368 |         try:
369 |             # Create machine-specific key for this installation
    |

desktop_ui\api_key_dialog.py:377:89: E501 Line too long (90 > 88)
    |
375 |         except Exception:
376 |             # Fallback if platform specific info fails
377 |             machine_id = "typing_trainer_default_key".encode("utf-8")  # Ensure it's bytes
    |                                                                                         ^^ E501
378 |
379 |         # Derive a key using PBKDF2
    |

desktop_ui\api_key_dialog.py:389:89: E501 Line too long (89 > 88)
    |
387 |         return key
388 |
389 |     def _set_permanent_environment_variable(self, var_name: str, var_value: str) -> None:
    |                                                                                         ^ E501
390 |         """
391 |                 Set a permanent environment variable for the current user's profile.
    |

desktop_ui\api_key_dialog.py:429:89: E501 Line too long (109 > 88)
    |
427 |                     print(f"Γ£à Environment variable '{var_name}' set permanently.")
428 |                 except Exception as e:
429 |                     # If broadcasting fails, the variable is still set, but may need a restart to take effect
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^ E501
430 |                     print(f"ΓÜá∩╕Å Variable set but may require restart: {e}")
431 |             else:
    |

desktop_ui\api_key_dialog.py:454:89: E501 Line too long (99 > 88)
    |
452 |                 # If not found or different, add/update it
453 |                 if not any(
454 |                     line.strip().startswith(f"export {var_name}=") for line in content.splitlines()
    |                                                                                         ^^^^^^^^^^^ E501
455 |                 ):
456 |                     with open(profile_file, "a") as f:
    |

desktop_ui\api_key_dialog.py:468:88: E501 Line too long (97 > 88)
    |
466 |                         f.write("\n".join(lines))
467 |
468 |                 print(f"Γ£à Environment variable '{var_name}' set permanently in {profile_file}.")
    |                                                                                         ^^^^^^^^^ E501
469 |         except Exception as e:
470 |             print(f"Γ¥î Failed to set environment variable: {e}")
    |

desktop_ui\api_key_dialog.py:505:89: E501 Line too long (91 > 88)
    |
503 |             dialog_instance._load_api_keys()
504 |
505 |             if key_type in dialog_instance.api_keys and dialog_instance.api_keys[key_type]:
    |                                                                                         ^^^ E501
506 |                 return dialog_instance.api_keys[key_type]
    |

desktop_ui\api_server_manager.py:53:89: E501 Line too long (93 > 88)
   |
51 |         try:
52 |             # Try to connect to the server
53 |             # Even if we get a 400 error (method not allowed), it means the server is running
   |                                                                                         ^^^^^ E501
54 |             response = requests.get(self._api_url, timeout=2)
55 |             return True
   |

desktop_ui\api_server_manager.py:54:13: F841 Local variable `response` is assigned to but never used
   |
52 |             # Try to connect to the server
53 |             # Even if we get a 400 error (method not allowed), it means the server is running
54 |             response = requests.get(self._api_url, timeout=2)
   |             ^^^^^^^^ F841
55 |             return True
56 |         except requests.exceptions.ConnectionError:
   |
   = help: Remove assignment to unused variable `response`

desktop_ui\api_server_manager.py:80:89: E501 Line too long (91 > 88)
   |
78 |             cmd = [python_executable, self._server_script_path]
79 |
80 |             # Start server as a separate process that won't die when the desktop app closes
   |                                                                                         ^^^ E501
81 |             self._server_process = subprocess.Popen(
82 |                 cmd,
   |

desktop_ui\category_model_tester.py:4:89: E501 Line too long (109 > 88)
  |
2 | Category Model Tester UI
3 | -----------------------
4 | A simple PySide6-based desktop UI for directly testing the Category object model (Category, CategoryManager).
  |                                                                                         ^^^^^^^^^^^^^^^^^^^^^ E501
5 |
6 | - List all categories
  |

desktop_ui\category_model_tester.py:12:89: E501 Line too long (93 > 88)
   |
10 | - Show validation and error messages
11 |
12 | Bypasses API and service layers; interacts directly with CategoryManager and DatabaseManager.
   |                                                                                         ^^^^^ E501
13 |
14 | Author: Cascade AI
   |

desktop_ui\db_viewer_dialog.py:50:89: E501 Line too long (101 > 88)
   |
48 |         super().__init__(parent)
49 |         self.service = service
50 |         self.current_table = ""  # Initialize with empty string, will be set when a table is selected
   |                                                                                         ^^^^^^^^^^^^^ E501
51 |         self.page = 1
52 |         self.page_size = 50
   |

desktop_ui\db_viewer_dialog.py:76:89: E501 Line too long (94 > 88)
   |
74 |         self.table_combo = QComboBox()
75 |         # Connecting a signal through a lambda ensures it works in tests
76 |         self.table_combo.currentTextChanged.connect(lambda text: self.on_table_selected(text))
   |                                                                                         ^^^^^^ E501
77 |         top_layout.addWidget(table_label)
78 |         top_layout.addWidget(self.table_combo)
   |

desktop_ui\db_viewer_dialog.py:97:89: E501 Line too long (98 > 88)
   |
95 |         # Table widget
96 |         self.table_widget = QTableWidget()
97 |         self.table_widget.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers)  # Read-only
   |                                                                                         ^^^^^^^^^^ E501
98 |
99 |         # Cast the header to ensure type safety
   |

desktop_ui\db_viewer_dialog.py:122:89: E501 Line too long (101 > 88)
    |
120 |             self.page_size_combo.addItem(str(size))
121 |         self.page_size_combo.setCurrentText(str(self.page_size))
122 |         self.page_size_combo.currentTextChanged.connect(lambda text: self.on_page_size_changed(text))
    |                                                                                         ^^^^^^^^^^^^^ E501
123 |
124 |         pagination_layout.addWidget(self.prev_btn)
    |

desktop_ui\db_viewer_dialog.py:209:89: E501 Line too long (90 > 88)
    |
208 |     def load_table_data(self) -> None:
209 |         """Load and display table data with current pagination, sorting, and filtering."""
    |                                                                                         ^^ E501
210 |         if not self.current_table:
211 |             return
    |

desktop_ui\db_viewer_dialog.py:231:89: E501 Line too long (95 > 88)
    |
229 |             data = results.get("rows", [])
230 |             self.total_rows = results.get("total_rows", 0)
231 |             self.total_pages = max(1, (self.total_rows + self.page_size - 1) // self.page_size)
    |                                                                                         ^^^^^^^ E501
232 |
233 |             # Configure table
    |

desktop_ui\db_viewer_dialog.py:306:24: F821 Undefined name `QProgressBar`
    |
305 |             # Show progress dialog
306 |             progress = QProgressBar(self)
    |                        ^^^^^^^^^^^^ F821
307 |             progress.setWindowTitle("Exporting data...")
308 |             progress.setRange(0, 0)  # Indeterminate
    |

desktop_ui\dialogs\keyboard_dialog.py:67:89: E501 Line too long (91 > 88)
   |
65 |         self.target_ms_spinbox.setSuffix(" ms")  # Add ms suffix
66 |         self.target_ms_spinbox.setAlignment(Qt.AlignmentFlag.AlignRight)
67 |         self.target_ms_spinbox.setToolTip("Target milliseconds per keystroke (speed goal)")
   |                                                                                         ^^^ E501
68 |         form_layout.addRow("Target Speed:", self.target_ms_spinbox)
   |

desktop_ui\dialogs\keyboard_dialog.py:98:89: E501 Line too long (98 > 88)
    |
 96 |         if target_ms < 50 or target_ms > 5000:
 97 |             QMessageBox.warning(
 98 |                 self, "Validation Error", "Target speed must be between 50 and 5000 milliseconds."
    |                                                                                         ^^^^^^^^^^ E501
 99 |             )
100 |             self.target_ms_spinbox.setFocus()
    |

desktop_ui\dialogs\user_dialog.py:99:89: E501 Line too long (96 > 88)
    |
 97 |         # Basic email validation
 98 |         if "@" not in email or "." not in email:
 99 |             QMessageBox.warning(self, "Validation Error", "Please enter a valid email address.")
    |                                                                                         ^^^^^^^^ E501
100 |             self.email_edit.setFocus()
101 |             return
    |

desktop_ui\drill_config.py:60:89: E501 Line too long (114 > 88)
   |
58 |         print("\n[DEBUG] ===== Starting DrillConfigDialog initialization =====")
59 |         print(
60 |             f"[DEBUG] Args - db_manager: {db_manager is not None}, user_id: {user_id}, keyboard_id: {keyboard_id}"
   |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
61 |         )
   |

desktop_ui\drill_config.py:70:89: E501 Line too long (104 > 88)
   |
68 |         self.user_id = user_id or ""
69 |         print(
70 |             f"[DEBUG] Set instance variables - user_id: {self.user_id}, keyboard_id: {self.keyboard_id}"
   |                                                                                         ^^^^^^^^^^^^^^^^ E501
71 |         )
   |

desktop_ui\drill_config.py:96:89: E501 Line too long (90 > 88)
   |
94 |                     print(f"\n[DEBUG] Attempting to load user with ID: {self.user_id}")
95 |                     try:
96 |                         self.current_user = self.user_manager.get_user_by_id(self.user_id)
   |                                                                                         ^^ E501
97 |                         print(f"[DEBUG] Successfully loaded user: {self.current_user}")
98 |                         print(f"[DEBUG] User type: {type(self.current_user)}")
   |

desktop_ui\drill_config.py:100:89: E501 Line too long (142 > 88)
    |
 98 | ΓÇªtype(self.current_user)}")
 99 | ΓÇª
100 | ΓÇªs: {vars(self.current_user) if hasattr(self.current_user, '__dict__') else 'No __dict__'}"
    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
101 | ΓÇª
102 | ΓÇª
    |

desktop_ui\drill_config.py:109:89: E501 Line too long (95 > 88)
    |
108 |                 if self.keyboard_id:
109 |                     print(f"\n[DEBUG] Attempting to load keyboard with ID: {self.keyboard_id}")
    |                                                                                         ^^^^^^^ E501
110 |                     try:
111 |                         self.current_keyboard = self.keyboard_manager.get_keyboard_by_id(
    |

desktop_ui\drill_config.py:111:89: E501 Line too long (89 > 88)
    |
109 |                     print(f"\n[DEBUG] Attempting to load keyboard with ID: {self.keyboard_id}")
110 |                     try:
111 |                         self.current_keyboard = self.keyboard_manager.get_keyboard_by_id(
    |                                                                                         ^ E501
112 |                             self.keyboard_id
113 |                         )
    |

desktop_ui\drill_config.py:114:89: E501 Line too long (95 > 88)
    |
112 |                             self.keyboard_id
113 |                         )
114 |                         print(f"[DEBUG] Successfully loaded keyboard: {self.current_keyboard}")
    |                                                                                         ^^^^^^^ E501
115 |                         print(f"[DEBUG] Keyboard type: {type(self.current_keyboard)}")
116 |                     except Exception as e:
    |

desktop_ui\drill_config.py:279:89: E501 Line too long (109 > 88)
    |
277 |             for i, category in enumerate(self.categories):
278 |                 print(
279 |                     f"[DEBUG] Adding category {i + 1}: {category.category_name} (ID: {category.category_id})"
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^ E501
280 |                 )
281 |                 self.category_selector.addItem(category.category_name, category)
    |

desktop_ui\drill_config.py:310:89: E501 Line too long (97 > 88)
    |
309 |         if index < 0 or not self.categories or not self.snippet_manager:
310 |             print("[DEBUG] No category selected, no categories available, or no snippet manager")
    |                                                                                         ^^^^^^^^^ E501
311 |             self.snippet_selector.clear()
312 |             self.snippet_selector.setEnabled(False)
    |

desktop_ui\drill_config.py:325:89: E501 Line too long (113 > 88)
    |
324 |         print(
325 |             f"[DEBUG] Selected category: {selected_category.category_name} (ID: {selected_category.category_id})"
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^ E501
326 |         )
    |

desktop_ui\drill_config.py:330:89: E501 Line too long (95 > 88)
    |
328 |         try:
329 |             # Load snippets for the selected category
330 |             print(f"[DEBUG] Loading snippets for category ID: {selected_category.category_id}")
    |                                                                                         ^^^^^^^ E501
331 |             self.snippets = self.snippet_manager.list_snippets_by_category(
332 |                 selected_category.category_id
    |

desktop_ui\drill_config.py:341:89: E501 Line too long (104 > 88)
    |
339 |             for i, snippet in enumerate(self.snippets):
340 |                 print(
341 |                     f"[DEBUG] Adding snippet {i + 1}: {snippet.snippet_name} (ID: {snippet.snippet_id})"
    |                                                                                         ^^^^^^^^^^^^^^^^ E501
342 |                 )
343 |                 self.snippet_selector.addItem(snippet.snippet_name, snippet)
    |

desktop_ui\drill_config.py:399:89: E501 Line too long (97 > 88)
    |
397 |                         try:
398 |                             start_idx = self.snippet_manager.get_starting_index(
399 |                                 str(snippet.snippet_id), str(self.user_id), str(self.keyboard_id)
    |                                                                                         ^^^^^^^^^ E501
400 |                             )
401 |                         except Exception as e:
    |

desktop_ui\drill_config.py:431:89: E501 Line too long (93 > 88)
    |
429 |         # Add user information if available
430 |         if self.current_user:
431 |             user_name = f"{self.current_user.first_name} {self.current_user.surname}".strip()
    |                                                                                         ^^^^^ E501
432 |             user_display = f"User: {user_name or self.current_user.user_id}"
433 |             status_parts.append(user_display)
    |

desktop_ui\drill_config.py:438:89: E501 Line too long (118 > 88)
    |
436 |         # Add keyboard information if available
437 |         if self.current_keyboard:
438 |             keyboard_display = f"Keyboard: {self.current_keyboard.keyboard_name or self.current_keyboard.keyboard_id}"
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
439 |             status_parts.append(keyboard_display)
440 |         else:
    |

desktop_ui\drill_config.py:465:89: E501 Line too long (103 > 88)
    |
463 |             new_end_index = content_length
464 |
465 |         print(f"[DEBUG] Start index changed: {new_start_index}, updating end index to {new_end_index}")
    |                                                                                         ^^^^^^^^^^^^^^^ E501
466 |
467 |         # Update end index
    |

desktop_ui\drill_config.py:494:89: E501 Line too long (105 > 88)
    |
492 |             new_end_index = content_length
493 |
494 |         print(f"[DEBUG] Drill length changed: {new_drill_length}, updating end index to {new_end_index}")
    |                                                                                         ^^^^^^^^^^^^^^^^^ E501
495 |
496 |         # Update end index
    |

desktop_ui\drill_config.py:509:89: E501 Line too long (90 > 88)
    |
507 |             # Load drill category (DRICAT)
508 |             try:
509 |                 cat_setting = self.setting_manager.get_setting("DRICAT", self.keyboard_id)
    |                                                                                         ^^ E501
510 |                 cat_name = cat_setting.setting_value
511 |                 for i in range(self.category_selector.count()):
    |

desktop_ui\drill_config.py:521:89: E501 Line too long (94 > 88)
    |
519 |             # Load drill snippet (DRISNP)
520 |             try:
521 |                 snippet_setting = self.setting_manager.get_setting("DRISNP", self.keyboard_id)
    |                                                                                         ^^^^^^ E501
522 |                 snippet_name = snippet_setting.setting_value
523 |                 for i in range(self.snippet_selector.count()):
    |

desktop_ui\drill_config.py:533:89: E501 Line too long (96 > 88)
    |
531 |             # Load drill length (DRILEN)
532 |             try:
533 |                 drill_len_setting = self.setting_manager.get_setting("DRILEN", self.keyboard_id)
    |                                                                                         ^^^^^^^^ E501
534 |                 self.drill_length.setValue(int(drill_len_setting.setting_value))
535 |             except Exception:
    |

desktop_ui\drill_config.py:678:89: E501 Line too long (91 > 88)
    |
676 |         # Store configuration for the typing drill screen
677 |         try:
678 |             # For custom text, adjust the start and end indices to match the custom content
    |                                                                                         ^^^ E501
679 |             if self.use_custom_text.isChecked():
680 |                 start_for_drill = 0
    |

desktop_ui\drill_config.py:713:89: E501 Line too long (90 > 88)
    |
712 |     def _on_cancel_clicked(self) -> None:
713 |         """Slot for Cancel button to ensure QDialog.reject is called for test patching."""
    |                                                                                         ^^ E501
714 |         self.reject()
    |

desktop_ui\drill_screen_tester.py:5:89: E501 Line too long (92 > 88)
  |
3 | ---------------------
4 | A minimal PySide6 UI for selecting between snippet-based or manual text input.
5 | - If 'Snippet Selection' is chosen: shows a dropdown of snippets and start/end index fields.
  |                                                                                         ^^^^ E501
6 | - If 'Manual Input' is chosen: shows a text box for manual entry.
7 | - A preview panel always shows the current text (subset or manual).
  |

desktop_ui\drill_screen_tester.py:20:1: E402 Module level import not at top of file
   |
18 |     sys.path.insert(0, project_root)
19 |
20 | import sys
   | ^^^^^^^^^^ E402
21 |
22 | from PySide6 import QtWidgets
   |

desktop_ui\drill_screen_tester.py:22:1: E402 Module level import not at top of file
   |
20 | import sys
21 |
22 | from PySide6 import QtWidgets
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
23 |
24 | # Dummy snippet data for demonstration
   |

desktop_ui\drill_screen_tester.py:161:89: E501 Line too long (89 > 88)
    |
159 |             print("Attempting to import from desktop_ui.typing_drill...")
160 |             from desktop_ui.typing_drill import TypingDrillScreen
161 |             print("Successfully imported TypingDrillScreen from desktop_ui.typing_drill")
    |                                                                                         ^ E501
162 |         except ModuleNotFoundError as e:
163 |             print(f"ModuleNotFoundError: {e}")
    |

desktop_ui\drill_screen_tester.py:180:89: E501 Line too long (90 > 88)
    |
178 |                 snippet_end = 0
179 |                 text = self.manual_text.toPlainText()
180 |                 print(f"Using manual text, length: {len(text)}, snippet_id: {snippet_id}")
    |                                                                                         ^^ E501
181 |             else:
182 |                 idx = self.snippet_combo.currentIndex()
    |

desktop_ui\drill_screen_tester.py:197:89: E501 Line too long (91 > 88)
    |
195 |                     snippet_end = len(snippet["content"])
196 |                 snippet_start = max(0, min(snippet_start, len(snippet["content"])))
197 |                 snippet_end = max(snippet_start, min(snippet_end, len(snippet["content"])))
    |                                                                                         ^^^ E501
198 |                 text = snippet["content"][snippet_start:snippet_end]
199 |                 print(f"Using snippet ID: {snippet_id}, start: {snippet_start}, end: {snippet_end}")
    |

desktop_ui\drill_screen_tester.py:199:89: E501 Line too long (100 > 88)
    |
197 |                 snippet_end = max(snippet_start, min(snippet_end, len(snippet["content"])))
198 |                 text = snippet["content"][snippet_start:snippet_end]
199 |                 print(f"Using snippet ID: {snippet_id}, start: {snippet_start}, end: {snippet_end}")
    |                                                                                         ^^^^^^^^^^^^ E501
200 |                 print(f"Content length: {len(text)}")
    |

desktop_ui\dynamic_config.py:19:1: E402 Module level import not at top of file
   |
17 |     sys.path.insert(0, project_root)
18 |
19 | from PySide6 import QtWidgets
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
20 | from PySide6.QtCore import Qt
21 | from PySide6.QtWidgets import QStatusBar
   |

desktop_ui\dynamic_config.py:20:1: E402 Module level import not at top of file
   |
19 | from PySide6 import QtWidgets
20 | from PySide6.QtCore import Qt
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
21 | from PySide6.QtWidgets import QStatusBar
   |

desktop_ui\dynamic_config.py:21:1: E402 Module level import not at top of file
   |
19 | from PySide6 import QtWidgets
20 | from PySide6.QtCore import Qt
21 | from PySide6.QtWidgets import QStatusBar
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
22 |
23 | from db.database_manager import DatabaseManager
   |

desktop_ui\dynamic_config.py:23:1: E402 Module level import not at top of file
   |
21 | from PySide6.QtWidgets import QStatusBar
22 |
23 | from db.database_manager import DatabaseManager
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
24 | from desktop_ui.typing_drill import TypingDrillScreen
25 | from models.category import Category
   |

desktop_ui\dynamic_config.py:24:1: E402 Module level import not at top of file
   |
23 | from db.database_manager import DatabaseManager
24 | from desktop_ui.typing_drill import TypingDrillScreen
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
25 | from models.category import Category
26 | from models.category_manager import CategoryManager
   |

desktop_ui\dynamic_config.py:25:1: E402 Module level import not at top of file
   |
23 | from db.database_manager import DatabaseManager
24 | from desktop_ui.typing_drill import TypingDrillScreen
25 | from models.category import Category
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
26 | from models.category_manager import CategoryManager
27 | from models.dynamic_content_manager import ContentMode, DynamicContentManager
   |

desktop_ui\dynamic_config.py:26:1: E402 Module level import not at top of file
   |
24 | from desktop_ui.typing_drill import TypingDrillScreen
25 | from models.category import Category
26 | from models.category_manager import CategoryManager
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
27 | from models.dynamic_content_manager import ContentMode, DynamicContentManager
28 | from models.keyboard_manager import KeyboardManager
   |

desktop_ui\dynamic_config.py:27:1: E402 Module level import not at top of file
   |
25 | from models.category import Category
26 | from models.category_manager import CategoryManager
27 | from models.dynamic_content_manager import ContentMode, DynamicContentManager
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
28 | from models.keyboard_manager import KeyboardManager
29 | from models.llm_ngram_service import LLMMissingAPIKeyError, LLMNgramService
   |

desktop_ui\dynamic_config.py:28:1: E402 Module level import not at top of file
   |
26 | from models.category_manager import CategoryManager
27 | from models.dynamic_content_manager import ContentMode, DynamicContentManager
28 | from models.keyboard_manager import KeyboardManager
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
29 | from models.llm_ngram_service import LLMMissingAPIKeyError, LLMNgramService
30 | from models.ngram_analytics_service import NGramAnalyticsService
   |

desktop_ui\dynamic_config.py:29:1: E402 Module level import not at top of file
   |
27 | from models.dynamic_content_manager import ContentMode, DynamicContentManager
28 | from models.keyboard_manager import KeyboardManager
29 | from models.llm_ngram_service import LLMMissingAPIKeyError, LLMNgramService
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
30 | from models.ngram_analytics_service import NGramAnalyticsService
31 | from models.ngram_manager import NGramManager
   |

desktop_ui\dynamic_config.py:30:1: E402 Module level import not at top of file
   |
28 | from models.keyboard_manager import KeyboardManager
29 | from models.llm_ngram_service import LLMMissingAPIKeyError, LLMNgramService
30 | from models.ngram_analytics_service import NGramAnalyticsService
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
31 | from models.ngram_manager import NGramManager
32 | from models.setting import Setting
   |

desktop_ui\dynamic_config.py:31:1: E402 Module level import not at top of file
   |
29 | from models.llm_ngram_service import LLMMissingAPIKeyError, LLMNgramService
30 | from models.ngram_analytics_service import NGramAnalyticsService
31 | from models.ngram_manager import NGramManager
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
32 | from models.setting import Setting
33 | from models.setting_manager import SettingManager
   |

desktop_ui\dynamic_config.py:32:1: E402 Module level import not at top of file
   |
30 | from models.ngram_analytics_service import NGramAnalyticsService
31 | from models.ngram_manager import NGramManager
32 | from models.setting import Setting
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
33 | from models.setting_manager import SettingManager
34 | from models.snippet import Snippet
   |

desktop_ui\dynamic_config.py:33:1: E402 Module level import not at top of file
   |
31 | from models.ngram_manager import NGramManager
32 | from models.setting import Setting
33 | from models.setting_manager import SettingManager
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
34 | from models.snippet import Snippet
35 | from models.snippet_manager import SnippetManager
   |

desktop_ui\dynamic_config.py:34:1: E402 Module level import not at top of file
   |
32 | from models.setting import Setting
33 | from models.setting_manager import SettingManager
34 | from models.snippet import Snippet
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
35 | from models.snippet_manager import SnippetManager
36 | from models.user_manager import UserManager
   |

desktop_ui\dynamic_config.py:35:1: E402 Module level import not at top of file
   |
33 | from models.setting_manager import SettingManager
34 | from models.snippet import Snippet
35 | from models.snippet_manager import SnippetManager
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
36 | from models.user_manager import UserManager
   |

desktop_ui\dynamic_config.py:36:1: E402 Module level import not at top of file
   |
34 | from models.snippet import Snippet
35 | from models.snippet_manager import SnippetManager
36 | from models.user_manager import UserManager
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
   |

desktop_ui\dynamic_config.py:77:89: E501 Line too long (96 > 88)
   |
75 |             self.keyboard_manager = KeyboardManager(db_manager)
76 |             self.ngram_manager = NGramManager(db_manager)
77 |             self.ngram_analytics_service = NGramAnalyticsService(db_manager, self.ngram_manager)
   |                                                                                         ^^^^^^^^ E501
78 |             self.category_manager = CategoryManager(db_manager)
79 |             self.snippet_manager = SnippetManager(db_manager)
   |

desktop_ui\dynamic_config.py:87:89: E501 Line too long (97 > 88)
   |
85 |                     self.current_user = self.user_manager.get_user_by_id(user_id)
86 |                 if keyboard_id:
87 |                     self.current_keyboard = self.keyboard_manager.get_keyboard_by_id(keyboard_id)
   |                                                                                         ^^^^^^^^^ E501
88 |             except Exception as e:
89 |                 # Log the error but continue - status bar will show limited info
   |

desktop_ui\dynamic_config.py:94:89: E501 Line too long (92 > 88)
   |
92 |         self.setWindowTitle("Practice Weak Points")
93 |         self.setMinimumSize(700, 600)
94 |         self.setWindowFlags(self.windowFlags() & ~Qt.WindowType.WindowContextHelpButtonHint)
   |                                                                                         ^^^^ E501
95 |
96 |         self._setup_ui()
   |

desktop_ui\dynamic_config.py:110:89: E501 Line too long (93 > 88)
    |
108 |         if self.current_user:
109 |             # Use first_name and surname instead of username
110 |             user_name = f"{self.current_user.first_name} {self.current_user.surname}".strip()
    |                                                                                         ^^^^^ E501
111 |             user_display = f"User: {user_name or self.current_user.user_id}"
112 |             status_text += user_display
    |

desktop_ui\dynamic_config.py:119:89: E501 Line too long (100 > 88)
    |
117 |             if status_text:
118 |                 status_text += " | "
119 |             keyboard_name = self.current_keyboard.keyboard_name or self.current_keyboard.keyboard_id
    |                                                                                         ^^^^^^^^^^^^ E501
120 |             keyboard_display = f"Keyboard: {keyboard_name}"
121 |             status_text += keyboard_display
    |

desktop_ui\dynamic_config.py:216:89: E501 Line too long (104 > 88)
    |
214 |         analysis_layout = QtWidgets.QVBoxLayout(analysis_group)
215 |
216 |         # Will initially create with 5 rows, but columns and headers will be set in _load_ngram_analysis
    |                                                                                         ^^^^^^^^^^^^^^^^ E501
217 |         # 5 rows, up to 4 columns for speed focus
218 |         self.ngram_table = QtWidgets.QTableWidget(5, 4)
    |

desktop_ui\dynamic_config.py:233:89: E501 Line too long (97 > 88)
    |
231 |         self.content_preview = QtWidgets.QTextEdit()
232 |         self.content_preview.setReadOnly(True)
233 |         self.content_preview.setPlaceholderText("Generated practice content will appear here...")
    |                                                                                         ^^^^^^^^^ E501
234 |
235 |         # Button box
    |

desktop_ui\dynamic_config.py:244:89: E501 Line too long (89 > 88)
    |
243 |         # Set OK button text to "Start Drill"
244 |         start_drill_btn = button_box.button(QtWidgets.QDialogButtonBox.StandardButton.Ok)
    |                                                                                         ^ E501
245 |         start_drill_btn.setText("Start Drill")
246 |         start_drill_btn.setEnabled(False)  # Disabled until content is generated
    |

desktop_ui\dynamic_config.py:262:89: E501 Line too long (94 > 88)
    |
261 |         selected_size = self.ngram_size.currentText()
262 |         # If "All" is selected, use a list of sizes from 2-10, otherwise use the selected size
    |                                                                                         ^^^^^^ E501
263 |         if selected_size == "All":
264 |             ngram_sizes = list(range(2, 11))
    |

desktop_ui\dynamic_config.py:313:89: E501 Line too long (97 > 88)
    |
311 |                     self.ngram_table.setRowCount(len(ngram_stats))
312 |                     for row, stats in enumerate(ngram_stats):
313 |                         self.ngram_table.setItem(row, 0, QtWidgets.QTableWidgetItem(stats.ngram))
    |                                                                                         ^^^^^^^^^ E501
314 |                         self.ngram_table.setItem(
315 |                             row, 1, QtWidgets.QTableWidgetItem(f"{stats.avg_speed:.2f}")
    |

desktop_ui\dynamic_config.py:318:89: E501 Line too long (92 > 88)
    |
316 |                         )
317 |                         self.ngram_table.setItem(
318 |                             row, 2, QtWidgets.QTableWidgetItem(f"{stats.total_occurrences}")
    |                                                                                         ^^^^ E501
319 |                         )
320 |                         self.ngram_table.setItem(
    |

desktop_ui\dynamic_config.py:321:89: E501 Line too long (90 > 88)
    |
319 |                         )
320 |                         self.ngram_table.setItem(
321 |                             row, 3, QtWidgets.QTableWidgetItem(f"{stats.ngram_score:.2f}")
    |                                                                                         ^^ E501
322 |                         )
323 |                 else:
    |

desktop_ui\dynamic_config.py:326:89: E501 Line too long (106 > 88)
    |
324 |                     # Show message when no data is available
325 |                     self.ngram_table.setRowCount(1)
326 |                     self.ngram_table.setItem(0, 0, QtWidgets.QTableWidgetItem("No n-gram data available"))
    |                                                                                         ^^^^^^^^^^^^^^^^^^ E501
327 |                     self.ngram_table.setItem(0, 1, QtWidgets.QTableWidgetItem("Complete some typing sessions first"))
328 |                     self.ngram_table.setItem(0, 2, QtWidgets.QTableWidgetItem("-"))
    |

desktop_ui\dynamic_config.py:327:89: E501 Line too long (117 > 88)
    |
325 |                     self.ngram_table.setRowCount(1)
326 |                     self.ngram_table.setItem(0, 0, QtWidgets.QTableWidgetItem("No n-gram data available"))
327 |                     self.ngram_table.setItem(0, 1, QtWidgets.QTableWidgetItem("Complete some typing sessions first"))
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
328 |                     self.ngram_table.setItem(0, 2, QtWidgets.QTableWidgetItem("-"))
329 |                     self.ngram_table.setItem(0, 3, QtWidgets.QTableWidgetItem("-"))
    |

desktop_ui\dynamic_config.py:340:89: E501 Line too long (92 > 88)
    |
338 |                 included_keys = list(included_keys_text) if included_keys_text else None
339 |
340 |                 # Get the specified number of most error-prone n-grams of the specified size
    |                                                                                         ^^^^ E501
341 |                 try:
342 |                     ngram_stats = self.ngram_analytics_service.error_n(
    |

desktop_ui\dynamic_config.py:357:89: E501 Line too long (92 > 88)
    |
355 |                 size_info = "various sizes" if selected_size == "All" else selected_size
356 |                 print(
357 |                     f"Retrieved {len(ngram_stats)} error-prone n-grams of size {size_info} "
    |                                                                                         ^^^^ E501
358 |                     f"(requested {top_n})"
359 |                 )
    |

desktop_ui\dynamic_config.py:365:89: E501 Line too long (97 > 88)
    |
363 |                     self.ngram_table.setRowCount(len(ngram_stats))
364 |                     for row, stats in enumerate(ngram_stats):
365 |                         self.ngram_table.setItem(row, 0, QtWidgets.QTableWidgetItem(stats.ngram))
    |                                                                                         ^^^^^^^^^ E501
366 |                         self.ngram_table.setItem(
367 |                             row, 1, QtWidgets.QTableWidgetItem(f"{stats.total_occurrences}")
    |

desktop_ui\dynamic_config.py:367:89: E501 Line too long (92 > 88)
    |
365 |                         self.ngram_table.setItem(row, 0, QtWidgets.QTableWidgetItem(stats.ngram))
366 |                         self.ngram_table.setItem(
367 |                             row, 1, QtWidgets.QTableWidgetItem(f"{stats.total_occurrences}")
    |                                                                                         ^^^^ E501
368 |                         )
369 |                 else:
    |

desktop_ui\dynamic_config.py:376:89: E501 Line too long (95 > 88)
    |
374 |                     )
375 |                     self.ngram_table.setItem(
376 |                         0, 1, QtWidgets.QTableWidgetItem("Complete some typing sessions first")
    |                                                                                         ^^^^^^^ E501
377 |                     )
    |

desktop_ui\dynamic_config.py:385:89: E501 Line too long (100 > 88)
    |
383 |             print(f"Error in _load_ngram_analysis: {error_details}")
384 |             QtWidgets.QMessageBox.warning(
385 |                 self, "Error Loading N-grams", f"Could not load n-gram analysis.\n\nError: {str(e)}"
    |                                                                                         ^^^^^^^^^^^^ E501
386 |             )
    |

desktop_ui\dynamic_config.py:477:89: E501 Line too long (91 > 88)
    |
475 |             button_box = self.findChild(QtWidgets.QDialogButtonBox)
476 |             if button_box:
477 |                 start_btn = button_box.button(QtWidgets.QDialogButtonBox.StandardButton.Ok)
    |                                                                                         ^^^ E501
478 |                 if start_btn:
479 |                     start_btn.setEnabled(True)
    |

desktop_ui\dynamic_config.py:490:89: E501 Line too long (90 > 88)
    |
488 |         except Exception as e:
489 |             QtWidgets.QMessageBox.critical(
490 |                 self, "Generation Error", f"Failed to generate practice content: {str(e)}"
    |                                                                                         ^^ E501
491 |             )
    |

desktop_ui\dynamic_config.py:498:89: E501 Line too long (97 > 88)
    |
496 |         if not self.generated_content:
497 |             QtWidgets.QMessageBox.warning(
498 |                 self, "No Content", "Please generate practice content before starting the drill."
    |                                                                                         ^^^^^^^^^ E501
499 |             )
500 |             return
    |

desktop_ui\graphql_client.py:14:9: ANN204 Missing return type annotation for special method `__init__`
   |
13 | class GraphQLClient:
14 |     def __init__(self, api_url: str = API_URL):
   |         ^^^^^^^^ ANN204
15 |         self.api_url = api_url
   |
   = help: Add return type annotation: `None`

desktop_ui\library_main.py:63:89: E501 Line too long (96 > 88)
   |
61 |             self.db_manager = db_manager
62 |         else:
63 |             db_path = os.path.join(os.path.dirname(os.path.dirname(__file__)), "typing_data.db")
   |                                                                                         ^^^^^^^^ E501
64 |             self.db_manager = DatabaseManager(db_path)
65 |         self.category_manager = CategoryManager(self.db_manager)
   |

desktop_ui\library_main.py:98:89: E501 Line too long (90 > 88)
    |
 96 |         self.categoryList.setObjectName("CategoryList")
 97 |         self.categoryList.setSizePolicy(
 98 |             QtWidgets.QSizePolicy.Policy.Expanding, QtWidgets.QSizePolicy.Policy.Expanding
    |                                                                                         ^^ E501
 99 |         )
100 |         cat_layout.addWidget(self.categoryList)
    |

desktop_ui\library_main.py:133:89: E501 Line too long (90 > 88)
    |
131 |         self.snippetList.setObjectName("SnippetList")
132 |         self.snippetList.setSizePolicy(
133 |             QtWidgets.QSizePolicy.Policy.Expanding, QtWidgets.QSizePolicy.Policy.Expanding
    |                                                                                         ^^ E501
134 |         )
135 |         snip_layout.addWidget(self.snippetList)
    |

desktop_ui\library_main.py:168:89: E501 Line too long (104 > 88)
    |
167 |     def load_data(self) -> None:
168 |         """Load categories and snippets into the UI. Ensures at least one category and snippet exist."""
    |                                                                                         ^^^^^^^^^^^^^^^^ E501
169 |         try:
170 |             self.categories = self.category_manager.list_all_categories()
    |

desktop_ui\library_main.py:174:89: E501 Line too long (98 > 88)
    |
172 |             if not self.categories:
173 |                 default_cat = Category(
174 |                     category_name="Default Category", description="Default auto-created category."
    |                                                                                         ^^^^^^^^^^ E501
175 |                 )
176 |                 self.category_manager.save_category(default_cat)
    |

desktop_ui\library_main.py:221:89: E501 Line too long (93 > 88)
    |
219 |             str(self.selected_category.category_id)
220 |         )
221 |         filtered = [s for s in all_snippets if search_text.lower() in s.snippet_name.lower()]
    |                                                                                         ^^^^^ E501
222 |         self.snippetList.clear()
223 |         for snip in filtered:
    |

desktop_ui\library_main.py:316:89: E501 Line too long (95 > 88)
    |
314 |             "Delete Category",
315 |             f"Delete category '{cat.category_name}' and all its snippets?",
316 |             QtWidgets.QMessageBox.StandardButton.Yes | QtWidgets.QMessageBox.StandardButton.No,
    |                                                                                         ^^^^^^^ E501
317 |         )
318 |         if confirm != QtWidgets.QMessageBox.StandardButton.Yes:
    |

desktop_ui\library_main.py:339:89: E501 Line too long (90 > 88)
    |
337 |                 cat_id = str(self.selected_category.category_id)
338 |                 snippet = Snippet(
339 |                     category_id=cat_id, snippet_name=name, content=content, description=""
    |                                                                                         ^^ E501
340 |                 )
341 |                 self.snippet_manager.save_snippet(snippet)
    |

desktop_ui\library_main.py:382:89: E501 Line too long (95 > 88)
    |
380 |             "Delete Snippet",
381 |             f"Delete snippet '{snippet.snippet_name}'?",
382 |             QtWidgets.QMessageBox.StandardButton.Yes | QtWidgets.QMessageBox.StandardButton.No,
    |                                                                                         ^^^^^^^ E501
383 |         )
384 |         if confirm != QtWidgets.QMessageBox.StandardButton.Yes:
    |

desktop_ui\main_menu.py:44:89: E501 Line too long (96 > 88)
   |
42 |         self.testing_mode = testing_mode
43 |         if db_path is None:
44 |             db_path = os.path.join(os.path.dirname(os.path.dirname(__file__)), "typing_data.db")
   |                                                                                         ^^^^^^^^ E501
45 |         self.db_manager = DatabaseManager(db_path, connection_type=connection_type)
46 |         self.db_manager.init_tables()  # Ensure all tables are created/initialized
   |

desktop_ui\main_menu.py:119:89: E501 Line too long (93 > 88)
    |
117 |         if normal:
118 |             return (
119 |                 "QPushButton { background-color: #0d6efd; color: white; border-radius: 5px; "
    |                                                                                         ^^^^^ E501
120 |                 "font-size: 14px; }"
121 |                 "QPushButton:pressed { background-color: #0b5ed7; }"
    |

desktop_ui\main_menu.py:125:89: E501 Line too long (93 > 88)
    |
123 |         else:
124 |             return (
125 |                 "QPushButton { background-color: #f0f0f0; color: black; border-radius: 5px; "
    |                                                                                         ^^^^^ E501
126 |                 "font-size: 14px; }"
127 |             )
    |

desktop_ui\main_menu.py:192:89: E501 Line too long (89 > 88)
    |
190 |             users = self.user_manager.list_all_users()
191 |             for user in users:
192 |                 display_text = f"{user.first_name} {user.surname} ({user.email_address})"
    |                                                                                         ^ E501
193 |                 self.user_combo.addItem(display_text, user)
    |

desktop_ui\main_menu.py:200:89: E501 Line too long (98 > 88)
    |
198 |             else:
199 |                 QtWidgets.QMessageBox.warning(
200 |                     self, "No Users Found", "Please create a user before starting a typing drill."
    |                                                                                         ^^^^^^^^^^ E501
201 |                 )
202 |         except (AttributeError, TypeError) as e:
    |

desktop_ui\main_menu.py:252:89: E501 Line too long (93 > 88)
    |
251 |                 this_setting = Setting(
252 |                     setting_type_id="LSTKBD", setting_value=kbd_id, related_entity_id=user_id
    |                                                                                         ^^^^^ E501
253 |                 )
254 |                 self.setting_manager.save_setting(this_setting)
    |

desktop_ui\main_menu.py:264:89: E501 Line too long (94 > 88)
    |
263 |     def _load_last_used_keyboard(self) -> None:
264 |         """Load the last used keyboard for the selected user using SettingManager (LSTKBD)."""
    |                                                                                         ^^^^^^ E501
265 |         from models.setting_manager import SettingNotFound
    |

desktop_ui\main_menu.py:271:89: E501 Line too long (96 > 88)
    |
269 |         try:
270 |             # related_entity_id is user_id, value is keyboard_id
271 |             setting = self.setting_manager.get_setting("LSTKBD", str(self.current_user.user_id))
    |                                                                                         ^^^^^^^^ E501
272 |             last_kbd_id = setting.setting_value
273 |             # Try to find this keyboard in the combo
    |

desktop_ui\main_menu.py:298:89: E501 Line too long (94 > 88)
    |
297 |     def _load_keyboards_for_user(self, user_id: str) -> None:
298 |         """Load keyboards for the selected user and select last used keyboard if available."""
    |                                                                                         ^^^^^^ E501
299 |         self.keyboard_combo.clear()
300 |         self.current_keyboard = None
    |

desktop_ui\main_menu.py:313:89: E501 Line too long (93 > 88)
    |
311 |                     self,
312 |                     "No Keyboards Found",
313 |                     "Please create a keyboard for this user before starting a typing drill.",
    |                                                                                         ^^^^^ E501
314 |                 )
315 |             else:
    |

desktop_ui\main_menu.py:330:89: E501 Line too long (96 > 88)
    |
328 |         if not self.current_user or not self.current_user.user_id:
329 |             QtWidgets.QMessageBox.warning(
330 |                 self, "No User Selected", "Please select a user before starting a typing drill."
    |                                                                                         ^^^^^^^^ E501
331 |             )
332 |             return
    |

desktop_ui\main_menu.py:333:89: E501 Line too long (89 > 88)
    |
331 |             )
332 |             return
333 |         if not self.keyboard_combo.isEnabled() or self.keyboard_combo.currentIndex() < 0:
    |                                                                                         ^ E501
334 |             QtWidgets.QMessageBox.warning(
335 |                 self,
    |

desktop_ui\main_menu.py:361:89: E501 Line too long (90 > 88)
    |
359 |         if not self.current_user or not self.current_user.user_id:
360 |             QtWidgets.QMessageBox.warning(
361 |                 self, "No User Selected", "Please select a user before starting practice."
    |                                                                                         ^^ E501
362 |             )
363 |             return
    |

desktop_ui\main_menu.py:364:89: E501 Line too long (89 > 88)
    |
362 |             )
363 |             return
364 |         if not self.keyboard_combo.isEnabled() or self.keyboard_combo.currentIndex() < 0:
    |                                                                                         ^ E501
365 |             QtWidgets.QMessageBox.warning(
366 |                 self, "No Keyboard Selected", "Please select a keyboard before starting practice."
    |

desktop_ui\main_menu.py:366:89: E501 Line too long (98 > 88)
    |
364 |         if not self.keyboard_combo.isEnabled() or self.keyboard_combo.currentIndex() < 0:
365 |             QtWidgets.QMessageBox.warning(
366 |                 self, "No Keyboard Selected", "Please select a keyboard before starting practice."
    |                                                                                         ^^^^^^^^^^ E501
367 |             )
368 |             return
    |

desktop_ui\main_menu.py:372:89: E501 Line too long (98 > 88)
    |
370 |         if not self.current_keyboard or not self.current_keyboard.keyboard_id:
371 |             QtWidgets.QMessageBox.warning(
372 |                 self, "No Keyboard Selected", "Please select a keyboard before starting practice."
    |                                                                                         ^^^^^^^^^^ E501
373 |             )
374 |             return
    |

desktop_ui\main_menu.py:387:89: E501 Line too long (93 > 88)
    |
385 |         except Exception as e:
386 |             QtWidgets.QMessageBox.critical(
387 |                 self, "Error", f"Could not open Practice Weak Points configuration: {str(e)}"
    |                                                                                         ^^^^^ E501
388 |             )
    |

desktop_ui\main_menu.py:401:89: E501 Line too long (92 > 88)
    |
399 |         if not self.current_user or not self.current_user.user_id:
400 |             QtWidgets.QMessageBox.warning(
401 |                 self, "No User Selected", "Please select a user before viewing the heatmap."
    |                                                                                         ^^^^ E501
402 |             )
403 |             return
    |

desktop_ui\main_menu.py:404:89: E501 Line too long (89 > 88)
    |
402 |             )
403 |             return
404 |         if not self.keyboard_combo.isEnabled() or self.keyboard_combo.currentIndex() < 0:
    |                                                                                         ^ E501
405 |             QtWidgets.QMessageBox.warning(
406 |                 self,
    |

desktop_ui\main_menu.py:454:89: E501 Line too long (95 > 88)
    |
452 |             "Reset Session Details",
453 |             "This will remove all session details - are you sure?",
454 |             QtWidgets.QMessageBox.StandardButton.Yes | QtWidgets.QMessageBox.StandardButton.No,
    |                                                                                         ^^^^^^^ E501
455 |             QtWidgets.QMessageBox.StandardButton.No,  # Default is No
456 |         )
    |

desktop_ui\main_menu.py:476:89: E501 Line too long (89 > 88)
    |
474 |         except Exception as e:
475 |             QtWidgets.QMessageBox.critical(
476 |                 self, "Error", f"An error occurred while removing session data: {str(e)}"
    |                                                                                         ^ E501
477 |             )
    |

desktop_ui\main_menu.py:518:89: E501 Line too long (97 > 88)
    |
517 |             dialog = QueryScreen(
518 |                 db_manager=self.db_manager, user_id=user_id, keyboard_id=keyboard_id, parent=self
    |                                                                                         ^^^^^^^^^ E501
519 |             )
520 |             dialog.exec()
    |

desktop_ui\main_menu.py:527:89: E501 Line too long (89 > 88)
    |
525 |         except Exception as e:
526 |             QtWidgets.QMessageBox.critical(
527 |                 self, "SQL Query Error", f"Could not open the SQL Query Screen: {str(e)}"
    |                                                                                         ^ E501
528 |             )
    |

desktop_ui\main_menu.py:531:89: E501 Line too long (95 > 88)
    |
530 |     def manage_users_keyboards(self) -> None:
531 |         """Open the Users and Keyboards management dialog and refresh dropdowns when closed."""
    |                                                                                         ^^^^^^^ E501
532 |         try:
533 |             dialog = UsersAndKeyboards(db_manager=self.db_manager, parent=self)
    |

desktop_ui\modern_dialogs.py:134:89: E501 Line too long (92 > 88)
    |
132 |     }
133 |     QPushButton {
134 |         background: qlineargradient(x1:0, y1:0, x2:0, y2:1, stop:0 #e8e8ef, stop:1 #d1d1e0);
    |                                                                                         ^^^^ E501
135 |         border-radius: 10px;
136 |         border: 1px solid #bfc8d6;
    |

desktop_ui\ngram_heatmap_screen.py:90:89: E501 Line too long (90 > 88)
   |
88 |         # User and keyboard info
89 |         info_layout = QtWidgets.QHBoxLayout()
90 |         user_label = QtWidgets.QLabel(f"User: {self.user.first_name} {self.user.surname}")
   |                                                                                         ^^ E501
91 |         keyboard_label = QtWidgets.QLabel(f"Keyboard: {self.keyboard.keyboard_name}")
92 |         info_layout.addWidget(user_label)
   |

desktop_ui\ngram_heatmap_screen.py:108:89: E501 Line too long (96 > 88)
    |
106 |         refresh_btn = QtWidgets.QPushButton("Refresh Data")
107 |         refresh_btn.clicked.connect(self.refresh_data)
108 |         self.button_box.addButton(refresh_btn, QtWidgets.QDialogButtonBox.ButtonRole.ActionRole)
    |                                                                                         ^^^^^^^^ E501
109 |
110 |         export_btn = QtWidgets.QPushButton("Export Data")
    |

desktop_ui\ngram_heatmap_screen.py:112:89: E501 Line too long (95 > 88)
    |
110 |         export_btn = QtWidgets.QPushButton("Export Data")
111 |         export_btn.clicked.connect(self.export_data)
112 |         self.button_box.addButton(export_btn, QtWidgets.QDialogButtonBox.ButtonRole.ActionRole)
    |                                                                                         ^^^^^^^ E501
113 |
114 |         close_btn = QtWidgets.QPushButton("Close")
    |

desktop_ui\ngram_heatmap_screen.py:116:89: E501 Line too long (94 > 88)
    |
114 |         close_btn = QtWidgets.QPushButton("Close")
115 |         close_btn.clicked.connect(self.accept)
116 |         self.button_box.addButton(close_btn, QtWidgets.QDialogButtonBox.ButtonRole.RejectRole)
    |                                                                                         ^^^^^^ E501
117 |
118 |         layout.addWidget(self.button_box)
    |

desktop_ui\ngram_heatmap_screen.py:170:89: E501 Line too long (89 > 88)
    |
168 |         control_layout.addWidget(QtWidgets.QLabel("Sort by:"), 1, 2)
169 |         self.sort_combo = QtWidgets.QComboBox()
170 |         self.sort_combo.addItems(["N-gram Text", "Speed", "Sample Count", "Performance"])
    |                                                                                         ^ E501
171 |         self.sort_combo.setCurrentText("Speed")
172 |         self.sort_combo.currentTextChanged.connect(self.apply_filters)
    |

desktop_ui\ngram_heatmap_screen.py:203:89: E501 Line too long (93 > 88)
    |
201 |         header.setStretchLastSection(True)
202 |         for i in range(5):
203 |             header.setSectionResizeMode(i, QtWidgets.QHeaderView.ResizeMode.ResizeToContents)
    |                                                                                         ^^^^^ E501
204 |
205 |         heatmap_layout.addWidget(self.heatmap_table)
    |

desktop_ui\ngram_heatmap_screen.py:222:89: E501 Line too long (97 > 88)
    |
220 |             legend_item = QtWidgets.QLabel(label)
221 |             legend_item.setStyleSheet(
222 |                 f"background-color: {color}; padding: 2px 8px; border-radius: 3px; color: white;"
    |                                                                                         ^^^^^^^^^ E501
223 |             )
224 |             legend_layout.addWidget(legend_item)
    |

desktop_ui\ngram_heatmap_screen.py:276:9: F841 Local variable `min_speed` is assigned to but never used
    |
275 |         # Get filter values
276 |         min_speed = self.speed_min_spin.value()
    |         ^^^^^^^^^ F841
277 |         max_speed = self.speed_max_spin.value()
278 |         ngram_size = self.ngram_size_combo.currentData()
    |
    = help: Remove assignment to unused variable `min_speed`

desktop_ui\ngram_heatmap_screen.py:277:9: F841 Local variable `max_speed` is assigned to but never used
    |
275 |         # Get filter values
276 |         min_speed = self.speed_min_spin.value()
277 |         max_speed = self.speed_max_spin.value()
    |         ^^^^^^^^^ F841
278 |         ngram_size = self.ngram_size_combo.currentData()
    |
    = help: Remove assignment to unused variable `max_speed`

desktop_ui\ngram_heatmap_screen.py:278:9: F841 Local variable `ngram_size` is assigned to but never used
    |
276 |         min_speed = self.speed_min_spin.value()
277 |         max_speed = self.speed_max_spin.value()
278 |         ngram_size = self.ngram_size_combo.currentData()
    |         ^^^^^^^^^^ F841
279 |
280 |         # Update display
    |
    = help: Remove assignment to unused variable `ngram_size`

desktop_ui\ngram_heatmap_screen.py:304:89: E501 Line too long (95 > 88)
    |
303 |         # Get save file path
304 |         default_filename = f"ngram_heatmap_{self.user.user_id}_{self.keyboard.keyboard_id}.csv"
    |                                                                                         ^^^^^^^ E501
305 |         file_path, _ = QtWidgets.QFileDialog.getSaveFileName(
306 |             self, "Export Heatmap Data", default_filename, "CSV files (*.csv)"
    |

desktop_ui\ngram_heatmap_screen.py:371:89: E501 Line too long (92 > 88)
    |
369 |         elif sort_by == "Performance":
370 |             perf_order = {"green": 1, "amber": 2, "grey": 3}
371 |             self.filtered_data.sort(key=lambda x: perf_order.get(x.performance_category, 4))
    |                                                                                         ^^^^ E501
372 |
373 |         self.update_table()
    |

desktop_ui\ngram_heatmap_screen.py:381:89: E501 Line too long (91 > 88)
    |
379 |         for row, item in enumerate(self.filtered_data):
380 |             # N-gram text
381 |             self.heatmap_table.setItem(row, 0, QtWidgets.QTableWidgetItem(item.ngram_text))
    |                                                                                         ^^^ E501
382 |
383 |             # Size
    |

desktop_ui\ngram_heatmap_screen.py:384:89: E501 Line too long (96 > 88)
    |
383 |             # Size
384 |             self.heatmap_table.setItem(row, 1, QtWidgets.QTableWidgetItem(str(item.ngram_size)))
    |                                                                                         ^^^^^^^^ E501
385 |
386 |             # Average speed
    |

desktop_ui\ngram_heatmap_screen.py:388:89: E501 Line too long (89 > 88)
    |
386 |             # Average speed
387 |             speed_item = QtWidgets.QTableWidgetItem(f"{item.decaying_average_ms:.1f}")
388 |             speed_item.setData(QtCore.Qt.ItemDataRole.UserRole, item.decaying_average_ms)
    |                                                                                         ^ E501
389 |             self.heatmap_table.setItem(row, 2, speed_item)
    |

desktop_ui\ngram_llm_screen.py:22:32: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `parent`
   |
21 | class NgramLLMScreen(QWidget):
22 |     def __init__(self, parent: Optional[Any] = None) -> None:
   |                                ^^^^^^^^^^^^^ ANN401
23 |         super().__init__(parent)
24 |         self.setWindowTitle("LLM N-Gram Word Generator")
   |

desktop_ui\query_screen.py:4:89: E501 Line too long (96 > 88)
  |
2 | SQL Query Screen for AI Typing Trainer (PySide6)
3 |
4 | This module provides a GUI for executing custom SQL queries on the database and viewing results.
  |                                                                                         ^^^^^^^^ E501
5 | """
  |

desktop_ui\query_screen.py:7:1: I001 [*] Import block is un-sorted or un-formatted
   |
 5 |   """
 6 |
 7 | / from typing import Any, Dict, List, Optional
 8 | |
 9 | | from PySide6 import QtWidgets
10 | | from PySide6.QtWidgets import (
11 | |     QDialog,
12 | |     QGridLayout,
13 | |     QHBoxLayout,
14 | |     QHeaderView,
15 | |     QLabel,
16 | |     QLineEdit,
17 | |     QMessageBox,
18 | |     QPushButton,
19 | |     QPlainTextEdit,
20 | |     QTableWidget,
21 | |     QTableWidgetItem,
22 | |     QVBoxLayout,
23 | | )
24 | |
25 | | from db.database_manager import DatabaseManager
   | |_______________________________________________^ I001
   |
   = help: Organize imports

desktop_ui\query_screen.py:110:89: E501 Line too long (99 > 88)
    |
109 |         self.results_table = QTableWidget()
110 |         self.results_table.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers)  # Read-only
    |                                                                                         ^^^^^^^^^^^ E501
111 |
112 |         # Set horizontal header to stretch
    |

desktop_ui\query_screen.py:138:89: E501 Line too long (94 > 88)
    |
137 |             if not results:
138 |                 self.status_label.setText("Query executed successfully. No results returned.")
    |                                                                                         ^^^^^^ E501
139 |                 self.results_table.setRowCount(0)
140 |                 self.results_table.setColumnCount(0)
    |

desktop_ui\query_screen.py:145:89: E501 Line too long (100 > 88)
    |
143 |             # Process results
144 |             self._populate_results_table(results)
145 |             self.status_label.setText(f"Query executed successfully. {len(results)} rows returned.")
    |                                                                                         ^^^^^^^^^^^^ E501
146 |
147 |         except Exception as e:
    |

desktop_ui\scaffold_add_speed_summary_for_session.py:2:89: E501 Line too long (94 > 88)
  |
1 | """
2 | ScaffoldAddSpeedSummaryForSession UI form for triggering speed summary for a specific session.
  |                                                                                         ^^^^^^ E501
3 |
4 | This form provides an interface to run the AddSpeedSummaryForSession method
  |

desktop_ui\scaffold_add_speed_summary_for_session.py:15:1: I001 [*] Import block is un-sorted or un-formatted
   |
13 |   sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), "..")))
14 |
15 | / from PySide6 import QtCore, QtWidgets
16 | | from PySide6.QtCore import QThread, Signal
17 | | from PySide6.QtWidgets import QMessageBox, QProgressBar, QTextEdit, QLineEdit
18 | |
19 | | from db.database_manager import ConnectionType, DatabaseManager
20 | | from models.ngram_analytics_service import NGramAnalyticsService
21 | | from models.ngram_manager import NGramManager
   | |_____________________________________________^ I001
   |
   = help: Organize imports

desktop_ui\scaffold_add_speed_summary_for_session.py:15:21: F401 [*] `PySide6.QtCore` imported but unused
   |
13 | sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), "..")))
14 |
15 | from PySide6 import QtCore, QtWidgets
   |                     ^^^^^^ F401
16 | from PySide6.QtCore import QThread, Signal
17 | from PySide6.QtWidgets import QMessageBox, QProgressBar, QTextEdit, QLineEdit
   |
   = help: Remove unused import: `PySide6.QtCore`

desktop_ui\scaffold_add_speed_summary_for_session.py:30:9: ANN204 Missing return type annotation for special method `__init__`
   |
28 |     error = Signal(str)      # Signal with error message
29 |     
30 |     def __init__(self, analytics_service: NGramAnalyticsService, session_id: str):
   |         ^^^^^^^^ ANN204
31 |         super().__init__()
32 |         self.analytics_service = analytics_service
   |
   = help: Add return type annotation: `None`

desktop_ui\scaffold_add_speed_summary_for_session.py:35:9: ANN201 Missing return type annotation for public function `run`
   |
33 |         self.session_id = session_id
34 |     
35 |     def run(self):
   |         ^^^ ANN201
36 |         try:
37 |             result = self.analytics_service.add_speed_summary_for_session(self.session_id)
   |
   = help: Add return type annotation: `None`

desktop_ui\scaffold_add_speed_summary_for_session.py:37:89: E501 Line too long (90 > 88)
   |
35 |     def run(self):
36 |         try:
37 |             result = self.analytics_service.add_speed_summary_for_session(self.session_id)
   |                                                                                         ^^ E501
38 |             self.finished.emit(result)
39 |         except Exception as e:
   |

desktop_ui\scaffold_add_speed_summary_for_session.py:62:89: E501 Line too long (96 > 88)
   |
60 |         # Initialize database connection
61 |         if db_path is None:
62 |             db_path = os.path.join(os.path.dirname(os.path.dirname(__file__)), "typing_data.db")
   |                                                                                         ^^^^^^^^ E501
63 |         
64 |         self.db_manager = DatabaseManager(db_path, connection_type=connection_type)
   |

desktop_ui\scaffold_add_speed_summary_for_session.py:69:89: E501 Line too long (91 > 88)
   |
67 |         # Initialize services
68 |         self.ngram_manager = NGramManager(self.db_manager)
69 |         self.analytics_service = NGramAnalyticsService(self.db_manager, self.ngram_manager)
   |                                                                                         ^^^ E501
70 |         
71 |         self.worker = None
   |

desktop_ui\scaffold_add_speed_summary_for_session.py:75:9: ANN201 Missing return type annotation for public function `setup_ui`
   |
73 |         self.load_recent_sessions()
74 |     
75 |     def setup_ui(self):
   |         ^^^^^^^^ ANN201
76 |         """Set up the user interface."""
77 |         layout = QtWidgets.QVBoxLayout(self)
   |
   = help: Add return type annotation: `None`

desktop_ui\scaffold_add_speed_summary_for_session.py:86:89: E501 Line too long (116 > 88)
   |
84 |         # Description
85 |         description = QtWidgets.QLabel(
86 |             "This tool calculates decaying average performance for a specific session using the last 20 sessions.\n"
   |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
87 |             "It updates ngram_speed_summary_curr (merge) and ngram_speed_summary_hist (insert)."
88 |         )
   |

desktop_ui\scaffold_add_speed_summary_for_session.py:87:89: E501 Line too long (96 > 88)
   |
85 |         description = QtWidgets.QLabel(
86 |             "This tool calculates decaying average performance for a specific session using the last 20 sessions.\n"
87 |             "It updates ngram_speed_summary_curr (merge) and ngram_speed_summary_hist (insert)."
   |                                                                                         ^^^^^^^^ E501
88 |         )
89 |         description.setWordWrap(True)
   |

desktop_ui\scaffold_add_speed_summary_for_session.py:121:89: E501 Line too long (122 > 88)
    |
119 |         self.process_button = QtWidgets.QPushButton("Process Session")
120 |         self.process_button.setStyleSheet(
121 |             "QPushButton { background-color: #2196F3; color: white; padding: 10px; font-size: 14px; border-radius: 5px; }"
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
122 |             "QPushButton:hover { background-color: #1976D2; }"
123 |             "QPushButton:disabled { background-color: #cccccc; }"
    |

desktop_ui\scaffold_add_speed_summary_for_session.py:131:89: E501 Line too long (107 > 88)
    |
129 |         self.results_text = QTextEdit()
130 |         self.results_text.setReadOnly(True)
131 |         self.results_text.setStyleSheet("background-color: #f5f5f5; border: 1px solid #ddd; padding: 5px;")
    |                                                                                         ^^^^^^^^^^^^^^^^^^^ E501
132 |         layout.addWidget(self.results_text)
    |

desktop_ui\scaffold_add_speed_summary_for_session.py:137:89: E501 Line too long (104 > 88)
    |
135 |         close_button = QtWidgets.QPushButton("Close")
136 |         close_button.setStyleSheet(
137 |             "QPushButton { background-color: #f44336; color: white; padding: 8px; border-radius: 5px; }"
    |                                                                                         ^^^^^^^^^^^^^^^^ E501
138 |             "QPushButton:hover { background-color: #da190b; }"
139 |         )
    |

desktop_ui\scaffold_add_speed_summary_for_session.py:143:9: ANN201 Missing return type annotation for public function `load_recent_sessions`
    |
141 |         layout.addWidget(close_button)
142 |     
143 |     def load_recent_sessions(self):
    |         ^^^^^^^^^^^^^^^^^^^^ ANN201
144 |         """Load recent sessions into the dropdown."""
145 |         try:
    |
    = help: Add return type annotation: `None`

desktop_ui\scaffold_add_speed_summary_for_session.py:157:89: E501 Line too long (128 > 88)
    |
155 |             self.recent_sessions_combo.addItem("Select a session...", "")
156 |             for session in sessions:
157 |                 display_text = f"{session['session_id'][:8]}... ({session['start_time']}) - {session['ms_per_keystroke']:.1f}ms"
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
158 |                 self.recent_sessions_combo.addItem(display_text, session['session_id'])
    |

desktop_ui\scaffold_add_speed_summary_for_session.py:163:9: ANN201 Missing return type annotation for public function `on_session_selected`
    |
161 |             self.results_text.append(f"Error loading sessions: {str(e)}")
162 |     
163 |     def on_session_selected(self, text):
    |         ^^^^^^^^^^^^^^^^^^^ ANN201
164 |         """Handle session selection from dropdown."""
165 |         current_data = self.recent_sessions_combo.currentData()
    |
    = help: Add return type annotation: `None`

desktop_ui\scaffold_add_speed_summary_for_session.py:163:35: ANN001 Missing type annotation for function argument `text`
    |
161 |             self.results_text.append(f"Error loading sessions: {str(e)}")
162 |     
163 |     def on_session_selected(self, text):
    |                                   ^^^^ ANN001
164 |         """Handle session selection from dropdown."""
165 |         current_data = self.recent_sessions_combo.currentData()
    |

desktop_ui\scaffold_add_speed_summary_for_session.py:169:9: ANN201 Missing return type annotation for public function `start_processing`
    |
167 |             self.session_input.setText(current_data)
168 |     
169 |     def start_processing(self):
    |         ^^^^^^^^^^^^^^^^ ANN201
170 |         """Start the processing in a background thread."""
171 |         session_id = self.session_input.text().strip()
    |
    = help: Add return type annotation: `None`

desktop_ui\scaffold_add_speed_summary_for_session.py:188:9: ANN201 Missing return type annotation for public function `on_processing_finished`
    |
186 |         self.worker.start()
187 |     
188 |     def on_processing_finished(self, result: dict):
    |         ^^^^^^^^^^^^^^^^^^^^^^ ANN201
189 |         """Handle successful completion of processing."""
190 |         self.progress_bar.setVisible(False)
    |
    = help: Add return type annotation: `None`

desktop_ui\scaffold_add_speed_summary_for_session.py:196:34: F541 [*] f-string without any placeholders
    |
194 |         curr_updated = result.get('curr_updated', 0)
195 |         
196 |         self.results_text.append(f"\nΓ£à Processing completed successfully!")
    |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ F541
197 |         self.results_text.append(f"≡ƒôè {curr_updated} records updated in ngram_speed_summary_curr")
198 |         self.results_text.append(f"≡ƒôê {hist_inserted} records inserted into ngram_speed_summary_hist")
    |
    = help: Remove extraneous `f` prefix

desktop_ui\scaffold_add_speed_summary_for_session.py:197:88: E501 Line too long (98 > 88)
    |
196 |         self.results_text.append(f"\nΓ£à Processing completed successfully!")
197 |         self.results_text.append(f"≡ƒôè {curr_updated} records updated in ngram_speed_summary_curr")
    |                                                                                         ^^^^^^^^^^ E501
198 |         self.results_text.append(f"≡ƒôê {hist_inserted} records inserted into ngram_speed_summary_hist")
    |

desktop_ui\scaffold_add_speed_summary_for_session.py:198:88: E501 Line too long (102 > 88)
    |
196 |         self.results_text.append(f"\nΓ£à Processing completed successfully!")
197 |         self.results_text.append(f"≡ƒôè {curr_updated} records updated in ngram_speed_summary_curr")
198 |         self.results_text.append(f"≡ƒôê {hist_inserted} records inserted into ngram_speed_summary_hist")
    |                                                                                         ^^^^^^^^^^^^^^ E501
199 |         
200 |         # Show success message
    |

desktop_ui\scaffold_add_speed_summary_for_session.py:209:9: ANN201 Missing return type annotation for public function `on_processing_error`
    |
207 |         )
208 |     
209 |     def on_processing_error(self, error_message: str):
    |         ^^^^^^^^^^^^^^^^^^^ ANN201
210 |         """Handle errors during processing."""
211 |         self.progress_bar.setVisible(False)
    |
    = help: Add return type annotation: `None`

desktop_ui\scaffold_add_speed_summary_for_session.py:214:34: F541 [*] f-string without any placeholders
    |
212 |         self.process_button.setEnabled(True)
213 |         
214 |         self.results_text.append(f"\nΓ¥î Error during processing:")
    |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ F541
215 |         self.results_text.append(f"   {error_message}")
    |
    = help: Remove extraneous `f` prefix

desktop_ui\scaffold_add_speed_summary_for_session.py:224:9: ANN201 Missing return type annotation for public function `closeEvent`
    |
222 |         )
223 |     
224 |     def closeEvent(self, event):
    |         ^^^^^^^^^^ ANN201
225 |         """Handle window close event."""
226 |         if self.worker and self.worker.isRunning():
    |
    = help: Add return type annotation: `None`

desktop_ui\scaffold_add_speed_summary_for_session.py:224:26: ANN001 Missing type annotation for function argument `event`
    |
222 |         )
223 |     
224 |     def closeEvent(self, event):
    |                          ^^^^^ ANN001
225 |         """Handle window close event."""
226 |         if self.worker and self.worker.isRunning():
    |

desktop_ui\scaffold_add_speed_summary_for_session.py:245:5: ANN201 Missing return type annotation for public function `launch_scaffold_add_speed_summary_for_session`
    |
245 | def launch_scaffold_add_speed_summary_for_session():
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
246 |     """Launch the ScaffoldAddSpeedSummaryForSession application."""
247 |     app = QtWidgets.QApplication.instance()
    |
    = help: Add return type annotation: `None`

desktop_ui\scaffold_catchup_speed_summary.py:2:89: E501 Line too long (90 > 88)
  |
1 | """
2 | ScaffoldCatchupSpeedSummary UI form for triggering speed summary catchup for all sessions.
  |                                                                                         ^^ E501
3 |
4 | This form provides an interface to run the CatchupSpeedSummary method
  |

desktop_ui\scaffold_catchup_speed_summary.py:31:9: ANN204 Missing return type annotation for special method `__init__`
   |
29 |     progress = Signal(str)  # Signal for progress updates
30 |
31 |     def __init__(self, analytics_service: NGramAnalyticsService):
   |         ^^^^^^^^ ANN204
32 |         super().__init__()
33 |         self.analytics_service = analytics_service
   |
   = help: Add return type annotation: `None`

desktop_ui\scaffold_catchup_speed_summary.py:35:9: ANN201 Missing return type annotation for public function `run`
   |
33 |         self.analytics_service = analytics_service
34 |
35 |     def run(self):
   |         ^^^ ANN201
36 |         try:
37 |             result = self.analytics_service.catchup_speed_summary()
   |
   = help: Add return type annotation: `None`

desktop_ui\scaffold_catchup_speed_summary.py:52:89: E501 Line too long (99 > 88)
   |
51 |     def __init__(
52 |         self, db_path: Optional[str] = None, connection_type: ConnectionType = ConnectionType.CLOUD
   |                                                                                         ^^^^^^^^^^^ E501
53 |     ) -> None:
54 |         super().__init__()
   |

desktop_ui\scaffold_catchup_speed_summary.py:60:89: E501 Line too long (96 > 88)
   |
58 |         # Initialize database connection
59 |         if db_path is None:
60 |             db_path = os.path.join(os.path.dirname(os.path.dirname(__file__)), "typing_data.db")
   |                                                                                         ^^^^^^^^ E501
61 |
62 |         self.db_manager = DatabaseManager(db_path, connection_type=connection_type)
   |

desktop_ui\scaffold_catchup_speed_summary.py:67:89: E501 Line too long (91 > 88)
   |
65 |         # Initialize services
66 |         self.ngram_manager = NGramManager(self.db_manager)
67 |         self.analytics_service = NGramAnalyticsService(self.db_manager, self.ngram_manager)
   |                                                                                         ^^^ E501
68 |
69 |         self.worker = None
   |

desktop_ui\scaffold_catchup_speed_summary.py:73:9: ANN201 Missing return type annotation for public function `setup_ui`
   |
71 |         self.load_session_stats()
72 |
73 |     def setup_ui(self):
   |         ^^^^^^^^ ANN201
74 |         """Set up the user interface."""
75 |         layout = QtWidgets.QVBoxLayout(self)
   |
   = help: Add return type annotation: `None`

desktop_ui\scaffold_catchup_speed_summary.py:84:89: E501 Line too long (99 > 88)
   |
82 |         # Description
83 |         description = QtWidgets.QLabel(
84 |             "This tool processes all sessions from oldest to newest to catch up speed summaries.\n"
   |                                                                                         ^^^^^^^^^^^ E501
85 |             "It calls AddSpeedSummaryForSession for each session and logs progress with record counts.\n"
86 |             "This may take a while for large datasets."
   |

desktop_ui\scaffold_catchup_speed_summary.py:85:89: E501 Line too long (105 > 88)
   |
83 |         description = QtWidgets.QLabel(
84 |             "This tool processes all sessions from oldest to newest to catch up speed summaries.\n"
85 |             "It calls AddSpeedSummaryForSession for each session and logs progress with record counts.\n"
   |                                                                                         ^^^^^^^^^^^^^^^^^ E501
86 |             "This may take a while for large datasets."
87 |         )
   |

desktop_ui\scaffold_catchup_speed_summary.py:105:89: E501 Line too long (141 > 88)
    |
103 | ΓÇª("Catchup Now")
104 | ΓÇª
105 | ΓÇª0; color: white; padding: 12px; font-size: 14px; border-radius: 5px; font-weight: bold; }"
    |                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
106 | ΓÇª#F57C00; }"
107 | ΓÇªr: #cccccc; }"
    |

desktop_ui\scaffold_catchup_speed_summary.py:116:89: E501 Line too long (117 > 88)
    |
114 |         self.results_text.setReadOnly(True)
115 |         self.results_text.setStyleSheet(
116 |             "background-color: #f5f5f5; border: 1px solid #ddd; padding: 5px; font-family: 'Courier New', monospace;"
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
117 |         )
118 |         layout.addWidget(self.results_text)
    |

desktop_ui\scaffold_catchup_speed_summary.py:126:89: E501 Line too long (104 > 88)
    |
124 |         clear_button = QtWidgets.QPushButton("Clear Log")
125 |         clear_button.setStyleSheet(
126 |             "QPushButton { background-color: #9E9E9E; color: white; padding: 8px; border-radius: 5px; }"
    |                                                                                         ^^^^^^^^^^^^^^^^ E501
127 |             "QPushButton:hover { background-color: #757575; }"
128 |         )
    |

desktop_ui\scaffold_catchup_speed_summary.py:135:89: E501 Line too long (104 > 88)
    |
133 |         close_button = QtWidgets.QPushButton("Close")
134 |         close_button.setStyleSheet(
135 |             "QPushButton { background-color: #f44336; color: white; padding: 8px; border-radius: 5px; }"
    |                                                                                         ^^^^^^^^^^^^^^^^ E501
136 |             "QPushButton:hover { background-color: #da190b; }"
137 |         )
    |

desktop_ui\scaffold_catchup_speed_summary.py:143:9: ANN201 Missing return type annotation for public function `load_session_stats`
    |
141 |         layout.addLayout(button_layout)
142 |
143 |     def load_session_stats(self):
    |         ^^^^^^^^^^^^^^^^^^ ANN201
144 |         """Load and display session statistics."""
145 |         try:
    |
    = help: Add return type annotation: `None`

desktop_ui\scaffold_catchup_speed_summary.py:154:89: E501 Line too long (102 > 88)
    |
152 |             # Get date range
153 |             date_range = self.db_manager.fetchone(
154 |                 "SELECT MIN(start_time) as earliest, MAX(start_time) as latest FROM practice_sessions"
    |                                                                                         ^^^^^^^^^^^^^^ E501
155 |             )
    |

desktop_ui\scaffold_catchup_speed_summary.py:172:9: ANN201 Missing return type annotation for public function `start_catchup`
    |
170 |             self.catchup_button.setEnabled(False)
171 |
172 |     def start_catchup(self):
    |         ^^^^^^^^^^^^^ ANN201
173 |         """Start the catchup process in a background thread."""
174 |         reply = QMessageBox.question(
    |
    = help: Add return type annotation: `None`

desktop_ui\scaffold_catchup_speed_summary.py:199:9: ANN201 Missing return type annotation for public function `on_catchup_finished`
    |
197 |         self.worker.start()
198 |
199 |     def on_catchup_finished(self, result: dict):
    |         ^^^^^^^^^^^^^^^^^^^ ANN201
200 |         """Handle successful completion of catchup."""
201 |         self.progress_bar.setVisible(False)
    |
    = help: Add return type annotation: `None`

desktop_ui\scaffold_catchup_speed_summary.py:211:88: E501 Line too long (97 > 88)
    |
209 |         self.results_text.append("\n" + "=" * 60)
210 |         self.results_text.append("Γ£à Catchup process completed successfully!")
211 |         self.results_text.append(f"≡ƒôè Sessions processed: {processed_sessions}/{total_sessions}")
    |                                                                                         ^^^^^^^^^ E501
212 |         self.results_text.append(f"≡ƒôê Total current records updated: {total_curr_updated}")
213 |         self.results_text.append(f"≡ƒôï Total history records inserted: {total_hist_inserted}")
    |

desktop_ui\scaffold_catchup_speed_summary.py:212:88: E501 Line too long (91 > 88)
    |
210 |         self.results_text.append("Γ£à Catchup process completed successfully!")
211 |         self.results_text.append(f"≡ƒôè Sessions processed: {processed_sessions}/{total_sessions}")
212 |         self.results_text.append(f"≡ƒôê Total current records updated: {total_curr_updated}")
    |                                                                                         ^^^ E501
213 |         self.results_text.append(f"≡ƒôï Total history records inserted: {total_hist_inserted}")
    |

desktop_ui\scaffold_catchup_speed_summary.py:213:88: E501 Line too long (93 > 88)
    |
211 |         self.results_text.append(f"≡ƒôè Sessions processed: {processed_sessions}/{total_sessions}")
212 |         self.results_text.append(f"≡ƒôê Total current records updated: {total_curr_updated}")
213 |         self.results_text.append(f"≡ƒôï Total history records inserted: {total_hist_inserted}")
    |                                                                                         ^^^^^ E501
214 |
215 |         # Show success message
    |

desktop_ui\scaffold_catchup_speed_summary.py:225:9: ANN201 Missing return type annotation for public function `on_catchup_error`
    |
223 |         )
224 |
225 |     def on_catchup_error(self, error_message: str):
    |         ^^^^^^^^^^^^^^^^ ANN201
226 |         """Handle errors during catchup."""
227 |         self.progress_bar.setVisible(False)
    |
    = help: Add return type annotation: `None`

desktop_ui\scaffold_catchup_speed_summary.py:235:89: E501 Line too long (96 > 88)
    |
233 |         # Show error message
234 |         QMessageBox.critical(
235 |             self, "Error", f"An error occurred during speed summary catchup:\n\n{error_message}"
    |                                                                                         ^^^^^^^^ E501
236 |         )
    |

desktop_ui\scaffold_catchup_speed_summary.py:238:9: ANN201 Missing return type annotation for public function `closeEvent`
    |
236 |         )
237 |
238 |     def closeEvent(self, event):
    |         ^^^^^^^^^^ ANN201
239 |         """Handle window close event."""
240 |         if self.worker and self.worker.isRunning():
    |
    = help: Add return type annotation: `None`

desktop_ui\scaffold_catchup_speed_summary.py:238:26: ANN001 Missing type annotation for function argument `event`
    |
236 |         )
237 |
238 |     def closeEvent(self, event):
    |                          ^^^^^ ANN001
239 |         """Handle window close event."""
240 |         if self.worker and self.worker.isRunning():
    |

desktop_ui\scaffold_catchup_speed_summary.py:245:89: E501 Line too long (95 > 88)
    |
243 |                 "Confirm Close",
244 |                 "Catchup process is still running. Are you sure you want to close?\n\n"
245 |                 "This will terminate the process and may leave data in an inconsistent state.",
    |                                                                                         ^^^^^^^ E501
246 |                 QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
247 |                 QMessageBox.StandardButton.No,
    |

desktop_ui\scaffold_catchup_speed_summary.py:260:5: ANN201 Missing return type annotation for public function `launch_scaffold_catchup_speed_summary`
    |
260 | def launch_scaffold_catchup_speed_summary():
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
261 |     """Launch the ScaffoldCatchupSpeedSummary application."""
262 |     app = QtWidgets.QApplication.instance()
    |
    = help: Add return type annotation: `None`

desktop_ui\scaffold_summarize_session_ngrams.py:30:9: ANN204 Missing return type annotation for special method `__init__`
   |
28 |     error = Signal(str)  # Signal with error message
29 |
30 |     def __init__(self, analytics_service: NGramAnalyticsService):
   |         ^^^^^^^^ ANN204
31 |         super().__init__()
32 |         self.analytics_service = analytics_service
   |
   = help: Add return type annotation: `None`

desktop_ui\scaffold_summarize_session_ngrams.py:34:9: ANN201 Missing return type annotation for public function `run`
   |
32 |         self.analytics_service = analytics_service
33 |
34 |     def run(self):
   |         ^^^ ANN201
35 |         try:
36 |             result = self.analytics_service.summarize_session_ngrams()
   |
   = help: Add return type annotation: `None`

desktop_ui\scaffold_summarize_session_ngrams.py:51:89: E501 Line too long (99 > 88)
   |
50 |     def __init__(
51 |         self, db_path: Optional[str] = None, connection_type: ConnectionType = ConnectionType.CLOUD
   |                                                                                         ^^^^^^^^^^^ E501
52 |     ) -> None:
53 |         super().__init__()
   |

desktop_ui\scaffold_summarize_session_ngrams.py:59:89: E501 Line too long (96 > 88)
   |
57 |         # Initialize database connection
58 |         if db_path is None:
59 |             db_path = os.path.join(os.path.dirname(os.path.dirname(__file__)), "typing_data.db")
   |                                                                                         ^^^^^^^^ E501
60 |
61 |         self.db_manager = DatabaseManager(db_path, connection_type=connection_type)
   |

desktop_ui\scaffold_summarize_session_ngrams.py:66:89: E501 Line too long (91 > 88)
   |
64 |         # Initialize services
65 |         self.ngram_manager = NGramManager(self.db_manager)
66 |         self.analytics_service = NGramAnalyticsService(self.db_manager, self.ngram_manager)
   |                                                                                         ^^^ E501
67 |
68 |         self.worker = None
   |

desktop_ui\scaffold_summarize_session_ngrams.py:71:9: ANN201 Missing return type annotation for public function `setup_ui`
   |
69 |         self.setup_ui()
70 |
71 |     def setup_ui(self):
   |         ^^^^^^^^ ANN201
72 |         """Set up the user interface."""
73 |         layout = QtWidgets.QVBoxLayout(self)
   |
   = help: Add return type annotation: `None`

desktop_ui\scaffold_summarize_session_ngrams.py:82:89: E501 Line too long (104 > 88)
   |
80 |         # Description
81 |         description = QtWidgets.QLabel(
82 |             "This tool summarizes ngram performance for all sessions that haven't been processed yet.\n"
   |                                                                                         ^^^^^^^^^^^^^^^^ E501
83 |             "It aggregates data from session_ngram_speed, session_ngram_errors, and session_keystrokes\n"
84 |             "tables and inserts the results into session_ngram_summary."
   |

desktop_ui\scaffold_summarize_session_ngrams.py:83:89: E501 Line too long (105 > 88)
   |
81 |         description = QtWidgets.QLabel(
82 |             "This tool summarizes ngram performance for all sessions that haven't been processed yet.\n"
83 |             "It aggregates data from session_ngram_speed, session_ngram_errors, and session_keystrokes\n"
   |                                                                                         ^^^^^^^^^^^^^^^^^ E501
84 |             "tables and inserts the results into session_ngram_summary."
85 |         )
   |

desktop_ui\scaffold_summarize_session_ngrams.py:98:89: E501 Line too long (122 > 88)
    |
 96 |         self.summarize_button = QtWidgets.QPushButton("Summarize Ngrams")
 97 |         self.summarize_button.setStyleSheet(
 98 |             "QPushButton { background-color: #4CAF50; color: white; padding: 10px; font-size: 14px; border-radius: 5px; }"
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
 99 |             "QPushButton:hover { background-color: #45a049; }"
100 |             "QPushButton:disabled { background-color: #cccccc; }"
    |

desktop_ui\scaffold_summarize_session_ngrams.py:116:89: E501 Line too long (104 > 88)
    |
114 |         close_button = QtWidgets.QPushButton("Close")
115 |         close_button.setStyleSheet(
116 |             "QPushButton { background-color: #f44336; color: white; padding: 8px; border-radius: 5px; }"
    |                                                                                         ^^^^^^^^^^^^^^^^ E501
117 |             "QPushButton:hover { background-color: #da190b; }"
118 |         )
    |

desktop_ui\scaffold_summarize_session_ngrams.py:122:9: ANN201 Missing return type annotation for public function `start_summarization`
    |
120 |         layout.addWidget(close_button)
121 |
122 |     def start_summarization(self):
    |         ^^^^^^^^^^^^^^^^^^^ ANN201
123 |         """Start the summarization process in a background thread."""
124 |         self.summarize_button.setEnabled(False)
    |
    = help: Add return type annotation: `None`

desktop_ui\scaffold_summarize_session_ngrams.py:136:9: ANN201 Missing return type annotation for public function `on_summarization_finished`
    |
134 |         self.worker.start()
135 |
136 |     def on_summarization_finished(self, records_inserted: int):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
137 |         """Handle successful completion of summarization."""
138 |         self.progress_bar.setVisible(False)
    |
    = help: Add return type annotation: `None`

desktop_ui\scaffold_summarize_session_ngrams.py:154:9: ANN201 Missing return type annotation for public function `on_summarization_error`
    |
152 |         )
153 |
154 |     def on_summarization_error(self, error_message: str):
    |         ^^^^^^^^^^^^^^^^^^^^^^ ANN201
155 |         """Handle errors during summarization."""
156 |         self.progress_bar.setVisible(False)
    |
    = help: Add return type annotation: `None`

desktop_ui\scaffold_summarize_session_ngrams.py:169:9: ANN201 Missing return type annotation for public function `closeEvent`
    |
167 |         )
168 |
169 |     def closeEvent(self, event):
    |         ^^^^^^^^^^ ANN201
170 |         """Handle window close event."""
171 |         if self.worker and self.worker.isRunning():
    |
    = help: Add return type annotation: `None`

desktop_ui\scaffold_summarize_session_ngrams.py:169:26: ANN001 Missing type annotation for function argument `event`
    |
167 |         )
168 |
169 |     def closeEvent(self, event):
    |                          ^^^^^ ANN001
170 |         """Handle window close event."""
171 |         if self.worker and self.worker.isRunning():
    |

desktop_ui\scaffold_summarize_session_ngrams.py:190:5: ANN201 Missing return type annotation for public function `launch_scaffold_summarize_session_ngrams`
    |
190 | def launch_scaffold_summarize_session_ngrams():
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
191 |     """Launch the ScaffoldSummarizeSessionNgrams application."""
192 |     app = QtWidgets.QApplication.instance()
    |
    = help: Add return type annotation: `None`

desktop_ui\snippet_model_tester.py:4:89: E501 Line too long (111 > 88)
  |
2 | Snippet Model Tester UI
3 | ----------------------
4 | A simple PySide6-based desktop UI for directly testing the Snippet object model (SnippetModel, SnippetManager).
  |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^ E501
5 |
6 | - List all snippets (optionally filter by category)
  |

desktop_ui\snippet_model_tester.py:12:89: E501 Line too long (107 > 88)
   |
10 | - Show validation and error messages
11 |
12 | Bypasses API and service layers; interacts directly with SnippetManager, SnippetModel, and CategoryManager.
   |                                                                                         ^^^^^^^^^^^^^^^^^^^ E501
13 |
14 | Author: Cascade AI
   |

desktop_ui\snippet_model_tester.py:119:89: E501 Line too long (147 > 88)
    |
117 | ΓÇª
118 | ΓÇª
119 | ΓÇªtegory_id}] {snip.snippet_name} - {snip.content[:40]}{'...' if len(snip.content)>40 else ''}"
    |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
120 | ΓÇª
121 | ΓÇª
    |

desktop_ui\snippet_scaffold.py:20:41: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `snippet_manager`
   |
18 |     """
19 |
20 |     def __init__(self, snippet_manager: Any) -> None:
   |                                         ^^^ ANN401
21 |         super().__init__()
22 |         self.snippet_manager = snippet_manager
   |

desktop_ui\snippet_scaffold.py:105:89: E501 Line too long (93 > 88)
    |
103 |         # Display a status message while loading
104 |         self.snippet_list.addItem("Loading snippets...")
105 |         QtWidgets.QApplication.processEvents()  # Process events to update the UI immediately
    |                                                                                         ^^^^^ E501
106 |
107 |         # For demo: use category_id=1
    |

desktop_ui\splash.py:48:24: ANN001 Missing type annotation for function argument `graphql`
   |
46 |     """
47 |
48 |     def __init__(self, graphql=None, config: Optional[SplashConfig] = None) -> None:
   |                        ^^^^^^^ ANN001
49 |         super().__init__()
50 |         self.setWindowTitle("AI Typing Trainer")
   |

desktop_ui\splash.py:97:89: E501 Line too long (89 > 88)
   |
95 |         else:
96 |             # Real mode: use APIServerManager and GraphQLClient
97 |             # Use the class-level server manager if it exists, otherwise create a new one
   |                                                                                         ^ E501
98 |             if SplashScreen._api_server_manager is None:
99 |                 SplashScreen._api_server_manager = APIServerManager()
   |

desktop_ui\splash.py:143:89: E501 Line too long (89 > 88)
    |
141 |             if self.api_server_manager and not self.graphql:
142 |                 self.status_label.setText("Restarting GraphQL server...")
143 |                 self.api_server_manager.shutdown_server()  # Shutdown any failed instance
    |                                                                                         ^ E501
144 |                 started = self.api_server_manager.start_server()
145 |                 if started:
    |

desktop_ui\splash.py:156:30: F821 Undefined name `GraphQLServerThread`
    |
154 |     def _start_graphql_server(self) -> None:
155 |         self.status_label.setText("Starting up GraphQL")
156 |         self.server_thread = GraphQLServerThread()
    |                              ^^^^^^^^^^^^^^^^^^^ F821
157 |         self.server_thread.started_signal.connect(self._poll_graphql)
158 |         self.server_thread.start()
    |

desktop_ui\splash.py:183:89: E501 Line too long (118 > 88)
    |
181 |     def check_graphql_and_show_count(self) -> None:
182 |         """
183 |         Checks if GraphQL is running; if not, updates status. If running, fetches snippet count and shows message box.
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
184 |         """
185 |         count = 0
    |

desktop_ui\typing_drill.py:8:1: I001 [*] Import block is un-sorted or un-formatted
   |
 7 |   # Move all imports to the top of the file for PEP8 compliance
 8 | / import datetime
 9 | | import logging
10 | | import time
11 | | import uuid
12 | | from typing import TYPE_CHECKING, Any, Dict, List, Optional
13 | |
14 | | from PySide6.QtCore import Qt, QTimer
15 | | from PySide6.QtGui import QColor, QFont, QPalette, QTextCharFormat, QTextCursor, QTextDocument
16 | | from PySide6.QtWidgets import (
17 | |     QDialog,
18 | |     QGridLayout,
19 | |     QHBoxLayout,
20 | |     QLabel,
21 | |     QProgressBar,
22 | |     QPushButton,
23 | |     QSizePolicy,
24 | |     QSpacerItem,
25 | |     QStatusBar,
26 | |     QTextEdit,
27 | |     QVBoxLayout,
28 | |     QWidget,
29 | | )
30 | |
31 | | from models.keyboard_manager import KeyboardManager, KeyboardNotFound
32 | | from models.keystroke import Keystroke
33 | | from models.keystroke_manager import KeystrokeManager
34 | | from models.ngram_analytics_service import NGramAnalyticsService
35 | | from models.ngram_manager import NGramManager
36 | | from models.session import Session
37 | | from models.session_manager import SessionManager
38 | | from models.user_manager import UserManager, UserNotFound
   | |_________________________________________________________^ I001
39 |
40 |   if TYPE_CHECKING:
   |
   = help: Organize imports

desktop_ui\typing_drill.py:425:13: ANN202 Missing return type annotation for private function `ensure_uuid`
    |
423 |         """
424 |
425 |         def ensure_uuid(val):
    |             ^^^^^^^^^^^ ANN202
426 |             try:
427 |                 return str(uuid.UUID(str(val)))
    |
    = help: Add return type annotation

desktop_ui\typing_drill.py:425:25: ANN001 Missing type annotation for function argument `val`
    |
423 |         """
424 |
425 |         def ensure_uuid(val):
    |                         ^^^ ANN001
426 |             try:
427 |                 return str(uuid.UUID(str(val)))
    |

desktop_ui\typing_drill.py:875:9: ANN202 Missing return type annotation for private function `_update_progress_bars`
    |
873 |         return (self.elapsed_time * 1000) / len(self.keystrokes)
874 |
875 |     def _update_progress_bars(self, wpm: float, errors: int):
    |         ^^^^^^^^^^^^^^^^^^^^^ ANN202
876 |         """Update all progress bars with current values."""
877 |         # Character progress
    |
    = help: Add return type annotation: `None`

desktop_ui\users_and_keyboards.py:41:89: E501 Line too long (94 > 88)
   |
39 |     """
40 |
41 |     def __init__(self, db_manager: DatabaseManager, parent: Optional[QWidget] = None) -> None:
   |                                                                                         ^^^^^^ E501
42 |         """
43 |         Initialize the Users and Keyboards dialog.
   |

desktop_ui\users_and_keyboards.py:144:89: E501 Line too long (98 > 88)
    |
142 |             users = self.user_manager.list_all_users()
143 |             for user in users:
144 |                 item = QListWidgetItem(f"{user.first_name} {user.surname} ({user.email_address})")
    |                                                                                         ^^^^^^^^^^ E501
145 |                 item.setData(Qt.ItemDataRole.UserRole, user.user_id)
146 |                 self.users_list.addItem(item)
    |

desktop_ui\users_and_keyboards.py:192:89: E501 Line too long (93 > 88)
    |
190 |             keyboard_id = selected_items[0].data(Qt.ItemDataRole.UserRole)
191 |             try:
192 |                 self.current_keyboard = self.keyboard_manager.get_keyboard_by_id(keyboard_id)
    |                                                                                         ^^^^^ E501
193 |             except KeyboardNotFound:
194 |                 QMessageBox.warning(self, "Not Found", "Selected keyboard not found.")
    |

desktop_ui\users_and_keyboards.py:305:89: E501 Line too long (91 > 88)
    |
303 |                 QMessageBox.warning(self, "Validation Error", str(e))
304 |             except Exception as e:
305 |                 QMessageBox.critical(self, "Error", f"Failed to update keyboard: {str(e)}")
    |                                                                                         ^^^ E501
306 |
307 |     def on_user_double_clicked(self, item: QListWidgetItem) -> None:
    |

desktop_ui\users_and_keyboards.py:338:89: E501 Line too long (91 > 88)
    |
336 |                 self.update_button_states()
337 |             except Exception as e:
338 |                 QMessageBox.critical(self, "Error", f"Failed to delete keyboard: {str(e)}")
    |                                                                                         ^^^ E501
    |

Found 252 errors.
[*] 6 fixable with the `--fix` option (33 hidden fixes can be enabled with the `--unsafe-fixes` option).
api\category_api.py:1:1: I001 [*] Import block is un-sorted or un-formatted
  |
1 | / from typing import Dict, List, Tuple, Union, Any
2 | |
3 | | from flask import Blueprint, jsonify, request, Response
4 | | from pydantic import BaseModel, ValidationError
5 | |
6 | | from db.database_manager import DatabaseManager
7 | | from models.category import CategoryManager
  | |___________________________________________^ I001
  |
  = help: Organize imports

api\category_api.py:1:20: F401 [*] `typing.Dict` imported but unused
  |
1 | from typing import Dict, List, Tuple, Union, Any
  |                    ^^^^ F401
2 |
3 | from flask import Blueprint, jsonify, request, Response
  |
  = help: Remove unused import

api\category_api.py:1:26: F401 [*] `typing.List` imported but unused
  |
1 | from typing import Dict, List, Tuple, Union, Any
  |                          ^^^^ F401
2 |
3 | from flask import Blueprint, jsonify, request, Response
  |
  = help: Remove unused import

api\category_api.py:1:46: F401 [*] `typing.Any` imported but unused
  |
1 | from typing import Dict, List, Tuple, Union, Any
  |                                              ^^^ F401
2 |
3 | from flask import Blueprint, jsonify, request, Response
  |
  = help: Remove unused import

api\category_graphql.py:45:41: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `_info`
   |
43 |     category = Field(CategoryType, category_id=Int(name="categoryId", required=True))
44 |
45 |     def resolve_categories(self, _info: Any) -> TypedList[Category]:
   |                                         ^^^ ANN401
46 |         """
47 |         Resolve all categories.
   |

api\category_graphql.py:57:39: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `_info`
   |
55 |         return CategoryManager.list_categories()
56 |
57 |     def resolve_category(self, _info: Any, category_id: int) -> Optional[Category]:
   |                                       ^^^ ANN401
58 |         """
59 |         Resolve a specific category by ID.
   |

api\category_graphql.py:85:29: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `_info`
   |
83 |     category = Field(lambda: CategoryType)
84 |
85 |     def mutate(self, _info: Any, category_name: str) -> "CreateCategory":
   |                             ^^^ ANN401
86 |         """
87 |         Create a new category with the provided name.
   |

api\category_graphql.py:105:13: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
    |
103 |         except (CategoryValidationError, ValueError) as e:
104 |             # Graphene will convert this to a proper GraphQL error
105 |             raise Exception(str(e))
    |             ^^^^^^^^^^^^^^^^^^^^^^^ B904
    |

api\category_graphql.py:121:22: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `_info`
    |
120 |     def mutate(
121 |         self, _info: Any, category_id: int, category_name: str
    |                      ^^^ ANN401
122 |     ) -> "UpdateCategory":
123 |         """
    |

api\category_graphql.py:143:13: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
    |
141 |         except (CategoryValidationError, CategoryNotFound, ValueError) as e:
142 |             # Graphene will convert this to a proper GraphQL error
143 |             raise Exception(str(e))
    |             ^^^^^^^^^^^^^^^^^^^^^^^ B904
    |

api\category_graphql.py:157:29: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `_info`
    |
155 |     ok = Boolean()
156 |
157 |     def mutate(self, _info: Any, category_id: int) -> "DeleteCategory":
    |                             ^^^ ANN401
158 |         """
159 |         Delete a category by ID.
    |

api\category_graphql.py:177:13: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
    |
175 |         except CategoryNotFound as e:
176 |             # Graphene will convert this to a proper GraphQL error
177 |             raise Exception(str(e))
    |             ^^^^^^^^^^^^^^^^^^^^^^^ B904
    |

api\dbviewer_api.py:34:5: ANN201 Missing return type annotation for public function `list_tables`
   |
33 | @dbviewer_api.route("/tables", methods=["GET"])
34 | def list_tables():
   |     ^^^^^^^^^^^ ANN201
35 |     """List all available database tables."""
36 |     try:
   |
   = help: Add return type annotation

api\dbviewer_api.py:52:5: ANN201 Missing return type annotation for public function `get_table_data`
   |
51 | @dbviewer_api.route("/table", methods=["GET"])
52 | def get_table_data():
   |     ^^^^^^^^^^^^^^ ANN201
53 |     """Get table data with pagination, sorting, and filtering.
   |
   = help: Add return type annotation

api\dbviewer_api.py:101:5: ANN201 Missing return type annotation for public function `export_table_to_csv`
    |
100 | @dbviewer_api.route("/export", methods=["GET"])
101 | def export_table_to_csv():
    |     ^^^^^^^^^^^^^^^^^^^ ANN201
102 |     """Export table data to CSV format.
    |
    = help: Add return type annotation

api\keystroke_api.py:8:1: E402 Module level import not at top of file
  |
6 | keystroke_api = Blueprint("keystroke_api", __name__)
7 |
8 | from typing import Optional
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
  |

api\keystroke_api.py:22:5: ANN201 Missing return type annotation for public function `api_record_keystroke`
   |
21 | @keystroke_api.route("/api/keystrokes", methods=["POST"])
22 | def api_record_keystroke():
   |     ^^^^^^^^^^^^^^^^^^^^ ANN201
23 |     import sys
   |
   = help: Add return type annotation

api\keystroke_api.py:54:89: E501 Line too long (92 > 88)
   |
52 |         exc_type, exc_value, _ = sys.exc_info()
53 |         print(
54 |             f"DEBUG: Keystroke save failed. Exception type: {exc_type}, value: {exc_value}",
   |                                                                                         ^^^^ E501
55 |             file=sys.stderr,
56 |         )
   |

api\keystroke_api.py:61:89: E501 Line too long (100 > 88)
   |
59 |                 jsonify(
60 |                     {
61 |                         "error": "Duplicate keystroke_id for session or unique constraint violation"
   |                                                                                         ^^^^^^^^^^^^ E501
62 |                     }
63 |                 ),
   |

api\keystroke_api.py:71:5: ANN201 Missing return type annotation for public function `api_list_keystrokes`
   |
70 | @keystroke_api.route("/api/keystrokes", methods=["GET"])
71 | def api_list_keystrokes():
   |     ^^^^^^^^^^^^^^^^^^^ ANN201
72 |     session_id = request.args.get("session_id")
73 |     if not session_id:
   |
   = help: Add return type annotation

api\library_graphql.py:18:5: ANN201 Missing return type annotation for public function `get_library_manager`
   |
18 | def get_library_manager():
   |     ^^^^^^^^^^^^^^^^^^^ ANN201
19 |     # Dependency injection for testability
20 |     db_manager = getattr(g, "db_manager", None)
   |
   = help: Add return type annotation

api\library_graphql.py:52:9: ANN201 Missing return type annotation for public function `resolve_categories`
   |
50 |     snippet_parts = List(SnippetPartType, snippet_id=Int(required=True))
51 |
52 |     def resolve_categories(self, info):
   |         ^^^^^^^^^^^^^^^^^^ ANN201
53 |         mgr = get_library_manager()
54 |         return mgr.list_categories()
   |
   = help: Add return type annotation

api\library_graphql.py:52:34: ANN001 Missing type annotation for function argument `info`
   |
50 |     snippet_parts = List(SnippetPartType, snippet_id=Int(required=True))
51 |
52 |     def resolve_categories(self, info):
   |                                  ^^^^ ANN001
53 |         mgr = get_library_manager()
54 |         return mgr.list_categories()
   |

api\library_graphql.py:56:9: ANN201 Missing return type annotation for public function `resolve_snippets`
   |
54 |         return mgr.list_categories()
55 |
56 |     def resolve_snippets(self, info, category_id):
   |         ^^^^^^^^^^^^^^^^ ANN201
57 |         mgr = get_library_manager()
58 |         return mgr.list_snippets(category_id)
   |
   = help: Add return type annotation

api\library_graphql.py:56:32: ANN001 Missing type annotation for function argument `info`
   |
54 |         return mgr.list_categories()
55 |
56 |     def resolve_snippets(self, info, category_id):
   |                                ^^^^ ANN001
57 |         mgr = get_library_manager()
58 |         return mgr.list_snippets(category_id)
   |

api\library_graphql.py:56:38: ANN001 Missing type annotation for function argument `category_id`
   |
54 |         return mgr.list_categories()
55 |
56 |     def resolve_snippets(self, info, category_id):
   |                                      ^^^^^^^^^^^ ANN001
57 |         mgr = get_library_manager()
58 |         return mgr.list_snippets(category_id)
   |

api\library_graphql.py:60:9: ANN201 Missing return type annotation for public function `resolve_snippet`
   |
58 |         return mgr.list_snippets(category_id)
59 |
60 |     def resolve_snippet(self, info, snippet_id):
   |         ^^^^^^^^^^^^^^^ ANN201
61 |         mgr = get_library_manager()
62 |         snippets = mgr.list_snippets(-1)  # Dummy call to get type
   |
   = help: Add return type annotation

api\library_graphql.py:60:31: ANN001 Missing type annotation for function argument `info`
   |
58 |         return mgr.list_snippets(category_id)
59 |
60 |     def resolve_snippet(self, info, snippet_id):
   |                               ^^^^ ANN001
61 |         mgr = get_library_manager()
62 |         snippets = mgr.list_snippets(-1)  # Dummy call to get type
   |

api\library_graphql.py:60:37: ANN001 Missing type annotation for function argument `snippet_id`
   |
58 |         return mgr.list_snippets(category_id)
59 |
60 |     def resolve_snippet(self, info, snippet_id):
   |                                     ^^^^^^^^^^ ANN001
61 |         mgr = get_library_manager()
62 |         snippets = mgr.list_snippets(-1)  # Dummy call to get type
   |

api\library_graphql.py:68:9: ANN201 Missing return type annotation for public function `resolve_snippet_parts`
   |
66 |         return None
67 |
68 |     def resolve_snippet_parts(self, info, snippet_id):
   |         ^^^^^^^^^^^^^^^^^^^^^ ANN201
69 |         mgr = get_library_manager()
70 |         return mgr.list_parts(snippet_id)
   |
   = help: Add return type annotation

api\library_graphql.py:68:37: ANN001 Missing type annotation for function argument `info`
   |
66 |         return None
67 |
68 |     def resolve_snippet_parts(self, info, snippet_id):
   |                                     ^^^^ ANN001
69 |         mgr = get_library_manager()
70 |         return mgr.list_parts(snippet_id)
   |

api\library_graphql.py:68:43: ANN001 Missing type annotation for function argument `snippet_id`
   |
66 |         return None
67 |
68 |     def resolve_snippet_parts(self, info, snippet_id):
   |                                           ^^^^^^^^^^ ANN001
69 |         mgr = get_library_manager()
70 |         return mgr.list_parts(snippet_id)
   |

api\library_graphql.py:82:9: ANN201 Missing return type annotation for public function `mutate`
   |
80 |     error = String()
81 |
82 |     def mutate(self, info, category_name):
   |         ^^^^^^ ANN201
83 |         mgr = get_library_manager()
84 |         try:
   |
   = help: Add return type annotation

api\library_graphql.py:82:22: ANN001 Missing type annotation for function argument `info`
   |
80 |     error = String()
81 |
82 |     def mutate(self, info, category_name):
   |                      ^^^^ ANN001
83 |         mgr = get_library_manager()
84 |         try:
   |

api\library_graphql.py:82:28: ANN001 Missing type annotation for function argument `category_name`
   |
80 |     error = String()
81 |
82 |     def mutate(self, info, category_name):
   |                            ^^^^^^^^^^^^^ ANN001
83 |         mgr = get_library_manager()
84 |         try:
   |

api\library_graphql.py:101:9: ANN201 Missing return type annotation for public function `mutate`
    |
 99 |     error = String()
100 |
101 |     def mutate(self, info, category_id, category_name):
    |         ^^^^^^ ANN201
102 |         mgr = get_library_manager()
103 |         try:
    |
    = help: Add return type annotation

api\library_graphql.py:101:22: ANN001 Missing type annotation for function argument `info`
    |
 99 |     error = String()
100 |
101 |     def mutate(self, info, category_id, category_name):
    |                      ^^^^ ANN001
102 |         mgr = get_library_manager()
103 |         try:
    |

api\library_graphql.py:101:28: ANN001 Missing type annotation for function argument `category_id`
    |
 99 |     error = String()
100 |
101 |     def mutate(self, info, category_id, category_name):
    |                            ^^^^^^^^^^^ ANN001
102 |         mgr = get_library_manager()
103 |         try:
    |

api\library_graphql.py:101:41: ANN001 Missing type annotation for function argument `category_name`
    |
 99 |     error = String()
100 |
101 |     def mutate(self, info, category_id, category_name):
    |                                         ^^^^^^^^^^^^^ ANN001
102 |         mgr = get_library_manager()
103 |         try:
    |

api\library_graphql.py:117:9: ANN201 Missing return type annotation for public function `mutate`
    |
115 |     error = String()
116 |
117 |     def mutate(self, info, category_id):
    |         ^^^^^^ ANN201
118 |         mgr = get_library_manager()
119 |         try:
    |
    = help: Add return type annotation

api\library_graphql.py:117:22: ANN001 Missing type annotation for function argument `info`
    |
115 |     error = String()
116 |
117 |     def mutate(self, info, category_id):
    |                      ^^^^ ANN001
118 |         mgr = get_library_manager()
119 |         try:
    |

api\library_graphql.py:117:28: ANN001 Missing type annotation for function argument `category_id`
    |
115 |     error = String()
116 |
117 |     def mutate(self, info, category_id):
    |                            ^^^^^^^^^^^ ANN001
118 |         mgr = get_library_manager()
119 |         try:
    |

api\library_graphql.py:136:9: ANN201 Missing return type annotation for public function `mutate`
    |
134 |     error = String()
135 |
136 |     def mutate(self, info, category_id, snippet_name, content):
    |         ^^^^^^ ANN201
137 |         mgr = get_library_manager()
138 |         try:
    |
    = help: Add return type annotation

api\library_graphql.py:136:22: ANN001 Missing type annotation for function argument `info`
    |
134 |     error = String()
135 |
136 |     def mutate(self, info, category_id, snippet_name, content):
    |                      ^^^^ ANN001
137 |         mgr = get_library_manager()
138 |         try:
    |

api\library_graphql.py:136:28: ANN001 Missing type annotation for function argument `category_id`
    |
134 |     error = String()
135 |
136 |     def mutate(self, info, category_id, snippet_name, content):
    |                            ^^^^^^^^^^^ ANN001
137 |         mgr = get_library_manager()
138 |         try:
    |

api\library_graphql.py:136:41: ANN001 Missing type annotation for function argument `snippet_name`
    |
134 |     error = String()
135 |
136 |     def mutate(self, info, category_id, snippet_name, content):
    |                                         ^^^^^^^^^^^^ ANN001
137 |         mgr = get_library_manager()
138 |         try:
    |

api\library_graphql.py:136:55: ANN001 Missing type annotation for function argument `content`
    |
134 |     error = String()
135 |
136 |     def mutate(self, info, category_id, snippet_name, content):
    |                                                       ^^^^^^^ ANN001
137 |         mgr = get_library_manager()
138 |         try:
    |

api\library_graphql.py:157:9: ANN201 Missing return type annotation for public function `mutate`
    |
155 |     error = String()
156 |
157 |     def mutate(self, info, snippet_id, snippet_name, content, category_id=None):
    |         ^^^^^^ ANN201
158 |         mgr = get_library_manager()
159 |         try:
    |
    = help: Add return type annotation

api\library_graphql.py:157:22: ANN001 Missing type annotation for function argument `info`
    |
155 |     error = String()
156 |
157 |     def mutate(self, info, snippet_id, snippet_name, content, category_id=None):
    |                      ^^^^ ANN001
158 |         mgr = get_library_manager()
159 |         try:
    |

api\library_graphql.py:157:28: ANN001 Missing type annotation for function argument `snippet_id`
    |
155 |     error = String()
156 |
157 |     def mutate(self, info, snippet_id, snippet_name, content, category_id=None):
    |                            ^^^^^^^^^^ ANN001
158 |         mgr = get_library_manager()
159 |         try:
    |

api\library_graphql.py:157:40: ANN001 Missing type annotation for function argument `snippet_name`
    |
155 |     error = String()
156 |
157 |     def mutate(self, info, snippet_id, snippet_name, content, category_id=None):
    |                                        ^^^^^^^^^^^^ ANN001
158 |         mgr = get_library_manager()
159 |         try:
    |

api\library_graphql.py:157:54: ANN001 Missing type annotation for function argument `content`
    |
155 |     error = String()
156 |
157 |     def mutate(self, info, snippet_id, snippet_name, content, category_id=None):
    |                                                      ^^^^^^^ ANN001
158 |         mgr = get_library_manager()
159 |         try:
    |

api\library_graphql.py:157:63: ANN001 Missing type annotation for function argument `category_id`
    |
155 |     error = String()
156 |
157 |     def mutate(self, info, snippet_id, snippet_name, content, category_id=None):
    |                                                               ^^^^^^^^^^^ ANN001
158 |         mgr = get_library_manager()
159 |         try:
    |

api\library_graphql.py:173:9: ANN201 Missing return type annotation for public function `mutate`
    |
171 |     error = String()
172 |
173 |     def mutate(self, info, snippet_id):
    |         ^^^^^^ ANN201
174 |         mgr = get_library_manager()
175 |         try:
    |
    = help: Add return type annotation

api\library_graphql.py:173:22: ANN001 Missing type annotation for function argument `info`
    |
171 |     error = String()
172 |
173 |     def mutate(self, info, snippet_id):
    |                      ^^^^ ANN001
174 |         mgr = get_library_manager()
175 |         try:
    |

api\library_graphql.py:173:28: ANN001 Missing type annotation for function argument `snippet_id`
    |
171 |     error = String()
172 |
173 |     def mutate(self, info, snippet_id):
    |                            ^^^^^^^^^^ ANN001
174 |         mgr = get_library_manager()
175 |         try:
    |

api\library_graphql.py:195:5: ANN201 Missing return type annotation for public function `graphql_api`
    |
194 | @library_graphql.route("/", methods=["POST", "GET"])
195 | def graphql_api():
    |     ^^^^^^^^^^^ ANN201
196 |     data = request.get_json()
197 |     result = schema.execute(
    |
    = help: Add return type annotation

api\run_library_api.py:26:5: ANN201 Missing return type annotation for public function `init_db`
   |
25 | # Initialize database tables on startup
26 | def init_db():
   |     ^^^^^^^ ANN201
27 |     """Initialize database tables"""
28 |     print("Initializing database tables...")
   |
   = help: Add return type annotation: `None`

api\session_api.py:16:5: ANN201 Missing return type annotation for public function `api_create_session`
   |
15 | @session_api.route("/api/sessions", methods=["POST"])
16 | def api_create_session():
   |     ^^^^^^^^^^^^^^^^^^ ANN201
17 |     try:
18 |         data = request.get_json()
   |
   = help: Add return type annotation

api\session_api.py:34:5: ANN201 Missing return type annotation for public function `api_get_session_info`
   |
33 | @session_api.route("/api/session/info", methods=["GET"])
34 | def api_get_session_info():
   |     ^^^^^^^^^^^^^^^^^^^^ ANN201
35 |     """Get last session indices and snippet length for a snippet_id."""
36 |     snippet_id = request.args.get("snippet_id", type=int)
   |
   = help: Add return type annotation

api\session_api.py:44:89: E501 Line too long (96 > 88)
   |
42 |         return make_response(jsonify(info), 200)
43 |     except Exception as e:
44 |         return make_response(jsonify({"error": f"Failed to fetch session info: {str(e)}"}), 500)
   |                                                                                         ^^^^^^^^ E501
   |

api\session_api.py:48:5: ANN201 Missing return type annotation for public function `api_get_session`
   |
47 | @session_api.route("/api/sessions/<session_id>", methods=["GET"])
48 | def api_get_session(session_id):
   |     ^^^^^^^^^^^^^^^ ANN201
49 |     session = Session.get_by_id(session_id)
50 |     if not session:
   |
   = help: Add return type annotation

api\session_api.py:48:21: ANN001 Missing type annotation for function argument `session_id`
   |
47 | @session_api.route("/api/sessions/<session_id>", methods=["GET"])
48 | def api_get_session(session_id):
   |                     ^^^^^^^^^^ ANN001
49 |     session = Session.get_by_id(session_id)
50 |     if not session:
   |

api\session_api.py:56:5: ANN201 Missing return type annotation for public function `api_update_session`
   |
55 | @session_api.route("/api/sessions/<session_id>", methods=["PUT"])
56 | def api_update_session(session_id):
   |     ^^^^^^^^^^^^^^^^^^ ANN201
57 |     session = Session.get_by_id(session_id)
58 |     if not session:
   |
   = help: Add return type annotation

api\session_api.py:56:24: ANN001 Missing type annotation for function argument `session_id`
   |
55 | @session_api.route("/api/sessions/<session_id>", methods=["PUT"])
56 | def api_update_session(session_id):
   |                        ^^^^^^^^^^ ANN001
57 |     session = Session.get_by_id(session_id)
58 |     if not session:
   |

api\session_api.py:76:89: E501 Line too long (97 > 88)
   |
74 |         return make_response(jsonify({"success": True}), 200)
75 |     except Exception as e:
76 |         return make_response(jsonify({"error": f"Invalid input or server error: {str(e)}"}), 400)
   |                                                                                         ^^^^^^^^^ E501
   |

api\snippet_api.py:19:5: ANN201 Missing return type annotation for public function `get_snippet`
   |
18 | @snippet_api.route("/api/snippets/<int:snippet_id>", methods=["GET"])
19 | def get_snippet(snippet_id: int):
   |     ^^^^^^^^^^^ ANN201
20 |     """Get a single snippet by ID.
   |
   = help: Add return type annotation

api\snippet_api.py:50:5: ANN201 Missing return type annotation for public function `api_get_snippets`
   |
49 | @snippet_api.route("/api/snippets", methods=["GET"])
50 | def api_get_snippets():
   |     ^^^^^^^^^^^^^^^^ ANN201
51 |     """Get all snippets for a specific category.
   |
   = help: Add return type annotation

api\snippet_api.py:87:5: ANN201 Missing return type annotation for public function `api_create_practice_snippet`
   |
86 | @snippet_api.route("/api/create-practice-snippet", methods=["POST"])
87 | def api_create_practice_snippet():
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
88 |     """Create a new practice snippet using the PracticeGenerator.
   |
   = help: Add return type annotation

api\snippet_api.py:107:5: ANN201 Missing return type annotation for public function `create_snippet`
    |
106 | @snippet_api.route("/api/snippets", methods=["POST"])
107 | def create_snippet():
    |     ^^^^^^^^^^^^^^ ANN201
108 |     """Create a new snippet.
    |
    = help: Add return type annotation

api\snippet_api.py:134:89: E501 Line too long (97 > 88)
    |
132 |             except (ValueError, TypeError):
133 |                 print(
134 |                     f"ERROR: Invalid category_id type: {type(category_id)}, value: {category_id}"
    |                                                                                         ^^^^^^^^^ E501
135 |                 )
136 |                 return (
    |

api\snippet_api.py:200:5: ANN201 Missing return type annotation for public function `edit_snippet`
    |
199 | @snippet_api.route("/api/snippets/<int:snippet_id>", methods=["PUT"])
200 | def edit_snippet(snippet_id: int):
    |     ^^^^^^^^^^^^ ANN201
201 |     """Update an existing snippet.
    |
    = help: Add return type annotation

api\snippet_api.py:253:5: ANN201 Missing return type annotation for public function `delete_snippet`
    |
252 | @snippet_api.route("/api/snippets/<int:snippet_id>", methods=["DELETE"])
253 | def delete_snippet(snippet_id: int):
    |     ^^^^^^^^^^^^^^ ANN201
254 |     """Delete a snippet by ID.
    |
    = help: Add return type annotation

api\unified_graphql.py:114:22: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `_info`
    |
113 |     def mutate(
114 |         self, _info: Any, category_id: int, snippet_name: str, content: str
    |                      ^^^ ANN401
115 |     ) -> CreateSnippetOutput:
116 |         """Create a new snippet with the provided data."""
    |

api\unified_graphql.py:160:16: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `_info`
    |
158 |     def mutate(
159 |         self,
160 |         _info: Any,
    |                ^^^ ANN401
161 |         snippet_id: int,
162 |         snippet_name: Optional[str] = None,
    |

api\unified_graphql.py:205:29: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `_info`
    |
203 |     Output = DeleteSnippetOutput
204 |
205 |     def mutate(self, _info: Any, snippet_id: int) -> DeleteSnippetOutput:
    |                             ^^^ ANN401
206 |         """Delete a snippet by ID."""
207 |         try:
    |

api\unified_graphql.py:252:29: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `_info`
    |
250 |     Output = CreateCategoryOutput
251 |
252 |     def mutate(self, _info: Any, category_name: str) -> CreateCategoryOutput:
    |                             ^^^ ANN401
253 |         """Create a new category with the provided name."""
254 |         try:
    |

api\unified_graphql.py:291:22: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `_info`
    |
290 |     def mutate(
291 |         self, _info: Any, category_id: int, category_name: str
    |                      ^^^ ANN401
292 |     ) -> UpdateCategoryOutput:
293 |         """Update an existing category with the provided name."""
    |

api\unified_graphql.py:330:29: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `_info`
    |
328 |     Output = DeleteCategoryOutput
329 |
330 |     def mutate(self, _info: Any, category_id: int) -> DeleteCategoryOutput:
    |                             ^^^ ANN401
331 |         """Delete a category by ID."""
332 |         try:
    |

api\unified_graphql.py:362:39: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `_info`
    |
360 |     category = Field(CategoryType, category_id=Int(required=True, name="categoryId"))
361 |
362 |     def resolve_snippets(self, _info: Any, category_id: int) -> TypedList[SnippetModel]:
    |                                       ^^^ ANN401
363 |         """Resolve all snippets for a given category."""
364 |         manager = get_snippet_manager()
    |

api\unified_graphql.py:367:38: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `_info`
    |
365 |         return manager.list_snippets(category_id)
366 |
367 |     def resolve_snippet(self, _info: Any, snippet_id: int) -> Optional[SnippetModel]:
    |                                      ^^^ ANN401
368 |         """Resolve a specific snippet by ID."""
369 |         try:
    |

api\unified_graphql.py:375:41: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `_info`
    |
373 |             return None
374 |
375 |     def resolve_categories(self, _info: Any) -> TypedList[Category]:
    |                                         ^^^ ANN401
376 |         """Resolve all categories."""
377 |         db_manager = get_db_manager()
    |

api\unified_graphql.py:381:39: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `_info`
    |
379 |         return cat_mgr.list_categories()
380 |
381 |     def resolve_category(self, _info: Any, category_id: int) -> Optional[Category]:
    |                                       ^^^ ANN401
382 |         """Resolve a specific category by ID."""
383 |         try:
    |

Found 83 errors.
[*] 4 fixable with the `--fix` option (1 hidden fix can be enabled with the `--unsafe-fixes` option).
tests\db\test_database_exceptions.py:37:89: E501 Line too long (96 > 88)
   |
35 |         with pytest.raises(ForeignKeyError):
36 |             db_with_tables.execute(
37 |                 "INSERT INTO snippets (snippet_id, category_id, snippet_name) VALUES (?, ?, ?)",
   |                                                                                         ^^^^^^^^ E501
38 |                 (1, 999, "test_snippet"),  # category_id 999 doesn't exist
39 |             )
   |

tests\db\test_database_exceptions.py:88:89: E501 Line too long (89 > 88)
   |
86 |         assert not hasattr(db_with_tables, "conn") or db_with_tables.conn is None
87 |
88 |     def test_table_not_found_error_select(self, db_with_tables: DatabaseManager) -> None:
   |                                                                                         ^ E501
89 |         """Test TableNotFoundError is raised for SELECT from a non-existent table."""
90 |         with pytest.raises(TableNotFoundError):
   |

tests\db\test_database_exceptions.py:93:89: E501 Line too long (89 > 88)
   |
91 |             db_with_tables.execute("SELECT * FROM totally_missing_table")
92 |
93 |     def test_table_not_found_error_insert(self, db_with_tables: DatabaseManager) -> None:
   |                                                                                         ^ E501
94 |         """Test TableNotFoundError is raised for INSERT into a non-existent table."""
95 |         with pytest.raises(TableNotFoundError):
   |

tests\db\test_database_exceptions.py:100:89: E501 Line too long (89 > 88)
    |
 98 |             )
 99 |
100 |     def test_table_not_found_error_update(self, db_with_tables: DatabaseManager) -> None:
    |                                                                                         ^ E501
101 |         """Test TableNotFoundError is raised for UPDATE on a non-existent table."""
102 |         with pytest.raises(TableNotFoundError):
    |

tests\db\test_database_exceptions.py:103:89: E501 Line too long (93 > 88)
    |
101 |         """Test TableNotFoundError is raised for UPDATE on a non-existent table."""
102 |         with pytest.raises(TableNotFoundError):
103 |             db_with_tables.execute("UPDATE missing_table SET name=? WHERE id=?", ("test", 1))
    |                                                                                         ^^^^^ E501
104 |
105 |     def test_table_not_found_error_delete(self, db_with_tables: DatabaseManager) -> None:
    |

tests\db\test_database_exceptions.py:105:89: E501 Line too long (89 > 88)
    |
103 |             db_with_tables.execute("UPDATE missing_table SET name=? WHERE id=?", ("test", 1))
104 |
105 |     def test_table_not_found_error_delete(self, db_with_tables: DatabaseManager) -> None:
    |                                                                                         ^ E501
106 |         """Test TableNotFoundError is raised for DELETE from a non-existent table."""
107 |         with pytest.raises(TableNotFoundError):
    |

tests\db\test_database_manager.py:144:89: E501 Line too long (94 > 88)
    |
142 |         # Verify the table was created by querying sqlite_master
143 |         result = db_manager.fetchone(
144 |             "SELECT name FROM sqlite_master WHERE type='table' AND name=?", (TEST_TABLE_NAME,)
    |                                                                                         ^^^^^^ E501
145 |         )
146 |         assert result is not None
    |

tests\db\test_database_manager.py:166:89: E501 Line too long (97 > 88)
    |
164 |         assert result["email"] == "david@example.com"
165 |
166 |     def test_fetchone_returns_none_for_no_results(self, initialized_db: DatabaseManager) -> None:
    |                                                                                         ^^^^^^^^^ E501
167 |         """Test that fetchone returns None when no results are found."""
168 |         result = initialized_db.fetchone(f"SELECT * FROM {TEST_TABLE_NAME} WHERE id = ?", (999,))
    |

tests\db\test_database_manager.py:168:89: E501 Line too long (97 > 88)
    |
166 |     def test_fetchone_returns_none_for_no_results(self, initialized_db: DatabaseManager) -> None:
167 |         """Test that fetchone returns None when no results are found."""
168 |         result = initialized_db.fetchone(f"SELECT * FROM {TEST_TABLE_NAME} WHERE id = ?", (999,))
    |                                                                                         ^^^^^^^^^ E501
169 |         assert result is None
    |

tests\db\test_database_manager.py:171:89: E501 Line too long (89 > 88)
    |
169 |         assert result is None
170 |
171 |     def test_fetchall_returns_all_results(self, initialized_db: DatabaseManager) -> None:
    |                                                                                         ^ E501
172 |         """Test that fetchall returns all matching rows."""
173 |         results = initialized_db.fetchall(f"SELECT * FROM {TEST_TABLE_NAME} ORDER BY id")
    |

tests\db\test_database_manager.py:173:89: E501 Line too long (89 > 88)
    |
171 |     def test_fetchall_returns_all_results(self, initialized_db: DatabaseManager) -> None:
172 |         """Test that fetchall returns all matching rows."""
173 |         results = initialized_db.fetchall(f"SELECT * FROM {TEST_TABLE_NAME} ORDER BY id")
    |                                                                                         ^ E501
174 |
175 |         assert len(results) == len(TEST_DATA)
    |

tests\db\test_database_manager.py:186:89: E501 Line too long (98 > 88)
    |
184 |     ) -> None:
185 |         """Test that fetchall returns an empty list when no results are found."""
186 |         results = initialized_db.fetchall(f"SELECT * FROM {TEST_TABLE_NAME} WHERE id = ?", (999,))
    |                                                                                         ^^^^^^^^^^ E501
187 |         assert results == []
    |

tests\db\test_database_manager.py:224:89: E501 Line too long (97 > 88)
    |
222 |         # Try to insert into child with invalid parent_id
223 |         with pytest.raises(ForeignKeyError):
224 |             db_manager.execute("INSERT INTO child (id, parent_id, name) VALUES (1, 999, 'test')")
    |                                                                                         ^^^^^^^^^ E501
225 |
226 |     def test_constraint_error_unique(self, db_manager: DatabaseManager) -> None:
    |

tests\db\test_database_manager.py:237:89: E501 Line too long (96 > 88)
    |
236 |         # Insert first row
237 |         db_manager.execute("INSERT INTO test_unique (id, email) VALUES (1, 'test@example.com')")
    |                                                                                         ^^^^^^^^ E501
238 |
239 |         # Try to insert duplicate email
    |

tests\db\test_database_manager.py:241:89: E501 Line too long (100 > 88)
    |
239 |         # Try to insert duplicate email
240 |         with pytest.raises(ConstraintError):
241 |             db_manager.execute("INSERT INTO test_unique (id, email) VALUES (2, 'test@example.com')")
    |                                                                                         ^^^^^^^^^^^^ E501
242 |
243 |     def test_constraint_error_not_null(self, db_manager: DatabaseManager) -> None:
    |

tests\desktop_ui\test_db_viewer_dialog.py:22:5: ANN201 Missing return type annotation for public function `qtapp`
   |
21 | @pytest.fixture
22 | def qtapp():
   |     ^^^^^ ANN201
23 |     """Create a QApplication instance for testing.
24 |     This avoids conflicts with pytest-flask by creating a dedicated QApplication for Qt tests.
   |
   = help: Add return type annotation

tests\desktop_ui\test_db_viewer_dialog.py:24:89: E501 Line too long (94 > 88)
   |
22 | def qtapp():
23 |     """Create a QApplication instance for testing.
24 |     This avoids conflicts with pytest-flask by creating a dedicated QApplication for Qt tests.
   |                                                                                         ^^^^^^ E501
25 |     """
26 |     app = QApplication.instance()
   |

tests\desktop_ui\test_db_viewer_dialog.py:35:9: ANN204 Missing return type annotation for special method `__init__`
   |
33 |     """Simple QtBot class to replace pytest-qt's qtbot when it's not available."""
34 |
35 |     def __init__(self, app):
   |         ^^^^^^^^ ANN204
36 |         self.app = app
37 |         self.widgets = []
   |
   = help: Add return type annotation: `None`

tests\desktop_ui\test_db_viewer_dialog.py:35:24: ANN001 Missing type annotation for function argument `app`
   |
33 |     """Simple QtBot class to replace pytest-qt's qtbot when it's not available."""
34 |
35 |     def __init__(self, app):
   |                        ^^^ ANN001
36 |         self.app = app
37 |         self.widgets = []
   |

tests\desktop_ui\test_db_viewer_dialog.py:39:9: ANN201 Missing return type annotation for public function `addWidget`
   |
37 |         self.widgets = []
38 |
39 |     def addWidget(self, widget):
   |         ^^^^^^^^^ ANN201
40 |         """Keep track of widgets to ensure they don't get garbage collected."""
41 |         self.widgets.append(widget)
   |
   = help: Add return type annotation

tests\desktop_ui\test_db_viewer_dialog.py:39:25: ANN001 Missing type annotation for function argument `widget`
   |
37 |         self.widgets = []
38 |
39 |     def addWidget(self, widget):
   |                         ^^^^^^ ANN001
40 |         """Keep track of widgets to ensure they don't get garbage collected."""
41 |         self.widgets.append(widget)
   |

tests\desktop_ui\test_db_viewer_dialog.py:44:9: ANN201 Missing return type annotation for public function `mouseClick`
   |
42 |         return widget
43 |
44 |     def mouseClick(self, widget, button=Qt.LeftButton, pos=None):
   |         ^^^^^^^^^^ ANN201
45 |         """Simulate mouse click."""
46 |         if pos is None:
   |
   = help: Add return type annotation: `None`

tests\desktop_ui\test_db_viewer_dialog.py:44:26: ANN001 Missing type annotation for function argument `widget`
   |
42 |         return widget
43 |
44 |     def mouseClick(self, widget, button=Qt.LeftButton, pos=None):
   |                          ^^^^^^ ANN001
45 |         """Simulate mouse click."""
46 |         if pos is None:
   |

tests\desktop_ui\test_db_viewer_dialog.py:44:34: ANN001 Missing type annotation for function argument `button`
   |
42 |         return widget
43 |
44 |     def mouseClick(self, widget, button=Qt.LeftButton, pos=None):
   |                                  ^^^^^^ ANN001
45 |         """Simulate mouse click."""
46 |         if pos is None:
   |

tests\desktop_ui\test_db_viewer_dialog.py:44:56: ANN001 Missing type annotation for function argument `pos`
   |
42 |         return widget
43 |
44 |     def mouseClick(self, widget, button=Qt.LeftButton, pos=None):
   |                                                        ^^^ ANN001
45 |         """Simulate mouse click."""
46 |         if pos is None:
   |

tests\desktop_ui\test_db_viewer_dialog.py:57:5: ANN201 Missing return type annotation for public function `qtbot`
   |
56 | @pytest.fixture
57 | def qtbot(qtapp):
   |     ^^^^^ ANN201
58 |     """Create a QtBot instance for testing when pytest-qt's qtbot isn't available."""
59 |     return QtBot(qtapp)
   |
   = help: Add return type annotation

tests\desktop_ui\test_db_viewer_dialog.py:57:11: ANN001 Missing type annotation for function argument `qtapp`
   |
56 | @pytest.fixture
57 | def qtbot(qtapp):
   |           ^^^^^ ANN001
58 |     """Create a QtBot instance for testing when pytest-qt's qtbot isn't available."""
59 |     return QtBot(qtapp)
   |

tests\desktop_ui\test_db_viewer_dialog.py:63:5: ANN201 Missing return type annotation for public function `mock_db_viewer_service`
   |
62 | @pytest.fixture
63 | def mock_db_viewer_service():
   |     ^^^^^^^^^^^^^^^^^^^^^^ ANN201
64 |     """Create a mock DatabaseViewerService for testing."""
65 |     service = MagicMock(spec=DatabaseViewerService)
   |
   = help: Add return type annotation

tests\desktop_ui\test_db_viewer_dialog.py:85:5: ANN201 Missing return type annotation for public function `test_db_viewer_dialog_initialization`
   |
85 | def test_db_viewer_dialog_initialization(qtapp, mock_db_viewer_service, qtbot):
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
86 |     """Test that the DatabaseViewerDialog initializes correctly."""
87 |     # Setup mock for table data with more complete structure
   |
   = help: Add return type annotation: `None`

tests\desktop_ui\test_db_viewer_dialog.py:85:42: ANN001 Missing type annotation for function argument `qtapp`
   |
85 | def test_db_viewer_dialog_initialization(qtapp, mock_db_viewer_service, qtbot):
   |                                          ^^^^^ ANN001
86 |     """Test that the DatabaseViewerDialog initializes correctly."""
87 |     # Setup mock for table data with more complete structure
   |

tests\desktop_ui\test_db_viewer_dialog.py:85:49: ANN001 Missing type annotation for function argument `mock_db_viewer_service`
   |
85 | def test_db_viewer_dialog_initialization(qtapp, mock_db_viewer_service, qtbot):
   |                                                 ^^^^^^^^^^^^^^^^^^^^^^ ANN001
86 |     """Test that the DatabaseViewerDialog initializes correctly."""
87 |     # Setup mock for table data with more complete structure
   |

tests\desktop_ui\test_db_viewer_dialog.py:85:73: ANN001 Missing type annotation for function argument `qtbot`
   |
85 | def test_db_viewer_dialog_initialization(qtapp, mock_db_viewer_service, qtbot):
   |                                                                         ^^^^^ ANN001
86 |     """Test that the DatabaseViewerDialog initializes correctly."""
87 |     # Setup mock for table data with more complete structure
   |

tests\desktop_ui\test_db_viewer_dialog.py:103:89: E501 Line too long (89 > 88)
    |
101 |     qtbot.addWidget(dialog)
102 |
103 |     # Check that the service methods were called to get tables and the first table's data
    |                                                                                         ^ E501
104 |     mock_db_viewer_service.list_tables.assert_called_once()
105 |     # Auto-selection happens in load_tables, so get_table_data should be called for table1
    |

tests\desktop_ui\test_db_viewer_dialog.py:105:89: E501 Line too long (90 > 88)
    |
103 |     # Check that the service methods were called to get tables and the first table's data
104 |     mock_db_viewer_service.list_tables.assert_called_once()
105 |     # Auto-selection happens in load_tables, so get_table_data should be called for table1
    |                                                                                         ^^ E501
106 |     mock_db_viewer_service.get_table_data.assert_called_with(
107 |         table_name="table1",  # First table should be auto-selected
    |

tests\desktop_ui\test_db_viewer_dialog.py:118:89: E501 Line too long (90 > 88)
    |
116 |     # Check UI components initialized correctly
117 |     assert dialog.windowTitle() == "Database Viewer"
118 |     assert dialog.table_combo.count() == 3  # Should have 3 items (table1, table2, table3)
    |                                                                                         ^^ E501
119 |     assert dialog.current_table == "table1"  # First table should be auto-selected
120 |     assert dialog.page == 1  # Initial page
    |

tests\desktop_ui\test_db_viewer_dialog.py:137:5: ANN201 Missing return type annotation for public function `test_table_selection`
    |
137 | def test_table_selection(qtapp, mock_db_viewer_service, qtbot):
    |     ^^^^^^^^^^^^^^^^^^^^ ANN201
138 |     """Test that selecting a table loads its data."""
139 |     dialog = DatabaseViewerDialog(service=mock_db_viewer_service)
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_db_viewer_dialog.py:137:26: ANN001 Missing type annotation for function argument `qtapp`
    |
137 | def test_table_selection(qtapp, mock_db_viewer_service, qtbot):
    |                          ^^^^^ ANN001
138 |     """Test that selecting a table loads its data."""
139 |     dialog = DatabaseViewerDialog(service=mock_db_viewer_service)
    |

tests\desktop_ui\test_db_viewer_dialog.py:137:33: ANN001 Missing type annotation for function argument `mock_db_viewer_service`
    |
137 | def test_table_selection(qtapp, mock_db_viewer_service, qtbot):
    |                                 ^^^^^^^^^^^^^^^^^^^^^^ ANN001
138 |     """Test that selecting a table loads its data."""
139 |     dialog = DatabaseViewerDialog(service=mock_db_viewer_service)
    |

tests\desktop_ui\test_db_viewer_dialog.py:137:57: ANN001 Missing type annotation for function argument `qtbot`
    |
137 | def test_table_selection(qtapp, mock_db_viewer_service, qtbot):
    |                                                         ^^^^^ ANN001
138 |     """Test that selecting a table loads its data."""
139 |     dialog = DatabaseViewerDialog(service=mock_db_viewer_service)
    |

tests\desktop_ui\test_db_viewer_dialog.py:162:89: E501 Line too long (93 > 88)
    |
160 |     dialog.on_table_selected("table2")
161 |
162 |     # Check that the service method was called to get table data for the newly selected table
    |                                                                                         ^^^^^ E501
163 |     mock_db_viewer_service.get_table_data.assert_called_once_with(
164 |         table_name="table2",
    |

tests\desktop_ui\test_db_viewer_dialog.py:184:5: ANN201 Missing return type annotation for public function `test_pagination`
    |
184 | def test_pagination(qtapp, mock_db_viewer_service, qtbot):
    |     ^^^^^^^^^^^^^^^ ANN201
185 |     """Test pagination controls."""
186 |     # First prepare the mock to return pagination data
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_db_viewer_dialog.py:184:21: ANN001 Missing type annotation for function argument `qtapp`
    |
184 | def test_pagination(qtapp, mock_db_viewer_service, qtbot):
    |                     ^^^^^ ANN001
185 |     """Test pagination controls."""
186 |     # First prepare the mock to return pagination data
    |

tests\desktop_ui\test_db_viewer_dialog.py:184:28: ANN001 Missing type annotation for function argument `mock_db_viewer_service`
    |
184 | def test_pagination(qtapp, mock_db_viewer_service, qtbot):
    |                            ^^^^^^^^^^^^^^^^^^^^^^ ANN001
185 |     """Test pagination controls."""
186 |     # First prepare the mock to return pagination data
    |

tests\desktop_ui\test_db_viewer_dialog.py:184:52: ANN001 Missing type annotation for function argument `qtbot`
    |
184 | def test_pagination(qtapp, mock_db_viewer_service, qtbot):
    |                                                    ^^^^^ ANN001
185 |     """Test pagination controls."""
186 |     # First prepare the mock to return pagination data
    |

tests\desktop_ui\test_db_viewer_dialog.py:241:5: ANN201 Missing return type annotation for public function `test_sorting`
    |
241 | def test_sorting(qtapp, mock_db_viewer_service, qtbot):
    |     ^^^^^^^^^^^^ ANN201
242 |     """Test column sorting."""
243 |     dialog = DatabaseViewerDialog(service=mock_db_viewer_service)
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_db_viewer_dialog.py:241:18: ANN001 Missing type annotation for function argument `qtapp`
    |
241 | def test_sorting(qtapp, mock_db_viewer_service, qtbot):
    |                  ^^^^^ ANN001
242 |     """Test column sorting."""
243 |     dialog = DatabaseViewerDialog(service=mock_db_viewer_service)
    |

tests\desktop_ui\test_db_viewer_dialog.py:241:25: ANN001 Missing type annotation for function argument `mock_db_viewer_service`
    |
241 | def test_sorting(qtapp, mock_db_viewer_service, qtbot):
    |                         ^^^^^^^^^^^^^^^^^^^^^^ ANN001
242 |     """Test column sorting."""
243 |     dialog = DatabaseViewerDialog(service=mock_db_viewer_service)
    |

tests\desktop_ui\test_db_viewer_dialog.py:241:49: ANN001 Missing type annotation for function argument `qtbot`
    |
241 | def test_sorting(qtapp, mock_db_viewer_service, qtbot):
    |                                                 ^^^^^ ANN001
242 |     """Test column sorting."""
243 |     dialog = DatabaseViewerDialog(service=mock_db_viewer_service)
    |

tests\desktop_ui\test_db_viewer_dialog.py:310:5: ANN201 Missing return type annotation for public function `test_filtering`
    |
310 | def test_filtering(qtapp, mock_db_viewer_service, qtbot):
    |     ^^^^^^^^^^^^^^ ANN201
311 |     """Test table filtering."""
312 |     dialog = DatabaseViewerDialog(service=mock_db_viewer_service)
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_db_viewer_dialog.py:310:20: ANN001 Missing type annotation for function argument `qtapp`
    |
310 | def test_filtering(qtapp, mock_db_viewer_service, qtbot):
    |                    ^^^^^ ANN001
311 |     """Test table filtering."""
312 |     dialog = DatabaseViewerDialog(service=mock_db_viewer_service)
    |

tests\desktop_ui\test_db_viewer_dialog.py:310:27: ANN001 Missing type annotation for function argument `mock_db_viewer_service`
    |
310 | def test_filtering(qtapp, mock_db_viewer_service, qtbot):
    |                           ^^^^^^^^^^^^^^^^^^^^^^ ANN001
311 |     """Test table filtering."""
312 |     dialog = DatabaseViewerDialog(service=mock_db_viewer_service)
    |

tests\desktop_ui\test_db_viewer_dialog.py:310:51: ANN001 Missing type annotation for function argument `qtbot`
    |
310 | def test_filtering(qtapp, mock_db_viewer_service, qtbot):
    |                                                   ^^^^^ ANN001
311 |     """Test table filtering."""
312 |     dialog = DatabaseViewerDialog(service=mock_db_viewer_service)
    |

tests\desktop_ui\test_db_viewer_dialog.py:352:5: ANN201 Missing return type annotation for public function `test_export_to_csv`
    |
350 | @patch("PySide6.QtWidgets.QFileDialog.getSaveFileName")
351 | @patch("PySide6.QtWidgets.QMessageBox.information")
352 | def test_export_to_csv(mock_info_box, mock_get_save_filename, qtapp, mock_db_viewer_service, qtbot):
    |     ^^^^^^^^^^^^^^^^^^ ANN201
353 |     """Test exporting to CSV."""
354 |     # Setup mock to return a file path
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_db_viewer_dialog.py:352:24: ANN001 Missing type annotation for function argument `mock_info_box`
    |
350 | @patch("PySide6.QtWidgets.QFileDialog.getSaveFileName")
351 | @patch("PySide6.QtWidgets.QMessageBox.information")
352 | def test_export_to_csv(mock_info_box, mock_get_save_filename, qtapp, mock_db_viewer_service, qtbot):
    |                        ^^^^^^^^^^^^^ ANN001
353 |     """Test exporting to CSV."""
354 |     # Setup mock to return a file path
    |

tests\desktop_ui\test_db_viewer_dialog.py:352:39: ANN001 Missing type annotation for function argument `mock_get_save_filename`
    |
350 | @patch("PySide6.QtWidgets.QFileDialog.getSaveFileName")
351 | @patch("PySide6.QtWidgets.QMessageBox.information")
352 | def test_export_to_csv(mock_info_box, mock_get_save_filename, qtapp, mock_db_viewer_service, qtbot):
    |                                       ^^^^^^^^^^^^^^^^^^^^^^ ANN001
353 |     """Test exporting to CSV."""
354 |     # Setup mock to return a file path
    |

tests\desktop_ui\test_db_viewer_dialog.py:352:63: ANN001 Missing type annotation for function argument `qtapp`
    |
350 | @patch("PySide6.QtWidgets.QFileDialog.getSaveFileName")
351 | @patch("PySide6.QtWidgets.QMessageBox.information")
352 | def test_export_to_csv(mock_info_box, mock_get_save_filename, qtapp, mock_db_viewer_service, qtbot):
    |                                                               ^^^^^ ANN001
353 |     """Test exporting to CSV."""
354 |     # Setup mock to return a file path
    |

tests\desktop_ui\test_db_viewer_dialog.py:352:70: ANN001 Missing type annotation for function argument `mock_db_viewer_service`
    |
350 | @patch("PySide6.QtWidgets.QFileDialog.getSaveFileName")
351 | @patch("PySide6.QtWidgets.QMessageBox.information")
352 | def test_export_to_csv(mock_info_box, mock_get_save_filename, qtapp, mock_db_viewer_service, qtbot):
    |                                                                      ^^^^^^^^^^^^^^^^^^^^^^ ANN001
353 |     """Test exporting to CSV."""
354 |     # Setup mock to return a file path
    |

tests\desktop_ui\test_db_viewer_dialog.py:352:89: E501 Line too long (100 > 88)
    |
350 | @patch("PySide6.QtWidgets.QFileDialog.getSaveFileName")
351 | @patch("PySide6.QtWidgets.QMessageBox.information")
352 | def test_export_to_csv(mock_info_box, mock_get_save_filename, qtapp, mock_db_viewer_service, qtbot):
    |                                                                                         ^^^^^^^^^^^^ E501
353 |     """Test exporting to CSV."""
354 |     # Setup mock to return a file path
    |

tests\desktop_ui\test_db_viewer_dialog.py:352:94: ANN001 Missing type annotation for function argument `qtbot`
    |
350 | @patch("PySide6.QtWidgets.QFileDialog.getSaveFileName")
351 | @patch("PySide6.QtWidgets.QMessageBox.information")
352 | def test_export_to_csv(mock_info_box, mock_get_save_filename, qtapp, mock_db_viewer_service, qtbot):
    |                                                                                              ^^^^^ ANN001
353 |     """Test exporting to CSV."""
354 |     # Setup mock to return a file path
    |

tests\desktop_ui\test_db_viewer_dialog.py:371:9: ANN202 Missing return type annotation for private function `custom_export`
    |
370 |     # Create a custom implementation of export_to_csv to bypass QFileDialog issue
371 |     def custom_export():
    |         ^^^^^^^^^^^^^ ANN202
372 |         # This simulates user selecting a file name from QFileDialog
373 |         # and the method proceeding with that file name
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_db_viewer_dialog.py:396:89: E501 Line too long (97 > 88)
    |
394 |     # Check service called with correct parameters
395 |     mock_db_viewer_service.export_table_to_csv.assert_called_once_with(
396 |         table_name="table1", output_file="test_export.csv", filter_column=None, filter_value=None
    |                                                                                         ^^^^^^^^^ E501
397 |     )
    |

tests\desktop_ui\test_db_viewer_dialog.py:405:5: ANN201 Missing return type annotation for public function `test_error_handling`
    |
405 | def test_error_handling(qtapp, mock_db_viewer_service, qtbot):
    |     ^^^^^^^^^^^^^^^^^^^ ANN201
406 |     """Test error handling for service exceptions."""
407 |     dialog = DatabaseViewerDialog(service=mock_db_viewer_service)
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_db_viewer_dialog.py:405:25: ANN001 Missing type annotation for function argument `qtapp`
    |
405 | def test_error_handling(qtapp, mock_db_viewer_service, qtbot):
    |                         ^^^^^ ANN001
406 |     """Test error handling for service exceptions."""
407 |     dialog = DatabaseViewerDialog(service=mock_db_viewer_service)
    |

tests\desktop_ui\test_db_viewer_dialog.py:405:32: ANN001 Missing type annotation for function argument `mock_db_viewer_service`
    |
405 | def test_error_handling(qtapp, mock_db_viewer_service, qtbot):
    |                                ^^^^^^^^^^^^^^^^^^^^^^ ANN001
406 |     """Test error handling for service exceptions."""
407 |     dialog = DatabaseViewerDialog(service=mock_db_viewer_service)
    |

tests\desktop_ui\test_db_viewer_dialog.py:405:56: ANN001 Missing type annotation for function argument `qtbot`
    |
405 | def test_error_handling(qtapp, mock_db_viewer_service, qtbot):
    |                                                        ^^^^^ ANN001
406 |     """Test error handling for service exceptions."""
407 |     dialog = DatabaseViewerDialog(service=mock_db_viewer_service)
    |

tests\desktop_ui\test_db_viewer_dialog.py:429:5: ANN201 Missing return type annotation for public function `test_empty_table_handling`
    |
429 | def test_empty_table_handling(qtapp, mock_db_viewer_service, qtbot):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
430 |     """Test handling of empty tables."""
431 |     # Configure service to return empty table data
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_db_viewer_dialog.py:429:31: ANN001 Missing type annotation for function argument `qtapp`
    |
429 | def test_empty_table_handling(qtapp, mock_db_viewer_service, qtbot):
    |                               ^^^^^ ANN001
430 |     """Test handling of empty tables."""
431 |     # Configure service to return empty table data
    |

tests\desktop_ui\test_db_viewer_dialog.py:429:38: ANN001 Missing type annotation for function argument `mock_db_viewer_service`
    |
429 | def test_empty_table_handling(qtapp, mock_db_viewer_service, qtbot):
    |                                      ^^^^^^^^^^^^^^^^^^^^^^ ANN001
430 |     """Test handling of empty tables."""
431 |     # Configure service to return empty table data
    |

tests\desktop_ui\test_db_viewer_dialog.py:429:62: ANN001 Missing type annotation for function argument `qtbot`
    |
429 | def test_empty_table_handling(qtapp, mock_db_viewer_service, qtbot):
    |                                                              ^^^^^ ANN001
430 |     """Test handling of empty tables."""
431 |     # Configure service to return empty table data
    |

tests\desktop_ui\test_db_viewer_dialog.py:460:5: ANN201 Missing return type annotation for public function `test_count_result_edge_cases`
    |
460 | def test_count_result_edge_cases(qtapp, qtbot):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
461 |     """Test edge cases in count result handling that could cause tuple index out of range."""
462 |     from services.database_viewer_service import DatabaseViewerService
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_db_viewer_dialog.py:460:34: ANN001 Missing type annotation for function argument `qtapp`
    |
460 | def test_count_result_edge_cases(qtapp, qtbot):
    |                                  ^^^^^ ANN001
461 |     """Test edge cases in count result handling that could cause tuple index out of range."""
462 |     from services.database_viewer_service import DatabaseViewerService
    |

tests\desktop_ui\test_db_viewer_dialog.py:460:41: ANN001 Missing type annotation for function argument `qtbot`
    |
460 | def test_count_result_edge_cases(qtapp, qtbot):
    |                                         ^^^^^ ANN001
461 |     """Test edge cases in count result handling that could cause tuple index out of range."""
462 |     from services.database_viewer_service import DatabaseViewerService
    |

tests\desktop_ui\test_db_viewer_dialog.py:461:89: E501 Line too long (93 > 88)
    |
460 | def test_count_result_edge_cases(qtapp, qtbot):
461 |     """Test edge cases in count result handling that could cause tuple index out of range."""
    |                                                                                         ^^^^^ E501
462 |     from services.database_viewer_service import DatabaseViewerService
463 |     from unittest.mock import MagicMock
    |

tests\desktop_ui\test_db_viewer_dialog.py:462:5: I001 [*] Import block is un-sorted or un-formatted
    |
460 |   def test_count_result_edge_cases(qtapp, qtbot):
461 |       """Test edge cases in count result handling that could cause tuple index out of range."""
462 | /     from services.database_viewer_service import DatabaseViewerService
463 | |     from unittest.mock import MagicMock
    | |_______________________________________^ I001
464 |
465 |       # Create a real service instance with mocked db_manager
    |
    = help: Organize imports

tests\desktop_ui\test_db_viewer_dialog.py:503:5: ANN201 Missing return type annotation for public function `test_pagination_with_zero_total_pages`
    |
503 | def test_pagination_with_zero_total_pages(qtapp, mock_db_viewer_service, qtbot):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
504 |     """Test pagination controls when total_pages is 0."""
505 |     # Configure service to return data with 0 total pages
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_db_viewer_dialog.py:503:43: ANN001 Missing type annotation for function argument `qtapp`
    |
503 | def test_pagination_with_zero_total_pages(qtapp, mock_db_viewer_service, qtbot):
    |                                           ^^^^^ ANN001
504 |     """Test pagination controls when total_pages is 0."""
505 |     # Configure service to return data with 0 total pages
    |

tests\desktop_ui\test_db_viewer_dialog.py:503:50: ANN001 Missing type annotation for function argument `mock_db_viewer_service`
    |
503 | def test_pagination_with_zero_total_pages(qtapp, mock_db_viewer_service, qtbot):
    |                                                  ^^^^^^^^^^^^^^^^^^^^^^ ANN001
504 |     """Test pagination controls when total_pages is 0."""
505 |     # Configure service to return data with 0 total pages
    |

tests\desktop_ui\test_db_viewer_dialog.py:503:74: ANN001 Missing type annotation for function argument `qtbot`
    |
503 | def test_pagination_with_zero_total_pages(qtapp, mock_db_viewer_service, qtbot):
    |                                                                          ^^^^^ ANN001
504 |     """Test pagination controls when total_pages is 0."""
505 |     # Configure service to return data with 0 total pages
    |

tests\desktop_ui\test_db_viewer_dialog.py:531:5: ANN201 Missing return type annotation for public function `test_service_integration_with_real_count_scenarios`
    |
531 | def test_service_integration_with_real_count_scenarios(qtapp, qtbot):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
532 |     """Test service integration with various count result scenarios."""
533 |     from services.database_viewer_service import DatabaseViewerService
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_db_viewer_dialog.py:531:56: ANN001 Missing type annotation for function argument `qtapp`
    |
531 | def test_service_integration_with_real_count_scenarios(qtapp, qtbot):
    |                                                        ^^^^^ ANN001
532 |     """Test service integration with various count result scenarios."""
533 |     from services.database_viewer_service import DatabaseViewerService
    |

tests\desktop_ui\test_db_viewer_dialog.py:531:63: ANN001 Missing type annotation for function argument `qtbot`
    |
531 | def test_service_integration_with_real_count_scenarios(qtapp, qtbot):
    |                                                               ^^^^^ ANN001
532 |     """Test service integration with various count result scenarios."""
533 |     from services.database_viewer_service import DatabaseViewerService
    |

tests\desktop_ui\test_db_viewer_dialog.py:533:5: I001 [*] Import block is un-sorted or un-formatted
    |
531 |   def test_service_integration_with_real_count_scenarios(qtapp, qtbot):
532 |       """Test service integration with various count result scenarios."""
533 | /     from services.database_viewer_service import DatabaseViewerService
534 | |     from unittest.mock import MagicMock
    | |_______________________________________^ I001
535 |
536 |       # Create service with mocked database manager
    |
    = help: Organize imports

tests\desktop_ui\test_db_viewer_dialog_fixed.py:25:89: E501 Line too long (94 > 88)
   |
23 | def qtapp() -> QApplication:
24 |     """Create a QApplication instance for testing.
25 |     This avoids conflicts with pytest-flask by creating a dedicated QApplication for Qt tests.
   |                                                                                         ^^^^^^ E501
26 |     """
27 |     app = QApplication.instance()
   |

tests\desktop_ui\test_db_viewer_dialog_fixed.py:41:33: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `widget`
   |
39 |         self.widgets: List[Any] = []
40 |
41 |     def addWidget(self, widget: Any) -> Any:
   |                                 ^^^ ANN401
42 |         """Keep track of widgets to ensure they don't get garbage collected."""
43 |         self.widgets.append(widget)
   |

tests\desktop_ui\test_db_viewer_dialog_fixed.py:41:41: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `addWidget`
   |
39 |         self.widgets: List[Any] = []
40 |
41 |     def addWidget(self, widget: Any) -> Any:
   |                                         ^^^ ANN401
42 |         """Keep track of widgets to ensure they don't get garbage collected."""
43 |         self.widgets.append(widget)
   |

tests\desktop_ui\test_db_viewer_dialog_fixed.py:46:34: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `widget`
   |
44 |         return widget
45 |
46 |     def mouseClick(self, widget: Any, button: Any = Qt.LeftButton, pos: Any = None) -> None:
   |                                  ^^^ ANN401
47 |         """Simulate mouse click."""
48 |         if pos is None:
   |

tests\desktop_ui\test_db_viewer_dialog_fixed.py:46:47: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `button`
   |
44 |         return widget
45 |
46 |     def mouseClick(self, widget: Any, button: Any = Qt.LeftButton, pos: Any = None) -> None:
   |                                               ^^^ ANN401
47 |         """Simulate mouse click."""
48 |         if pos is None:
   |

tests\desktop_ui\test_db_viewer_dialog_fixed.py:46:73: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `pos`
   |
44 |         return widget
45 |
46 |     def mouseClick(self, widget: Any, button: Any = Qt.LeftButton, pos: Any = None) -> None:
   |                                                                         ^^^ ANN401
47 |         """Simulate mouse click."""
48 |         if pos is None:
   |

tests\desktop_ui\test_db_viewer_dialog_fixed.py:46:89: E501 Line too long (92 > 88)
   |
44 |         return widget
45 |
46 |     def mouseClick(self, widget: Any, button: Any = Qt.LeftButton, pos: Any = None) -> None:
   |                                                                                         ^^^^ E501
47 |         """Simulate mouse click."""
48 |         if pos is None:
   |

tests\desktop_ui\test_db_viewer_dialog_fixed.py:119:89: E501 Line too long (89 > 88)
    |
117 |     qtbot.addWidget(dialog)
118 |
119 |     # Check that the service methods were called to get tables and the first table's data
    |                                                                                         ^ E501
120 |     mock_db_viewer_service.list_tables.assert_called_once()
121 |     # Auto-selection happens in load_tables, so get_table_data should be called for table1
    |

tests\desktop_ui\test_db_viewer_dialog_fixed.py:121:89: E501 Line too long (90 > 88)
    |
119 |     # Check that the service methods were called to get tables and the first table's data
120 |     mock_db_viewer_service.list_tables.assert_called_once()
121 |     # Auto-selection happens in load_tables, so get_table_data should be called for table1
    |                                                                                         ^^ E501
122 |     mock_db_viewer_service.get_table_data.assert_called_with(
123 |         table_name="table1",  # First table should be auto-selected
    |

tests\desktop_ui\test_db_viewer_dialog_fixed.py:134:89: E501 Line too long (90 > 88)
    |
132 |     # Check UI components initialized correctly
133 |     assert dialog.windowTitle() == "Database Viewer"
134 |     assert dialog.table_combo.count() == 3  # Should have 3 items (table1, table2, table3)
    |                                                                                         ^^ E501
135 |     assert dialog.current_table == "table1"  # First table should be auto-selected
136 |     assert dialog.page == 1  # Initial page
    |

tests\desktop_ui\test_db_viewer_dialog_fixed.py:181:89: E501 Line too long (93 > 88)
    |
179 |     dialog.on_table_selected("table2")
180 |
181 |     # Check that the service method was called to get table data for the newly selected table
    |                                                                                         ^^^^^ E501
182 |     mock_db_viewer_service.get_table_data.assert_called_once_with(
183 |         table_name="table2",
    |

tests\desktop_ui\test_db_viewer_dialog_fixed.py:209:89: E501 Line too long (98 > 88)
    |
209 | def test_pagination(qtapp: QApplication, mock_db_viewer_service: MagicMock, qtbot: QtBot) -> None:
    |                                                                                         ^^^^^^^^^^ E501
210 |     """Test pagination controls."""
211 |     # First prepare the mock to return pagination data
    |

tests\desktop_ui\test_db_viewer_dialog_fixed.py:305:89: E501 Line too long (97 > 88)
    |
305 | def test_filtering(qtapp: QApplication, mock_db_viewer_service: MagicMock, qtbot: QtBot) -> None:
    |                                                                                         ^^^^^^^^^ E501
306 |     """Test table filtering functionality."""
307 |     dialog = DatabaseViewerDialog(service=mock_db_viewer_service)
    |

tests\desktop_ui\test_library_main_ui_new.py:4:89: E501 Line too long (97 > 88)
  |
2 | Tests for LibraryManager and Snippets Library functionality.
3 |
4 | This test suite covers only the models/library.py logic (categories, snippets, CRUD, validation).
  |                                                                                         ^^^^^^^^^ E501
5 | """
  |

tests\desktop_ui\test_library_main_ui_new.py:76:5: ANN201 Missing return type annotation for public function `qt_app`
   |
75 | @pytest.fixture(scope="module")
76 | def qt_app():
   |     ^^^^^^ ANN201
77 |     """Provide a QApplication instance for UI tests."""
78 |     app = QApplication.instance()
   |
   = help: Add return type annotation

tests\desktop_ui\test_library_main_ui_new.py:85:5: ANN201 Missing return type annotation for public function `mock_db_manager`
   |
84 | @pytest.fixture
85 | def mock_db_manager(db_manager):
   |     ^^^^^^^^^^^^^^^ ANN201
86 |     # Patch CategoryManager and SnippetManager to use the test db
87 |     return db_manager
   |
   = help: Add return type annotation

tests\desktop_ui\test_library_main_ui_new.py:85:21: ANN001 Missing type annotation for function argument `db_manager`
   |
84 | @pytest.fixture
85 | def mock_db_manager(db_manager):
   |                     ^^^^^^^^^^ ANN001
86 |     # Patch CategoryManager and SnippetManager to use the test db
87 |     return db_manager
   |

tests\desktop_ui\test_library_main_ui_new.py:91:5: ANN201 Missing return type annotation for public function `main_window`
   |
90 | @pytest.fixture
91 | def main_window(qt_app, mock_db_manager):
   |     ^^^^^^^^^^^ ANN201
92 |     win = library_main.LibraryMainWindow(db_manager=mock_db_manager, testing_mode=True)
93 |     yield win
   |
   = help: Add return type annotation

tests\desktop_ui\test_library_main_ui_new.py:91:17: ANN001 Missing type annotation for function argument `qt_app`
   |
90 | @pytest.fixture
91 | def main_window(qt_app, mock_db_manager):
   |                 ^^^^^^ ANN001
92 |     win = library_main.LibraryMainWindow(db_manager=mock_db_manager, testing_mode=True)
93 |     yield win
   |

tests\desktop_ui\test_library_main_ui_new.py:91:25: ANN001 Missing type annotation for function argument `mock_db_manager`
   |
90 | @pytest.fixture
91 | def main_window(qt_app, mock_db_manager):
   |                         ^^^^^^^^^^^^^^^ ANN001
92 |     win = library_main.LibraryMainWindow(db_manager=mock_db_manager, testing_mode=True)
93 |     yield win
   |

tests\desktop_ui\test_library_main_ui_new.py:139:89: E501 Line too long (91 > 88)
    |
137 |     library_manager.edit_snippet(snip_id, "Edited", "New content")
138 |     snippets = library_manager.list_snippets(cat_id)
139 |     assert any(s.snippet_name == "Edited" and s.content == "New content" for s in snippets)
    |                                                                                         ^^^ E501
    |

tests\desktop_ui\test_library_main_ui_new.py:153:10: B017 Do not assert blind exception: `Exception`
    |
151 | def test_create_snippet_invalid_category(library_manager: LibraryManager) -> None:
152 |     """Test creating a snippet with an invalid category."""
153 |     with pytest.raises(Exception):
    |          ^^^^^^^^^^^^^^^^^^^^^^^^ B017
154 |         library_manager.create_snippet("nonexistent", "Name", "Content")
    |

tests\desktop_ui\test_library_main_ui_new.py:159:10: B017 Do not assert blind exception: `Exception`
    |
157 | def test_edit_snippet_invalid_id(library_manager: LibraryManager) -> None:
158 |     """Test editing a snippet with an invalid ID."""
159 |     with pytest.raises(Exception):
    |          ^^^^^^^^^^^^^^^^^^^^^^^^ B017
160 |         library_manager.edit_snippet("badid", "Name", "Content")
    |

tests\desktop_ui\test_library_main_ui_new.py:183:9: ANN201 Missing return type annotation for public function `test_load_data_and_initial_state`
    |
182 | class TestLibraryMainWindowUI:
183 |     def test_load_data_and_initial_state(self, main_window):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
184 |         win = main_window
185 |         # Should load with no categories/snippets
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:183:48: ANN001 Missing type annotation for function argument `main_window`
    |
182 | class TestLibraryMainWindowUI:
183 |     def test_load_data_and_initial_state(self, main_window):
    |                                                ^^^^^^^^^^^ ANN001
184 |         win = main_window
185 |         # Should load with no categories/snippets
    |

tests\desktop_ui\test_library_main_ui_new.py:190:9: ANN201 Missing return type annotation for public function `test_add_category`
    |
188 |         assert win.status.text() == ""
189 |
190 |     def test_add_category(self, main_window, monkeypatch):
    |         ^^^^^^^^^^^^^^^^^ ANN201
191 |         win = main_window
192 |         # Simulate dialog returning Accepted and a name
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:190:33: ANN001 Missing type annotation for function argument `main_window`
    |
188 |         assert win.status.text() == ""
189 |
190 |     def test_add_category(self, main_window, monkeypatch):
    |                                 ^^^^^^^^^^^ ANN001
191 |         win = main_window
192 |         # Simulate dialog returning Accepted and a name
    |

tests\desktop_ui\test_library_main_ui_new.py:190:46: ANN001 Missing type annotation for function argument `monkeypatch`
    |
188 |         assert win.status.text() == ""
189 |
190 |     def test_add_category(self, main_window, monkeypatch):
    |                                              ^^^^^^^^^^^ ANN001
191 |         win = main_window
192 |         # Simulate dialog returning Accepted and a name
    |

tests\desktop_ui\test_library_main_ui_new.py:193:89: E501 Line too long (93 > 88)
    |
191 |         win = main_window
192 |         # Simulate dialog returning Accepted and a name
193 |         monkeypatch.setattr("desktop_ui.modern_dialogs.CategoryDialog.exec_", lambda self: 1)
    |                                                                                         ^^^^^ E501
194 |         monkeypatch.setattr(
195 |             "desktop_ui.modern_dialogs.CategoryDialog.get_value", lambda self: "UI Cat"
    |

tests\desktop_ui\test_library_main_ui_new.py:202:9: ANN201 Missing return type annotation for public function `test_edit_category`
    |
200 |         assert win.categoryList.count() > 0
201 |
202 |     def test_edit_category(self, main_window, monkeypatch):
    |         ^^^^^^^^^^^^^^^^^^ ANN201
203 |         win = main_window
204 |         # Ensure there is at least one category to edit
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:202:34: ANN001 Missing type annotation for function argument `main_window`
    |
200 |         assert win.categoryList.count() > 0
201 |
202 |     def test_edit_category(self, main_window, monkeypatch):
    |                                  ^^^^^^^^^^^ ANN001
203 |         win = main_window
204 |         # Ensure there is at least one category to edit
    |

tests\desktop_ui\test_library_main_ui_new.py:202:47: ANN001 Missing type annotation for function argument `monkeypatch`
    |
200 |         assert win.categoryList.count() > 0
201 |
202 |     def test_edit_category(self, main_window, monkeypatch):
    |                                               ^^^^^^^^^^^ ANN001
203 |         win = main_window
204 |         # Ensure there is at least one category to edit
    |

tests\desktop_ui\test_library_main_ui_new.py:208:21: ANN202 Missing return type annotation for private function `exec_`
    |
207 |             class FakeAddDialog:
208 |                 def exec_(self):
    |                     ^^^^^ ANN202
209 |                     return 1
    |
    = help: Add return type annotation: `int`

tests\desktop_ui\test_library_main_ui_new.py:211:21: ANN202 Missing return type annotation for private function `get_value`
    |
209 |                     return 1
210 |
211 |                 def get_value(self):
    |                     ^^^^^^^^^ ANN202
212 |                     return "Initial Cat"
    |
    = help: Add return type annotation: `str`

tests\desktop_ui\test_library_main_ui_new.py:214:89: E501 Line too long (96 > 88)
    |
212 |                     return "Initial Cat"
213 |
214 |             monkeypatch.setattr(library_main, "CategoryDialog", lambda *a, **k: FakeAddDialog())
    |                                                                                         ^^^^^^^^ E501
215 |             win.add_category()
216 |         # Select the first category
    |

tests\desktop_ui\test_library_main_ui_new.py:220:17: ANN202 Missing return type annotation for private function `exec_`
    |
219 |         class FakeEditDialog:
220 |             def exec_(self):
    |                 ^^^^^ ANN202
221 |                 return 1
    |
    = help: Add return type annotation: `int`

tests\desktop_ui\test_library_main_ui_new.py:223:17: ANN202 Missing return type annotation for private function `get_value`
    |
221 |                 return 1
222 |
223 |             def get_value(self):
    |                 ^^^^^^^^^ ANN202
224 |                 return "Renamed Cat"
    |
    = help: Add return type annotation: `str`

tests\desktop_ui\test_library_main_ui_new.py:226:89: E501 Line too long (93 > 88)
    |
224 |                 return "Renamed Cat"
225 |
226 |         monkeypatch.setattr(library_main, "CategoryDialog", lambda *a, **k: FakeEditDialog())
    |                                                                                         ^^^^^ E501
227 |         win.edit_category()
228 |         assert any(c.category_name == "Renamed Cat" for c in win.categories)
    |

tests\desktop_ui\test_library_main_ui_new.py:231:9: ANN201 Missing return type annotation for public function `test_delete_category`
    |
229 |         assert win.status.text() == "Category updated."
230 |
231 |     def test_delete_category(self, main_window, monkeypatch):
    |         ^^^^^^^^^^^^^^^^^^^^ ANN201
232 |         win = main_window
233 |         win.categoryList.setCurrentRow(0)
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:231:36: ANN001 Missing type annotation for function argument `main_window`
    |
229 |         assert win.status.text() == "Category updated."
230 |
231 |     def test_delete_category(self, main_window, monkeypatch):
    |                                    ^^^^^^^^^^^ ANN001
232 |         win = main_window
233 |         win.categoryList.setCurrentRow(0)
    |

tests\desktop_ui\test_library_main_ui_new.py:231:49: ANN001 Missing type annotation for function argument `monkeypatch`
    |
229 |         assert win.status.text() == "Category updated."
230 |
231 |     def test_delete_category(self, main_window, monkeypatch):
    |                                                 ^^^^^^^^^^^ ANN001
232 |         win = main_window
233 |         win.categoryList.setCurrentRow(0)
    |

tests\desktop_ui\test_library_main_ui_new.py:236:89: E501 Line too long (99 > 88)
    |
234 |         cat = win.categories[0]
235 |         # Simulate user confirming deletion
236 |         monkeypatch.setattr("PySide6.QtWidgets.QMessageBox.question", lambda *a, **k: 16384)  # Yes
    |                                                                                         ^^^^^^^^^^^ E501
237 |         win.delete_category()
238 |         assert all(c.category_name != cat.category_name for c in win.categories)
    |

tests\desktop_ui\test_library_main_ui_new.py:241:9: ANN201 Missing return type annotation for public function `test_add_snippet`
    |
239 |         assert win.status.text() == "Category deleted."
240 |
241 |     def test_add_snippet(self, main_window, monkeypatch):
    |         ^^^^^^^^^^^^^^^^ ANN201
242 |         win = main_window
243 |         # Add a category first
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:241:32: ANN001 Missing type annotation for function argument `main_window`
    |
239 |         assert win.status.text() == "Category deleted."
240 |
241 |     def test_add_snippet(self, main_window, monkeypatch):
    |                                ^^^^^^^^^^^ ANN001
242 |         win = main_window
243 |         # Add a category first
    |

tests\desktop_ui\test_library_main_ui_new.py:241:45: ANN001 Missing type annotation for function argument `monkeypatch`
    |
239 |         assert win.status.text() == "Category deleted."
240 |
241 |     def test_add_snippet(self, main_window, monkeypatch):
    |                                             ^^^^^^^^^^^ ANN001
242 |         win = main_window
243 |         # Add a category first
    |

tests\desktop_ui\test_library_main_ui_new.py:244:89: E501 Line too long (93 > 88)
    |
242 |         win = main_window
243 |         # Add a category first
244 |         monkeypatch.setattr("desktop_ui.modern_dialogs.CategoryDialog.exec_", lambda self: 1)
    |                                                                                         ^^^^^ E501
245 |         monkeypatch.setattr(
246 |             "desktop_ui.modern_dialogs.CategoryDialog.get_value", lambda self: "Cat2"
    |

tests\desktop_ui\test_library_main_ui_new.py:251:89: E501 Line too long (92 > 88)
    |
249 |         win.categoryList.setCurrentRow(0)
250 |         # Simulate snippet dialog
251 |         monkeypatch.setattr("desktop_ui.modern_dialogs.SnippetDialog.exec_", lambda self: 1)
    |                                                                                         ^^^^ E501
252 |         monkeypatch.setattr(
253 |             "desktop_ui.modern_dialogs.SnippetDialog.get_values", lambda self: ("Snip1", "Content1")
    |

tests\desktop_ui\test_library_main_ui_new.py:253:89: E501 Line too long (100 > 88)
    |
251 |         monkeypatch.setattr("desktop_ui.modern_dialogs.SnippetDialog.exec_", lambda self: 1)
252 |         monkeypatch.setattr(
253 |             "desktop_ui.modern_dialogs.SnippetDialog.get_values", lambda self: ("Snip1", "Content1")
    |                                                                                         ^^^^^^^^^^^^ E501
254 |         )
255 |         win.add_snippet()
    |

tests\desktop_ui\test_library_main_ui_new.py:259:9: ANN201 Missing return type annotation for public function `test_edit_snippet`
    |
257 |         assert win.status.text() == "Snippet added."
258 |
259 |     def test_edit_snippet(self, main_window, monkeypatch):
    |         ^^^^^^^^^^^^^^^^^ ANN201
260 |         win = main_window
261 |         win.snippetList.setCurrentRow(0)
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:259:33: ANN001 Missing type annotation for function argument `main_window`
    |
257 |         assert win.status.text() == "Snippet added."
258 |
259 |     def test_edit_snippet(self, main_window, monkeypatch):
    |                                 ^^^^^^^^^^^ ANN001
260 |         win = main_window
261 |         win.snippetList.setCurrentRow(0)
    |

tests\desktop_ui\test_library_main_ui_new.py:259:46: ANN001 Missing type annotation for function argument `monkeypatch`
    |
257 |         assert win.status.text() == "Snippet added."
258 |
259 |     def test_edit_snippet(self, main_window, monkeypatch):
    |                                              ^^^^^^^^^^^ ANN001
260 |         win = main_window
261 |         win.snippetList.setCurrentRow(0)
    |

tests\desktop_ui\test_library_main_ui_new.py:262:89: E501 Line too long (92 > 88)
    |
260 |         win = main_window
261 |         win.snippetList.setCurrentRow(0)
262 |         monkeypatch.setattr("desktop_ui.modern_dialogs.SnippetDialog.exec_", lambda self: 1)
    |                                                                                         ^^^^ E501
263 |         monkeypatch.setattr(
264 |             "desktop_ui.modern_dialogs.SnippetDialog.get_values",
    |

tests\desktop_ui\test_library_main_ui_new.py:271:9: ANN201 Missing return type annotation for public function `test_delete_snippet`
    |
269 |         assert win.status.text() == "Snippet updated."
270 |
271 |     def test_delete_snippet(self, main_window, monkeypatch):
    |         ^^^^^^^^^^^^^^^^^^^ ANN201
272 |         win = main_window
273 |         win.snippetList.setCurrentRow(0)
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:271:35: ANN001 Missing type annotation for function argument `main_window`
    |
269 |         assert win.status.text() == "Snippet updated."
270 |
271 |     def test_delete_snippet(self, main_window, monkeypatch):
    |                                   ^^^^^^^^^^^ ANN001
272 |         win = main_window
273 |         win.snippetList.setCurrentRow(0)
    |

tests\desktop_ui\test_library_main_ui_new.py:271:48: ANN001 Missing type annotation for function argument `monkeypatch`
    |
269 |         assert win.status.text() == "Snippet updated."
270 |
271 |     def test_delete_snippet(self, main_window, monkeypatch):
    |                                                ^^^^^^^^^^^ ANN001
272 |         win = main_window
273 |         win.snippetList.setCurrentRow(0)
    |

tests\desktop_ui\test_library_main_ui_new.py:274:89: E501 Line too long (99 > 88)
    |
272 |         win = main_window
273 |         win.snippetList.setCurrentRow(0)
274 |         monkeypatch.setattr("PySide6.QtWidgets.QMessageBox.question", lambda *a, **k: 16384)  # Yes
    |                                                                                         ^^^^^^^^^^^ E501
275 |         win.delete_snippet()
276 |         assert win.snippetList.count() == 0
    |

tests\desktop_ui\test_library_main_ui_new.py:279:9: ANN201 Missing return type annotation for public function `test_filter_snippets`
    |
277 |         assert win.status.text() == "Snippet deleted."
278 |
279 |     def test_filter_snippets(self, main_window, monkeypatch):
    |         ^^^^^^^^^^^^^^^^^^^^ ANN201
280 |         win = main_window
281 |         # Add a snippet again
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:279:36: ANN001 Missing type annotation for function argument `main_window`
    |
277 |         assert win.status.text() == "Snippet deleted."
278 |
279 |     def test_filter_snippets(self, main_window, monkeypatch):
    |                                    ^^^^^^^^^^^ ANN001
280 |         win = main_window
281 |         # Add a snippet again
    |

tests\desktop_ui\test_library_main_ui_new.py:279:49: ANN001 Missing type annotation for function argument `monkeypatch`
    |
277 |         assert win.status.text() == "Snippet deleted."
278 |
279 |     def test_filter_snippets(self, main_window, monkeypatch):
    |                                                 ^^^^^^^^^^^ ANN001
280 |         win = main_window
281 |         # Add a snippet again
    |

tests\desktop_ui\test_library_main_ui_new.py:282:89: E501 Line too long (92 > 88)
    |
280 |         win = main_window
281 |         # Add a snippet again
282 |         monkeypatch.setattr("desktop_ui.modern_dialogs.SnippetDialog.exec_", lambda self: 1)
    |                                                                                         ^^^^ E501
283 |         monkeypatch.setattr(
284 |             "desktop_ui.modern_dialogs.SnippetDialog.get_values", lambda self: ("Alpha", "A")
    |

tests\desktop_ui\test_library_main_ui_new.py:284:89: E501 Line too long (93 > 88)
    |
282 |         monkeypatch.setattr("desktop_ui.modern_dialogs.SnippetDialog.exec_", lambda self: 1)
283 |         monkeypatch.setattr(
284 |             "desktop_ui.modern_dialogs.SnippetDialog.get_values", lambda self: ("Alpha", "A")
    |                                                                                         ^^^^^ E501
285 |         )
286 |         win.add_snippet()
    |

tests\desktop_ui\test_library_main_ui_new.py:288:89: E501 Line too long (92 > 88)
    |
286 |         win.add_snippet()
287 |         monkeypatch.setattr(
288 |             "desktop_ui.modern_dialogs.SnippetDialog.get_values", lambda self: ("Beta", "B")
    |                                                                                         ^^^^ E501
289 |         )
290 |         win.add_snippet()
    |

tests\desktop_ui\test_library_main_ui_new.py:297:9: ANN201 Missing return type annotation for public function `test_show_error_and_info`
    |
295 |         assert win.snippetList.count() == 2
296 |
297 |     def test_show_error_and_info(self, main_window):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
298 |         win = main_window
299 |         win.show_error("ErrMsg")
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:297:40: ANN001 Missing type annotation for function argument `main_window`
    |
295 |         assert win.snippetList.count() == 2
296 |
297 |     def test_show_error_and_info(self, main_window):
    |                                        ^^^^^^^^^^^ ANN001
298 |         win = main_window
299 |         win.show_error("ErrMsg")
    |

tests\desktop_ui\test_library_main_ui_new.py:304:9: ANN201 Missing return type annotation for public function `test_update_snippet_buttons_state`
    |
302 |         assert win.status.text() == "InfoMsg"
303 |
304 |     def test_update_snippet_buttons_state(self, main_window):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
305 |         win = main_window
306 |         win.update_snippet_buttons_state(True)
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:304:49: ANN001 Missing type annotation for function argument `main_window`
    |
302 |         assert win.status.text() == "InfoMsg"
303 |
304 |     def test_update_snippet_buttons_state(self, main_window):
    |                                                 ^^^^^^^^^^^ ANN001
305 |         win = main_window
306 |         win.update_snippet_buttons_state(True)
    |

tests\desktop_ui\test_library_main_ui_new.py:315:9: ANN201 Missing return type annotation for public function `test_on_category_selection_changed_and_load_snippets`
    |
313 |         assert not win.delSnipBtn.isEnabled()
314 |
315 |     def test_on_category_selection_changed_and_load_snippets(self, main_window):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
316 |         win = main_window
317 |         win.categoryList.setCurrentRow(0)
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:315:68: ANN001 Missing type annotation for function argument `main_window`
    |
313 |         assert not win.delSnipBtn.isEnabled()
314 |
315 |     def test_on_category_selection_changed_and_load_snippets(self, main_window):
    |                                                                    ^^^^^^^^^^^ ANN001
316 |         win = main_window
317 |         win.categoryList.setCurrentRow(0)
    |

tests\desktop_ui\test_library_main_ui_new.py:322:9: ANN201 Missing return type annotation for public function `test_on_snippet_selection_changed`
    |
320 |         assert win.snippetList.count() >= 0
321 |
322 |     def test_on_snippet_selection_changed(self, main_window):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
323 |         win = main_window
324 |         if win.snippetList.count() > 0:
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:322:49: ANN001 Missing type annotation for function argument `main_window`
    |
320 |         assert win.snippetList.count() >= 0
321 |
322 |     def test_on_snippet_selection_changed(self, main_window):
    |                                                 ^^^^^^^^^^^ ANN001
323 |         win = main_window
324 |         if win.snippetList.count() > 0:
    |

tests\desktop_ui\test_library_main_ui_new.py:329:9: ANN201 Missing return type annotation for public function `test_view_snippet`
    |
327 |             assert win.selected_snippet is not None
328 |
329 |     def test_view_snippet(self, main_window, monkeypatch):
    |         ^^^^^^^^^^^^^^^^^ ANN201
330 |         win = main_window
331 |         if win.snippetList.count() > 0:
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:329:33: ANN001 Missing type annotation for function argument `main_window`
    |
327 |             assert win.selected_snippet is not None
328 |
329 |     def test_view_snippet(self, main_window, monkeypatch):
    |                                 ^^^^^^^^^^^ ANN001
330 |         win = main_window
331 |         if win.snippetList.count() > 0:
    |

tests\desktop_ui\test_library_main_ui_new.py:329:46: ANN001 Missing type annotation for function argument `monkeypatch`
    |
327 |             assert win.selected_snippet is not None
328 |
329 |     def test_view_snippet(self, main_window, monkeypatch):
    |                                              ^^^^^^^^^^^ ANN001
330 |         win = main_window
331 |         if win.snippetList.count() > 0:
    |

tests\desktop_ui\test_library_main_ui_new.py:339:9: ANN201 Missing return type annotation for public function `test_add_category_error`
    |
337 |             win.view_snippet(item)
338 |
339 |     def test_add_category_error(self, main_window, monkeypatch):
    |         ^^^^^^^^^^^^^^^^^^^^^^^ ANN201
340 |         win = main_window
341 |         # Simulate dialog accepted but error in save_category
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:339:39: ANN001 Missing type annotation for function argument `main_window`
    |
337 |             win.view_snippet(item)
338 |
339 |     def test_add_category_error(self, main_window, monkeypatch):
    |                                       ^^^^^^^^^^^ ANN001
340 |         win = main_window
341 |         # Simulate dialog accepted but error in save_category
    |

tests\desktop_ui\test_library_main_ui_new.py:339:52: ANN001 Missing type annotation for function argument `monkeypatch`
    |
337 |             win.view_snippet(item)
338 |
339 |     def test_add_category_error(self, main_window, monkeypatch):
    |                                                    ^^^^^^^^^^^ ANN001
340 |         win = main_window
341 |         # Simulate dialog accepted but error in save_category
    |

tests\desktop_ui\test_library_main_ui_new.py:342:89: E501 Line too long (93 > 88)
    |
340 |         win = main_window
341 |         # Simulate dialog accepted but error in save_category
342 |         monkeypatch.setattr("desktop_ui.modern_dialogs.CategoryDialog.exec_", lambda self: 1)
    |                                                                                         ^^^^^ E501
343 |         monkeypatch.setattr(
344 |             "desktop_ui.modern_dialogs.CategoryDialog.get_value", lambda self: "ErrCat"
    |

tests\desktop_ui\test_library_main_ui_new.py:354:9: ANN201 Missing return type annotation for public function `test_add_snippet_error`
    |
352 |         assert "Failed to add category" in win.status.text()
353 |
354 |     def test_add_snippet_error(self, main_window, monkeypatch):
    |         ^^^^^^^^^^^^^^^^^^^^^^ ANN201
355 |         # Ensure a category exists and is selected
356 |         if not main_window.categories:
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:354:38: ANN001 Missing type annotation for function argument `main_window`
    |
352 |         assert "Failed to add category" in win.status.text()
353 |
354 |     def test_add_snippet_error(self, main_window, monkeypatch):
    |                                      ^^^^^^^^^^^ ANN001
355 |         # Ensure a category exists and is selected
356 |         if not main_window.categories:
    |

tests\desktop_ui\test_library_main_ui_new.py:354:51: ANN001 Missing type annotation for function argument `monkeypatch`
    |
352 |         assert "Failed to add category" in win.status.text()
353 |
354 |     def test_add_snippet_error(self, main_window, monkeypatch):
    |                                                   ^^^^^^^^^^^ ANN001
355 |         # Ensure a category exists and is selected
356 |         if not main_window.categories:
    |

tests\desktop_ui\test_library_main_ui_new.py:359:21: ANN202 Missing return type annotation for private function `exec_`
    |
358 |             class FakeCatDialog:
359 |                 def exec_(self):
    |                     ^^^^^ ANN202
360 |                     return 1
    |
    = help: Add return type annotation: `int`

tests\desktop_ui\test_library_main_ui_new.py:362:21: ANN202 Missing return type annotation for private function `get_value`
    |
360 |                     return 1
361 |
362 |                 def get_value(self):
    |                     ^^^^^^^^^ ANN202
363 |                     return "CatForError"
    |
    = help: Add return type annotation: `str`

tests\desktop_ui\test_library_main_ui_new.py:365:89: E501 Line too long (96 > 88)
    |
363 |                     return "CatForError"
364 |
365 |             monkeypatch.setattr(library_main, "CategoryDialog", lambda *a, **k: FakeCatDialog())
    |                                                                                         ^^^^^^^^ E501
366 |             main_window.add_category()
367 |         main_window.categoryList.setCurrentRow(0)
    |

tests\desktop_ui\test_library_main_ui_new.py:370:17: ANN202 Missing return type annotation for private function `exec_`
    |
369 |         class FakeDialog:
370 |             def exec_(self):
    |                 ^^^^^ ANN202
371 |                 return 1
    |
    = help: Add return type annotation: `int`

tests\desktop_ui\test_library_main_ui_new.py:373:17: ANN202 Missing return type annotation for private function `get_values`
    |
371 |                 return 1
372 |
373 |             def get_values(self):
    |                 ^^^^^^^^^^ ANN202
374 |                 return ("ErrSnip", "X")
    |
    = help: Add return type annotation

tests\desktop_ui\test_library_main_ui_new.py:378:13: ANN202 Missing return type annotation for private function `fail_save_snippet`
    |
376 |         monkeypatch.setattr(library_main, "SnippetDialog", lambda *a, **k: FakeDialog())
377 |
378 |         def fail_save_snippet(snip):
    |             ^^^^^^^^^^^^^^^^^ ANN202
379 |             raise Exception("failsnip")
    |
    = help: Add return type annotation: `Never`

tests\desktop_ui\test_library_main_ui_new.py:378:31: ANN001 Missing type annotation for function argument `snip`
    |
376 |         monkeypatch.setattr(library_main, "SnippetDialog", lambda *a, **k: FakeDialog())
377 |
378 |         def fail_save_snippet(snip):
    |                               ^^^^ ANN001
379 |             raise Exception("failsnip")
    |

tests\desktop_ui\test_library_main_ui_new.py:381:89: E501 Line too long (91 > 88)
    |
379 |             raise Exception("failsnip")
380 |
381 |         monkeypatch.setattr(main_window.snippet_manager, "save_snippet", fail_save_snippet)
    |                                                                                         ^^^ E501
382 |         main_window.add_snippet()
383 |         assert "failsnip" in main_window.status.text()
    |

tests\desktop_ui\test_library_main_ui_new.py:385:9: ANN201 Missing return type annotation for public function `test_edit_category_error`
    |
383 |         assert "failsnip" in main_window.status.text()
384 |
385 |     def test_edit_category_error(self, main_window, monkeypatch):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
386 |         win = main_window
387 |         # Ensure a category exists and is selected
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:385:40: ANN001 Missing type annotation for function argument `main_window`
    |
383 |         assert "failsnip" in main_window.status.text()
384 |
385 |     def test_edit_category_error(self, main_window, monkeypatch):
    |                                        ^^^^^^^^^^^ ANN001
386 |         win = main_window
387 |         # Ensure a category exists and is selected
    |

tests\desktop_ui\test_library_main_ui_new.py:385:53: ANN001 Missing type annotation for function argument `monkeypatch`
    |
383 |         assert "failsnip" in main_window.status.text()
384 |
385 |     def test_edit_category_error(self, main_window, monkeypatch):
    |                                                     ^^^^^^^^^^^ ANN001
386 |         win = main_window
387 |         # Ensure a category exists and is selected
    |

tests\desktop_ui\test_library_main_ui_new.py:391:21: ANN202 Missing return type annotation for private function `exec_`
    |
390 |             class FakeAddDialog:
391 |                 def exec_(self):
    |                     ^^^^^ ANN202
392 |                     return 1
    |
    = help: Add return type annotation: `int`

tests\desktop_ui\test_library_main_ui_new.py:394:21: ANN202 Missing return type annotation for private function `get_value`
    |
392 |                     return 1
393 |
394 |                 def get_value(self):
    |                     ^^^^^^^^^ ANN202
395 |                     return "ErrEditCat"
    |
    = help: Add return type annotation: `str`

tests\desktop_ui\test_library_main_ui_new.py:397:89: E501 Line too long (96 > 88)
    |
395 |                     return "ErrEditCat"
396 |
397 |             monkeypatch.setattr(library_main, "CategoryDialog", lambda *a, **k: FakeAddDialog())
    |                                                                                         ^^^^^^^^ E501
398 |             win.add_category()
399 |         win.categoryList.setCurrentRow(0)
    |

tests\desktop_ui\test_library_main_ui_new.py:400:89: E501 Line too long (93 > 88)
    |
398 |             win.add_category()
399 |         win.categoryList.setCurrentRow(0)
400 |         monkeypatch.setattr("desktop_ui.modern_dialogs.CategoryDialog.exec_", lambda self: 1)
    |                                                                                         ^^^^^ E501
401 |         monkeypatch.setattr(
402 |             "desktop_ui.modern_dialogs.CategoryDialog.get_value", lambda self: "ErrEditCat"
    |

tests\desktop_ui\test_library_main_ui_new.py:402:89: E501 Line too long (91 > 88)
    |
400 |         monkeypatch.setattr("desktop_ui.modern_dialogs.CategoryDialog.exec_", lambda self: 1)
401 |         monkeypatch.setattr(
402 |             "desktop_ui.modern_dialogs.CategoryDialog.get_value", lambda self: "ErrEditCat"
    |                                                                                         ^^^ E501
403 |         )
404 |         monkeypatch.setattr(
    |

tests\desktop_ui\test_library_main_ui_new.py:410:89: E501 Line too long (98 > 88)
    |
408 |         )
409 |         win.edit_category()
410 |         assert "Failed to update category" in win.status.text() or "failcat2" in win.status.text()
    |                                                                                         ^^^^^^^^^^ E501
411 |
412 |     def test_edit_snippet_error(self, main_window, monkeypatch):
    |

tests\desktop_ui\test_library_main_ui_new.py:412:9: ANN201 Missing return type annotation for public function `test_edit_snippet_error`
    |
410 |         assert "Failed to update category" in win.status.text() or "failcat2" in win.status.text()
411 |
412 |     def test_edit_snippet_error(self, main_window, monkeypatch):
    |         ^^^^^^^^^^^^^^^^^^^^^^^ ANN201
413 |         win = main_window
414 |         # Ensure a snippet exists and is selected
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:412:39: ANN001 Missing type annotation for function argument `main_window`
    |
410 |         assert "Failed to update category" in win.status.text() or "failcat2" in win.status.text()
411 |
412 |     def test_edit_snippet_error(self, main_window, monkeypatch):
    |                                       ^^^^^^^^^^^ ANN001
413 |         win = main_window
414 |         # Ensure a snippet exists and is selected
    |

tests\desktop_ui\test_library_main_ui_new.py:412:52: ANN001 Missing type annotation for function argument `monkeypatch`
    |
410 |         assert "Failed to update category" in win.status.text() or "failcat2" in win.status.text()
411 |
412 |     def test_edit_snippet_error(self, main_window, monkeypatch):
    |                                                    ^^^^^^^^^^^ ANN001
413 |         win = main_window
414 |         # Ensure a snippet exists and is selected
    |

tests\desktop_ui\test_library_main_ui_new.py:420:25: ANN202 Missing return type annotation for private function `exec_`
    |
419 |                 class FakeCatDialog:
420 |                     def exec_(self):
    |                         ^^^^^ ANN202
421 |                         return 1
    |
    = help: Add return type annotation: `int`

tests\desktop_ui\test_library_main_ui_new.py:423:25: ANN202 Missing return type annotation for private function `get_value`
    |
421 |                         return 1
422 |
423 |                     def get_value(self):
    |                         ^^^^^^^^^ ANN202
424 |                         return "CatForEditError"
    |
    = help: Add return type annotation: `str`

tests\desktop_ui\test_library_main_ui_new.py:426:89: E501 Line too long (100 > 88)
    |
424 |                         return "CatForEditError"
425 |
426 |                 monkeypatch.setattr(library_main, "CategoryDialog", lambda *a, **k: FakeCatDialog())
    |                                                                                         ^^^^^^^^^^^^ E501
427 |                 win.add_category()
428 |             win.categoryList.setCurrentRow(0)
    |

tests\desktop_ui\test_library_main_ui_new.py:431:21: ANN202 Missing return type annotation for private function `exec_`
    |
430 |             class FakeAddDialog:
431 |                 def exec_(self):
    |                     ^^^^^ ANN202
432 |                     return 1
    |
    = help: Add return type annotation: `int`

tests\desktop_ui\test_library_main_ui_new.py:434:21: ANN202 Missing return type annotation for private function `get_values`
    |
432 |                     return 1
433 |
434 |                 def get_values(self):
    |                     ^^^^^^^^^^ ANN202
435 |                     return ("SnippetToEditError", "ContentToEditError")
    |
    = help: Add return type annotation

tests\desktop_ui\test_library_main_ui_new.py:437:89: E501 Line too long (95 > 88)
    |
435 |                     return ("SnippetToEditError", "ContentToEditError")
436 |
437 |             monkeypatch.setattr(library_main, "SnippetDialog", lambda *a, **k: FakeAddDialog())
    |                                                                                         ^^^^^^^ E501
438 |             win.add_snippet()
439 |         win.snippetList.setCurrentRow(0)
    |

tests\desktop_ui\test_library_main_ui_new.py:442:17: ANN202 Missing return type annotation for private function `exec_`
    |
441 |         class FakeDialog:
442 |             def exec_(self):
    |                 ^^^^^ ANN202
443 |                 return 1
    |
    = help: Add return type annotation: `int`

tests\desktop_ui\test_library_main_ui_new.py:445:17: ANN202 Missing return type annotation for private function `get_values`
    |
443 |                 return 1
444 |
445 |             def get_values(self):
    |                 ^^^^^^^^^^ ANN202
446 |                 return ("ErrEditSnip", "X")
    |
    = help: Add return type annotation

tests\desktop_ui\test_library_main_ui_new.py:450:13: ANN202 Missing return type annotation for private function `fail_save_snippet`
    |
448 |         monkeypatch.setattr(library_main, "SnippetDialog", lambda *a, **k: FakeDialog())
449 |
450 |         def fail_save_snippet(snip):
    |             ^^^^^^^^^^^^^^^^^ ANN202
451 |             raise Exception("failsnip2")
    |
    = help: Add return type annotation: `Never`

tests\desktop_ui\test_library_main_ui_new.py:450:31: ANN001 Missing type annotation for function argument `snip`
    |
448 |         monkeypatch.setattr(library_main, "SnippetDialog", lambda *a, **k: FakeDialog())
449 |
450 |         def fail_save_snippet(snip):
    |                               ^^^^ ANN001
451 |             raise Exception("failsnip2")
    |

tests\desktop_ui\test_library_main_ui_new.py:453:89: E501 Line too long (91 > 88)
    |
451 |             raise Exception("failsnip2")
452 |
453 |         monkeypatch.setattr(main_window.snippet_manager, "save_snippet", fail_save_snippet)
    |                                                                                         ^^^ E501
454 |         win.edit_snippet()
455 |         assert "Failed to update snippet" in win.status.text() or "failsnip2" in win.status.text()
    |

tests\desktop_ui\test_library_main_ui_new.py:455:89: E501 Line too long (98 > 88)
    |
453 |         monkeypatch.setattr(main_window.snippet_manager, "save_snippet", fail_save_snippet)
454 |         win.edit_snippet()
455 |         assert "Failed to update snippet" in win.status.text() or "failsnip2" in win.status.text()
    |                                                                                         ^^^^^^^^^^ E501
456 |
457 |     def test_delete_category_error(self, main_window, monkeypatch):
    |

tests\desktop_ui\test_library_main_ui_new.py:457:9: ANN201 Missing return type annotation for public function `test_delete_category_error`
    |
455 |         assert "Failed to update snippet" in win.status.text() or "failsnip2" in win.status.text()
456 |
457 |     def test_delete_category_error(self, main_window, monkeypatch):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
458 |         # Ensure a category exists and is selected
459 |         if not main_window.categories:
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:457:42: ANN001 Missing type annotation for function argument `main_window`
    |
455 |         assert "Failed to update snippet" in win.status.text() or "failsnip2" in win.status.text()
456 |
457 |     def test_delete_category_error(self, main_window, monkeypatch):
    |                                          ^^^^^^^^^^^ ANN001
458 |         # Ensure a category exists and is selected
459 |         if not main_window.categories:
    |

tests\desktop_ui\test_library_main_ui_new.py:457:55: ANN001 Missing type annotation for function argument `monkeypatch`
    |
455 |         assert "Failed to update snippet" in win.status.text() or "failsnip2" in win.status.text()
456 |
457 |     def test_delete_category_error(self, main_window, monkeypatch):
    |                                                       ^^^^^^^^^^^ ANN001
458 |         # Ensure a category exists and is selected
459 |         if not main_window.categories:
    |

tests\desktop_ui\test_library_main_ui_new.py:462:21: ANN202 Missing return type annotation for private function `exec_`
    |
461 |             class FakeCatDialog:
462 |                 def exec_(self):
    |                     ^^^^^ ANN202
463 |                     return 1
    |
    = help: Add return type annotation: `int`

tests\desktop_ui\test_library_main_ui_new.py:465:21: ANN202 Missing return type annotation for private function `get_value`
    |
463 |                     return 1
464 |
465 |                 def get_value(self):
    |                     ^^^^^^^^^ ANN202
466 |                     return "CatForDeleteError"
    |
    = help: Add return type annotation: `str`

tests\desktop_ui\test_library_main_ui_new.py:468:89: E501 Line too long (96 > 88)
    |
466 |                     return "CatForDeleteError"
467 |
468 |             monkeypatch.setattr(library_main, "CategoryDialog", lambda *a, **k: FakeCatDialog())
    |                                                                                         ^^^^^^^^ E501
469 |             main_window.add_category()
470 |         main_window.categoryList.setCurrentRow(0)
    |

tests\desktop_ui\test_library_main_ui_new.py:477:13: ANN202 Missing return type annotation for private function `fail_delete_category_by_id`
    |
475 |         )
476 |
477 |         def fail_delete_category_by_id(cid):
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN202
478 |             raise Exception("faildelcat")
    |
    = help: Add return type annotation: `Never`

tests\desktop_ui\test_library_main_ui_new.py:477:40: ANN001 Missing type annotation for function argument `cid`
    |
475 |         )
476 |
477 |         def fail_delete_category_by_id(cid):
    |                                        ^^^ ANN001
478 |             raise Exception("faildelcat")
    |

tests\desktop_ui\test_library_main_ui_new.py:481:89: E501 Line too long (93 > 88)
    |
480 |         monkeypatch.setattr(
481 |             main_window.category_manager, "delete_category_by_id", fail_delete_category_by_id
    |                                                                                         ^^^^^ E501
482 |         )
483 |         main_window.delete_category()
    |

tests\desktop_ui\test_library_main_ui_new.py:489:9: ANN201 Missing return type annotation for public function `test_delete_snippet_error`
    |
487 |         )
488 |
489 |     def test_delete_snippet_error(self, main_window, monkeypatch):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
490 |         win = main_window
491 |         # Ensure a category exists and is selected
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:489:41: ANN001 Missing type annotation for function argument `main_window`
    |
487 |         )
488 |
489 |     def test_delete_snippet_error(self, main_window, monkeypatch):
    |                                         ^^^^^^^^^^^ ANN001
490 |         win = main_window
491 |         # Ensure a category exists and is selected
    |

tests\desktop_ui\test_library_main_ui_new.py:489:54: ANN001 Missing type annotation for function argument `monkeypatch`
    |
487 |         )
488 |
489 |     def test_delete_snippet_error(self, main_window, monkeypatch):
    |                                                      ^^^^^^^^^^^ ANN001
490 |         win = main_window
491 |         # Ensure a category exists and is selected
    |

tests\desktop_ui\test_library_main_ui_new.py:495:21: ANN202 Missing return type annotation for private function `exec_`
    |
494 |             class FakeCatDialog:
495 |                 def exec_(self):
    |                     ^^^^^ ANN202
496 |                     return 1
    |
    = help: Add return type annotation: `int`

tests\desktop_ui\test_library_main_ui_new.py:498:21: ANN202 Missing return type annotation for private function `get_value`
    |
496 |                     return 1
497 |
498 |                 def get_value(self):
    |                     ^^^^^^^^^ ANN202
499 |                     return "CatForDeleteError"
    |
    = help: Add return type annotation: `str`

tests\desktop_ui\test_library_main_ui_new.py:501:89: E501 Line too long (96 > 88)
    |
499 |                     return "CatForDeleteError"
500 |
501 |             monkeypatch.setattr(library_main, "CategoryDialog", lambda *a, **k: FakeCatDialog())
    |                                                                                         ^^^^^^^^ E501
502 |             win.add_category()
503 |         win.categoryList.setCurrentRow(0)
    |

tests\desktop_ui\test_library_main_ui_new.py:508:21: ANN202 Missing return type annotation for private function `exec_`
    |
507 |             class FakeSnipDialog:
508 |                 def exec_(self):
    |                     ^^^^^ ANN202
509 |                     return 1
    |
    = help: Add return type annotation: `int`

tests\desktop_ui\test_library_main_ui_new.py:511:21: ANN202 Missing return type annotation for private function `get_values`
    |
509 |                     return 1
510 |
511 |                 def get_values(self):
    |                     ^^^^^^^^^^ ANN202
512 |                     return ("ToDelError", "X")
    |
    = help: Add return type annotation

tests\desktop_ui\test_library_main_ui_new.py:514:89: E501 Line too long (96 > 88)
    |
512 |                     return ("ToDelError", "X")
513 |
514 |             monkeypatch.setattr(library_main, "SnippetDialog", lambda *a, **k: FakeSnipDialog())
    |                                                                                         ^^^^^^^^ E501
515 |             win.add_snippet()
516 |         win.snippetList.setCurrentRow(win.snippetList.count() - 1)
    |

tests\desktop_ui\test_library_main_ui_new.py:517:89: E501 Line too long (99 > 88)
    |
515 |             win.add_snippet()
516 |         win.snippetList.setCurrentRow(win.snippetList.count() - 1)
517 |         monkeypatch.setattr("PySide6.QtWidgets.QMessageBox.question", lambda *a, **k: 16384)  # Yes
    |                                                                                         ^^^^^^^^^^^ E501
518 |
519 |         def fail_delete_snippet(sid):
    |

tests\desktop_ui\test_library_main_ui_new.py:519:13: ANN202 Missing return type annotation for private function `fail_delete_snippet`
    |
517 |         monkeypatch.setattr("PySide6.QtWidgets.QMessageBox.question", lambda *a, **k: 16384)  # Yes
518 |
519 |         def fail_delete_snippet(sid):
    |             ^^^^^^^^^^^^^^^^^^^ ANN202
520 |             raise Exception("faildelsnip")
    |
    = help: Add return type annotation: `Never`

tests\desktop_ui\test_library_main_ui_new.py:519:33: ANN001 Missing type annotation for function argument `sid`
    |
517 |         monkeypatch.setattr("PySide6.QtWidgets.QMessageBox.question", lambda *a, **k: 16384)  # Yes
518 |
519 |         def fail_delete_snippet(sid):
    |                                 ^^^ ANN001
520 |             raise Exception("faildelsnip")
    |

tests\desktop_ui\test_library_main_ui_new.py:524:89: E501 Line too long (100 > 88)
    |
522 |         monkeypatch.setattr(win.snippet_manager, "delete_snippet", fail_delete_snippet)
523 |         win.delete_snippet()
524 |         assert "Failed to delete snippet" in win.status.text() or "faildelsnip" in win.status.text()
    |                                                                                         ^^^^^^^^^^^^ E501
525 |
526 |     def test_load_data_error(self, main_window, monkeypatch):
    |

tests\desktop_ui\test_library_main_ui_new.py:526:9: ANN201 Missing return type annotation for public function `test_load_data_error`
    |
524 |         assert "Failed to delete snippet" in win.status.text() or "faildelsnip" in win.status.text()
525 |
526 |     def test_load_data_error(self, main_window, monkeypatch):
    |         ^^^^^^^^^^^^^^^^^^^^ ANN201
527 |         win = main_window
528 |         monkeypatch.setattr(
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:526:36: ANN001 Missing type annotation for function argument `main_window`
    |
524 |         assert "Failed to delete snippet" in win.status.text() or "faildelsnip" in win.status.text()
525 |
526 |     def test_load_data_error(self, main_window, monkeypatch):
    |                                    ^^^^^^^^^^^ ANN001
527 |         win = main_window
528 |         monkeypatch.setattr(
    |

tests\desktop_ui\test_library_main_ui_new.py:526:49: ANN001 Missing type annotation for function argument `monkeypatch`
    |
524 |         assert "Failed to delete snippet" in win.status.text() or "faildelsnip" in win.status.text()
525 |
526 |     def test_load_data_error(self, main_window, monkeypatch):
    |                                                 ^^^^^^^^^^^ ANN001
527 |         win = main_window
528 |         monkeypatch.setattr(
    |

tests\desktop_ui\test_library_main_ui_new.py:536:9: ANN201 Missing return type annotation for public function `test_load_snippets_error`
    |
534 |         assert "Error loading data" in win.status.text()
535 |
536 |     def test_load_snippets_error(self, main_window, monkeypatch):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
537 |         win = main_window
538 |         win.categoryList.setCurrentRow(0)
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:536:40: ANN001 Missing type annotation for function argument `main_window`
    |
534 |         assert "Error loading data" in win.status.text()
535 |
536 |     def test_load_snippets_error(self, main_window, monkeypatch):
    |                                        ^^^^^^^^^^^ ANN001
537 |         win = main_window
538 |         win.categoryList.setCurrentRow(0)
    |

tests\desktop_ui\test_library_main_ui_new.py:536:53: ANN001 Missing type annotation for function argument `monkeypatch`
    |
534 |         assert "Error loading data" in win.status.text()
535 |
536 |     def test_load_snippets_error(self, main_window, monkeypatch):
    |                                                     ^^^^^^^^^^^ ANN001
537 |         win = main_window
538 |         win.categoryList.setCurrentRow(0)
    |

tests\desktop_ui\test_library_main_ui_new.py:551:5: ANN201 Missing return type annotation for public function `test_window_initialization`
    |
551 | def test_window_initialization(main_window):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
552 |     """Test that the main window initializes with the correct default state.
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:551:32: ANN001 Missing type annotation for function argument `main_window`
    |
551 | def test_window_initialization(main_window):
    |                                ^^^^^^^^^^^ ANN001
552 |     """Test that the main window initializes with the correct default state.
    |

tests\desktop_ui\test_library_main_ui_new.py:597:5: ANN201 Missing return type annotation for public function `test_add_category_ui`
    |
597 | def test_add_category_ui(main_window, monkeypatch):
    |     ^^^^^^^^^^^^^^^^^^^^ ANN201
598 |     # Simulate CategoryDialog returning Accepted and a name
599 |     class FakeDialog:
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:597:26: ANN001 Missing type annotation for function argument `main_window`
    |
597 | def test_add_category_ui(main_window, monkeypatch):
    |                          ^^^^^^^^^^^ ANN001
598 |     # Simulate CategoryDialog returning Accepted and a name
599 |     class FakeDialog:
    |

tests\desktop_ui\test_library_main_ui_new.py:597:39: ANN001 Missing type annotation for function argument `monkeypatch`
    |
597 | def test_add_category_ui(main_window, monkeypatch):
    |                                       ^^^^^^^^^^^ ANN001
598 |     # Simulate CategoryDialog returning Accepted and a name
599 |     class FakeDialog:
    |

tests\desktop_ui\test_library_main_ui_new.py:600:13: ANN202 Missing return type annotation for private function `exec_`
    |
598 |     # Simulate CategoryDialog returning Accepted and a name
599 |     class FakeDialog:
600 |         def exec_(self):
    |             ^^^^^ ANN202
601 |             return 1  # Accepted
    |
    = help: Add return type annotation: `int`

tests\desktop_ui\test_library_main_ui_new.py:603:13: ANN202 Missing return type annotation for private function `get_value`
    |
601 |             return 1  # Accepted
602 |
603 |         def get_value(self):
    |             ^^^^^^^^^ ANN202
604 |             return "UI Cat"
    |
    = help: Add return type annotation: `str`

tests\desktop_ui\test_library_main_ui_new.py:612:5: ANN201 Missing return type annotation for public function `test_edit_category_ui`
    |
612 | def test_edit_category_ui(main_window, monkeypatch):
    |     ^^^^^^^^^^^^^^^^^^^^^ ANN201
613 |     # Ensure there is at least one category to edit
614 |     if not main_window.categories:
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:612:27: ANN001 Missing type annotation for function argument `main_window`
    |
612 | def test_edit_category_ui(main_window, monkeypatch):
    |                           ^^^^^^^^^^^ ANN001
613 |     # Ensure there is at least one category to edit
614 |     if not main_window.categories:
    |

tests\desktop_ui\test_library_main_ui_new.py:612:40: ANN001 Missing type annotation for function argument `monkeypatch`
    |
612 | def test_edit_category_ui(main_window, monkeypatch):
    |                                        ^^^^^^^^^^^ ANN001
613 |     # Ensure there is at least one category to edit
614 |     if not main_window.categories:
    |

tests\desktop_ui\test_library_main_ui_new.py:617:17: ANN202 Missing return type annotation for private function `exec_`
    |
616 |         class FakeAddDialog:
617 |             def exec_(self):
    |                 ^^^^^ ANN202
618 |                 return 1
    |
    = help: Add return type annotation: `int`

tests\desktop_ui\test_library_main_ui_new.py:620:17: ANN202 Missing return type annotation for private function `get_value`
    |
618 |                 return 1
619 |
620 |             def get_value(self):
    |                 ^^^^^^^^^ ANN202
621 |                 return "Initial Cat"
    |
    = help: Add return type annotation: `str`

tests\desktop_ui\test_library_main_ui_new.py:623:89: E501 Line too long (92 > 88)
    |
621 |                 return "Initial Cat"
622 |
623 |         monkeypatch.setattr(library_main, "CategoryDialog", lambda *a, **k: FakeAddDialog())
    |                                                                                         ^^^^ E501
624 |         main_window.add_category()
625 |     # Select the first category
    |

tests\desktop_ui\test_library_main_ui_new.py:629:13: ANN202 Missing return type annotation for private function `exec_`
    |
628 |     class FakeEditDialog:
629 |         def exec_(self):
    |             ^^^^^ ANN202
630 |             return 1
    |
    = help: Add return type annotation: `int`

tests\desktop_ui\test_library_main_ui_new.py:632:13: ANN202 Missing return type annotation for private function `get_value`
    |
630 |             return 1
631 |
632 |         def get_value(self):
    |             ^^^^^^^^^ ANN202
633 |             return "Renamed Cat"
    |
    = help: Add return type annotation: `str`

tests\desktop_ui\test_library_main_ui_new.py:635:89: E501 Line too long (89 > 88)
    |
633 |             return "Renamed Cat"
634 |
635 |     monkeypatch.setattr(library_main, "CategoryDialog", lambda *a, **k: FakeEditDialog())
    |                                                                                         ^ E501
636 |     main_window.edit_category()
637 |     assert any(c.category_name == "Renamed Cat" for c in main_window.categories)
    |

tests\desktop_ui\test_library_main_ui_new.py:641:5: ANN201 Missing return type annotation for public function `test_delete_category_ui`
    |
641 | def test_delete_category_ui(main_window, monkeypatch):
    |     ^^^^^^^^^^^^^^^^^^^^^^^ ANN201
642 |     # Add a category to delete
643 |     cat = library_main.Category(category_name="ToDelete", description="")
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:641:29: ANN001 Missing type annotation for function argument `main_window`
    |
641 | def test_delete_category_ui(main_window, monkeypatch):
    |                             ^^^^^^^^^^^ ANN001
642 |     # Add a category to delete
643 |     cat = library_main.Category(category_name="ToDelete", description="")
    |

tests\desktop_ui\test_library_main_ui_new.py:641:42: ANN001 Missing type annotation for function argument `monkeypatch`
    |
641 | def test_delete_category_ui(main_window, monkeypatch):
    |                                          ^^^^^^^^^^^ ANN001
642 |     # Add a category to delete
643 |     cat = library_main.Category(category_name="ToDelete", description="")
    |

tests\desktop_ui\test_library_main_ui_new.py:660:5: ANN201 Missing return type annotation for public function `test_add_snippet_ui`
    |
660 | def test_add_snippet_ui(main_window, monkeypatch):
    |     ^^^^^^^^^^^^^^^^^^^ ANN201
661 |     # Ensure a category exists and is selected
662 |     if not main_window.categories:
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:660:25: ANN001 Missing type annotation for function argument `main_window`
    |
660 | def test_add_snippet_ui(main_window, monkeypatch):
    |                         ^^^^^^^^^^^ ANN001
661 |     # Ensure a category exists and is selected
662 |     if not main_window.categories:
    |

tests\desktop_ui\test_library_main_ui_new.py:660:38: ANN001 Missing type annotation for function argument `monkeypatch`
    |
660 | def test_add_snippet_ui(main_window, monkeypatch):
    |                                      ^^^^^^^^^^^ ANN001
661 |     # Ensure a category exists and is selected
662 |     if not main_window.categories:
    |

tests\desktop_ui\test_library_main_ui_new.py:665:17: ANN202 Missing return type annotation for private function `exec_`
    |
664 |         class FakeCatDialog:
665 |             def exec_(self):
    |                 ^^^^^ ANN202
666 |                 return 1
    |
    = help: Add return type annotation: `int`

tests\desktop_ui\test_library_main_ui_new.py:668:17: ANN202 Missing return type annotation for private function `get_value`
    |
666 |                 return 1
667 |
668 |             def get_value(self):
    |                 ^^^^^^^^^ ANN202
669 |                 return "CatForSnippet"
    |
    = help: Add return type annotation: `str`

tests\desktop_ui\test_library_main_ui_new.py:671:89: E501 Line too long (92 > 88)
    |
669 |                 return "CatForSnippet"
670 |
671 |         monkeypatch.setattr(library_main, "CategoryDialog", lambda *a, **k: FakeCatDialog())
    |                                                                                         ^^^^ E501
672 |         main_window.add_category()
673 |     main_window.categoryList.setCurrentRow(0)
    |

tests\desktop_ui\test_library_main_ui_new.py:676:13: ANN202 Missing return type annotation for private function `exec_`
    |
675 |     class FakeDialog:
676 |         def exec_(self):
    |             ^^^^^ ANN202
677 |             return 1
    |
    = help: Add return type annotation: `int`

tests\desktop_ui\test_library_main_ui_new.py:679:13: ANN202 Missing return type annotation for private function `get_values`
    |
677 |             return 1
678 |
679 |         def get_values(self):
    |             ^^^^^^^^^^ ANN202
680 |             return ("SnippetA", "ContentA")
    |
    = help: Add return type annotation

tests\desktop_ui\test_library_main_ui_new.py:688:5: ANN201 Missing return type annotation for public function `test_edit_snippet_ui`
    |
688 | def test_edit_snippet_ui(main_window, monkeypatch):
    |     ^^^^^^^^^^^^^^^^^^^^ ANN201
689 |     # Ensure there is at least one snippet to edit
690 |     if not main_window.snippets:
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:688:26: ANN001 Missing type annotation for function argument `main_window`
    |
688 | def test_edit_snippet_ui(main_window, monkeypatch):
    |                          ^^^^^^^^^^^ ANN001
689 |     # Ensure there is at least one snippet to edit
690 |     if not main_window.snippets:
    |

tests\desktop_ui\test_library_main_ui_new.py:688:39: ANN001 Missing type annotation for function argument `monkeypatch`
    |
688 | def test_edit_snippet_ui(main_window, monkeypatch):
    |                                       ^^^^^^^^^^^ ANN001
689 |     # Ensure there is at least one snippet to edit
690 |     if not main_window.snippets:
    |

tests\desktop_ui\test_library_main_ui_new.py:695:21: ANN202 Missing return type annotation for private function `exec_`
    |
694 |             class FakeCatDialog:
695 |                 def exec_(self):
    |                     ^^^^^ ANN202
696 |                     return 1
    |
    = help: Add return type annotation: `int`

tests\desktop_ui\test_library_main_ui_new.py:698:21: ANN202 Missing return type annotation for private function `get_value`
    |
696 |                     return 1
697 |
698 |                 def get_value(self):
    |                     ^^^^^^^^^ ANN202
699 |                     return "CatForEdit"
    |
    = help: Add return type annotation: `str`

tests\desktop_ui\test_library_main_ui_new.py:701:89: E501 Line too long (96 > 88)
    |
699 |                     return "CatForEdit"
700 |
701 |             monkeypatch.setattr(library_main, "CategoryDialog", lambda *a, **k: FakeCatDialog())
    |                                                                                         ^^^^^^^^ E501
702 |             main_window.add_category()
703 |         main_window.categoryList.setCurrentRow(0)
    |

tests\desktop_ui\test_library_main_ui_new.py:706:17: ANN202 Missing return type annotation for private function `exec_`
    |
705 |         class FakeAddDialog:
706 |             def exec_(self):
    |                 ^^^^^ ANN202
707 |                 return 1
    |
    = help: Add return type annotation: `int`

tests\desktop_ui\test_library_main_ui_new.py:709:17: ANN202 Missing return type annotation for private function `get_values`
    |
707 |                 return 1
708 |
709 |             def get_values(self):
    |                 ^^^^^^^^^^ ANN202
710 |                 return ("SnippetToEdit", "ContentToEdit")
    |
    = help: Add return type annotation

tests\desktop_ui\test_library_main_ui_new.py:712:89: E501 Line too long (91 > 88)
    |
710 |                 return ("SnippetToEdit", "ContentToEdit")
711 |
712 |         monkeypatch.setattr(library_main, "SnippetDialog", lambda *a, **k: FakeAddDialog())
    |                                                                                         ^^^ E501
713 |         main_window.add_snippet()
714 |     main_window.snippetList.setCurrentRow(0)
    |

tests\desktop_ui\test_library_main_ui_new.py:717:13: ANN202 Missing return type annotation for private function `exec_`
    |
716 |     class FakeEditDialog:
717 |         def exec_(self):
    |             ^^^^^ ANN202
718 |             return 1
    |
    = help: Add return type annotation: `int`

tests\desktop_ui\test_library_main_ui_new.py:720:13: ANN202 Missing return type annotation for private function `get_values`
    |
718 |             return 1
719 |
720 |         def get_values(self):
    |             ^^^^^^^^^^ ANN202
721 |             return ("SnippetA-Edit", "ContentA-Edit")
    |
    = help: Add return type annotation

tests\desktop_ui\test_library_main_ui_new.py:729:5: ANN201 Missing return type annotation for public function `test_delete_snippet_ui`
    |
729 | def test_delete_snippet_ui(main_window, monkeypatch):
    |     ^^^^^^^^^^^^^^^^^^^^^^ ANN201
730 |     # Ensure a category exists and is selected
731 |     if not main_window.categories:
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:729:28: ANN001 Missing type annotation for function argument `main_window`
    |
729 | def test_delete_snippet_ui(main_window, monkeypatch):
    |                            ^^^^^^^^^^^ ANN001
730 |     # Ensure a category exists and is selected
731 |     if not main_window.categories:
    |

tests\desktop_ui\test_library_main_ui_new.py:729:41: ANN001 Missing type annotation for function argument `monkeypatch`
    |
729 | def test_delete_snippet_ui(main_window, monkeypatch):
    |                                         ^^^^^^^^^^^ ANN001
730 |     # Ensure a category exists and is selected
731 |     if not main_window.categories:
    |

tests\desktop_ui\test_library_main_ui_new.py:734:17: ANN202 Missing return type annotation for private function `exec_`
    |
733 |         class FakeCatDialog:
734 |             def exec_(self):
    |                 ^^^^^ ANN202
735 |                 return 1
    |
    = help: Add return type annotation: `int`

tests\desktop_ui\test_library_main_ui_new.py:737:17: ANN202 Missing return type annotation for private function `get_value`
    |
735 |                 return 1
736 |
737 |             def get_value(self):
    |                 ^^^^^^^^^ ANN202
738 |                 return "CatForDelete"
    |
    = help: Add return type annotation: `str`

tests\desktop_ui\test_library_main_ui_new.py:740:89: E501 Line too long (92 > 88)
    |
738 |                 return "CatForDelete"
739 |
740 |         monkeypatch.setattr(library_main, "CategoryDialog", lambda *a, **k: FakeCatDialog())
    |                                                                                         ^^^^ E501
741 |         main_window.add_category()
742 |     main_window.categoryList.setCurrentRow(0)
    |

tests\desktop_ui\test_library_main_ui_new.py:747:17: ANN202 Missing return type annotation for private function `exec_`
    |
746 |         class FakeSnipDialog:
747 |             def exec_(self):
    |                 ^^^^^ ANN202
748 |                 return 1
    |
    = help: Add return type annotation: `int`

tests\desktop_ui\test_library_main_ui_new.py:750:17: ANN202 Missing return type annotation for private function `get_values`
    |
748 |                 return 1
749 |
750 |             def get_values(self):
    |                 ^^^^^^^^^^ ANN202
751 |                 return ("ToDel", "X")
    |
    = help: Add return type annotation

tests\desktop_ui\test_library_main_ui_new.py:753:89: E501 Line too long (92 > 88)
    |
751 |                 return ("ToDel", "X")
752 |
753 |         monkeypatch.setattr(library_main, "SnippetDialog", lambda *a, **k: FakeSnipDialog())
    |                                                                                         ^^^^ E501
754 |         main_window.add_snippet()
755 |     main_window.snippetList.setCurrentRow(main_window.snippetList.count() - 1)
    |

tests\desktop_ui\test_library_main_ui_new.py:766:5: ANN201 Missing return type annotation for public function `test_filter_snippets`
    |
766 | def test_filter_snippets(main_window):
    |     ^^^^^^^^^^^^^^^^^^^^ ANN201
767 |     main_window.search_input.setText("Edit")
768 |     # Should only show snippets with 'Edit' in name
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:766:26: ANN001 Missing type annotation for function argument `main_window`
    |
766 | def test_filter_snippets(main_window):
    |                          ^^^^^^^^^^^ ANN001
767 |     main_window.search_input.setText("Edit")
768 |     # Should only show snippets with 'Edit' in name
    |

tests\desktop_ui\test_library_main_ui_new.py:775:5: ANN201 Missing return type annotation for public function `test_show_error_and_info`
    |
775 | def test_show_error_and_info(main_window):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
776 |     main_window.show_error("errormsg")
777 |     assert main_window.status.text() == "errormsg"
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:775:30: ANN001 Missing type annotation for function argument `main_window`
    |
775 | def test_show_error_and_info(main_window):
    |                              ^^^^^^^^^^^ ANN001
776 |     main_window.show_error("errormsg")
777 |     assert main_window.status.text() == "errormsg"
    |

tests\desktop_ui\test_library_main_ui_new.py:782:5: ANN201 Missing return type annotation for public function `test_update_snippet_buttons_state`
    |
782 | def test_update_snippet_buttons_state(main_window):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
783 |     main_window.update_snippet_buttons_state(True)
784 |     assert main_window.addSnipBtn.isEnabled()
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:782:39: ANN001 Missing type annotation for function argument `main_window`
    |
782 | def test_update_snippet_buttons_state(main_window):
    |                                       ^^^^^^^^^^^ ANN001
783 |     main_window.update_snippet_buttons_state(True)
784 |     assert main_window.addSnipBtn.isEnabled()
    |

tests\desktop_ui\test_library_main_ui_new.py:789:5: ANN201 Missing return type annotation for public function `test_add_category_error`
    |
789 | def test_add_category_error(monkeypatch, main_window):
    |     ^^^^^^^^^^^^^^^^^^^^^^^ ANN201
790 |     class FakeDialog:
791 |         def exec_(self):
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:789:29: ANN001 Missing type annotation for function argument `monkeypatch`
    |
789 | def test_add_category_error(monkeypatch, main_window):
    |                             ^^^^^^^^^^^ ANN001
790 |     class FakeDialog:
791 |         def exec_(self):
    |

tests\desktop_ui\test_library_main_ui_new.py:789:42: ANN001 Missing type annotation for function argument `main_window`
    |
789 | def test_add_category_error(monkeypatch, main_window):
    |                                          ^^^^^^^^^^^ ANN001
790 |     class FakeDialog:
791 |         def exec_(self):
    |

tests\desktop_ui\test_library_main_ui_new.py:791:13: ANN202 Missing return type annotation for private function `exec_`
    |
789 | def test_add_category_error(monkeypatch, main_window):
790 |     class FakeDialog:
791 |         def exec_(self):
    |             ^^^^^ ANN202
792 |             return 1
    |
    = help: Add return type annotation: `int`

tests\desktop_ui\test_library_main_ui_new.py:794:13: ANN202 Missing return type annotation for private function `get_value`
    |
792 |             return 1
793 |
794 |         def get_value(self):
    |             ^^^^^^^^^ ANN202
795 |             return "ErrorCat"
    |
    = help: Add return type annotation: `str`

tests\desktop_ui\test_library_main_ui_new.py:799:9: ANN202 Missing return type annotation for private function `fail_save_category`
    |
797 |     monkeypatch.setattr(library_main, "CategoryDialog", lambda *a, **k: FakeDialog())
798 |
799 |     def fail_save_category(cat):
    |         ^^^^^^^^^^^^^^^^^^ ANN202
800 |         raise Exception("failcat")
    |
    = help: Add return type annotation: `Never`

tests\desktop_ui\test_library_main_ui_new.py:799:28: ANN001 Missing type annotation for function argument `cat`
    |
797 |     monkeypatch.setattr(library_main, "CategoryDialog", lambda *a, **k: FakeDialog())
798 |
799 |     def fail_save_category(cat):
    |                            ^^^ ANN001
800 |         raise Exception("failcat")
    |

tests\desktop_ui\test_library_main_ui_new.py:802:89: E501 Line too long (90 > 88)
    |
800 |         raise Exception("failcat")
801 |
802 |     monkeypatch.setattr(main_window.category_manager, "save_category", fail_save_category)
    |                                                                                         ^^ E501
803 |     main_window.add_category()
804 |     assert "failcat" in main_window.status.text()
    |

tests\desktop_ui\test_library_main_ui_new.py:807:5: ANN201 Missing return type annotation for public function `test_add_snippet_error`
    |
807 | def test_add_snippet_error(monkeypatch, main_window):
    |     ^^^^^^^^^^^^^^^^^^^^^^ ANN201
808 |     # Ensure a category exists and is selected
809 |     if not main_window.categories:
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:807:28: ANN001 Missing type annotation for function argument `monkeypatch`
    |
807 | def test_add_snippet_error(monkeypatch, main_window):
    |                            ^^^^^^^^^^^ ANN001
808 |     # Ensure a category exists and is selected
809 |     if not main_window.categories:
    |

tests\desktop_ui\test_library_main_ui_new.py:807:41: ANN001 Missing type annotation for function argument `main_window`
    |
807 | def test_add_snippet_error(monkeypatch, main_window):
    |                                         ^^^^^^^^^^^ ANN001
808 |     # Ensure a category exists and is selected
809 |     if not main_window.categories:
    |

tests\desktop_ui\test_library_main_ui_new.py:812:17: ANN202 Missing return type annotation for private function `exec_`
    |
811 |         class FakeCatDialog:
812 |             def exec_(self):
    |                 ^^^^^ ANN202
813 |                 return 1
    |
    = help: Add return type annotation: `int`

tests\desktop_ui\test_library_main_ui_new.py:815:17: ANN202 Missing return type annotation for private function `get_value`
    |
813 |                 return 1
814 |
815 |             def get_value(self):
    |                 ^^^^^^^^^ ANN202
816 |                 return "CatForError"
    |
    = help: Add return type annotation: `str`

tests\desktop_ui\test_library_main_ui_new.py:818:89: E501 Line too long (92 > 88)
    |
816 |                 return "CatForError"
817 |
818 |         monkeypatch.setattr(library_main, "CategoryDialog", lambda *a, **k: FakeCatDialog())
    |                                                                                         ^^^^ E501
819 |         main_window.add_category()
820 |     main_window.categoryList.setCurrentRow(0)
    |

tests\desktop_ui\test_library_main_ui_new.py:823:13: ANN202 Missing return type annotation for private function `exec_`
    |
822 |     class FakeDialog:
823 |         def exec_(self):
    |             ^^^^^ ANN202
824 |             return 1
    |
    = help: Add return type annotation: `int`

tests\desktop_ui\test_library_main_ui_new.py:826:13: ANN202 Missing return type annotation for private function `get_values`
    |
824 |             return 1
825 |
826 |         def get_values(self):
    |             ^^^^^^^^^^ ANN202
827 |             return ("ErrSnip", "X")
    |
    = help: Add return type annotation

tests\desktop_ui\test_library_main_ui_new.py:831:9: ANN202 Missing return type annotation for private function `fail_save_snippet`
    |
829 |     monkeypatch.setattr(library_main, "SnippetDialog", lambda *a, **k: FakeDialog())
830 |
831 |     def fail_save_snippet(snip):
    |         ^^^^^^^^^^^^^^^^^ ANN202
832 |         raise Exception("failsnip")
    |
    = help: Add return type annotation: `Never`

tests\desktop_ui\test_library_main_ui_new.py:831:27: ANN001 Missing type annotation for function argument `snip`
    |
829 |     monkeypatch.setattr(library_main, "SnippetDialog", lambda *a, **k: FakeDialog())
830 |
831 |     def fail_save_snippet(snip):
    |                           ^^^^ ANN001
832 |         raise Exception("failsnip")
    |

tests\desktop_ui\test_library_main_ui_new.py:839:5: ANN201 Missing return type annotation for public function `test_edit_category_no_selection`
    |
839 | def test_edit_category_no_selection(main_window):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
840 |     main_window.categoryList.clearSelection()
841 |     main_window.edit_category()
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:839:37: ANN001 Missing type annotation for function argument `main_window`
    |
839 | def test_edit_category_no_selection(main_window):
    |                                     ^^^^^^^^^^^ ANN001
840 |     main_window.categoryList.clearSelection()
841 |     main_window.edit_category()
    |

tests\desktop_ui\test_library_main_ui_new.py:845:5: ANN201 Missing return type annotation for public function `test_delete_category_no_selection`
    |
845 | def test_delete_category_no_selection(main_window):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
846 |     main_window.categoryList.clearSelection()
847 |     main_window.delete_category()
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:845:39: ANN001 Missing type annotation for function argument `main_window`
    |
845 | def test_delete_category_no_selection(main_window):
    |                                       ^^^^^^^^^^^ ANN001
846 |     main_window.categoryList.clearSelection()
847 |     main_window.delete_category()
    |

tests\desktop_ui\test_library_main_ui_new.py:851:5: ANN201 Missing return type annotation for public function `test_add_snippet_no_category`
    |
851 | def test_add_snippet_no_category(main_window):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
852 |     main_window.selected_category = None
853 |     main_window.add_snippet()
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:851:34: ANN001 Missing type annotation for function argument `main_window`
    |
851 | def test_add_snippet_no_category(main_window):
    |                                  ^^^^^^^^^^^ ANN001
852 |     main_window.selected_category = None
853 |     main_window.add_snippet()
    |

tests\desktop_ui\test_library_main_ui_new.py:857:5: ANN201 Missing return type annotation for public function `test_edit_snippet_no_selection`
    |
857 | def test_edit_snippet_no_selection(main_window):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
858 |     main_window.snippetList.clearSelection()
859 |     main_window.edit_snippet()
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:857:36: ANN001 Missing type annotation for function argument `main_window`
    |
857 | def test_edit_snippet_no_selection(main_window):
    |                                    ^^^^^^^^^^^ ANN001
858 |     main_window.snippetList.clearSelection()
859 |     main_window.edit_snippet()
    |

tests\desktop_ui\test_library_main_ui_new.py:863:5: ANN201 Missing return type annotation for public function `test_delete_snippet_no_selection`
    |
863 | def test_delete_snippet_no_selection(main_window):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
864 |     main_window.snippetList.clearSelection()
865 |     main_window.delete_snippet()
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:863:38: ANN001 Missing type annotation for function argument `main_window`
    |
863 | def test_delete_snippet_no_selection(main_window):
    |                                      ^^^^^^^^^^^ ANN001
864 |     main_window.snippetList.clearSelection()
865 |     main_window.delete_snippet()
    |

tests\desktop_ui\test_library_main_ui_new.py:869:5: ANN201 Missing return type annotation for public function `test_edit_category_error`
    |
869 | def test_edit_category_error(monkeypatch, main_window):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
870 |     # Ensure a category exists and is selected
871 |     if not main_window.categories:
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:869:30: ANN001 Missing type annotation for function argument `monkeypatch`
    |
869 | def test_edit_category_error(monkeypatch, main_window):
    |                              ^^^^^^^^^^^ ANN001
870 |     # Ensure a category exists and is selected
871 |     if not main_window.categories:
    |

tests\desktop_ui\test_library_main_ui_new.py:869:43: ANN001 Missing type annotation for function argument `main_window`
    |
869 | def test_edit_category_error(monkeypatch, main_window):
    |                                           ^^^^^^^^^^^ ANN001
870 |     # Ensure a category exists and is selected
871 |     if not main_window.categories:
    |

tests\desktop_ui\test_library_main_ui_new.py:874:17: ANN202 Missing return type annotation for private function `exec_`
    |
873 |         class FakeCatDialog:
874 |             def exec_(self):
    |                 ^^^^^ ANN202
875 |                 return 1
    |
    = help: Add return type annotation: `int`

tests\desktop_ui\test_library_main_ui_new.py:877:17: ANN202 Missing return type annotation for private function `get_value`
    |
875 |                 return 1
876 |
877 |             def get_value(self):
    |                 ^^^^^^^^^ ANN202
878 |                 return "ErrEditCat"
    |
    = help: Add return type annotation: `str`

tests\desktop_ui\test_library_main_ui_new.py:880:89: E501 Line too long (92 > 88)
    |
878 |                 return "ErrEditCat"
879 |
880 |         monkeypatch.setattr(library_main, "CategoryDialog", lambda *a, **k: FakeCatDialog())
    |                                                                                         ^^^^ E501
881 |         main_window.add_category()
882 |     main_window.categoryList.setCurrentRow(0)
    |

tests\desktop_ui\test_library_main_ui_new.py:885:13: ANN202 Missing return type annotation for private function `exec_`
    |
884 |     class FakeDialog:
885 |         def exec_(self):
    |             ^^^^^ ANN202
886 |             return 1
    |
    = help: Add return type annotation: `int`

tests\desktop_ui\test_library_main_ui_new.py:888:13: ANN202 Missing return type annotation for private function `get_value`
    |
886 |             return 1
887 |
888 |         def get_value(self):
    |             ^^^^^^^^^ ANN202
889 |             return "ErrEditCat"
    |
    = help: Add return type annotation: `str`

tests\desktop_ui\test_library_main_ui_new.py:893:9: ANN202 Missing return type annotation for private function `fail_save_category`
    |
891 |     monkeypatch.setattr(library_main, "CategoryDialog", lambda *a, **k: FakeDialog())
892 |
893 |     def fail_save_category(cat):
    |         ^^^^^^^^^^^^^^^^^^ ANN202
894 |         raise Exception("failcat2")
    |
    = help: Add return type annotation: `Never`

tests\desktop_ui\test_library_main_ui_new.py:893:28: ANN001 Missing type annotation for function argument `cat`
    |
891 |     monkeypatch.setattr(library_main, "CategoryDialog", lambda *a, **k: FakeDialog())
892 |
893 |     def fail_save_category(cat):
    |                            ^^^ ANN001
894 |         raise Exception("failcat2")
    |

tests\desktop_ui\test_library_main_ui_new.py:896:89: E501 Line too long (90 > 88)
    |
894 |         raise Exception("failcat2")
895 |
896 |     monkeypatch.setattr(main_window.category_manager, "save_category", fail_save_category)
    |                                                                                         ^^ E501
897 |     main_window.edit_category()
898 |     assert (
    |

tests\desktop_ui\test_library_main_ui_new.py:904:5: ANN201 Missing return type annotation for public function `test_edit_snippet_error`
    |
904 | def test_edit_snippet_error(monkeypatch, main_window):
    |     ^^^^^^^^^^^^^^^^^^^^^^^ ANN201
905 |     # Ensure a snippet exists and is selected
906 |     if not main_window.snippets:
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:904:29: ANN001 Missing type annotation for function argument `monkeypatch`
    |
904 | def test_edit_snippet_error(monkeypatch, main_window):
    |                             ^^^^^^^^^^^ ANN001
905 |     # Ensure a snippet exists and is selected
906 |     if not main_window.snippets:
    |

tests\desktop_ui\test_library_main_ui_new.py:904:42: ANN001 Missing type annotation for function argument `main_window`
    |
904 | def test_edit_snippet_error(monkeypatch, main_window):
    |                                          ^^^^^^^^^^^ ANN001
905 |     # Ensure a snippet exists and is selected
906 |     if not main_window.snippets:
    |

tests\desktop_ui\test_library_main_ui_new.py:911:21: ANN202 Missing return type annotation for private function `exec_`
    |
910 |             class FakeCatDialog:
911 |                 def exec_(self):
    |                     ^^^^^ ANN202
912 |                     return 1
    |
    = help: Add return type annotation: `int`

tests\desktop_ui\test_library_main_ui_new.py:914:21: ANN202 Missing return type annotation for private function `get_value`
    |
912 |                     return 1
913 |
914 |                 def get_value(self):
    |                     ^^^^^^^^^ ANN202
915 |                     return "CatForEditError"
    |
    = help: Add return type annotation: `str`

tests\desktop_ui\test_library_main_ui_new.py:917:89: E501 Line too long (96 > 88)
    |
915 |                     return "CatForEditError"
916 |
917 |             monkeypatch.setattr(library_main, "CategoryDialog", lambda *a, **k: FakeCatDialog())
    |                                                                                         ^^^^^^^^ E501
918 |             main_window.add_category()
919 |         main_window.categoryList.setCurrentRow(0)
    |

tests\desktop_ui\test_library_main_ui_new.py:922:17: ANN202 Missing return type annotation for private function `exec_`
    |
921 |         class FakeAddDialog:
922 |             def exec_(self):
    |                 ^^^^^ ANN202
923 |                 return 1
    |
    = help: Add return type annotation: `int`

tests\desktop_ui\test_library_main_ui_new.py:925:17: ANN202 Missing return type annotation for private function `get_values`
    |
923 |                 return 1
924 |
925 |             def get_values(self):
    |                 ^^^^^^^^^^ ANN202
926 |                 return ("SnippetToEditError", "ContentToEditError")
    |
    = help: Add return type annotation

tests\desktop_ui\test_library_main_ui_new.py:928:89: E501 Line too long (91 > 88)
    |
926 |                 return ("SnippetToEditError", "ContentToEditError")
927 |
928 |         monkeypatch.setattr(library_main, "SnippetDialog", lambda *a, **k: FakeAddDialog())
    |                                                                                         ^^^ E501
929 |         main_window.add_snippet()
930 |     main_window.snippetList.setCurrentRow(0)
    |

tests\desktop_ui\test_library_main_ui_new.py:933:13: ANN202 Missing return type annotation for private function `exec_`
    |
932 |     class FakeDialog:
933 |         def exec_(self):
    |             ^^^^^ ANN202
934 |             return 1
    |
    = help: Add return type annotation: `int`

tests\desktop_ui\test_library_main_ui_new.py:936:13: ANN202 Missing return type annotation for private function `get_values`
    |
934 |             return 1
935 |
936 |         def get_values(self):
    |             ^^^^^^^^^^ ANN202
937 |             return ("ErrEditSnip", "X")
    |
    = help: Add return type annotation

tests\desktop_ui\test_library_main_ui_new.py:941:9: ANN202 Missing return type annotation for private function `fail_save_snippet`
    |
939 |     monkeypatch.setattr(library_main, "SnippetDialog", lambda *a, **k: FakeDialog())
940 |
941 |     def fail_save_snippet(snip):
    |         ^^^^^^^^^^^^^^^^^ ANN202
942 |         raise Exception("failsnip2")
    |
    = help: Add return type annotation: `Never`

tests\desktop_ui\test_library_main_ui_new.py:941:27: ANN001 Missing type annotation for function argument `snip`
    |
939 |     monkeypatch.setattr(library_main, "SnippetDialog", lambda *a, **k: FakeDialog())
940 |
941 |     def fail_save_snippet(snip):
    |                           ^^^^ ANN001
942 |         raise Exception("failsnip2")
    |

tests\desktop_ui\test_library_main_ui_new.py:952:5: ANN201 Missing return type annotation for public function `test_delete_category_error`
    |
952 | def test_delete_category_error(monkeypatch, main_window):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
953 |     # Ensure a category exists and is selected
954 |     if not main_window.categories:
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:952:32: ANN001 Missing type annotation for function argument `monkeypatch`
    |
952 | def test_delete_category_error(monkeypatch, main_window):
    |                                ^^^^^^^^^^^ ANN001
953 |     # Ensure a category exists and is selected
954 |     if not main_window.categories:
    |

tests\desktop_ui\test_library_main_ui_new.py:952:45: ANN001 Missing type annotation for function argument `main_window`
    |
952 | def test_delete_category_error(monkeypatch, main_window):
    |                                             ^^^^^^^^^^^ ANN001
953 |     # Ensure a category exists and is selected
954 |     if not main_window.categories:
    |

tests\desktop_ui\test_library_main_ui_new.py:957:17: ANN202 Missing return type annotation for private function `exec_`
    |
956 |         class FakeCatDialog:
957 |             def exec_(self):
    |                 ^^^^^ ANN202
958 |                 return 1
    |
    = help: Add return type annotation: `int`

tests\desktop_ui\test_library_main_ui_new.py:960:17: ANN202 Missing return type annotation for private function `get_value`
    |
958 |                 return 1
959 |
960 |             def get_value(self):
    |                 ^^^^^^^^^ ANN202
961 |                 return "CatForDelete"
    |
    = help: Add return type annotation: `str`

tests\desktop_ui\test_library_main_ui_new.py:963:89: E501 Line too long (92 > 88)
    |
961 |                 return "CatForDelete"
962 |
963 |         monkeypatch.setattr(library_main, "CategoryDialog", lambda *a, **k: FakeCatDialog())
    |                                                                                         ^^^^ E501
964 |         main_window.add_category()
965 |     main_window.categoryList.setCurrentRow(0)
    |

tests\desktop_ui\test_library_main_ui_new.py:972:9: ANN202 Missing return type annotation for private function `fail_delete_category_by_id`
    |
970 |     )
971 |
972 |     def fail_delete_category_by_id(cid):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN202
973 |         raise Exception("faildelcat")
    |
    = help: Add return type annotation: `Never`

tests\desktop_ui\test_library_main_ui_new.py:972:36: ANN001 Missing type annotation for function argument `cid`
    |
970 |     )
971 |
972 |     def fail_delete_category_by_id(cid):
    |                                    ^^^ ANN001
973 |         raise Exception("faildelcat")
    |

tests\desktop_ui\test_library_main_ui_new.py:976:89: E501 Line too long (89 > 88)
    |
975 |     monkeypatch.setattr(
976 |         main_window.category_manager, "delete_category_by_id", fail_delete_category_by_id
    |                                                                                         ^ E501
977 |     )
978 |     main_window.delete_category()
    |

tests\desktop_ui\test_library_main_ui_new.py:982:5: ANN201 Missing return type annotation for public function `test_delete_snippet_error`
    |
982 | def test_delete_snippet_error(monkeypatch, main_window):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
983 |     # Ensure a category exists and is selected
984 |     if not main_window.categories:
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:982:31: ANN001 Missing type annotation for function argument `monkeypatch`
    |
982 | def test_delete_snippet_error(monkeypatch, main_window):
    |                               ^^^^^^^^^^^ ANN001
983 |     # Ensure a category exists and is selected
984 |     if not main_window.categories:
    |

tests\desktop_ui\test_library_main_ui_new.py:982:44: ANN001 Missing type annotation for function argument `main_window`
    |
982 | def test_delete_snippet_error(monkeypatch, main_window):
    |                                            ^^^^^^^^^^^ ANN001
983 |     # Ensure a category exists and is selected
984 |     if not main_window.categories:
    |

tests\desktop_ui\test_library_main_ui_new.py:987:17: ANN202 Missing return type annotation for private function `exec_`
    |
986 |         class FakeCatDialog:
987 |             def exec_(self):
    |                 ^^^^^ ANN202
988 |                 return 1
    |
    = help: Add return type annotation: `int`

tests\desktop_ui\test_library_main_ui_new.py:990:17: ANN202 Missing return type annotation for private function `get_value`
    |
988 |                 return 1
989 |
990 |             def get_value(self):
    |                 ^^^^^^^^^ ANN202
991 |                 return "CatForDeleteError"
    |
    = help: Add return type annotation: `str`

tests\desktop_ui\test_library_main_ui_new.py:993:89: E501 Line too long (92 > 88)
    |
991 |                 return "CatForDeleteError"
992 |
993 |         monkeypatch.setattr(library_main, "CategoryDialog", lambda *a, **k: FakeCatDialog())
    |                                                                                         ^^^^ E501
994 |         main_window.add_category()
995 |     main_window.categoryList.setCurrentRow(0)
    |

tests\desktop_ui\test_library_main_ui_new.py:1000:17: ANN202 Missing return type annotation for private function `exec_`
     |
 999 |         class FakeSnipDialog:
1000 |             def exec_(self):
     |                 ^^^^^ ANN202
1001 |                 return 1
     |
     = help: Add return type annotation: `int`

tests\desktop_ui\test_library_main_ui_new.py:1003:17: ANN202 Missing return type annotation for private function `get_values`
     |
1001 |                 return 1
1002 |
1003 |             def get_values(self):
     |                 ^^^^^^^^^^ ANN202
1004 |                 return ("ToDelError", "X")
     |
     = help: Add return type annotation

tests\desktop_ui\test_library_main_ui_new.py:1006:89: E501 Line too long (92 > 88)
     |
1004 |                 return ("ToDelError", "X")
1005 |
1006 |         monkeypatch.setattr(library_main, "SnippetDialog", lambda *a, **k: FakeSnipDialog())
     |                                                                                         ^^^^ E501
1007 |         main_window.add_snippet()
1008 |     main_window.snippetList.setCurrentRow(main_window.snippetList.count() - 1)
     |

tests\desktop_ui\test_library_main_ui_new.py:1015:9: ANN202 Missing return type annotation for private function `fail_delete_snippet`
     |
1013 |     )
1014 |
1015 |     def fail_delete_snippet(sid):
     |         ^^^^^^^^^^^^^^^^^^^ ANN202
1016 |         raise Exception("faildelsnip")
     |
     = help: Add return type annotation: `Never`

tests\desktop_ui\test_library_main_ui_new.py:1015:29: ANN001 Missing type annotation for function argument `sid`
     |
1013 |     )
1014 |
1015 |     def fail_delete_snippet(sid):
     |                             ^^^ ANN001
1016 |         raise Exception("faildelsnip")
     |

tests\desktop_ui\test_library_main_ui_new.py:1018:89: E501 Line too long (91 > 88)
     |
1016 |         raise Exception("faildelsnip")
1017 |
1018 |     monkeypatch.setattr(main_window.snippet_manager, "delete_snippet", fail_delete_snippet)
     |                                                                                         ^^^ E501
1019 |     main_window.delete_snippet()
1020 |     assert (
     |

tests\desktop_ui\test_library_main_ui_new.py:1026:5: ANN201 Missing return type annotation for public function `test_view_snippet_dialog`
     |
1026 | def test_view_snippet_dialog(monkeypatch, main_window):
     |     ^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
1027 |     # Ensure a category exists and is selected
1028 |     if not main_window.categories:
     |
     = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:1026:30: ANN001 Missing type annotation for function argument `monkeypatch`
     |
1026 | def test_view_snippet_dialog(monkeypatch, main_window):
     |                              ^^^^^^^^^^^ ANN001
1027 |     # Ensure a category exists and is selected
1028 |     if not main_window.categories:
     |

tests\desktop_ui\test_library_main_ui_new.py:1026:43: ANN001 Missing type annotation for function argument `main_window`
     |
1026 | def test_view_snippet_dialog(monkeypatch, main_window):
     |                                           ^^^^^^^^^^^ ANN001
1027 |     # Ensure a category exists and is selected
1028 |     if not main_window.categories:
     |

tests\desktop_ui\test_library_main_ui_new.py:1031:17: ANN202 Missing return type annotation for private function `exec_`
     |
1030 |         class FakeCatDialog:
1031 |             def exec_(self):
     |                 ^^^^^ ANN202
1032 |                 return 1
     |
     = help: Add return type annotation: `int`

tests\desktop_ui\test_library_main_ui_new.py:1034:17: ANN202 Missing return type annotation for private function `get_value`
     |
1032 |                 return 1
1033 |
1034 |             def get_value(self):
     |                 ^^^^^^^^^ ANN202
1035 |                 return "CatForView"
     |
     = help: Add return type annotation: `str`

tests\desktop_ui\test_library_main_ui_new.py:1037:89: E501 Line too long (92 > 88)
     |
1035 |                 return "CatForView"
1036 |
1037 |         monkeypatch.setattr(library_main, "CategoryDialog", lambda *a, **k: FakeCatDialog())
     |                                                                                         ^^^^ E501
1038 |         main_window.add_category()
1039 |     main_window.categoryList.setCurrentRow(0)
     |

tests\desktop_ui\test_library_main_ui_new.py:1044:17: ANN202 Missing return type annotation for private function `exec_`
     |
1043 |         class FakeSnipDialog:
1044 |             def exec_(self):
     |                 ^^^^^ ANN202
1045 |                 return 1
     |
     = help: Add return type annotation: `int`

tests\desktop_ui\test_library_main_ui_new.py:1047:17: ANN202 Missing return type annotation for private function `get_values`
     |
1045 |                 return 1
1046 |
1047 |             def get_values(self):
     |                 ^^^^^^^^^^ ANN202
1048 |                 return ("ViewMe", "Content")
     |
     = help: Add return type annotation

tests\desktop_ui\test_library_main_ui_new.py:1050:89: E501 Line too long (92 > 88)
     |
1048 |                 return ("ViewMe", "Content")
1049 |
1050 |         monkeypatch.setattr(library_main, "SnippetDialog", lambda *a, **k: FakeSnipDialog())
     |                                                                                         ^^^^ E501
1051 |         main_window.add_snippet()
1052 |     main_window.snippetList.setCurrentRow(0)
     |

tests\desktop_ui\test_library_main_ui_new.py:1056:13: ANN204 Missing return type annotation for special method `__init__`
     |
1055 |     class FakeViewDialog:
1056 |         def __init__(self, **kwargs):
     |             ^^^^^^^^ ANN204
1057 |             called["shown"] = True
     |
     = help: Add return type annotation: `None`

tests\desktop_ui\test_library_main_ui_new.py:1056:28: ANN003 Missing type annotation for `**kwargs`
     |
1055 |     class FakeViewDialog:
1056 |         def __init__(self, **kwargs):
     |                            ^^^^^^^^ ANN003
1057 |             called["shown"] = True
     |

tests\desktop_ui\test_library_main_ui_new.py:1059:13: ANN202 Missing return type annotation for private function `exec_`
     |
1057 |             called["shown"] = True
1058 |
1059 |         def exec_(self):
     |             ^^^^^ ANN202
1060 |             called["exec"] = True
     |
     = help: Add return type annotation: `None`

tests\desktop_ui\test_ngram_heatmap_dialog.py:8:1: I001 [*] Import block is un-sorted or un-formatted
   |
 6 |   """
 7 |
 8 | / import os
 9 | | import sys
10 | | from unittest.mock import Mock, patch, MagicMock
11 | |
12 | | import pytest
13 | | from PySide6 import QtWidgets, QtCore
   | |_____________________________________^ I001
14 |
15 |   # Ensure project root is in sys.path
   |
   = help: Organize imports

tests\desktop_ui\test_ngram_heatmap_dialog.py:18:1: I001 [*] Import block is un-sorted or un-formatted
   |
16 |   sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), "..", "..")))
17 |
18 | / from desktop_ui.ngram_heatmap_screen import NGramHeatmapDialog
19 | | from models.ngram_analytics_service import NGramHeatmapData
20 | | from models.user import User
21 | | from models.keyboard import Keyboard
   | |____________________________________^ I001
   |
   = help: Organize imports

tests\desktop_ui\test_ngram_heatmap_dialog.py:92:89: E501 Line too long (91 > 88)
   |
90 |     ) -> NGramHeatmapDialog:
91 |         """Test objective: Create NGramHeatmapDialog instance for testing."""
92 |         with patch('desktop_ui.ngram_heatmap_screen.DatabaseManager') as mock_db_manager, \
   |                                                                                         ^^^ E501
93 |              patch('desktop_ui.ngram_heatmap_screen.NGramAnalyticsService') as mock_service_class, \
94 |              patch('desktop_ui.ngram_heatmap_screen.NGramManager'):
   |

tests\desktop_ui\test_ngram_heatmap_dialog.py:93:89: E501 Line too long (100 > 88)
   |
91 |         """Test objective: Create NGramHeatmapDialog instance for testing."""
92 |         with patch('desktop_ui.ngram_heatmap_screen.DatabaseManager') as mock_db_manager, \
93 |              patch('desktop_ui.ngram_heatmap_screen.NGramAnalyticsService') as mock_service_class, \
   |                                                                                         ^^^^^^^^^^^^ E501
94 |              patch('desktop_ui.ngram_heatmap_screen.NGramManager'):
   |

tests\desktop_ui\test_ngram_heatmap_dialog.py:141:89: E501 Line too long (95 > 88)
    |
140 |         # Check button types
141 |         refresh_btn = dialog.button_box.button(QtWidgets.QDialogButtonBox.StandardButton.Reset)
    |                                                                                         ^^^^^^^ E501
142 |         assert refresh_btn is not None
143 |         assert refresh_btn.text() == "Refresh Data"
    |

tests\desktop_ui\test_ngram_heatmap_dialog.py:146:89: E501 Line too long (99 > 88)
    |
145 |         # Check other buttons exist
146 |         assert dialog.button_box.button(QtWidgets.QDialogButtonBox.StandardButton.Save) is not None
    |                                                                                         ^^^^^^^^^^^ E501
147 |         assert dialog.button_box.button(QtWidgets.QDialogButtonBox.StandardButton.Close) is not None
    |

tests\desktop_ui\test_ngram_heatmap_dialog.py:147:89: E501 Line too long (100 > 88)
    |
145 |         # Check other buttons exist
146 |         assert dialog.button_box.button(QtWidgets.QDialogButtonBox.StandardButton.Save) is not None
147 |         assert dialog.button_box.button(QtWidgets.QDialogButtonBox.StandardButton.Close) is not None
    |                                                                                         ^^^^^^^^^^^^ E501
148 |     
149 |     def test_load_data(self, dialog: NGramHeatmapDialog, mock_analytics_service: Mock) -> None:
    |

tests\desktop_ui\test_ngram_heatmap_dialog.py:149:89: E501 Line too long (95 > 88)
    |
147 |         assert dialog.button_box.button(QtWidgets.QDialogButtonBox.StandardButton.Close) is not None
148 |     
149 |     def test_load_data(self, dialog: NGramHeatmapDialog, mock_analytics_service: Mock) -> None:
    |                                                                                         ^^^^^^^ E501
150 |         """Test objective: Verify data loading functionality."""
151 |         # Note: load_data is already called during dialog initialization
    |

tests\desktop_ui\test_ngram_heatmap_dialog.py:166:89: E501 Line too long (99 > 88)
    |
164 |         assert dialog.status_label.text() == "Loaded 2 n-grams"
165 |     
166 |     def test_apply_filters(self, dialog: NGramHeatmapDialog, mock_analytics_service: Mock) -> None:
    |                                                                                         ^^^^^^^^^^^ E501
167 |         """Test objective: Verify filter functionality."""
168 |         # Load data first
    |

tests\desktop_ui\test_ngram_heatmap_dialog.py:186:89: E501 Line too long (99 > 88)
    |
184 |         assert "Showing 1 of 2 n-grams" in dialog.status_label.text()
185 |     
186 |     def test_apply_sorting(self, dialog: NGramHeatmapDialog, mock_analytics_service: Mock) -> None:
    |                                                                                         ^^^^^^^^^^^ E501
187 |         """Test objective: Verify sorting functionality."""
188 |         # Load data first
    |

tests\desktop_ui\test_ngram_heatmap_dialog.py:199:89: E501 Line too long (98 > 88)
    |
197 |         assert dialog.filtered_data[1].ngram_text == "th"  # 155ms
198 |     
199 |     def test_refresh_data(self, dialog: NGramHeatmapDialog, mock_analytics_service: Mock) -> None:
    |                                                                                         ^^^^^^^^^^ E501
200 |         """Test objective: Verify refresh functionality."""
201 |         dialog.load_data()
    |

tests\desktop_ui\test_ngram_heatmap_dialog.py:213:89: E501 Line too long (100 > 88)
    |
211 |         dialog.filtered_data = []
212 |         
213 |         with patch('desktop_ui.ngram_heatmap_screen.QtWidgets.QMessageBox.information') as mock_msg:
    |                                                                                         ^^^^^^^^^^^^ E501
214 |             dialog.export_data()
215 |             mock_msg.assert_called_once_with(dialog, "No Data", "No data to export.")
    |

tests\desktop_ui\test_ngram_heatmap_dialog.py:217:89: E501 Line too long (105 > 88)
    |
215 |             mock_msg.assert_called_once_with(dialog, "No Data", "No data to export.")
216 |     
217 |     def test_export_data_success(self, dialog: NGramHeatmapDialog, mock_analytics_service: Mock) -> None:
    |                                                                                         ^^^^^^^^^^^^^^^^^ E501
218 |         """Test objective: Verify successful export functionality."""
219 |         dialog.load_data()
    |

tests\desktop_ui\test_ngram_heatmap_dialog.py:221:89: E501 Line too long (99 > 88)
    |
219 |         dialog.load_data()
220 |         
221 |         file_dialog_patch = 'desktop_ui.ngram_heatmap_screen.QtWidgets.QFileDialog.getSaveFileName'
    |                                                                                         ^^^^^^^^^^^ E501
222 |         open_patch = 'desktop_ui.ngram_heatmap_screen.open'
223 |         writer_patch = 'desktop_ui.ngram_heatmap_screen.csv.writer'
    |

tests\desktop_ui\test_ngram_heatmap_dialog.py:239:89: E501 Line too long (92 > 88)
    |
237 |             dialog.export_data()
238 |             
239 |             mock_open.assert_called_once_with("test.csv", 'w', newline='', encoding='utf-8')
    |                                                                                         ^^^^ E501
240 |             mock_writer.assert_called_once_with(mock_file)
241 |             mock_csv_writer.writerow.assert_called()
    |

tests\desktop_ui\test_ngram_heatmap_dialog.py:245:89: E501 Line too long (107 > 88)
    |
243 |             mock_msg.assert_called_once_with(dialog, "Export Complete", expected_msg)
244 |     
245 |     def test_export_data_cancelled(self, dialog: NGramHeatmapDialog, mock_analytics_service: Mock) -> None:
    |                                                                                         ^^^^^^^^^^^^^^^^^^^ E501
246 |         """Test objective: Verify export handles cancellation properly."""
247 |         dialog.load_data()
    |

tests\desktop_ui\test_ngram_heatmap_dialog.py:249:89: E501 Line too long (99 > 88)
    |
247 |         dialog.load_data()
248 |         
249 |         file_dialog_patch = 'desktop_ui.ngram_heatmap_screen.QtWidgets.QFileDialog.getSaveFileName'
    |                                                                                         ^^^^^^^^^^^ E501
250 |         with patch(file_dialog_patch) as mock_file_dlg:
251 |             mock_file_dlg.return_value = ("", "")  # User cancelled
    |

tests\desktop_ui\test_users_and_keyboards.py:6:1: I001 [*] Import block is un-sorted or un-formatted
   |
 4 |   Updated to use PySide6 instead of PyQt5.
 5 |   """
 6 | / import pytest
 7 | | from typing import Generator, List, Tuple
 8 | | from unittest.mock import MagicMock, patch
 9 | | from PySide6 import QtCore, QtWidgets
10 | | from PySide6.QtCore import Qt
11 | | from pytestqt.qtbot import QtBot
12 | |
13 | | from db.database_manager import DatabaseManager
14 | | from desktop_ui.users_and_keyboards import UsersAndKeyboards
15 | | from models.keyboard import Keyboard
16 | | from models.keyboard_manager import KeyboardManager
17 | | from models.user import User
18 | | from models.user_manager import UserManager
   | |___________________________________________^ I001
19 |
20 |   # Test data constants
   |
   = help: Organize imports

tests\desktop_ui\test_users_and_keyboards.py:80:89: E501 Line too long (90 > 88)
   |
78 |     state = {"users": [test_user]}
79 |
80 |     # Define static return values for list_all_users to avoid potential infinite recursion
   |                                                                                         ^^ E501
81 |     mock.list_all_users.return_value = state["users"]
   |

tests\desktop_ui\test_users_and_keyboards.py:125:89: E501 Line too long (92 > 88)
    |
124 | @pytest.fixture
125 | def mock_keyboard_manager(mock_db_manager: MagicMock, test_keyboard: Keyboard) -> MagicMock:
    |                                                                                         ^^^^ E501
126 |     """Create a stateful mock keyboard manager."""
127 |     mock = MagicMock(spec=KeyboardManager)
    |

tests\desktop_ui\test_users_and_keyboards.py:198:89: E501 Line too long (92 > 88)
    |
196 |     """
197 |     with (
198 |         patch("desktop_ui.users_and_keyboards.UserManager", return_value=mock_user_manager),
    |                                                                                         ^^^^ E501
199 |         patch(
200 |             "desktop_ui.users_and_keyboards.KeyboardManager",
    |

tests\desktop_ui\test_users_and_keyboards.py:223:89: E501 Line too long (89 > 88)
    |
222 |     def test_load_users(
223 |         self, users_and_keyboards_dialog: Tuple[UsersAndKeyboards, MagicMock, MagicMock],
    |                                                                                         ^ E501
224 |         test_user: User
225 |     ) -> None:
    |

tests\desktop_ui\test_users_and_keyboards.py:267:89: E501 Line too long (90 > 88)
    |
265 |         # Create a new user that will be returned by the mocked dialog
266 |         new_user = User(
267 |             user_id="550e8400-e29b-41d4-a716-446655440001",  # Different ID from test_user
    |                                                                                         ^^ E501
268 |             first_name=NEW_USER_DATA["first_name"],
269 |             surname=NEW_USER_DATA["surname"],
    |

tests\desktop_ui\test_users_and_keyboards.py:283:89: E501 Line too long (89 > 88)
    |
282 |             # Check that the user manager was called to save the user
283 |             assert mock_user_manager.save_user.call_count > 0, "save_user was not called"
    |                                                                                         ^ E501
284 |             assert dialog.users_list.count() == initial_count + 1, "User count did not increase"
    |

tests\desktop_ui\test_users_and_keyboards.py:284:89: E501 Line too long (96 > 88)
    |
282 |             # Check that the user manager was called to save the user
283 |             assert mock_user_manager.save_user.call_count > 0, "save_user was not called"
284 |             assert dialog.users_list.count() == initial_count + 1, "User count did not increase"
    |                                                                                         ^^^^^^^^ E501
285 |
286 |             # Verify the new user is in the list
    |

tests\desktop_ui\test_users_and_keyboards.py:337:89: E501 Line too long (89 > 88)
    |
336 |             # Check that the user manager was called to save the user
337 |             assert mock_user_manager.save_user.call_count > 0, "save_user was not called"
    |                                                                                         ^ E501
338 |
339 |             # Make sure we stay at the same index
    |

tests\desktop_ui\test_users_and_keyboards.py:361:89: E501 Line too long (101 > 88)
    |
360 |         # Patch QMessageBox.question to return Yes
361 |         with patch("PySide6.QtWidgets.QMessageBox.question", return_value=QtWidgets.QMessageBox.Yes):
    |                                                                                         ^^^^^^^^^^^^^ E501
362 |             # Click the delete user button
363 |             qtbot.mouseClick(dialog.delete_user_btn, QtCore.Qt.MouseButton.LeftButton)
    |

tests\desktop_ui\test_users_and_keyboards.py:414:89: E501 Line too long (105 > 88)
    |
412 |         # Use a different ID to ensure it's treated as a new keyboard
413 |         new_keyboard = Keyboard(
414 |             keyboard_id="550e8400-e29b-41d4-a716-446655440002",  # Unique ID different from test_keyboard
    |                                                                                         ^^^^^^^^^^^^^^^^^ E501
415 |             user_id=TEST_USER_ID,
416 |             keyboard_name="New Keyboard",
    |

tests\desktop_ui\test_users_and_keyboards.py:465:89: E501 Line too long (90 > 88)
    |
463 |         ):
464 |             # Click the delete keyboard button
465 |             qtbot.mouseClick(dialog.delete_keyboard_btn, QtCore.Qt.MouseButton.LeftButton)
    |                                                                                         ^^ E501
466 |
467 |             # Check that the keyboard manager was called with the correct user ID
    |

tests\helpers\db_helpers.py:4:89: E501 Line too long (92 > 88)
  |
2 | Database testing helpers and fixtures.
3 |
4 | This module provides reusable fixtures and helper functions for testing database operations.
  |                                                                                         ^^^^ E501
5 | It includes fixtures for creating temporary databases and handling database connections.
6 | """
  |

tests\models\conftest.py:24:89: E501 Line too long (95 > 88)
   |
23 | # Removed pytest_plugins as per pytest deprecation warning.
24 | # Fixtures should be imported in the top-level conftest.py or tests/conftest.py for global use.
   |                                                                                         ^^^^^^^ E501
25 | """
26 | Database testing helpers and fixtures.
   |

tests\models\conftest.py:28:89: E501 Line too long (92 > 88)
   |
26 | Database testing helpers and fixtures.
27 |
28 | This module provides reusable fixtures and helper functions for testing database operations.
   |                                                                                         ^^^^ E501
29 | It includes fixtures for creating temporary databases and handling database connections.
30 | """
   |

tests\models\conftest.py:58:89: E501 Line too long (92 > 88)
   |
56 | def db_manager(temp_db: str) -> DatabaseManager:
57 |     """
58 |     Create a DatabaseManager instance with a temporary database using LOCAL connection type.
   |                                                                                         ^^^^ E501
59 |
60 |     Args:
   |

tests\models\conftest.py:226:89: E501 Line too long (92 > 88)
    |
224 |         db.execute(
225 |             """
226 |             INSERT INTO snippets (snippet_id, category_id, title, content, difficulty_level)
    |                                                                                         ^^^^ E501
227 |             VALUES (?, ?, ?, ?, ?)
228 |             """,
    |

tests\models\debug_session_test.py:13:89: E501 Line too long (96 > 88)
   |
12 | def test_debug_all_failing_cases() -> None:
13 |     """Test the specific failing test cases from test_session_creation_and_calculated_fields."""
   |                                                                                         ^^^^^^^^ E501
14 |     test_cases = [
15 |         # Case 1: Long duration, low WPM/CPM, incomplete
   |

tests\models\debug_session_test.py:33:89: E501 Line too long (98 > 88)
   |
31 |                 "total_time": 3600.0,
32 |                 "efficiency": 0.5,
33 |                 "correctness": 0.0,  # (actual_chars - errors) / actual_chars = (50 - 50) / 50 = 0
   |                                                                                         ^^^^^^^^^^ E501
34 |                 "accuracy": 0.0,     # correctness * efficiency = 0.0 * 0.5 = 0.0
35 |                 "session_cpm": 50.0 / 60.0,
   |

tests\models\debug_session_test.py:94:89: E501 Line too long (117 > 88)
   |
92 |                 s = Session.from_dict(case['data'])
93 |                 print("Session created successfully")
94 |                 print(f"expected_chars - Expected: {case['expected']['expected_chars']}, Actual: {s.expected_chars}")
   |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
95 |                 print(f"total_time - Expected: {case['expected']['total_time']}, Actual: {s.total_time}")
96 |                 print(f"efficiency - Expected: {case['expected']['efficiency']}, Actual: {s.efficiency}")
   |

tests\models\debug_session_test.py:95:89: E501 Line too long (105 > 88)
   |
93 |                 print("Session created successfully")
94 |                 print(f"expected_chars - Expected: {case['expected']['expected_chars']}, Actual: {s.expected_chars}")
95 |                 print(f"total_time - Expected: {case['expected']['total_time']}, Actual: {s.total_time}")
   |                                                                                         ^^^^^^^^^^^^^^^^^ E501
96 |                 print(f"efficiency - Expected: {case['expected']['efficiency']}, Actual: {s.efficiency}")
97 |                 print(f"correctness - Expected: {case['expected']['correctness']}, Actual: {s.correctness}")
   |

tests\models\debug_session_test.py:96:89: E501 Line too long (105 > 88)
   |
94 |                 print(f"expected_chars - Expected: {case['expected']['expected_chars']}, Actual: {s.expected_chars}")
95 |                 print(f"total_time - Expected: {case['expected']['total_time']}, Actual: {s.total_time}")
96 |                 print(f"efficiency - Expected: {case['expected']['efficiency']}, Actual: {s.efficiency}")
   |                                                                                         ^^^^^^^^^^^^^^^^^ E501
97 |                 print(f"correctness - Expected: {case['expected']['correctness']}, Actual: {s.correctness}")
98 |                 print(f"accuracy - Expected: {case['expected']['accuracy']}, Actual: {s.accuracy}")
   |

tests\models\debug_session_test.py:97:89: E501 Line too long (108 > 88)
   |
95 |                 print(f"total_time - Expected: {case['expected']['total_time']}, Actual: {s.total_time}")
96 |                 print(f"efficiency - Expected: {case['expected']['efficiency']}, Actual: {s.efficiency}")
97 |                 print(f"correctness - Expected: {case['expected']['correctness']}, Actual: {s.correctness}")
   |                                                                                         ^^^^^^^^^^^^^^^^^^^^ E501
98 |                 print(f"accuracy - Expected: {case['expected']['accuracy']}, Actual: {s.accuracy}")
99 |                 print(f"session_cpm - Expected: {case['expected']['session_cpm']}, Actual: {s.session_cpm}")
   |

tests\models\debug_session_test.py:98:89: E501 Line too long (99 > 88)
    |
 96 |                 print(f"efficiency - Expected: {case['expected']['efficiency']}, Actual: {s.efficiency}")
 97 |                 print(f"correctness - Expected: {case['expected']['correctness']}, Actual: {s.correctness}")
 98 |                 print(f"accuracy - Expected: {case['expected']['accuracy']}, Actual: {s.accuracy}")
    |                                                                                         ^^^^^^^^^^^ E501
 99 |                 print(f"session_cpm - Expected: {case['expected']['session_cpm']}, Actual: {s.session_cpm}")
100 |                 print(f"session_wpm - Expected: {case['expected']['session_wpm']}, Actual: {s.session_wpm}")
    |

tests\models\debug_session_test.py:99:89: E501 Line too long (108 > 88)
    |
 97 |                 print(f"correctness - Expected: {case['expected']['correctness']}, Actual: {s.correctness}")
 98 |                 print(f"accuracy - Expected: {case['expected']['accuracy']}, Actual: {s.accuracy}")
 99 |                 print(f"session_cpm - Expected: {case['expected']['session_cpm']}, Actual: {s.session_cpm}")
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^ E501
100 |                 print(f"session_wpm - Expected: {case['expected']['session_wpm']}, Actual: {s.session_wpm}")
101 |         except Exception as e:
    |

tests\models\debug_session_test.py:100:89: E501 Line too long (108 > 88)
    |
 98 |                 print(f"accuracy - Expected: {case['expected']['accuracy']}, Actual: {s.accuracy}")
 99 |                 print(f"session_cpm - Expected: {case['expected']['session_cpm']}, Actual: {s.session_cpm}")
100 |                 print(f"session_wpm - Expected: {case['expected']['session_wpm']}, Actual: {s.session_wpm}")
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^ E501
101 |         except Exception as e:
102 |             print(f"ERROR: Unexpected exception: {e}")
    |

tests\models\debug_session_tests.py:106:89: E501 Line too long (112 > 88)
    |
104 |     ]
105 |
106 |     for idx, (case_name, overrides, expected_exception_type, expected_exception_match) in enumerate(test_cases):
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^ E501
107 |         print(f"\nTesting case {idx}: {case_name}")
108 |         data = valid_session_dict_fixture.copy()
    |

tests\models\debug_session_tests.py:112:89: E501 Line too long (89 > 88)
    |
111 |         if "snippet_index_end" in overrides and "content" not in overrides:
112 |             start_idx = overrides.get("snippet_index_start", data["snippet_index_start"])
    |                                                                                         ^ E501
113 |             data["content"] = "a" * (overrides["snippet_index_end"] - start_idx)
114 |         elif "content" in overrides and ("snippet_index_start" in data and "snippet_index_end" in data):
    |

tests\models\debug_session_tests.py:114:89: E501 Line too long (104 > 88)
    |
112 |             start_idx = overrides.get("snippet_index_start", data["snippet_index_start"])
113 |             data["content"] = "a" * (overrides["snippet_index_end"] - start_idx)
114 |         elif "content" in overrides and ("snippet_index_start" in data and "snippet_index_end" in data):
    |                                                                                         ^^^^^^^^^^^^^^^^ E501
115 |             data["snippet_index_start"] = 0
116 |             data["snippet_index_end"] = len(str(data["content"]))
    |

tests\models\debug_session_tests.py:119:13: F841 Local variable `s` is assigned to but never used
    |
118 |         try:
119 |             s = Session.from_dict(data)
    |             ^ F841
120 |             print(f"Case {idx} passed successfully")
121 |             if expected_exception_type:
    |
    = help: Remove assignment to unused variable `s`

tests\models\debug_session_tests.py:122:89: E501 Line too long (104 > 88)
    |
120 |             print(f"Case {idx} passed successfully")
121 |             if expected_exception_type:
122 |                 print(f"ERROR: Expected {expected_exception_type.__name__} but no exception was raised")
    |                                                                                         ^^^^^^^^^^^^^^^^ E501
123 |         except Exception as e:
124 |             print(f"Case {idx} failed with: {type(e).__name__}: {str(e)}")
    |

tests\models\debug_session_tests.py:127:89: E501 Line too long (107 > 88)
    |
125 |             if expected_exception_type:
126 |                 if not isinstance(e, expected_exception_type):
127 |                     print(f"ERROR: Expected {expected_exception_type.__name__} but got {type(e).__name__}")
    |                                                                                         ^^^^^^^^^^^^^^^^^^^ E501
128 |                 elif expected_exception_match and expected_exception_match not in str(e):
129 |                     print(f"ERROR: Expected message '{expected_exception_match}' but got '{str(e)}'")
    |

tests\models\debug_session_tests.py:128:89: E501 Line too long (89 > 88)
    |
126 |                 if not isinstance(e, expected_exception_type):
127 |                     print(f"ERROR: Expected {expected_exception_type.__name__} but got {type(e).__name__}")
128 |                 elif expected_exception_match and expected_exception_match not in str(e):
    |                                                                                         ^ E501
129 |                     print(f"ERROR: Expected message '{expected_exception_match}' but got '{str(e)}'")
130 |                 else:
    |

tests\models\debug_session_tests.py:129:89: E501 Line too long (101 > 88)
    |
127 |                     print(f"ERROR: Expected {expected_exception_type.__name__} but got {type(e).__name__}")
128 |                 elif expected_exception_match and expected_exception_match not in str(e):
129 |                     print(f"ERROR: Expected message '{expected_exception_match}' but got '{str(e)}'")
    |                                                                                         ^^^^^^^^^^^^^ E501
130 |                 else:
131 |                     print(f"Case {idx} failed as expected with correct exception")
    |

tests\models\debug_test_snippet_manager.py:11:89: E501 Line too long (121 > 88)
   |
 9 |     # Run the tests with detailed error reporting
10 |     # Run a specific test that might be failing
11 |     test_path = "tests/models/test_snippet_manager.py::TestCreateSnippet::test_create_snippet_pydantic_validation_errors"
   |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
12 |     print(f"\nRunning test: {test_path}\n")
13 |     exit_code = pytest.main([test_path, "-vv"])
   |

tests\models\debug_test_snippet_manager.py:15:89: E501 Line too long (94 > 88)
   |
13 |     exit_code = pytest.main([test_path, "-vv"])
14 |
15 |     print(f"\nTest result: {'PASSED' if exit_code == 0 else f'FAILED with code {exit_code}'}")
   |                                                                                         ^^^^^^ E501
16 |     sys.exit(exit_code)
   |

tests\models\import_test.py:1:89: E501 Line too long (89 > 88)
  |
1 | """Simple import test to verify what's available in the current ngram_analyzer module."""
  |                                                                                         ^ E501
2 | import sys
3 | from pathlib import Path
  |

tests\models\import_test.py:10:39: F401 `models.ngram_analyzer.NGram` imported but unused; consider using `importlib.util.find_spec` to test for availability
   |
 8 | try:
 9 |     # Import and print what's available in the module
10 |     from models.ngram_analyzer import NGram, NGramAnalyzer
   |                                       ^^^^^ F401
11 |
12 |     print("Successfully imported NGramAnalyzer and NGram")
   |
   = help: Remove unused import

tests\models\import_test.py:10:46: F401 `models.ngram_analyzer.NGramAnalyzer` imported but unused; consider using `importlib.util.find_spec` to test for availability
   |
 8 | try:
 9 |     # Import and print what's available in the module
10 |     from models.ngram_analyzer import NGram, NGramAnalyzer
   |                                              ^^^^^^^^^^^^^ F401
11 |
12 |     print("Successfully imported NGramAnalyzer and NGram")
   |
   = help: Remove unused import

tests\models\import_test.py:16:43: F401 `models.ngram_analyzer.NGramStats` imported but unused; consider using `importlib.util.find_spec` to test for availability
   |
14 |     # Try to access the required imports that are failing
15 |     try:
16 |         from models.ngram_analyzer import NGramStats
   |                                           ^^^^^^^^^^ F401
17 |         print("NGramStats exists")
18 |     except ImportError:
   |
   = help: Remove unused import: `models.ngram_analyzer.NGramStats`

tests\models\import_test.py:22:43: F401 `models.ngram_analyzer.Session` imported but unused; consider using `importlib.util.find_spec` to test for availability
   |
21 |     try:
22 |         from models.ngram_analyzer import Session
   |                                           ^^^^^^^ F401
23 |         print("Session exists")
24 |     except ImportError:
   |
   = help: Remove unused import: `models.ngram_analyzer.Session`

tests\models\test_category.py:27:89: E501 Line too long (95 > 88)
   |
25 |         assert cat.category_name == "Valid Name"
26 |
27 |         cat_stripped = Category(category_id=str(uuid.uuid4()), category_name="  Spaced Name  ")
   |                                                                                         ^^^^^^^ E501
28 |         assert cat_stripped.category_name == "Spaced Name"
   |

tests\models\test_category.py:39:89: E501 Line too long (97 > 88)
   |
37 |         ],
38 |     )
39 |     def test_category_name_validation(self, name: str, expected_error_message_part: str) -> None:
   |                                                                                         ^^^^^^^^^ E501
40 |         """
41 |         Test objective: Verify Category model's name validation for format, length, and ASCII.
   |

tests\models\test_category.py:41:89: E501 Line too long (94 > 88)
   |
39 |     def test_category_name_validation(self, name: str, expected_error_message_part: str) -> None:
40 |         """
41 |         Test objective: Verify Category model's name validation for format, length, and ASCII.
   |                                                                                         ^^^^^^ E501
42 |         """
43 |         with pytest.raises(ValidationError) as exc_info:
   |

tests\models\test_category.py:112:89: E501 Line too long (90 > 88)
    |
111 |     def test_category_db_rows_fail_validation(self) -> None:
112 |         """Test that current DB rows would fail Pydantic validation (simulate DB load)."""
    |                                                                                         ^^ E501
113 |         # These are the actual rows from the current categories table
114 |         db_rows = [
    |

tests\models\test_category_manager.py:6:1: I001 [*] Import block is un-sorted or un-formatted
   |
 4 |   """
 5 |
 6 | / import uuid
 7 | |
 8 | | import pytest
 9 | | from pydantic import ValidationError
10 | |
11 | | from db.database_manager import DatabaseManager
12 | | from models.category import Category
13 | | from models.category_manager import CategoryManager, CategoryNotFound, CategoryValidationError
14 | | from models.snippet import Snippet
15 | | from models.snippet_manager import SnippetManager
   | |_________________________________________________^ I001
   |
   = help: Organize imports

tests\models\test_category_manager.py:13:89: E501 Line too long (94 > 88)
   |
11 | from db.database_manager import DatabaseManager
12 | from models.category import Category
13 | from models.category_manager import CategoryManager, CategoryNotFound, CategoryValidationError
   |                                                                                         ^^^^^^ E501
14 | from models.snippet import Snippet
15 | from models.snippet_manager import SnippetManager
   |

tests\models\test_category_manager.py:69:89: E501 Line too long (89 > 88)
   |
67 |         assert err_msg_part.lower() in str(e.value).lower()
68 |
69 |     def test_create_category_duplicate_name(self, category_mgr: CategoryManager) -> None:
   |                                                                                         ^ E501
70 |         """
71 |         Test objective: Attempt to create a category with a duplicate name.
   |

tests\models\test_category_manager.py:98:89: E501 Line too long (90 > 88)
    |
 96 |             category_mgr.get_category_by_id(str(uuid.uuid4()))
 97 |
 98 |     def test_get_category_by_id_invalid_uuid(self, category_mgr: CategoryManager) -> None:
    |                                                                                         ^^ E501
 99 |         """
100 |         Test objective: Attempt to retrieve a category with an invalid (non-UUID) ID string.
    |

tests\models\test_category_manager.py:100:89: E501 Line too long (92 > 88)
    |
 98 |     def test_get_category_by_id_invalid_uuid(self, category_mgr: CategoryManager) -> None:
 99 |         """
100 |         Test objective: Attempt to retrieve a category with an invalid (non-UUID) ID string.
    |                                                                                         ^^^^ E501
101 |         """
102 |         with pytest.raises(CategoryNotFound):
    |

tests\models\test_category_manager.py:117:89: E501 Line too long (89 > 88)
    |
115 |         assert retrieved_cat.category_name == cat_name
116 |
117 |     def test_get_category_by_name_not_found(self, category_mgr: CategoryManager) -> None:
    |                                                                                         ^ E501
118 |         """
119 |         Test objective: Attempt to retrieve a non-existent category by name.
    |

tests\models\test_category_manager.py:124:89: E501 Line too long (94 > 88)
    |
122 |             category_mgr.get_category_by_name("NonExistent Name")
123 |
124 |     def test_get_category_by_name_case_sensitive(self, category_mgr: CategoryManager) -> None:
    |                                                                                         ^^^^^^ E501
125 |         """
126 |         Test objective: Verify category name retrieval is case-sensitive.
    |

tests\models\test_category_manager.py:183:89: E501 Line too long (90 > 88)
    |
181 |     ) -> None:
182 |         """
183 |         Test objective: Attempt to update a category with an invalid new name format using
    |                                                                                         ^^ E501
184 |         save_category.
185 |         """
    |

tests\models\test_category_manager.py:193:89: E501 Line too long (92 > 88)
    |
191 |         assert err_msg_part.lower() in str(e.value).lower()
192 |
193 |     def test_update_category_to_duplicate_name(self, category_mgr: CategoryManager) -> None:
    |                                                                                         ^^^^ E501
194 |         """
195 |         Test objective: Attempt to update a category name to an existing different category's name
    |

tests\models\test_category_manager.py:195:89: E501 Line too long (98 > 88)
    |
193 |     def test_update_category_to_duplicate_name(self, category_mgr: CategoryManager) -> None:
194 |         """
195 |         Test objective: Attempt to update a category name to an existing different category's name
    |                                                                                         ^^^^^^^^^^ E501
196 |         using save_category.
197 |         """
    |

tests\models\test_category_manager.py:207:89: E501 Line too long (100 > 88)
    |
205 |         assert "must be unique" in str(e.value).lower()
206 |
207 |     def test_update_category_to_case_variant_duplicate(self, category_mgr: CategoryManager) -> None:
    |                                                                                         ^^^^^^^^^^^^ E501
208 |         """
209 |         Test objective: Attempt to update a category name to a case-variant of an existing name
    |

tests\models\test_category_manager.py:209:89: E501 Line too long (95 > 88)
    |
207 |     def test_update_category_to_case_variant_duplicate(self, category_mgr: CategoryManager) -> None:
208 |         """
209 |         Test objective: Attempt to update a category name to a case-variant of an existing name
    |                                                                                         ^^^^^^^ E501
210 |         using save_category.
211 |         """
    |

tests\models\test_category_manager.py:247:89: E501 Line too long (93 > 88)
    |
245 |             category_mgr.get_category_by_id(str(category.category_id))
246 |
247 |     def test_delete_category_by_id_invalid_uuid(self, category_mgr: CategoryManager) -> None:
    |                                                                                         ^^^^^ E501
248 |         """
249 |         Test objective: Attempt to delete a category with an invalid (non-UUID) ID string.
    |

tests\models\test_category_manager.py:249:89: E501 Line too long (90 > 88)
    |
247 |     def test_delete_category_by_id_invalid_uuid(self, category_mgr: CategoryManager) -> None:
248 |         """
249 |         Test objective: Attempt to delete a category with an invalid (non-UUID) ID string.
    |                                                                                         ^^ E501
250 |         """
251 |         assert category_mgr.delete_category_by_id("not-a-uuid") is False
    |

tests\models\test_category_manager.py:275:89: E501 Line too long (92 > 88)
    |
273 |     ) -> None:
274 |         """
275 |         Test objective: Verify that deleting a category also deletes associated snippets and
    |                                                                                         ^^^^ E501
276 |         snippet_parts.
277 |         """
    |

tests\models\test_category_manager.py:304:89: E501 Line too long (98 > 88)
    |
302 |             snippet_mgr.get_snippet_by_id(str(snippet.snippet_id))
303 |
304 |     def test_category_validation_blank_and_duplicate(self, category_mgr: CategoryManager) -> None:
    |                                                                                         ^^^^^^^^^^ E501
305 |         """
306 |         Test objective: Destructively test blank and duplicate category names.
    |

tests\models\test_dynamic_content_manager.py:6:1: I001 [*] Import block is un-sorted or un-formatted
   |
 4 |   """
 5 |
 6 | / import pytest
 7 | | import random
 8 | | from unittest.mock import MagicMock, patch
 9 | | from typing import List, Optional
10 | |
11 | | from models.dynamic_content_manager import DynamicContentManager, ContentMode
12 | | from models.llm_ngram_service import LLMNgramService
   | |____________________________________________________^ I001
   |
   = help: Organize imports

tests\models\test_dynamic_content_manager.py:8:27: F401 [*] `unittest.mock.MagicMock` imported but unused
  |
6 | import pytest
7 | import random
8 | from unittest.mock import MagicMock, patch
  |                           ^^^^^^^^^ F401
9 | from typing import List, Optional
  |
  = help: Remove unused import: `unittest.mock.MagicMock`

tests\models\test_dynamic_content_manager.py:9:26: F401 [*] `typing.Optional` imported but unused
   |
 7 | import random
 8 | from unittest.mock import MagicMock, patch
 9 | from typing import List, Optional
   |                          ^^^^^^^^ F401
10 |
11 | from models.dynamic_content_manager import DynamicContentManager, ContentMode
   |
   = help: Remove unused import: `typing.Optional`

tests\models\test_dynamic_content_manager.py:12:38: F401 [*] `models.llm_ngram_service.LLMNgramService` imported but unused
   |
11 | from models.dynamic_content_manager import DynamicContentManager, ContentMode
12 | from models.llm_ngram_service import LLMNgramService
   |                                      ^^^^^^^^^^^^^^^ F401
   |
   = help: Remove unused import: `models.llm_ngram_service.LLMNgramService`

tests\models\test_dynamic_content_manager.py:39:5: ANN201 Missing return type annotation for public function `mock_llm_service`
   |
38 | @pytest.fixture
39 | def mock_llm_service():
   |     ^^^^^^^^^^^^^^^^ ANN201
40 |     """Fixture providing a mock LLM service."""
41 |     return MockLLMNgramService()
   |
   = help: Add return type annotation

tests\models\test_dynamic_content_manager.py:45:5: ANN201 Missing return type annotation for public function `basic_manager`
   |
44 | @pytest.fixture
45 | def basic_manager(mock_llm_service):
   |     ^^^^^^^^^^^^^ ANN201
46 |     """Fixture providing a basic DynamicContentManager instance."""
47 |     return DynamicContentManager(
   |
   = help: Add return type annotation

tests\models\test_dynamic_content_manager.py:45:19: ANN001 Missing type annotation for function argument `mock_llm_service`
   |
44 | @pytest.fixture
45 | def basic_manager(mock_llm_service):
   |                   ^^^^^^^^^^^^^^^^ ANN001
46 |     """Fixture providing a basic DynamicContentManager instance."""
47 |     return DynamicContentManager(
   |

tests\models\test_dynamic_content_manager.py:59:9: ANN201 Missing return type annotation for public function `test_init_with_valid_params`
   |
57 |     """Test suite for DynamicContentManager initialization and validation."""
58 |
59 |     def test_init_with_valid_params(self):
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
60 |         """Test initializing with valid parameters."""
61 |         manager = DynamicContentManager(
   |
   = help: Add return type annotation: `None`

tests\models\test_dynamic_content_manager.py:73:9: ANN201 Missing return type annotation for public function `test_init_with_defaults`
   |
71 |         assert manager.mode == ContentMode.NGRAM_ONLY
72 |
73 |     def test_init_with_defaults(self):
   |         ^^^^^^^^^^^^^^^^^^^^^^^ ANN201
74 |         """Test initialization with default values."""
75 |         manager = DynamicContentManager()
   |
   = help: Add return type annotation: `None`

tests\models\test_dynamic_content_manager.py:83:9: ANN201 Missing return type annotation for public function `test_invalid_practice_length_too_small`
   |
81 |         assert manager.llm_service is None
82 |
83 |     def test_invalid_practice_length_too_small(self):
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
84 |         """Test validation of practice length (too small)."""
85 |         with pytest.raises(ValueError, match="Practice length must be between 1 and 1000"):
   |
   = help: Add return type annotation: `None`

tests\models\test_dynamic_content_manager.py:85:89: E501 Line too long (91 > 88)
   |
83 |     def test_invalid_practice_length_too_small(self):
84 |         """Test validation of practice length (too small)."""
85 |         with pytest.raises(ValueError, match="Practice length must be between 1 and 1000"):
   |                                                                                         ^^^ E501
86 |             DynamicContentManager(practice_length=0)
   |

tests\models\test_dynamic_content_manager.py:88:9: ANN201 Missing return type annotation for public function `test_invalid_practice_length_too_large`
   |
86 |             DynamicContentManager(practice_length=0)
87 |
88 |     def test_invalid_practice_length_too_large(self):
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
89 |         """Test validation of practice length (too large)."""
90 |         with pytest.raises(ValueError, match="Practice length must be between 1 and 1000"):
   |
   = help: Add return type annotation: `None`

tests\models\test_dynamic_content_manager.py:90:89: E501 Line too long (91 > 88)
   |
88 |     def test_invalid_practice_length_too_large(self):
89 |         """Test validation of practice length (too large)."""
90 |         with pytest.raises(ValueError, match="Practice length must be between 1 and 1000"):
   |                                                                                         ^^^ E501
91 |             DynamicContentManager(practice_length=1001)
   |

tests\models\test_dynamic_content_manager.py:93:9: ANN201 Missing return type annotation for public function `test_invalid_practice_length_type`
   |
91 |             DynamicContentManager(practice_length=1001)
92 |
93 |     def test_invalid_practice_length_type(self):
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
94 |         """Test validation of practice length with non-integer value."""
95 |         with pytest.raises(ValueError, match="Practice length must be an integer"):
   |
   = help: Add return type annotation: `None`

tests\models\test_dynamic_content_manager.py:98:9: ANN201 Missing return type annotation for public function `test_mode_setter_with_string`
    |
 96 |             DynamicContentManager(practice_length="50")  # type: ignore
 97 |
 98 |     def test_mode_setter_with_string(self):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
 99 |         """Test setting mode with a string value."""
100 |         manager = DynamicContentManager()
    |
    = help: Add return type annotation: `None`

tests\models\test_dynamic_content_manager.py:104:9: ANN201 Missing return type annotation for public function `test_mode_setter_with_invalid_string`
    |
102 |         assert manager.mode == ContentMode.NGRAM_ONLY
103 |
104 |     def test_mode_setter_with_invalid_string(self):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
105 |         """Test setting mode with an invalid string value."""
106 |         manager = DynamicContentManager()
    |
    = help: Add return type annotation: `None`

tests\models\test_dynamic_content_manager.py:110:9: ANN201 Missing return type annotation for public function `test_mode_setter_with_enum`
    |
108 |             manager.mode = "InvalidMode"
109 |
110 |     def test_mode_setter_with_enum(self):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
111 |         """Test setting mode with ContentMode enum."""
112 |         manager = DynamicContentManager()
    |
    = help: Add return type annotation: `None`

tests\models\test_dynamic_content_manager.py:120:9: ANN201 Missing return type annotation for public function `test_validate_missing_ngrams`
    |
118 |     """Tests for validation of requirements before content generation."""
119 |
120 |     def test_validate_missing_ngrams(self, basic_manager):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
121 |         """Test validation with missing ngram focus list."""
122 |         basic_manager.ngram_focus_list = []
    |
    = help: Add return type annotation: `None`

tests\models\test_dynamic_content_manager.py:120:44: ANN001 Missing type annotation for function argument `basic_manager`
    |
118 |     """Tests for validation of requirements before content generation."""
119 |
120 |     def test_validate_missing_ngrams(self, basic_manager):
    |                                            ^^^^^^^^^^^^^ ANN001
121 |         """Test validation with missing ngram focus list."""
122 |         basic_manager.ngram_focus_list = []
    |

tests\models\test_dynamic_content_manager.py:126:9: ANN201 Missing return type annotation for public function `test_validate_missing_in_scope_keys`
    |
124 |             basic_manager.generate_content()
125 |
126 |     def test_validate_missing_in_scope_keys(self, basic_manager):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
127 |         """Test validation with missing in-scope keys."""
128 |         basic_manager.in_scope_keys = []
    |
    = help: Add return type annotation: `None`

tests\models\test_dynamic_content_manager.py:126:51: ANN001 Missing type annotation for function argument `basic_manager`
    |
124 |             basic_manager.generate_content()
125 |
126 |     def test_validate_missing_in_scope_keys(self, basic_manager):
    |                                                   ^^^^^^^^^^^^^ ANN001
127 |         """Test validation with missing in-scope keys."""
128 |         basic_manager.in_scope_keys = []
    |

tests\models\test_dynamic_content_manager.py:132:9: ANN201 Missing return type annotation for public function `test_validate_missing_llm_service_for_words_mode`
    |
130 |             basic_manager.generate_content()
131 |
132 |     def test_validate_missing_llm_service_for_words_mode(self):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
133 |         """Test validation for missing LLM service in WordsOnly mode."""
134 |         manager = DynamicContentManager(
    |
    = help: Add return type annotation: `None`

tests\models\test_dynamic_content_manager.py:140:89: E501 Line too long (102 > 88)
    |
138 |         )
139 |
140 |         with pytest.raises(ValueError, match="LLM service is required for WordsOnly and Mixed modes"):
    |                                                                                         ^^^^^^^^^^^^^^ E501
141 |             manager.generate_content()
    |

tests\models\test_dynamic_content_manager.py:143:9: ANN201 Missing return type annotation for public function `test_validate_missing_llm_service_for_mixed_mode`
    |
141 |             manager.generate_content()
142 |
143 |     def test_validate_missing_llm_service_for_mixed_mode(self):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
144 |         """Test validation for missing LLM service in Mixed mode."""
145 |         manager = DynamicContentManager(
    |
    = help: Add return type annotation: `None`

tests\models\test_dynamic_content_manager.py:151:89: E501 Line too long (102 > 88)
    |
149 |         )
150 |
151 |         with pytest.raises(ValueError, match="LLM service is required for WordsOnly and Mixed modes"):
    |                                                                                         ^^^^^^^^^^^^^^ E501
152 |             manager.generate_content()
    |

tests\models\test_dynamic_content_manager.py:158:9: ANN201 Missing return type annotation for public function `test_generate_ngram_content`
    |
156 |     """Tests for NGramOnly content generation mode."""
157 |
158 |     def test_generate_ngram_content(self, basic_manager):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
159 |         """Test generating content with NGramOnly mode."""
160 |         basic_manager.mode = ContentMode.NGRAM_ONLY
    |
    = help: Add return type annotation: `None`

tests\models\test_dynamic_content_manager.py:158:43: ANN001 Missing type annotation for function argument `basic_manager`
    |
156 |     """Tests for NGramOnly content generation mode."""
157 |
158 |     def test_generate_ngram_content(self, basic_manager):
    |                                           ^^^^^^^^^^^^^ ANN001
159 |         """Test generating content with NGramOnly mode."""
160 |         basic_manager.mode = ContentMode.NGRAM_ONLY
    |

tests\models\test_dynamic_content_manager.py:165:89: E501 Line too long (105 > 88)
    |
163 |         # Verify content format and constraints
164 |         assert content, "Content should not be empty"
165 |         assert len(content) <= basic_manager.practice_length, "Content should not exceed practice length"
    |                                                                                         ^^^^^^^^^^^^^^^^^ E501
166 |
167 |         # Verify content only contains ngrams from focus list
    |

tests\models\test_dynamic_content_manager.py:170:89: E501 Line too long (105 > 88)
    |
168 |         parts = content.split()
169 |         for part in parts:
170 |             assert part in basic_manager.ngram_focus_list, f"Part '{part}' should be in ngram focus list"
    |                                                                                         ^^^^^^^^^^^^^^^^^ E501
171 |
172 |     def test_ngram_content_custom_delimiter(self, basic_manager):
    |

tests\models\test_dynamic_content_manager.py:172:9: ANN201 Missing return type annotation for public function `test_ngram_content_custom_delimiter`
    |
170 |             assert part in basic_manager.ngram_focus_list, f"Part '{part}' should be in ngram focus list"
171 |
172 |     def test_ngram_content_custom_delimiter(self, basic_manager):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
173 |         """Test generating NGramOnly content with custom delimiter."""
174 |         basic_manager.mode = ContentMode.NGRAM_ONLY
    |
    = help: Add return type annotation: `None`

tests\models\test_dynamic_content_manager.py:172:51: ANN001 Missing type annotation for function argument `basic_manager`
    |
170 |             assert part in basic_manager.ngram_focus_list, f"Part '{part}' should be in ngram focus list"
171 |
172 |     def test_ngram_content_custom_delimiter(self, basic_manager):
    |                                                   ^^^^^^^^^^^^^ ANN001
173 |         """Test generating NGramOnly content with custom delimiter."""
174 |         basic_manager.mode = ContentMode.NGRAM_ONLY
    |

tests\models\test_dynamic_content_manager.py:181:89: E501 Line too long (94 > 88)
    |
179 |         if delimiter in content:
180 |             parts = content.split(delimiter)
181 |             assert len(parts) > 1, "Content should have multiple parts separated by delimiter"
    |                                                                                         ^^^^^^ E501
182 |
183 |     def test_ngram_content_respects_length_limit(self, basic_manager):
    |

tests\models\test_dynamic_content_manager.py:183:9: ANN201 Missing return type annotation for public function `test_ngram_content_respects_length_limit`
    |
181 |             assert len(parts) > 1, "Content should have multiple parts separated by delimiter"
182 |
183 |     def test_ngram_content_respects_length_limit(self, basic_manager):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
184 |         """Test NGramOnly content respects the practice length limit."""
185 |         basic_manager.mode = ContentMode.NGRAM_ONLY
    |
    = help: Add return type annotation: `None`

tests\models\test_dynamic_content_manager.py:183:56: ANN001 Missing type annotation for function argument `basic_manager`
    |
181 |             assert len(parts) > 1, "Content should have multiple parts separated by delimiter"
182 |
183 |     def test_ngram_content_respects_length_limit(self, basic_manager):
    |                                                        ^^^^^^^^^^^^^ ANN001
184 |         """Test NGramOnly content respects the practice length limit."""
185 |         basic_manager.mode = ContentMode.NGRAM_ONLY
    |

tests\models\test_dynamic_content_manager.py:191:9: ANN201 Missing return type annotation for public function `test_ngram_content_filters_out_of_scope_chars`
    |
189 |         assert len(content) <= 10, "Content length should not exceed practice_length"
190 |
191 |     def test_ngram_content_filters_out_of_scope_chars(self):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
192 |         """Test that NGramOnly content filters out ngrams with out-of-scope characters."""
193 |         manager = DynamicContentManager(
    |
    = help: Add return type annotation: `None`

tests\models\test_dynamic_content_manager.py:192:89: E501 Line too long (90 > 88)
    |
191 |     def test_ngram_content_filters_out_of_scope_chars(self):
192 |         """Test that NGramOnly content filters out ngrams with out-of-scope characters."""
    |                                                                                         ^^ E501
193 |         manager = DynamicContentManager(
194 |             in_scope_keys=["a", "b"],
    |

tests\models\test_dynamic_content_manager.py:202:89: E501 Line too long (104 > 88)
    |
201 |         # Content should only include "ab"
202 |         assert content == "ab" or content == "", "Content should only include ngrams with in-scope keys"
    |                                                                                         ^^^^^^^^^^^^^^^^ E501
    |

tests\models\test_dynamic_content_manager.py:208:9: ANN201 Missing return type annotation for public function `test_generate_words_content`
    |
206 |     """Tests for WordsOnly content generation mode."""
207 |
208 |     def test_generate_words_content(self, basic_manager):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
209 |         """Test generating content with WordsOnly mode."""
210 |         basic_manager.mode = ContentMode.WORDS_ONLY
    |
    = help: Add return type annotation: `None`

tests\models\test_dynamic_content_manager.py:208:43: ANN001 Missing type annotation for function argument `basic_manager`
    |
206 |     """Tests for WordsOnly content generation mode."""
207 |
208 |     def test_generate_words_content(self, basic_manager):
    |                                           ^^^^^^^^^^^^^ ANN001
209 |         """Test generating content with WordsOnly mode."""
210 |         basic_manager.mode = ContentMode.WORDS_ONLY
    |

tests\models\test_dynamic_content_manager.py:217:89: E501 Line too long (105 > 88)
    |
215 |         # Verify content format and constraints
216 |         assert content, "Content should not be empty"
217 |         assert len(content) <= basic_manager.practice_length, "Content should not exceed practice length"
    |                                                                                         ^^^^^^^^^^^^^^^^^ E501
218 |
219 |         # Verify content contains words with the ngrams
    |

tests\models\test_dynamic_content_manager.py:229:9: ANN201 Missing return type annotation for public function `test_words_content_filters_out_of_scope_chars`
    |
227 |         assert ngram_found, "Content should include words containing the ngrams"
228 |
229 |     def test_words_content_filters_out_of_scope_chars(self, mock_llm_service):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
230 |         """Test that WordsOnly content filters out words with out-of-scope characters."""
231 |         # Create a custom mock that returns words with both in-scope and out-of-scope characters
    |
    = help: Add return type annotation: `None`

tests\models\test_dynamic_content_manager.py:229:61: ANN001 Missing type annotation for function argument `mock_llm_service`
    |
227 |         assert ngram_found, "Content should include words containing the ngrams"
228 |
229 |     def test_words_content_filters_out_of_scope_chars(self, mock_llm_service):
    |                                                             ^^^^^^^^^^^^^^^^ ANN001
230 |         """Test that WordsOnly content filters out words with out-of-scope characters."""
231 |         # Create a custom mock that returns words with both in-scope and out-of-scope characters
    |

tests\models\test_dynamic_content_manager.py:230:89: E501 Line too long (89 > 88)
    |
229 |     def test_words_content_filters_out_of_scope_chars(self, mock_llm_service):
230 |         """Test that WordsOnly content filters out words with out-of-scope characters."""
    |                                                                                         ^ E501
231 |         # Create a custom mock that returns words with both in-scope and out-of-scope characters
232 |         custom_mock = MockLLMNgramService()
    |

tests\models\test_dynamic_content_manager.py:231:89: E501 Line too long (96 > 88)
    |
229 |     def test_words_content_filters_out_of_scope_chars(self, mock_llm_service):
230 |         """Test that WordsOnly content filters out words with out-of-scope characters."""
231 |         # Create a custom mock that returns words with both in-scope and out-of-scope characters
    |                                                                                         ^^^^^^^^ E501
232 |         custom_mock = MockLLMNgramService()
    |

tests\models\test_dynamic_content_manager.py:252:9: ANN201 Missing return type annotation for public function `test_words_content_custom_delimiter`
    |
250 |                     f"Word '{word}' contains out-of-scope characters"
251 |
252 |     def test_words_content_custom_delimiter(self, basic_manager):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
253 |         """Test generating WordsOnly content with custom delimiter."""
254 |         basic_manager.mode = ContentMode.WORDS_ONLY
    |
    = help: Add return type annotation: `None`

tests\models\test_dynamic_content_manager.py:252:51: ANN001 Missing type annotation for function argument `basic_manager`
    |
250 |                     f"Word '{word}' contains out-of-scope characters"
251 |
252 |     def test_words_content_custom_delimiter(self, basic_manager):
    |                                                   ^^^^^^^^^^^^^ ANN001
253 |         """Test generating WordsOnly content with custom delimiter."""
254 |         basic_manager.mode = ContentMode.WORDS_ONLY
    |

tests\models\test_dynamic_content_manager.py:261:89: E501 Line too long (94 > 88)
    |
259 |         if delimiter in content:
260 |             parts = content.split(delimiter)
261 |             assert len(parts) > 1, "Content should have multiple parts separated by delimiter"
    |                                                                                         ^^^^^^ E501
    |

tests\models\test_dynamic_content_manager.py:267:9: ANN201 Missing return type annotation for public function `test_generate_mixed_content`
    |
265 |     """Tests for Mixed content generation mode."""
266 |
267 |     def test_generate_mixed_content(self, basic_manager):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
268 |         """Test generating content with Mixed mode."""
269 |         basic_manager.mode = ContentMode.MIXED
    |
    = help: Add return type annotation: `None`

tests\models\test_dynamic_content_manager.py:267:43: ANN001 Missing type annotation for function argument `basic_manager`
    |
265 |     """Tests for Mixed content generation mode."""
266 |
267 |     def test_generate_mixed_content(self, basic_manager):
    |                                           ^^^^^^^^^^^^^ ANN001
268 |         """Test generating content with Mixed mode."""
269 |         basic_manager.mode = ContentMode.MIXED
    |

tests\models\test_dynamic_content_manager.py:277:89: E501 Line too long (105 > 88)
    |
275 |         # Verify content format and constraints
276 |         assert content, "Content should not be empty"
277 |         assert len(content) <= basic_manager.practice_length, "Content should not exceed practice length"
    |                                                                                         ^^^^^^^^^^^^^^^^^ E501
278 |
279 |     def test_mixed_content_has_variety(self, basic_manager):
    |

tests\models\test_dynamic_content_manager.py:279:9: ANN201 Missing return type annotation for public function `test_mixed_content_has_variety`
    |
277 |         assert len(content) <= basic_manager.practice_length, "Content should not exceed practice length"
278 |
279 |     def test_mixed_content_has_variety(self, basic_manager):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
280 |         """Test that Mixed content includes both ngrams and words."""
281 |         # This test is a bit tricky since the mixed content is randomized
    |
    = help: Add return type annotation: `None`

tests\models\test_dynamic_content_manager.py:279:46: ANN001 Missing type annotation for function argument `basic_manager`
    |
277 |         assert len(content) <= basic_manager.practice_length, "Content should not exceed practice length"
278 |
279 |     def test_mixed_content_has_variety(self, basic_manager):
    |                                              ^^^^^^^^^^^^^ ANN001
280 |         """Test that Mixed content includes both ngrams and words."""
281 |         # This test is a bit tricky since the mixed content is randomized
    |

tests\models\test_keyboard.py:26:89: E501 Line too long (90 > 88)
   |
25 | def test_keyboard_name_strip() -> None:
26 |     k = Keyboard(keyboard_id=str(uuid4()), user_id=str(uuid4()), keyboard_name="  Test  ")
   |                                                                                         ^^ E501
27 |     assert k.keyboard_name == "Test"
   |

tests\models\test_keyboard.py:56:89: E501 Line too long (96 > 88)
   |
54 |             target_ms_per_keystroke=49,
55 |         )
56 |     assert "Target milliseconds per keystroke must be between 50 and 5000" in str(excinfo.value)
   |                                                                                         ^^^^^^^^ E501
   |

tests\models\test_keyboard.py:68:89: E501 Line too long (96 > 88)
   |
66 |             target_ms_per_keystroke=5001,
67 |         )
68 |     assert "Target milliseconds per keystroke must be between 50 and 5000" in str(excinfo.value)
   |                                                                                         ^^^^^^^^ E501
   |

tests\models\test_keyboard.py:73:44: F841 Local variable `excinfo` is assigned to but never used
   |
71 | def test_keyboard_target_ms_none() -> None:
72 |     # Test that validator rejects None values
73 |     with pytest.raises(ValidationError) as excinfo:
   |                                            ^^^^^^^ F841
74 |         # We need to use a dict and model_validate to bypass Pydantic's type checking
75 |         # and test our explicit None validator
   |
   = help: Remove assignment to unused variable `excinfo`

tests\models\test_keyboard_manager.py:1:1: I001 [*] Import block is un-sorted or un-formatted
  |
1 | / import pytest
2 | | from pydantic import ValidationError
3 | |
4 | | from db.database_manager import DatabaseManager
5 | | from models.keyboard import Keyboard
6 | | from models.keyboard_manager import KeyboardManager, KeyboardNotFound, KeyboardValidationError
7 | | from models.user import User
  | |____________________________^ I001
  |
  = help: Organize imports

tests\models\test_keyboard_manager.py:6:89: E501 Line too long (94 > 88)
  |
4 | from db.database_manager import DatabaseManager
5 | from models.keyboard import Keyboard
6 | from models.keyboard_manager import KeyboardManager, KeyboardNotFound, KeyboardValidationError
  |                                                                                         ^^^^^^ E501
7 | from models.user import User
  |

tests\models\test_keyboard_manager.py:32:89: E501 Line too long (90 > 88)
   |
32 | def test_update_keyboard_name(keyboard_manager: KeyboardManager, test_user: User) -> None:
   |                                                                                         ^^ E501
33 |     k = Keyboard(user_id=str(test_user.user_id), keyboard_name="Gamma")
34 |     keyboard_manager.save_keyboard(k)
   |

tests\models\test_keyboard_manager.py:47:89: E501 Line too long (98 > 88)
   |
47 | def test_update_keyboard_target_speed(keyboard_manager: KeyboardManager, test_user: User) -> None:
   |                                                                                         ^^^^^^^^^^ E501
48 |     """Test updating the target_ms_per_keystroke field."""
49 |     # Create keyboard with default target speed (100)
   |

tests\models\test_keystroke.py:40:89: E501 Line too long (100 > 88)
   |
38 |     """Test Keystroke model creation and validation."""
39 |
40 |     def test_keystroke_creation_with_valid_data(self, valid_keystroke_data: Dict[str, Any]) -> None:
   |                                                                                         ^^^^^^^^^^^^ E501
41 |         """Test creating a Keystroke with valid data."""
42 |         keystroke = Keystroke(**valid_keystroke_data)
   |

tests\models\test_keystroke.py:47:89: E501 Line too long (91 > 88)
   |
45 |         assert keystroke.expected_char == valid_keystroke_data["expected_char"]
46 |         assert keystroke.is_error == valid_keystroke_data["is_error"]
47 |         assert keystroke.time_since_previous == valid_keystroke_data["time_since_previous"]
   |                                                                                         ^^^ E501
48 |
49 |     def test_keystroke_creation_with_defaults(self) -> None:
   |

tests\models\test_keystroke.py:92:89: E501 Line too long (91 > 88)
   |
90 |     """Test Keystroke.from_dict method for various data types and edge cases."""
91 |
92 |     def test_from_dict_with_valid_data(self, valid_keystroke_data: Dict[str, Any]) -> None:
   |                                                                                         ^^^ E501
93 |         """Test from_dict with completely valid data."""
94 |         keystroke = Keystroke.from_dict(valid_keystroke_data)
   |

tests\models\test_keystroke.py:131:89: E501 Line too long (98 > 88)
    |
129 |     def test_from_dict_invalid_datetime_string(self) -> None:
130 |         """Test from_dict with invalid datetime string falls back to current time."""
131 |         data = {"keystroke_time": "not-a-valid-date", "keystroke_char": "z", "expected_char": "z"}
    |                                                                                         ^^^^^^^^^^ E501
132 |         before = datetime.datetime.now()
133 |         keystroke = Keystroke.from_dict(data)
    |

tests\models\test_keystroke.py:164:89: E501 Line too long (94 > 88)
    |
162 |         ],
163 |     )
164 |     def test_from_dict_is_error_string_values(self, error_value: str, expected: bool) -> None:
    |                                                                                         ^^^^^^ E501
165 |         """Test from_dict with various string values for is_error."""
166 |         data = {"is_error": error_value, "keystroke_char": "a", "expected_char": "a"}
    |

tests\models\test_keystroke.py:179:89: E501 Line too long (95 > 88)
    |
177 |         ],
178 |     )
179 |     def test_from_dict_is_error_integer_values(self, error_value: int, expected: bool) -> None:
    |                                                                                         ^^^^^^^ E501
180 |         """Test from_dict with integer values for is_error."""
181 |         data = {"is_error": error_value, "keystroke_char": "a", "expected_char": "a"}
    |

tests\models\test_keystroke.py:199:89: E501 Line too long (97 > 88)
    |
197 |     def test_from_dict_session_id_invalid_conversion(self) -> None:
198 |         """Test from_dict handles invalid session_id conversion gracefully."""
199 |         data = {"session_id": {"invalid": "object"}, "keystroke_char": "a", "expected_char": "a"}
    |                                                                                         ^^^^^^^^^ E501
200 |         keystroke = Keystroke.from_dict(data)
201 |         assert keystroke.session_id is None
    |

tests\models\test_keystroke.py:211:89: E501 Line too long (99 > 88)
    |
209 |     def test_from_dict_keystroke_id_invalid_conversion(self) -> None:
210 |         """Test from_dict handles invalid keystroke_id conversion gracefully."""
211 |         data = {"keystroke_id": {"invalid": "object"}, "keystroke_char": "a", "expected_char": "a"}
    |                                                                                         ^^^^^^^^^^^ E501
212 |         keystroke = Keystroke.from_dict(data)
213 |         # Should fallback to a UUID string
    |

tests\models\test_keystroke.py:255:89: E501 Line too long (91 > 88)
    |
253 |     def test_to_dict_with_none_values(self) -> None:
254 |         """Test to_dict with None values."""
255 |         keystroke = Keystroke(session_id=None, keystroke_id=None, time_since_previous=None)
    |                                                                                         ^^^ E501
256 |         result = keystroke.to_dict()
257 |         assert result["session_id"] is None
    |

tests\models\test_keystroke_manager.py:6:89: E501 Line too long (89 > 88)
  |
4 | This module provides extensive test coverage for the KeystrokeManager class,
5 | including all methods, edge cases, error conditions, and integration scenarios.
6 | Tests aim for >95% coverage and validate the manager's behavior under various conditions.
  |                                                                                         ^ E501
7 | """
  |

tests\models\test_keystroke_manager.py:140:89: E501 Line too long (92 > 88)
    |
138 |         """Test successful retrieval of keystrokes for a session."""
139 |         session_id = "test-session-456"
140 |         mock_keystrokes = [Mock(spec=Keystroke), Mock(spec=Keystroke), Mock(spec=Keystroke)]
    |                                                                                         ^^^^ E501
141 |         mock_get_for_session.return_value = mock_keystrokes
    |

tests\models\test_keystroke_manager.py:256:89: E501 Line too long (94 > 88)
    |
254 |             assert params[6] == sample_keystrokes[i].time_since_previous
255 |
256 |     def test_save_keystrokes_empty_list(self, manager_with_mock_db: KeystrokeManager) -> None:
    |                                                                                         ^^^^^^ E501
257 |         """Test saving when keystroke list is empty."""
258 |         manager_with_mock_db.keystroke_list = []
    |

tests\models\test_keystroke_manager.py:373:89: E501 Line too long (97 > 88)
    |
371 |         )
372 |
373 |     def test_delete_all_keystrokes_success(self, manager_with_mock_db: KeystrokeManager) -> None:
    |                                                                                         ^^^^^^^^^ E501
374 |         """Test successful deletion of all keystrokes."""
375 |         result = manager_with_mock_db.delete_all_keystrokes()
    |

tests\models\test_keystroke_manager.py:386:89: E501 Line too long (92 > 88)
    |
384 |     ) -> None:
385 |         """Test handling of database errors during delete all."""
386 |         manager_with_mock_db.db_manager.execute.side_effect = Exception("Delete all failed")
    |                                                                                         ^^^^ E501
387 |
388 |         with patch("builtins.print"):
    |

tests\models\test_keystroke_manager.py:414:89: E501 Line too long (96 > 88)
    |
412 |         return KeystrokeManager(db_manager=mock_db)
413 |
414 |     def test_count_keystrokes_dict_result(self, manager_with_mock_db: KeystrokeManager) -> None:
    |                                                                                         ^^^^^^^^ E501
415 |         """Test counting with dict-like result (Row object)."""
416 |         session_id = "count-test-session"
    |

tests\models\test_keystroke_manager.py:432:89: E501 Line too long (97 > 88)
    |
430 |         )
431 |
432 |     def test_count_keystrokes_tuple_result(self, manager_with_mock_db: KeystrokeManager) -> None:
    |                                                                                         ^^^^^^^^^ E501
433 |         """Test counting with tuple result."""
434 |         session_id = "tuple-test-session"
    |

tests\models\test_keystroke_manager.py:441:89: E501 Line too long (96 > 88)
    |
439 |         assert result == 15
440 |
441 |     def test_count_keystrokes_zero_result(self, manager_with_mock_db: KeystrokeManager) -> None:
    |                                                                                         ^^^^^^^^ E501
442 |         """Test counting when result is zero."""
443 |         session_id = "zero-session"
    |

tests\models\test_keystroke_manager.py:451:89: E501 Line too long (96 > 88)
    |
449 |         assert result == 0
450 |
451 |     def test_count_keystrokes_none_result(self, manager_with_mock_db: KeystrokeManager) -> None:
    |                                                                                         ^^^^^^^^ E501
452 |         """Test counting when database returns None."""
453 |         session_id = "none-session"
    |

tests\models\test_keystroke_manager.py:472:89: E501 Line too long (99 > 88)
    |
470 |         assert result == 0
471 |
472 |     def test_count_keystrokes_database_error(self, manager_with_mock_db: KeystrokeManager) -> None:
    |                                                                                         ^^^^^^^^^^^ E501
473 |         """Test handling of database errors during count."""
474 |         session_id = "error-session"
    |

tests\models\test_keystroke_manager.py:502:89: E501 Line too long (100 > 88)
    |
500 |         assert result == 0
501 |
502 |     def test_count_keystrokes_uuid_session_id(self, manager_with_mock_db: KeystrokeManager) -> None:
    |                                                                                         ^^^^^^^^^^^^ E501
503 |         """Test counting with UUID session ID."""
504 |         session_id = str(uuid.uuid4())
    |

tests\models\test_keystroke_manager.py:551:89: E501 Line too long (90 > 88)
    |
549 |         return KeystrokeManager(db_manager=db)
550 |
551 |     def test_full_keystroke_workflow(self, integration_manager: KeystrokeManager) -> None:
    |                                                                                         ^^ E501
552 |         """Test complete workflow: add, save, count, retrieve, delete."""
553 |         import uuid
    |

tests\models\test_keystroke_manager.py:571:89: E501 Line too long (99 > 88)
    |
569 |                 is_error INTEGER NOT NULL,
570 |                 time_since_previous INTEGER,
571 |                 FOREIGN KEY (session_id) REFERENCES practice_sessions(session_id) ON DELETE CASCADE
    |                                                                                         ^^^^^^^^^^^ E501
572 |             )
573 |             """
    |

tests\models\test_keystroke_manager.py:587:89: E501 Line too long (89 > 88)
    |
585 |         db.execute(
586 |             """
587 |             INSERT INTO snippets (snippet_id, category_id, snippet_name) VALUES (?, ?, ?)
    |                                                                                         ^ E501
588 |             """,
589 |             (snippet_id, category_id, "integration-snippet"),
    |

tests\models\test_keystroke_manager.py:594:89: E501 Line too long (98 > 88)
    |
592 |         keyboard_id = str(uuid.uuid4())
593 |         db.execute(
594 |             "INSERT INTO users (user_id, first_name, surname, email_address) VALUES (?, ?, ?, ?)",
    |                                                                                         ^^^^^^^^^^ E501
595 |             (user_id, "Test", "User", f"testuser_{user_id[:8]}@example.com"),
596 |         )
    |

tests\models\test_keystroke_manager.py:598:89: E501 Line too long (91 > 88)
    |
596 |         )
597 |         db.execute(
598 |             "INSERT INTO keyboards (keyboard_id, user_id, keyboard_name) VALUES (?, ?, ?)",
    |                                                                                         ^^^ E501
599 |             (keyboard_id, user_id, "Test Keyboard"),
600 |         )
    |

tests\models\test_keystroke_manager.py:602:89: E501 Line too long (246 > 88)
    |
600 | ΓÇª
601 | ΓÇª
602 | ΓÇªrd_id, snippet_index_start, snippet_index_end, content, start_time, end_time, actual_chars, errors, ms_per_keystroke) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)",
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
603 | ΓÇª
604 | ΓÇª
    |

tests\models\test_keystroke_manager.py:649:89: E501 Line too long (89 > 88)
    |
647 |         assert delete_result is True
648 |         # Verify deletion
649 |         count_after_delete = integration_manager.count_keystrokes_per_session(session_id)
    |                                                                                         ^ E501
650 |         assert count_after_delete == 0
    |

tests\models\test_keystroke_manager.py:652:89: E501 Line too long (94 > 88)
    |
650 |         assert count_after_delete == 0
651 |
652 |     def test_concurrent_session_handling(self, integration_manager: KeystrokeManager) -> None:
    |                                                                                         ^^^^^^ E501
653 |         """Test handling multiple sessions concurrently."""
654 |         db = integration_manager.db_manager
    |

tests\models\test_keystroke_manager.py:662:89: E501 Line too long (98 > 88)
    |
660 |         keyboard_id = str(uuid.uuid4())
661 |         db.execute(
662 |             "INSERT INTO users (user_id, first_name, surname, email_address) VALUES (?, ?, ?, ?)",
    |                                                                                         ^^^^^^^^^^ E501
663 |             (user_id, "Test", "User", f"testuser_{user_id[:8]}@example.com"),
664 |         )
    |

tests\models\test_keystroke_manager.py:666:89: E501 Line too long (91 > 88)
    |
664 |         )
665 |         db.execute(
666 |             "INSERT INTO keyboards (keyboard_id, user_id, keyboard_name) VALUES (?, ?, ?)",
    |                                                                                         ^^^ E501
667 |             (keyboard_id, user_id, "Test Keyboard"),
668 |         )
    |

tests\models\test_keystroke_manager.py:680:89: E501 Line too long (96 > 88)
    |
678 |             )
679 |             db.execute(
680 |                 "INSERT INTO snippets (snippet_id, category_id, snippet_name) VALUES (?, ?, ?)",
    |                                                                                         ^^^^^^^^ E501
681 |                 (snippet_id, category_id, f"TestSnippet_{session_id}"),
682 |             )
    |

tests\models\test_keystroke_manager.py:684:89: E501 Line too long (250 > 88)
    |
682 | ΓÇª
683 | ΓÇª
684 | ΓÇªnippet_id, snippet_index_start, snippet_index_end, content, start_time, end_time, actual_chars, errors, ms_per_keystroke) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)",
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
685 | ΓÇª
686 | ΓÇª
    |

tests\models\test_keystroke_manager.py:1049:89: E501 Line too long (94 > 88)
     |
1047 |     user_id = str(uuid.uuid4())
1048 |     db.execute(
1049 |         "INSERT INTO users (user_id, first_name, surname, email_address) VALUES (?, ?, ?, ?)",
     |                                                                                         ^^^^^^ E501
1050 |         (user_id, f"user_{user_id}", f"user_{user_id}@example.com"),
1051 |     )
     |

tests\models\test_keystroke_manager.py:1070:89: E501 Line too long (92 > 88)
     |
1069 | @pytest.fixture(scope="module")
1070 | def test_session(request: pytest.FixtureRequest, test_user: str, test_keyboard: str) -> str:
     |                                                                                         ^^^^ E501
1071 |     db: DatabaseManager = getattr(request, "db", None)
1072 |     if db is None:
     |

tests\models\test_llm_ngram_service.py:1:1: I001 [*] Import block is un-sorted or un-formatted
  |
1 | / from unittest.mock import MagicMock, patch
2 | | from typing import Any, Dict
3 | | import pytest
4 | |
5 | | from models.llm_ngram_service import LLMMissingAPIKeyError, LLMNgramService
  | |___________________________________________________________________________^ I001
  |
  = help: Organize imports

tests\models\test_llm_ngram_service.py:2:20: F401 [*] `typing.Any` imported but unused
  |
1 | from unittest.mock import MagicMock, patch
2 | from typing import Any, Dict
  |                    ^^^ F401
3 | import pytest
  |
  = help: Remove unused import

tests\models\test_llm_ngram_service.py:2:25: F401 [*] `typing.Dict` imported but unused
  |
1 | from unittest.mock import MagicMock, patch
2 | from typing import Any, Dict
  |                         ^^^^ F401
3 | import pytest
  |
  = help: Remove unused import

tests\models\test_llm_ngram_service.py:8:5: ANN201 Missing return type annotation for public function `test_missing_api_key`
   |
 8 | def test_missing_api_key():
   |     ^^^^^^^^^^^^^^^^^^^^ ANN201
 9 |     with pytest.raises(LLMMissingAPIKeyError):
10 |         LLMNgramService(api_key=None)  # type: ignore
   |
   = help: Add return type annotation: `None`

tests\models\test_llm_ngram_service.py:13:5: ANN201 Missing return type annotation for public function `test_invalid_ngrams`
   |
13 | def test_invalid_ngrams():
   |     ^^^^^^^^^^^^^^^^^^^ ANN201
14 |     svc = LLMNgramService(api_key="sk-test")
15 |     with pytest.raises(ValueError):
   |
   = help: Add return type annotation: `None`

tests\models\test_next_session_position.py:18:1: E402 Module level import not at top of file
   |
16 |     sys.path.insert(0, project_root)
17 |
18 | from db.database_manager import DatabaseManager
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
19 | from models.session import Session
20 | from models.session_manager import SessionManager
   |

tests\models\test_next_session_position.py:19:1: E402 Module level import not at top of file
   |
18 | from db.database_manager import DatabaseManager
19 | from models.session import Session
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
20 | from models.session_manager import SessionManager
   |

tests\models\test_next_session_position.py:20:1: E402 Module level import not at top of file
   |
18 | from db.database_manager import DatabaseManager
19 | from models.session import Session
20 | from models.session_manager import SessionManager
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
   |

tests\models\test_next_session_position.py:24:5: ANN201 Missing return type annotation for public function `temp_db`
   |
23 | @pytest.fixture
24 | def temp_db():
   |     ^^^^^^^ ANN201
25 |     """Create a temporary in-memory database for testing."""
26 |     db_manager = DatabaseManager(":memory:")
   |
   = help: Add return type annotation

tests\models\test_next_session_position.py:47:89: E501 Line too long (89 > 88)
   |
45 |     db_manager.execute(
46 |         "INSERT INTO snippet_parts (snippet_id, part_number, content) VALUES (?, ?, ?)",
47 |         (snippet_id, 1, "This is a test snippet that is exactly fifty characters long."),
   |                                                                                         ^ E501
48 |     )
   |

tests\models\test_next_session_position.py:53:89: E501 Line too long (94 > 88)
   |
51 |     user_id = str(uuid.uuid4())
52 |     db_manager.execute(
53 |         "INSERT INTO users (user_id, first_name, surname, email_address) VALUES (?, ?, ?, ?)",
   |                                                                                         ^^^^^^ E501
54 |         (user_id, "Test", "User", f"testuser_{user_id[:8]}@example.com"),
55 |     )
   |

tests\models\test_next_session_position.py:71:89: E501 Line too long (91 > 88)
   |
69 |         "session_manager": session_manager,
70 |         "snippet_id": snippet_id,
71 |         "snippet_content": "This is a test snippet that is exactly fifty characters long.",
   |                                                                                         ^^^ E501
72 |         "user_id": user_id,
73 |         "keyboard_id": keyboard_id,
   |

tests\models\test_next_session_position.py:119:89: E501 Line too long (99 > 88)
    |
118 | def test_get_next_position_wrap_around(temp_db: dict) -> None:
119 |     """Test that next position wraps to 0 when the last session ended at the end of the snippet."""
    |                                                                                         ^^^^^^^^^^^ E501
120 |     session_manager = temp_db["session_manager"]
121 |     snippet_id = temp_db["snippet_id"]
    |

tests\models\test_next_session_position.py:151:5: F841 Local variable `snippet_length` is assigned to but never used
    |
149 |     session_manager = temp_db["session_manager"]
150 |     snippet_id = temp_db["snippet_id"]
151 |     snippet_length = len(temp_db["snippet_content"])
    |     ^^^^^^^^^^^^^^ F841
152 |
153 |     # Create a session with end position beyond actual snippet length (simulating content change)
    |
    = help: Remove assignment to unused variable `snippet_length`

tests\models\test_next_session_position.py:153:89: E501 Line too long (97 > 88)
    |
151 |     snippet_length = len(temp_db["snippet_content"])
152 |
153 |     # Create a session with end position beyond actual snippet length (simulating content change)
    |                                                                                         ^^^^^^^^^ E501
154 |     session = Session(
155 |         session_id=str(uuid.uuid4()),
    |

tests\models\test_ngram_analytics_service.py:19:1: I001 [*] Import block is un-sorted or un-formatted
   |
17 |   sys.path.insert(0, "d:\\SeanDevLocal\\AITypingTrainer")
18 |
19 | / from db.database_manager import DatabaseManager
20 | | from models.ngram_analytics_service import (
21 | |     DecayingAverageCalculator,
22 | |     NGramAnalyticsService,
23 | |     NGramHeatmapData,
24 | |     NGramHistoricalData,
25 | |     NGramPerformanceData,
26 | | )
27 | | from models.ngram_manager import NGramManager
28 | |
29 | | # Import fixtures and types from conftest
30 | | from tests.models.conftest import (
31 | |     MockNGramSpeedData,
32 | |     MockSessionData,
33 | |     ngram_speed_test_data,
34 | | )
   | |_^ I001
   |
   = help: Organize imports

tests\models\test_ngram_analytics_service.py:33:5: F401 [*] `tests.models.conftest.ngram_speed_test_data` imported but unused
   |
31 |     MockNGramSpeedData,
32 |     MockSessionData,
33 |     ngram_speed_test_data,
   |     ^^^^^^^^^^^^^^^^^^^^^ F401
34 | )
   |
   = help: Remove unused import: `tests.models.conftest.ngram_speed_test_data`

tests\models\test_ngram_analytics_service.py:68:89: E501 Line too long (94 > 88)
   |
66 |         assert result > 200.0  # Should be higher than simple average (200)
67 |         assert result < 220.0  # But not too much higher with decay_factor=0.9
68 |         assert result == pytest.approx(207.01, abs=1.0)  # Should be close to calculated value
   |                                                                                         ^^^^^^ E501
69 |
70 |     def test_calculate_decaying_average_single_value(self) -> None:
   |

tests\models\test_ngram_analytics_service.py:253:38: F821 Undefined name `temp_db`
    |
251 |         performance calculations and color coding.
252 |         """
253 |         ngram_manager = NGramManager(temp_db)
    |                                      ^^^^^^^ F821
254 |         service = NGramAnalyticsService(temp_db, ngram_manager)
    |

tests\models\test_ngram_analytics_service.py:254:41: F821 Undefined name `temp_db`
    |
252 |         """
253 |         ngram_manager = NGramManager(temp_db)
254 |         service = NGramAnalyticsService(temp_db, ngram_manager)
    |                                         ^^^^^^^ F821
255 |
256 |         # TODO: Set up test data
    |

tests\models\test_ngram_analytics_service.py:274:38: F821 Undefined name `temp_db`
    |
272 |         over the specified time window.
273 |         """
274 |         ngram_manager = NGramManager(temp_db)
    |                                      ^^^^^^^ F821
275 |         service = NGramAnalyticsService(temp_db, ngram_manager)
    |

tests\models\test_ngram_analytics_service.py:275:41: F821 Undefined name `temp_db`
    |
273 |         """
274 |         ngram_manager = NGramManager(temp_db)
275 |         service = NGramAnalyticsService(temp_db, ngram_manager)
    |                                         ^^^^^^^ F821
276 |
277 |         # TODO: Set up test data
    |

tests\models\test_ngram_analytics_service.py:288:9: F811 Redefinition of unused `ngram_speed_test_data` from line 33
    |
286 |     def test_slowest_n_moved_from_ngram_manager(
287 |         self, 
288 |         ngram_speed_test_data: Tuple[DatabaseManager, NGramAnalyticsService, str, str, str]
    |         ^^^^^^^^^^^^^^^^^^^^^ F811
289 |     ) -> None:
290 |         """
    |
    = help: Remove definition: `ngram_speed_test_data`

tests\models\test_ngram_analytics_service.py:288:89: E501 Line too long (91 > 88)
    |
286 |     def test_slowest_n_moved_from_ngram_manager(
287 |         self, 
288 |         ngram_speed_test_data: Tuple[DatabaseManager, NGramAnalyticsService, str, str, str]
    |                                                                                         ^^^ E501
289 |     ) -> None:
290 |         """
    |

tests\models\test_ngram_analytics_service.py:326:89: E501 Line too long (99 > 88)
    |
324 |         assert empty_result == []
325 |
326 |         no_sizes = service.slowest_n(n=5, keyboard_id=keyboard_id, user_id=user_id, ngram_sizes=[])
    |                                                                                         ^^^^^^^^^^^ E501
327 |         assert no_sizes == []
    |

tests\models\test_ngram_analytics_service.py:349:89: E501 Line too long (99 > 88)
    |
347 |         temp_db.execute(
348 |             """INSERT INTO practice_sessions 
349 |             (session_id, user_id, keyboard_id, snippet_id, snippet_index_start, snippet_index_end, 
    |                                                                                         ^^^^^^^^^^^ E501
350 |              content, start_time, end_time, actual_chars, errors, ms_per_keystroke) 
351 |             VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)""",
    |

tests\models\test_ngram_analytics_service.py:370:89: E501 Line too long (101 > 88)
    |
368 |         # Insert test n-gram error data
369 |         temp_db.execute(
370 |             "INSERT INTO session_ngram_errors (session_id, ngram_text, ngram_size) VALUES (?, ?, ?)",
    |                                                                                         ^^^^^^^^^^^^^ E501
371 |             (session_id, "th", 2),
372 |         )
    |

tests\models\test_ngram_analytics_service.py:374:89: E501 Line too long (101 > 88)
    |
372 |         )
373 |         temp_db.execute(
374 |             "INSERT INTO session_ngram_errors (session_id, ngram_text, ngram_size) VALUES (?, ?, ?)",
    |                                                                                         ^^^^^^^^^^^^^ E501
375 |             (session_id, "the", 3),
376 |         )
    |

tests\models\test_ngram_analytics_service.py:378:89: E501 Line too long (101 > 88)
    |
376 |         )
377 |         temp_db.execute(
378 |             "INSERT INTO session_ngram_errors (session_id, ngram_text, ngram_size) VALUES (?, ?, ?)",
    |                                                                                         ^^^^^^^^^^^^^ E501
379 |             (session_id, "er", 2),
380 |         )
    |

tests\models\test_ngram_analytics_service.py:383:89: E501 Line too long (101 > 88)
    |
381 |         # Add more occurrences to meet minimum count requirement
382 |         temp_db.execute(
383 |             "INSERT INTO session_ngram_errors (session_id, ngram_text, ngram_size) VALUES (?, ?, ?)",
    |                                                                                         ^^^^^^^^^^^^^ E501
384 |             (session_id, "th", 2),
385 |         )
    |

tests\models\test_ngram_analytics_service.py:387:89: E501 Line too long (101 > 88)
    |
385 |         )
386 |         temp_db.execute(
387 |             "INSERT INTO session_ngram_errors (session_id, ngram_text, ngram_size) VALUES (?, ?, ?)",
    |                                                                                         ^^^^^^^^^^^^^ E501
388 |             (session_id, "the", 3),
389 |         )
    |

tests\models\test_ngram_analytics_service.py:419:89: E501 Line too long (97 > 88)
    |
417 |         assert empty_result == []
418 |
419 |         no_sizes = service.error_n(n=5, keyboard_id=keyboard_id, user_id=user_id, ngram_sizes=[])
    |                                                                                         ^^^^^^^^^ E501
420 |         assert no_sizes == []
    |

tests\models\test_ngram_analytics_service.py:429:89: E501 Line too long (94 > 88)
    |
427 |     ) -> None:
428 |         """
429 |         Test objective: Verify dual-insert creates records in both current and history tables.
    |                                                                                         ^^^^^^ E501
430 |
431 |         Tests that when refresh_speed_summaries is called, records are created
    |

tests\models\test_ngram_analytics_service.py:445:89: E501 Line too long (103 > 88)
    |
443 |             temp_db.execute(
444 |                 """INSERT INTO practice_sessions 
445 |                 (session_id, user_id, keyboard_id, snippet_id, snippet_index_start, snippet_index_end, 
    |                                                                                         ^^^^^^^^^^^^^^^ E501
446 |                  content, start_time, end_time, actual_chars, errors, ms_per_keystroke) 
447 |                 VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)""",
    |

tests\models\test_ngram_analytics_service.py:467:89: E501 Line too long (102 > 88)
    |
465 |             temp_db.execute(
466 |                 """INSERT INTO session_ngram_speed 
467 |                 (ngram_speed_id, session_id, ngram_size, ngram_text, ngram_time_ms, ms_per_keystroke) 
    |                                                                                         ^^^^^^^^^^^^^^ E501
468 |                 VALUES (?, ?, ?, ?, ?, ?)""",
469 |                 (
    |

tests\models\test_ngram_analytics_service.py:480:89: E501 Line too long (107 > 88)
    |
479 |         temp_db.execute(
480 |             "INSERT INTO keyboards (keyboard_id, keyboard_name, target_ms_per_keystroke) VALUES (?, ?, ?)",
    |                                                                                         ^^^^^^^^^^^^^^^^^^^ E501
481 |             (keyboard_id, "Test Keyboard", 100),
482 |         )
    |

tests\models\test_ngram_analytics_service.py:488:89: E501 Line too long (92 > 88)
    |
487 |         # Check record counts in both tables
488 |         current_count = temp_db.fetchone("SELECT COUNT(*) FROM ngram_speed_summary_curr")[0]
    |                                                                                         ^^^^ E501
489 |         history_count = temp_db.fetchone("SELECT COUNT(*) FROM ngram_speed_summary_hist")[0]
    |

tests\models\test_ngram_analytics_service.py:489:89: E501 Line too long (92 > 88)
    |
487 |         # Check record counts in both tables
488 |         current_count = temp_db.fetchone("SELECT COUNT(*) FROM ngram_speed_summary_curr")[0]
489 |         history_count = temp_db.fetchone("SELECT COUNT(*) FROM ngram_speed_summary_hist")[0]
    |                                                                                         ^^^^ E501
490 |
491 |         assert current_count > 0, "Current table should have records"
    |

tests\models\test_ngram_analytics_service.py:493:89: E501 Line too long (95 > 88)
    |
491 |         assert current_count > 0, "Current table should have records"
492 |         assert history_count > 0, "History table should have records"
493 |         assert current_count == history_count, "Both tables should have same number of records"
    |                                                                                         ^^^^^^^ E501
494 |
495 |     def test_history_table_accumulates_all_records(
    |

tests\models\test_ngram_analytics_service.py:502:89: E501 Line too long (90 > 88)
    |
500 |     ) -> None:
501 |         """
502 |         Test objective: Verify history table contains all records over multiple refreshes.
    |                                                                                         ^^ E501
503 |
504 |         Tests that the history table accumulates all records from multiple
    |

tests\models\test_ngram_analytics_service.py:517:89: E501 Line too long (103 > 88)
    |
515 |             temp_db.execute(
516 |                 """INSERT INTO practice_sessions 
517 |                 (session_id, user_id, keyboard_id, snippet_id, snippet_index_start, snippet_index_end, 
    |                                                                                         ^^^^^^^^^^^^^^^ E501
518 |                  content, start_time, end_time, actual_chars, errors, ms_per_keystroke) 
519 |                 VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)""",
    |

tests\models\test_ngram_analytics_service.py:539:89: E501 Line too long (102 > 88)
    |
537 |             temp_db.execute(
538 |                 """INSERT INTO session_ngram_speed 
539 |                 (ngram_speed_id, session_id, ngram_size, ngram_text, ngram_time_ms, ms_per_keystroke) 
    |                                                                                         ^^^^^^^^^^^^^^ E501
540 |                 VALUES (?, ?, ?, ?, ?, ?)""",
541 |                 (
    |

tests\models\test_ngram_analytics_service.py:552:89: E501 Line too long (107 > 88)
    |
551 |         temp_db.execute(
552 |             "INSERT INTO keyboards (keyboard_id, keyboard_name, target_ms_per_keystroke) VALUES (?, ?, ?)",
    |                                                                                         ^^^^^^^^^^^^^^^^^^^ E501
553 |             (keyboard_id, "Test Keyboard", 100),
554 |         )
    |

tests\models\test_ngram_analytics_service.py:558:89: E501 Line too long (94 > 88)
    |
556 |         # First refresh
557 |         service.refresh_speed_summaries(user_id, keyboard_id)
558 |         history_count_1 = temp_db.fetchone("SELECT COUNT(*) FROM ngram_speed_summary_hist")[0]
    |                                                                                         ^^^^^^ E501
559 |
560 |         # Add more data and refresh again
    |

tests\models\test_ngram_analytics_service.py:564:89: E501 Line too long (99 > 88)
    |
562 |         temp_db.execute(
563 |             """INSERT INTO practice_sessions 
564 |             (session_id, user_id, keyboard_id, snippet_id, snippet_index_start, snippet_index_end, 
    |                                                                                         ^^^^^^^^^^^ E501
565 |              content, start_time, end_time, actual_chars, errors, ms_per_keystroke) 
566 |             VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)""",
    |

tests\models\test_ngram_analytics_service.py:585:89: E501 Line too long (98 > 88)
    |
583 |         temp_db.execute(
584 |             """INSERT INTO session_ngram_speed 
585 |             (ngram_speed_id, session_id, ngram_size, ngram_text, ngram_time_ms, ms_per_keystroke) 
    |                                                                                         ^^^^^^^^^^ E501
586 |             VALUES (?, ?, ?, ?, ?, ?)""",
587 |             ("new_ngram_1", session_id_2, 2, "ab", 200.0, 100.0),
    |

tests\models\test_ngram_analytics_service.py:592:89: E501 Line too long (94 > 88)
    |
590 |         # Second refresh
591 |         service.refresh_speed_summaries(user_id, keyboard_id)
592 |         history_count_2 = temp_db.fetchone("SELECT COUNT(*) FROM ngram_speed_summary_hist")[0]
    |                                                                                         ^^^^^^ E501
593 |
594 |         # History should accumulate all records
    |

tests\models\test_ngram_analytics_service.py:600:89: E501 Line too long (92 > 88)
    |
599 |         # Current table should only have latest values
600 |         current_count = temp_db.fetchone("SELECT COUNT(*) FROM ngram_speed_summary_curr")[0]
    |                                                                                         ^^^^ E501
601 |         assert current_count <= history_count_2, (
602 |             "Current table should have same or fewer records than history"
    |

tests\models\test_ngram_analytics_service.py:627:89: E501 Line too long (103 > 88)
    |
625 |             temp_db.execute(
626 |                 """INSERT INTO practice_sessions 
627 |                 (session_id, user_id, keyboard_id, snippet_id, snippet_index_start, snippet_index_end, 
    |                                                                                         ^^^^^^^^^^^^^^^ E501
628 |                  content, start_time, end_time, actual_chars, errors, ms_per_keystroke) 
629 |                 VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)""",
    |

tests\models\test_ngram_analytics_service.py:649:89: E501 Line too long (102 > 88)
    |
647 |             temp_db.execute(
648 |                 """INSERT INTO session_ngram_speed 
649 |                 (ngram_speed_id, session_id, ngram_size, ngram_text, ngram_time_ms, ms_per_keystroke) 
    |                                                                                         ^^^^^^^^^^^^^^ E501
650 |                 VALUES (?, ?, ?, ?, ?, ?)""",
651 |                 (
    |

tests\models\test_ngram_analytics_service.py:662:89: E501 Line too long (107 > 88)
    |
661 |         temp_db.execute(
662 |             "INSERT INTO keyboards (keyboard_id, keyboard_name, target_ms_per_keystroke) VALUES (?, ?, ?)",
    |                                                                                         ^^^^^^^^^^^^^^^^^^^ E501
663 |             (keyboard_id, "Test Keyboard", 100),
664 |         )
    |

tests\models\test_ngram_analytics_service.py:675:89: E501 Line too long (98 > 88)
    |
673 |             "Should return NGramHistoricalData objects"
674 |         )
675 |         assert all(record.ngram_text == "th" for record in history), "Should filter by ngram_text"
    |                                                                                         ^^^^^^^^^^ E501
676 |
677 |     def test_history_table_schema_compatibility(
    |

tests\models\test_ngram_analytics_service.py:687:9: F841 Local variable `service` is assigned to but never used
    |
685 |         """
686 |         ngram_manager = NGramManager(temp_db)
687 |         service = NGramAnalyticsService(temp_db, ngram_manager)
    |         ^^^^^^^ F841
688 |
689 |         # Verify table schemas are compatible
    |
    = help: Remove assignment to unused variable `service`

tests\models\test_ngram_analytics_service.py:718:89: E501 Line too long (98 > 88)
    |
717 |         # History table should have additional history-specific columns
718 |         assert "measurement_date" in history_columns, "History table should have measurement_date"
    |                                                                                         ^^^^^^^^^^ E501
    |

tests\models\test_ngram_analytics_service_session_methods.py:27:89: E501 Line too long (113 > 88)
   |
26 | @pytest.fixture
27 | def test_data_setup(db_with_tables: DatabaseManager, test_user: User, test_keyboard: Keyboard) -> Dict[str, Any]:
   |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^ E501
28 |     """Set up comprehensive test data for session analytics tests."""
29 |     db = db_with_tables
   |

tests\models\test_ngram_analytics_service_session_methods.py:63:9: ANN201 Missing return type annotation for public function `test_summarize_with_ngram_speed_only`
   |
61 |         (3, 3),  # Multiple ngram speed entries
62 |     ])
63 |     def test_summarize_with_ngram_speed_only(
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
64 |         self, 
65 |         analytics_service: NGramAnalyticsService,
   |
   = help: Add return type annotation: `None`

tests\models\test_ngram_analytics_service_session_methods.py:84:89: E501 Line too long (89 > 88)
   |
82 |             })
83 |         
84 |         TestSessionMethodsFixtures.create_session_ngram_speed(db, session_id, ngram_data)
   |                                                                                         ^ E501
85 |         
86 |         # Run summarization
   |

tests\models\test_ngram_analytics_service_session_methods.py:111:9: ANN201 Missing return type annotation for public function `test_summarize_with_ngram_errors_only`
    |
109 |         (2, 2),  # Multiple error entries
110 |     ])
111 |     def test_summarize_with_ngram_errors_only(
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
112 |         self,
113 |         analytics_service: NGramAnalyticsService,
    |
    = help: Add return type annotation: `None`

tests\models\test_ngram_analytics_service_session_methods.py:129:89: E501 Line too long (89 > 88)
    |
127 |             'ms_per_keystroke': 100.0
128 |         }]
129 |         TestSessionMethodsFixtures.create_session_ngram_speed(db, session_id, speed_data)
    |                                                                                         ^ E501
130 |         
131 |         # Create error data
    |

tests\models\test_ngram_analytics_service_session_methods.py:133:13: B007 Loop control variable `i` not used within loop body
    |
131 |         # Create error data
132 |         error_data = []
133 |         for i in range(error_count):
    |             ^ B007
134 |             error_data.append({
135 |                 'ngram_size': 2,
    |
    = help: Rename unused `i` to `_i`

tests\models\test_ngram_analytics_service_session_methods.py:139:89: E501 Line too long (90 > 88)
    |
137 |             })
138 |         
139 |         TestSessionMethodsFixtures.create_session_ngram_errors(db, session_id, error_data)
    |                                                                                         ^^ E501
140 |         
141 |         # Run summarization
    |

tests\models\test_ngram_analytics_service_session_methods.py:149:89: E501 Line too long (93 > 88)
    |
147 |         # Check error count was aggregated correctly
148 |         summary_records = db.fetchall(
149 |             "SELECT * FROM session_ngram_summary WHERE session_id = ? AND ngram_text = 'te'",
    |                                                                                         ^^^^^ E501
150 |             (session_id,)
151 |         )
    |

tests\models\test_ngram_analytics_service_session_methods.py:156:9: ANN201 Missing return type annotation for public function `test_summarize_with_speed_and_errors`
    |
154 |         assert summary_records[0]['error_count'] == expected_errors
155 |     
156 |     def test_summarize_with_speed_and_errors(
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
157 |         self,
158 |         analytics_service: NGramAnalyticsService,
    |
    = help: Add return type annotation: `None`

tests\models\test_ngram_analytics_service_session_methods.py:180:89: E501 Line too long (89 > 88)
    |
178 |             }
179 |         ]
180 |         TestSessionMethodsFixtures.create_session_ngram_speed(db, session_id, speed_data)
    |                                                                                         ^ E501
181 |         
182 |         # Create error data
    |

tests\models\test_ngram_analytics_service_session_methods.py:187:89: E501 Line too long (90 > 88)
    |
185 |             {'ngram_size': 2, 'ngram_text': 'th'}   # Second error for same ngram
186 |         ]
187 |         TestSessionMethodsFixtures.create_session_ngram_errors(db, session_id, error_data)
    |                                                                                         ^^ E501
188 |         
189 |         # Run summarization
    |

tests\models\test_ngram_analytics_service_session_methods.py:197:89: E501 Line too long (93 > 88)
    |
195 |         # Check both ngrams were processed
196 |         th_record = db.fetchone(
197 |             "SELECT * FROM session_ngram_summary WHERE session_id = ? AND ngram_text = 'th'",
    |                                                                                         ^^^^^ E501
198 |             (session_id,)
199 |         )
    |

tests\models\test_ngram_analytics_service_session_methods.py:201:89: E501 Line too long (94 > 88)
    |
199 |         )
200 |         the_record = db.fetchone(
201 |             "SELECT * FROM session_ngram_summary WHERE session_id = ? AND ngram_text = 'the'",
    |                                                                                         ^^^^^^ E501
202 |             (session_id,)
203 |         )
    |

tests\models\test_ngram_analytics_service_session_methods.py:217:9: ANN201 Missing return type annotation for public function `test_summarize_with_keystrokes`
    |
215 |         (3, 3),  # Multiple keystrokes
216 |     ])
217 |     def test_summarize_with_keystrokes(
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
218 |         self,
219 |         analytics_service: NGramAnalyticsService,
    |
    = help: Add return type annotation: `None`

tests\models\test_ngram_analytics_service_session_methods.py:241:89: E501 Line too long (92 > 88)
    |
239 |             })
240 |         
241 |         TestSessionMethodsFixtures.create_session_keystrokes(db, session_id, keystroke_data)
    |                                                                                         ^^^^ E501
242 |         
243 |         # Run summarization
    |

tests\models\test_ngram_analytics_service_session_methods.py:251:89: E501 Line too long (90 > 88)
    |
249 |         # Check 1-gram records were created
250 |         summary_records = db.fetchall(
251 |             "SELECT * FROM session_ngram_summary WHERE session_id = ? AND ngram_size = 1",
    |                                                                                         ^^ E501
252 |             (session_id,)
253 |         )
    |

tests\models\test_ngram_analytics_service_session_methods.py:262:9: ANN201 Missing return type annotation for public function `test_no_sessions_missing`
    |
260 |             assert record['avg_ms_per_keystroke'] > 0
261 |     
262 |     def test_no_sessions_missing(
    |         ^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
263 |         self,
264 |         analytics_service: NGramAnalyticsService,
    |
    = help: Add return type annotation: `None`

tests\models\test_ngram_analytics_service_session_methods.py:293:9: ANN201 Missing return type annotation for public function `test_sessions_missing_no_data`
    |
291 |         assert result == 0
292 |     
293 |     def test_sessions_missing_no_data(
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
294 |         self,
295 |         analytics_service: NGramAnalyticsService,
    |
    = help: Add return type annotation: `None`

tests\models\test_ngram_analytics_service_session_methods.py:311:9: ANN201 Missing return type annotation for public function `test_single_session_processing`
    |
309 |     """Test cases for AddSpeedSummaryForSession method."""
310 |     
311 |     def test_single_session_processing(
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
312 |         self,
313 |         analytics_service: NGramAnalyticsService,
    |
    = help: Add return type annotation: `None`

tests\models\test_ngram_analytics_service_session_methods.py:346:9: ANN201 Missing return type annotation for public function `test_nonexistent_session`
    |
344 |         assert result['curr_updated'] >= 0
345 |     
346 |     def test_nonexistent_session(
    |         ^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
347 |         self,
348 |         analytics_service: NGramAnalyticsService
    |
    = help: Add return type annotation: `None`

tests\models\test_ngram_analytics_service_session_methods.py:356:9: ANN201 Missing return type annotation for public function `test_multiple_ngrams_processing`
    |
354 |             analytics_service.add_speed_summary_for_session(fake_session_id)
355 |     
356 |     def test_multiple_ngrams_processing(
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
357 |         self,
358 |         analytics_service: NGramAnalyticsService,
    |
    = help: Add return type annotation: `None`

tests\models\test_ngram_analytics_service_session_methods.py:405:9: ANN201 Missing return type annotation for public function `test_empty_database_catchup`
    |
403 |     """Test cases for CatchupSpeedSummary method."""
404 |     
405 |     def test_empty_database_catchup(
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
406 |         self,
407 |         analytics_service: NGramAnalyticsService
    |
    = help: Add return type annotation: `None`

tests\models\test_ngram_analytics_service_session_methods.py:417:9: ANN201 Missing return type annotation for public function `test_single_session_catchup`
    |
415 |         assert result['total_curr_updated'] == 0
416 |     
417 |     def test_single_session_catchup(
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
418 |         self,
419 |         analytics_service: NGramAnalyticsService,
    |
    = help: Add return type annotation: `None`

tests\models\test_ngram_analytics_service_session_methods.py:451:9: ANN201 Missing return type annotation for public function `test_multiple_sessions_catchup`
    |
449 |         assert result['total_curr_updated'] >= 0
450 |     
451 |     def test_multiple_sessions_catchup(
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
452 |         self,
453 |         analytics_service: NGramAnalyticsService,
    |
    = help: Add return type annotation: `None`

tests\models\test_ngram_analytics_service_session_methods.py:486:9: ANN201 Missing return type annotation for public function `test_catchup_with_session_errors`
    |
484 |         # (verified by the method's internal logging)
485 |     
486 |     def test_catchup_with_session_errors(
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
487 |         self,
488 |         analytics_service: NGramAnalyticsService,
    |
    = help: Add return type annotation: `None`

tests\models\test_ngram_analytics_service_session_methods.py:510:89: E501 Line too long (98 > 88)
    |
508 |         )
509 |         
510 |         # Second session will have no summary data (will cause processing to skip/fail gracefully)
    |                                                                                         ^^^^^^^^^^ E501
511 |         
512 |         # Run catchup
    |

tests\models\test_ngram_analytics_service_session_methods.py:524:9: ANN201 Missing return type annotation for public function `test_full_workflow_integration`
    |
522 |     """Integration tests combining multiple methods."""
523 |     
524 |     def test_full_workflow_integration(
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
525 |         self,
526 |         analytics_service: NGramAnalyticsService,
    |
    = help: Add return type annotation: `None`

tests\models\test_ngram_analytics_service_session_methods.py:540:89: E501 Line too long (89 > 88)
    |
538 |             'ms_per_keystroke': 80.0
539 |         }]
540 |         TestSessionMethodsFixtures.create_session_ngram_speed(db, session_id, speed_data)
    |                                                                                         ^ E501
541 |         
542 |         keystroke_data = [{
    |

tests\models\test_ngram_analytics_service_session_methods.py:549:89: E501 Line too long (92 > 88)
    |
547 |             'time_since_previous': 95
548 |         }]
549 |         TestSessionMethodsFixtures.create_session_keystrokes(db, session_id, keystroke_data)
    |                                                                                         ^^^^ E501
550 |         
551 |         # Step 2: Summarize sessions
    |

tests\models\test_ngram_clean.py:87:89: E501 Line too long (89 > 88)
   |
85 |     ),
86 |     # Size 1 n-grams are not allowed per specification (ignored)
87 |     ([Keystroke(char="z", expected="z", timestamp=T0)], 1, [], "1char ignored per spec"),
   |                                                                                         ^ E501
88 |     # Not clean: Contains error
89 |     (
   |

tests\models\test_ngram_clean.py:311:89: E501 Line too long (94 > 88)
    |
309 |     ),
310 |     # Size 1 n-grams are not allowed per specification (ignored)
311 |     ([Keystroke(char="a", expected="a", timestamp=T10K_US)], 1, [], "1char ignored per spec"),
    |                                                                                         ^^^^^^ E501
312 |     (
313 |         [
    |

tests\models\test_ngram_clean.py:494:89: E501 Line too long (94 > 88)
    |
493 | @pytest.mark.parametrize(
494 |     "keystrokes, ngram_size, expected_clean_ngram_texts, description", CLEAN_STATUS_TEST_CASES
    |                                                                                         ^^^^^^ E501
495 | )
496 | def test_ngram_clean_status(
    |

tests\models\test_ngram_clean.py:505:89: E501 Line too long (92 > 88)
    |
503 |     ngram_manager = NGramManager(db_manager=None)
504 |     # Instantiate real NGramManager
505 |     generated_ngrams = ngram_manager.generate_ngrams_from_keystrokes(keystrokes, ngram_size)
    |                                                                                         ^^^^ E501
506 |
507 |     clean_ngram_texts_generated = [ngram.text for ngram in generated_ngrams if ngram.is_clean]
    |

tests\models\test_ngram_clean.py:507:89: E501 Line too long (94 > 88)
    |
505 |     generated_ngrams = ngram_manager.generate_ngrams_from_keystrokes(keystrokes, ngram_size)
506 |
507 |     clean_ngram_texts_generated = [ngram.text for ngram in generated_ngrams if ngram.is_clean]
    |                                                                                         ^^^^^^ E501
508 |
509 |     sorted_generated = sorted(clean_ngram_texts_generated)
    |

tests\models\test_ngram_clean.py:512:89: E501 Line too long (91 > 88)
    |
510 |     sorted_expected = sorted(expected_clean_ngram_texts)
511 |     assert sorted_generated == sorted_expected, (
512 |         f"FAIL: {description}. EXP_CLEAN: {sorted_expected}, GOT_CLEAN: {sorted_generated}"
    |                                                                                         ^^^ E501
513 |     )
    |

tests\models\test_ngram_error.py:11:89: E501 Line too long (89 > 88)
   |
 9 | from db.database_manager import DatabaseManager
10 |
11 | # Test cases: (keystrokes, ngram_size, expected_ngram_texts_with_error_true, description)
   |                                                                                         ^ E501
12 | # We expect a list of texts for ngrams where is_error should be True.
13 | # Rule: is_error is True if an error exists ONLY in the last position of the ngram's keystrokes.
   |

tests\models\test_ngram_error.py:13:89: E501 Line too long (96 > 88)
   |
11 | # Test cases: (keystrokes, ngram_size, expected_ngram_texts_with_error_true, description)
12 | # We expect a list of texts for ngrams where is_error should be True.
13 | # Rule: is_error is True if an error exists ONLY in the last position of the ngram's keystrokes.
   |                                                                                         ^^^^^^^^ E501
14 | ERROR_STATUS_TEST_CASES: List[Tuple[List[Keystroke], int, List[str], str]] = [
15 |     # Basic cases for is_error = True (error ONLY at the end)
   |

tests\models\test_ngram_error.py:18:89: E501 Line too long (91 > 88)
   |
16 |     (
17 |         [
18 |             Keystroke(char="a", expected="a", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
   |                                                                                         ^^^ E501
19 |             Keystroke(char="x", expected="b", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
20 |         ],
   |

tests\models\test_ngram_error.py:19:89: E501 Line too long (96 > 88)
   |
17 |         [
18 |             Keystroke(char="a", expected="a", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
19 |             Keystroke(char="x", expected="b", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
   |                                                                                         ^^^^^^^^ E501
20 |         ],
21 |         2,
   |

tests\models\test_ngram_error.py:27:89: E501 Line too long (91 > 88)
   |
25 |     (
26 |         [
27 |             Keystroke(char="c", expected="c", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
   |                                                                                         ^^^ E501
28 |             Keystroke(char="a", expected="a", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
29 |             Keystroke(char="X", expected="t", timestamp=datetime(2023, 1, 1, 12, 0, 0, 200000)),
   |

tests\models\test_ngram_error.py:28:89: E501 Line too long (96 > 88)
   |
26 |         [
27 |             Keystroke(char="c", expected="c", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
28 |             Keystroke(char="a", expected="a", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
   |                                                                                         ^^^^^^^^ E501
29 |             Keystroke(char="X", expected="t", timestamp=datetime(2023, 1, 1, 12, 0, 0, 200000)),
30 |         ],
   |

tests\models\test_ngram_error.py:29:89: E501 Line too long (96 > 88)
   |
27 |             Keystroke(char="c", expected="c", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
28 |             Keystroke(char="a", expected="a", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
29 |             Keystroke(char="X", expected="t", timestamp=datetime(2023, 1, 1, 12, 0, 0, 200000)),
   |                                                                                         ^^^^^^^^ E501
30 |         ],
31 |         3,
   |

tests\models\test_ngram_error.py:38:89: E501 Line too long (91 > 88)
   |
36 |     (
37 |         [
38 |             Keystroke(char="a", expected="a", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
   |                                                                                         ^^^ E501
39 |             Keystroke(char="b", expected="b", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
40 |         ],
   |

tests\models\test_ngram_error.py:39:89: E501 Line too long (96 > 88)
   |
37 |         [
38 |             Keystroke(char="a", expected="a", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
39 |             Keystroke(char="b", expected="b", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
   |                                                                                         ^^^^^^^^ E501
40 |         ],
41 |         2,
   |

tests\models\test_ngram_error.py:47:89: E501 Line too long (91 > 88)
   |
45 |     (
46 |         [
47 |             Keystroke(char="c", expected="c", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
   |                                                                                         ^^^ E501
48 |             Keystroke(char="a", expected="a", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
49 |             Keystroke(char="t", expected="t", timestamp=datetime(2023, 1, 1, 12, 0, 0, 200000)),
   |

tests\models\test_ngram_error.py:48:89: E501 Line too long (96 > 88)
   |
46 |         [
47 |             Keystroke(char="c", expected="c", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
48 |             Keystroke(char="a", expected="a", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
   |                                                                                         ^^^^^^^^ E501
49 |             Keystroke(char="t", expected="t", timestamp=datetime(2023, 1, 1, 12, 0, 0, 200000)),
50 |         ],
   |

tests\models\test_ngram_error.py:49:89: E501 Line too long (96 > 88)
   |
47 |             Keystroke(char="c", expected="c", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
48 |             Keystroke(char="a", expected="a", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
49 |             Keystroke(char="t", expected="t", timestamp=datetime(2023, 1, 1, 12, 0, 0, 200000)),
   |                                                                                         ^^^^^^^^ E501
50 |         ],
51 |         3,
   |

tests\models\test_ngram_error.py:61:89: E501 Line too long (96 > 88)
   |
59 |                 char="x", expected="a", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)
60 |             ),  # Error at start
61 |             Keystroke(char="b", expected="b", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
   |                                                                                         ^^^^^^^^ E501
62 |         ],
63 |         2,
   |

tests\models\test_ngram_error.py:82:89: E501 Line too long (91 > 88)
   |
80 |     (
81 |         [
82 |             Keystroke(char="c", expected="c", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
   |                                                                                         ^^^ E501
83 |             Keystroke(
84 |                 char="X", expected="a", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)
   |

tests\models\test_ngram_error.py:86:89: E501 Line too long (96 > 88)
   |
84 |                 char="X", expected="a", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)
85 |             ),  # Error in middle
86 |             Keystroke(char="t", expected="t", timestamp=datetime(2023, 1, 1, 12, 0, 0, 200000)),
   |                                                                                         ^^^^^^^^ E501
87 |         ],
88 |         3,
   |

tests\models\test_ngram_error.py:97:89: E501 Line too long (96 > 88)
   |
95 |                 char="C", expected="c", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)
96 |             ),  # All errors
97 |             Keystroke(char="A", expected="a", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
   |                                                                                         ^^^^^^^^ E501
98 |             Keystroke(char="T", expected="t", timestamp=datetime(2023, 1, 1, 12, 0, 0, 200000)),
99 |         ],
   |

tests\models\test_ngram_error.py:98:89: E501 Line too long (96 > 88)
    |
 96 |             ),  # All errors
 97 |             Keystroke(char="A", expected="a", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
 98 |             Keystroke(char="T", expected="t", timestamp=datetime(2023, 1, 1, 12, 0, 0, 200000)),
    |                                                                                         ^^^^^^^^ E501
 99 |         ],
100 |         3,
    |

tests\models\test_ngram_error.py:106:89: E501 Line too long (91 > 88)
    |
104 |     (
105 |         [
106 |             Keystroke(char="c", expected="c", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
    |                                                                                         ^^^ E501
107 |             Keystroke(
108 |                 char="X", expected="a", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)
    |

tests\models\test_ngram_error.py:121:89: E501 Line too long (89 > 88)
    |
119 |     ([], 2, [], "Empty keystrokes"),
120 |     (
121 |         [Keystroke(char="a", expected="a", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0))],
    |                                                                                         ^ E501
122 |         2,
123 |         [],
    |

tests\models\test_ngram_error.py:128:89: E501 Line too long (89 > 88)
    |
126 |     # Size 1 n-grams are not allowed per specification (ignored)
127 |     (
128 |         [Keystroke(char="X", expected="a", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0))],
    |                                                                                         ^ E501
129 |         1,
130 |         [],
    |

tests\models\test_ngram_error.py:134:89: E501 Line too long (89 > 88)
    |
132 |     ),
133 |     (
134 |         [Keystroke(char="a", expected="a", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0))],
    |                                                                                         ^ E501
135 |         1,
136 |         [],
    |

tests\models\test_ngram_error.py:142:89: E501 Line too long (91 > 88)
    |
140 |     (
141 |         [
142 |             Keystroke(char="t", expected="t", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
    |                                                                                         ^^^ E501
143 |             Keystroke(char="h", expected="h", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
144 |             Keystroke(char="e", expected="e", timestamp=datetime(2023, 1, 1, 12, 0, 0, 200000)),
    |

tests\models\test_ngram_error.py:143:89: E501 Line too long (96 > 88)
    |
141 |         [
142 |             Keystroke(char="t", expected="t", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
143 |             Keystroke(char="h", expected="h", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
    |                                                                                         ^^^^^^^^ E501
144 |             Keystroke(char="e", expected="e", timestamp=datetime(2023, 1, 1, 12, 0, 0, 200000)),
145 |             Keystroke(
    |

tests\models\test_ngram_error.py:144:89: E501 Line too long (96 > 88)
    |
142 |             Keystroke(char="t", expected="t", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
143 |             Keystroke(char="h", expected="h", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
144 |             Keystroke(char="e", expected="e", timestamp=datetime(2023, 1, 1, 12, 0, 0, 200000)),
    |                                                                                         ^^^^^^^^ E501
145 |             Keystroke(
146 |                 char="N", expected="n", timestamp=datetime(2023, 1, 1, 12, 0, 0, 300000)
    |

tests\models\test_ngram_error.py:156:89: E501 Line too long (91 > 88)
    |
154 |     (
155 |         [
156 |             Keystroke(char="t", expected="t", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
    |                                                                                         ^^^ E501
157 |             Keystroke(char="h", expected="h", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
158 |             Keystroke(char="e", expected="e", timestamp=datetime(2023, 1, 1, 12, 0, 0, 200000)),
    |

tests\models\test_ngram_error.py:157:89: E501 Line too long (96 > 88)
    |
155 |         [
156 |             Keystroke(char="t", expected="t", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
157 |             Keystroke(char="h", expected="h", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
    |                                                                                         ^^^^^^^^ E501
158 |             Keystroke(char="e", expected="e", timestamp=datetime(2023, 1, 1, 12, 0, 0, 200000)),
159 |             Keystroke(
    |

tests\models\test_ngram_error.py:158:89: E501 Line too long (96 > 88)
    |
156 |             Keystroke(char="t", expected="t", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
157 |             Keystroke(char="h", expected="h", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
158 |             Keystroke(char="e", expected="e", timestamp=datetime(2023, 1, 1, 12, 0, 0, 200000)),
    |                                                                                         ^^^^^^^^ E501
159 |             Keystroke(
160 |                 char="N", expected="n", timestamp=datetime(2023, 1, 1, 12, 0, 0, 300000)
    |

tests\models\test_ngram_error.py:170:89: E501 Line too long (91 > 88)
    |
168 |     (
169 |         [
170 |             Keystroke(char="t", expected="t", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
    |                                                                                         ^^^ E501
171 |             Keystroke(char="h", expected="h", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
172 |             Keystroke(char="e", expected="e", timestamp=datetime(2023, 1, 1, 12, 0, 0, 200000)),
    |

tests\models\test_ngram_error.py:171:89: E501 Line too long (96 > 88)
    |
169 |         [
170 |             Keystroke(char="t", expected="t", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
171 |             Keystroke(char="h", expected="h", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
    |                                                                                         ^^^^^^^^ E501
172 |             Keystroke(char="e", expected="e", timestamp=datetime(2023, 1, 1, 12, 0, 0, 200000)),
173 |             Keystroke(
    |

tests\models\test_ngram_error.py:172:89: E501 Line too long (96 > 88)
    |
170 |             Keystroke(char="t", expected="t", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
171 |             Keystroke(char="h", expected="h", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
172 |             Keystroke(char="e", expected="e", timestamp=datetime(2023, 1, 1, 12, 0, 0, 200000)),
    |                                                                                         ^^^^^^^^ E501
173 |             Keystroke(
174 |                 char="N", expected="n", timestamp=datetime(2023, 1, 1, 12, 0, 0, 300000)
    |

tests\models\test_ngram_error.py:186:89: E501 Line too long (96 > 88)
    |
184 |                 char="q", expected="Q", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)
185 |             ),  # error at start of 'Qui'
186 |             Keystroke(char="u", expected="u", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
    |                                                                                         ^^^^^^^^ E501
187 |             Keystroke(char="i", expected="i", timestamp=datetime(2023, 1, 1, 12, 0, 0, 200000)),
188 |             Keystroke(char="c", expected="c", timestamp=datetime(2023, 1, 1, 12, 0, 0, 300000)),
    |

tests\models\test_ngram_error.py:187:89: E501 Line too long (96 > 88)
    |
185 |             ),  # error at start of 'Qui'
186 |             Keystroke(char="u", expected="u", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
187 |             Keystroke(char="i", expected="i", timestamp=datetime(2023, 1, 1, 12, 0, 0, 200000)),
    |                                                                                         ^^^^^^^^ E501
188 |             Keystroke(char="c", expected="c", timestamp=datetime(2023, 1, 1, 12, 0, 0, 300000)),
189 |             Keystroke(
    |

tests\models\test_ngram_error.py:188:89: E501 Line too long (96 > 88)
    |
186 |             Keystroke(char="u", expected="u", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
187 |             Keystroke(char="i", expected="i", timestamp=datetime(2023, 1, 1, 12, 0, 0, 200000)),
188 |             Keystroke(char="c", expected="c", timestamp=datetime(2023, 1, 1, 12, 0, 0, 300000)),
    |                                                                                         ^^^^^^^^ E501
189 |             Keystroke(
190 |                 char="K", expected="k", timestamp=datetime(2023, 1, 1, 12, 0, 0, 400000)
    |

tests\models\test_ngram_error.py:199:89: E501 Line too long (91 > 88)
    |
197 |     (
198 |         [
199 |             Keystroke(char="e", expected="E", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
    |                                                                                         ^^^ E501
200 |             Keystroke(char="r", expected="R", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
201 |             Keystroke(char="r", expected="R", timestamp=datetime(2023, 1, 1, 12, 0, 0, 200000)),
    |

tests\models\test_ngram_error.py:200:89: E501 Line too long (96 > 88)
    |
198 |         [
199 |             Keystroke(char="e", expected="E", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
200 |             Keystroke(char="r", expected="R", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
    |                                                                                         ^^^^^^^^ E501
201 |             Keystroke(char="r", expected="R", timestamp=datetime(2023, 1, 1, 12, 0, 0, 200000)),
202 |             Keystroke(char="s", expected="S", timestamp=datetime(2023, 1, 1, 12, 0, 0, 300000)),
    |

tests\models\test_ngram_error.py:201:89: E501 Line too long (96 > 88)
    |
199 |             Keystroke(char="e", expected="E", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
200 |             Keystroke(char="r", expected="R", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
201 |             Keystroke(char="r", expected="R", timestamp=datetime(2023, 1, 1, 12, 0, 0, 200000)),
    |                                                                                         ^^^^^^^^ E501
202 |             Keystroke(char="s", expected="S", timestamp=datetime(2023, 1, 1, 12, 0, 0, 300000)),
203 |         ],
    |

tests\models\test_ngram_error.py:202:89: E501 Line too long (96 > 88)
    |
200 |             Keystroke(char="r", expected="R", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
201 |             Keystroke(char="r", expected="R", timestamp=datetime(2023, 1, 1, 12, 0, 0, 200000)),
202 |             Keystroke(char="s", expected="S", timestamp=datetime(2023, 1, 1, 12, 0, 0, 300000)),
    |                                                                                         ^^^^^^^^ E501
203 |         ],
204 |         2,
    |

tests\models\test_ngram_error.py:210:89: E501 Line too long (91 > 88)
    |
208 |     (
209 |         [
210 |             Keystroke(char="o", expected="o", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
    |                                                                                         ^^^ E501
211 |             Keystroke(char="n", expected="n", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
212 |             Keystroke(
    |

tests\models\test_ngram_error.py:211:89: E501 Line too long (96 > 88)
    |
209 |         [
210 |             Keystroke(char="o", expected="o", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
211 |             Keystroke(char="n", expected="n", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
    |                                                                                         ^^^^^^^^ E501
212 |             Keystroke(
213 |                 char="L", expected="l", timestamp=datetime(2023, 1, 1, 12, 0, 0, 200000)
    |

tests\models\test_ngram_error.py:215:89: E501 Line too long (96 > 88)
    |
213 |                 char="L", expected="l", timestamp=datetime(2023, 1, 1, 12, 0, 0, 200000)
214 |             ),  # error in middle of 'onLy' and 'nLyE'
215 |             Keystroke(char="y", expected="y", timestamp=datetime(2023, 1, 1, 12, 0, 0, 300000)),
    |                                                                                         ^^^^^^^^ E501
216 |             Keystroke(
217 |                 char="E", expected="e", timestamp=datetime(2023, 1, 1, 12, 0, 0, 400000)
    |

tests\models\test_ngram_error.py:226:57: F821 Undefined name `T0`
    |
224 |     (
225 |         [
226 |             Keystroke(char="a", expected="a", timestamp=T0),
    |                                                         ^^ F821
227 |             Keystroke(char="b", expected="b", timestamp=T100K_US),
228 |             Keystroke(char="c", expected="c", timestamp=T200K_US),
    |

tests\models\test_ngram_error.py:227:57: F821 Undefined name `T100K_US`
    |
225 |         [
226 |             Keystroke(char="a", expected="a", timestamp=T0),
227 |             Keystroke(char="b", expected="b", timestamp=T100K_US),
    |                                                         ^^^^^^^^ F821
228 |             Keystroke(char="c", expected="c", timestamp=T200K_US),
229 |             Keystroke(char="d", expected="d", timestamp=T300K_US),
    |

tests\models\test_ngram_error.py:228:57: F821 Undefined name `T200K_US`
    |
226 |             Keystroke(char="a", expected="a", timestamp=T0),
227 |             Keystroke(char="b", expected="b", timestamp=T100K_US),
228 |             Keystroke(char="c", expected="c", timestamp=T200K_US),
    |                                                         ^^^^^^^^ F821
229 |             Keystroke(char="d", expected="d", timestamp=T300K_US),
230 |             Keystroke(char="e", expected="e", timestamp=T400K_US),
    |

tests\models\test_ngram_error.py:229:57: F821 Undefined name `T300K_US`
    |
227 |             Keystroke(char="b", expected="b", timestamp=T100K_US),
228 |             Keystroke(char="c", expected="c", timestamp=T200K_US),
229 |             Keystroke(char="d", expected="d", timestamp=T300K_US),
    |                                                         ^^^^^^^^ F821
230 |             Keystroke(char="e", expected="e", timestamp=T400K_US),
231 |             Keystroke(char="f", expected="f", timestamp=T500K_US),
    |

tests\models\test_ngram_error.py:230:57: F821 Undefined name `T400K_US`
    |
228 |             Keystroke(char="c", expected="c", timestamp=T200K_US),
229 |             Keystroke(char="d", expected="d", timestamp=T300K_US),
230 |             Keystroke(char="e", expected="e", timestamp=T400K_US),
    |                                                         ^^^^^^^^ F821
231 |             Keystroke(char="f", expected="f", timestamp=T500K_US),
232 |             Keystroke(char="g", expected="g", timestamp=T600K_US),
    |

tests\models\test_ngram_error.py:231:57: F821 Undefined name `T500K_US`
    |
229 |             Keystroke(char="d", expected="d", timestamp=T300K_US),
230 |             Keystroke(char="e", expected="e", timestamp=T400K_US),
231 |             Keystroke(char="f", expected="f", timestamp=T500K_US),
    |                                                         ^^^^^^^^ F821
232 |             Keystroke(char="g", expected="g", timestamp=T600K_US),
233 |             Keystroke(char="h", expected="h", timestamp=T700K_US),
    |

tests\models\test_ngram_error.py:232:57: F821 Undefined name `T600K_US`
    |
230 |             Keystroke(char="e", expected="e", timestamp=T400K_US),
231 |             Keystroke(char="f", expected="f", timestamp=T500K_US),
232 |             Keystroke(char="g", expected="g", timestamp=T600K_US),
    |                                                         ^^^^^^^^ F821
233 |             Keystroke(char="h", expected="h", timestamp=T700K_US),
234 |             Keystroke(char="i", expected="i", timestamp=T800K_US),
    |

tests\models\test_ngram_error.py:233:57: F821 Undefined name `T700K_US`
    |
231 |             Keystroke(char="f", expected="f", timestamp=T500K_US),
232 |             Keystroke(char="g", expected="g", timestamp=T600K_US),
233 |             Keystroke(char="h", expected="h", timestamp=T700K_US),
    |                                                         ^^^^^^^^ F821
234 |             Keystroke(char="i", expected="i", timestamp=T800K_US),
235 |             Keystroke(char="j", expected="j", timestamp=T900K_US),
    |

tests\models\test_ngram_error.py:234:57: F821 Undefined name `T800K_US`
    |
232 |             Keystroke(char="g", expected="g", timestamp=T600K_US),
233 |             Keystroke(char="h", expected="h", timestamp=T700K_US),
234 |             Keystroke(char="i", expected="i", timestamp=T800K_US),
    |                                                         ^^^^^^^^ F821
235 |             Keystroke(char="j", expected="j", timestamp=T900K_US),
236 |             Keystroke(char="k", expected="k", timestamp=T1000K_US),
    |

tests\models\test_ngram_error.py:235:57: F821 Undefined name `T900K_US`
    |
233 |             Keystroke(char="h", expected="h", timestamp=T700K_US),
234 |             Keystroke(char="i", expected="i", timestamp=T800K_US),
235 |             Keystroke(char="j", expected="j", timestamp=T900K_US),
    |                                                         ^^^^^^^^ F821
236 |             Keystroke(char="k", expected="k", timestamp=T1000K_US),
237 |             Keystroke(char="l", expected="l", timestamp=T1100K_US),
    |

tests\models\test_ngram_error.py:236:57: F821 Undefined name `T1000K_US`
    |
234 |             Keystroke(char="i", expected="i", timestamp=T800K_US),
235 |             Keystroke(char="j", expected="j", timestamp=T900K_US),
236 |             Keystroke(char="k", expected="k", timestamp=T1000K_US),
    |                                                         ^^^^^^^^^ F821
237 |             Keystroke(char="l", expected="l", timestamp=T1100K_US),
238 |             Keystroke(char="m", expected="m", timestamp=T1200K_US),
    |

tests\models\test_ngram_error.py:237:57: F821 Undefined name `T1100K_US`
    |
235 |             Keystroke(char="j", expected="j", timestamp=T900K_US),
236 |             Keystroke(char="k", expected="k", timestamp=T1000K_US),
237 |             Keystroke(char="l", expected="l", timestamp=T1100K_US),
    |                                                         ^^^^^^^^^ F821
238 |             Keystroke(char="m", expected="m", timestamp=T1200K_US),
239 |             Keystroke(char="n", expected="n", timestamp=T1300K_US),
    |

tests\models\test_ngram_error.py:238:57: F821 Undefined name `T1200K_US`
    |
236 |             Keystroke(char="k", expected="k", timestamp=T1000K_US),
237 |             Keystroke(char="l", expected="l", timestamp=T1100K_US),
238 |             Keystroke(char="m", expected="m", timestamp=T1200K_US),
    |                                                         ^^^^^^^^^ F821
239 |             Keystroke(char="n", expected="n", timestamp=T1300K_US),
240 |             Keystroke(char="o", expected="o", timestamp=T1400K_US),
    |

tests\models\test_ngram_error.py:239:57: F821 Undefined name `T1300K_US`
    |
237 |             Keystroke(char="l", expected="l", timestamp=T1100K_US),
238 |             Keystroke(char="m", expected="m", timestamp=T1200K_US),
239 |             Keystroke(char="n", expected="n", timestamp=T1300K_US),
    |                                                         ^^^^^^^^^ F821
240 |             Keystroke(char="o", expected="o", timestamp=T1400K_US),
241 |             Keystroke(char="p", expected="p", timestamp=T1500K_US),
    |

tests\models\test_ngram_error.py:240:57: F821 Undefined name `T1400K_US`
    |
238 |             Keystroke(char="m", expected="m", timestamp=T1200K_US),
239 |             Keystroke(char="n", expected="n", timestamp=T1300K_US),
240 |             Keystroke(char="o", expected="o", timestamp=T1400K_US),
    |                                                         ^^^^^^^^^ F821
241 |             Keystroke(char="p", expected="p", timestamp=T1500K_US),
242 |             Keystroke(char="q", expected="q", timestamp=T1600K_US),
    |

tests\models\test_ngram_error.py:241:57: F821 Undefined name `T1500K_US`
    |
239 |             Keystroke(char="n", expected="n", timestamp=T1300K_US),
240 |             Keystroke(char="o", expected="o", timestamp=T1400K_US),
241 |             Keystroke(char="p", expected="p", timestamp=T1500K_US),
    |                                                         ^^^^^^^^^ F821
242 |             Keystroke(char="q", expected="q", timestamp=T1600K_US),
243 |             Keystroke(char="r", expected="r", timestamp=T1700K_US),
    |

tests\models\test_ngram_error.py:242:57: F821 Undefined name `T1600K_US`
    |
240 |             Keystroke(char="o", expected="o", timestamp=T1400K_US),
241 |             Keystroke(char="p", expected="p", timestamp=T1500K_US),
242 |             Keystroke(char="q", expected="q", timestamp=T1600K_US),
    |                                                         ^^^^^^^^^ F821
243 |             Keystroke(char="r", expected="r", timestamp=T1700K_US),
244 |             Keystroke(char="s", expected="s", timestamp=T1800K_US),
    |

tests\models\test_ngram_error.py:243:57: F821 Undefined name `T1700K_US`
    |
241 |             Keystroke(char="p", expected="p", timestamp=T1500K_US),
242 |             Keystroke(char="q", expected="q", timestamp=T1600K_US),
243 |             Keystroke(char="r", expected="r", timestamp=T1700K_US),
    |                                                         ^^^^^^^^^ F821
244 |             Keystroke(char="s", expected="s", timestamp=T1800K_US),
245 |             Keystroke(char="T", expected="t", timestamp=T1900K_US),
    |

tests\models\test_ngram_error.py:244:57: F821 Undefined name `T1800K_US`
    |
242 |             Keystroke(char="q", expected="q", timestamp=T1600K_US),
243 |             Keystroke(char="r", expected="r", timestamp=T1700K_US),
244 |             Keystroke(char="s", expected="s", timestamp=T1800K_US),
    |                                                         ^^^^^^^^^ F821
245 |             Keystroke(char="T", expected="t", timestamp=T1900K_US),
246 |             Keystroke(char="u", expected="u", timestamp=T2000K_US),
    |

tests\models\test_ngram_error.py:245:57: F821 Undefined name `T1900K_US`
    |
243 |             Keystroke(char="r", expected="r", timestamp=T1700K_US),
244 |             Keystroke(char="s", expected="s", timestamp=T1800K_US),
245 |             Keystroke(char="T", expected="t", timestamp=T1900K_US),
    |                                                         ^^^^^^^^^ F821
246 |             Keystroke(char="u", expected="u", timestamp=T2000K_US),
247 |             Keystroke(char="v", expected="v", timestamp=T2100K_US),
    |

tests\models\test_ngram_error.py:246:57: F821 Undefined name `T2000K_US`
    |
244 |             Keystroke(char="s", expected="s", timestamp=T1800K_US),
245 |             Keystroke(char="T", expected="t", timestamp=T1900K_US),
246 |             Keystroke(char="u", expected="u", timestamp=T2000K_US),
    |                                                         ^^^^^^^^^ F821
247 |             Keystroke(char="v", expected="v", timestamp=T2100K_US),
248 |         ],
    |

tests\models\test_ngram_error.py:247:57: F821 Undefined name `T2100K_US`
    |
245 |             Keystroke(char="T", expected="t", timestamp=T1900K_US),
246 |             Keystroke(char="u", expected="u", timestamp=T2000K_US),
247 |             Keystroke(char="v", expected="v", timestamp=T2100K_US),
    |                                                         ^^^^^^^^^ F821
248 |         ],
249 |         20,
    |

tests\models\test_ngram_error.py:255:57: F821 Undefined name `T0`
    |
253 |     (
254 |         [
255 |             Keystroke(char="a", expected="a", timestamp=T0),
    |                                                         ^^ F821
256 |             Keystroke(char="b", expected="b", timestamp=T100K_US),
257 |             Keystroke(char="c", expected="c", timestamp=T200K_US),
    |

tests\models\test_ngram_error.py:256:57: F821 Undefined name `T100K_US`
    |
254 |         [
255 |             Keystroke(char="a", expected="a", timestamp=T0),
256 |             Keystroke(char="b", expected="b", timestamp=T100K_US),
    |                                                         ^^^^^^^^ F821
257 |             Keystroke(char="c", expected="c", timestamp=T200K_US),
258 |             Keystroke(char="d", expected="d", timestamp=T300K_US),
    |

tests\models\test_ngram_error.py:257:57: F821 Undefined name `T200K_US`
    |
255 |             Keystroke(char="a", expected="a", timestamp=T0),
256 |             Keystroke(char="b", expected="b", timestamp=T100K_US),
257 |             Keystroke(char="c", expected="c", timestamp=T200K_US),
    |                                                         ^^^^^^^^ F821
258 |             Keystroke(char="d", expected="d", timestamp=T300K_US),
259 |             Keystroke(char="e", expected="e", timestamp=T400K_US),
    |

tests\models\test_ngram_error.py:258:57: F821 Undefined name `T300K_US`
    |
256 |             Keystroke(char="b", expected="b", timestamp=T100K_US),
257 |             Keystroke(char="c", expected="c", timestamp=T200K_US),
258 |             Keystroke(char="d", expected="d", timestamp=T300K_US),
    |                                                         ^^^^^^^^ F821
259 |             Keystroke(char="e", expected="e", timestamp=T400K_US),
260 |             Keystroke(char="f", expected="f", timestamp=T500K_US),
    |

tests\models\test_ngram_error.py:259:57: F821 Undefined name `T400K_US`
    |
257 |             Keystroke(char="c", expected="c", timestamp=T200K_US),
258 |             Keystroke(char="d", expected="d", timestamp=T300K_US),
259 |             Keystroke(char="e", expected="e", timestamp=T400K_US),
    |                                                         ^^^^^^^^ F821
260 |             Keystroke(char="f", expected="f", timestamp=T500K_US),
261 |             Keystroke(char="g", expected="g", timestamp=T600K_US),
    |

tests\models\test_ngram_error.py:260:57: F821 Undefined name `T500K_US`
    |
258 |             Keystroke(char="d", expected="d", timestamp=T300K_US),
259 |             Keystroke(char="e", expected="e", timestamp=T400K_US),
260 |             Keystroke(char="f", expected="f", timestamp=T500K_US),
    |                                                         ^^^^^^^^ F821
261 |             Keystroke(char="g", expected="g", timestamp=T600K_US),
262 |             Keystroke(char="h", expected="h", timestamp=T700K_US),
    |

tests\models\test_ngram_error.py:261:57: F821 Undefined name `T600K_US`
    |
259 |             Keystroke(char="e", expected="e", timestamp=T400K_US),
260 |             Keystroke(char="f", expected="f", timestamp=T500K_US),
261 |             Keystroke(char="g", expected="g", timestamp=T600K_US),
    |                                                         ^^^^^^^^ F821
262 |             Keystroke(char="h", expected="h", timestamp=T700K_US),
263 |             Keystroke(char="i", expected="i", timestamp=T800K_US),
    |

tests\models\test_ngram_error.py:262:57: F821 Undefined name `T700K_US`
    |
260 |             Keystroke(char="f", expected="f", timestamp=T500K_US),
261 |             Keystroke(char="g", expected="g", timestamp=T600K_US),
262 |             Keystroke(char="h", expected="h", timestamp=T700K_US),
    |                                                         ^^^^^^^^ F821
263 |             Keystroke(char="i", expected="i", timestamp=T800K_US),
264 |             Keystroke(char="j", expected="j", timestamp=T900K_US),
    |

tests\models\test_ngram_error.py:263:57: F821 Undefined name `T800K_US`
    |
261 |             Keystroke(char="g", expected="g", timestamp=T600K_US),
262 |             Keystroke(char="h", expected="h", timestamp=T700K_US),
263 |             Keystroke(char="i", expected="i", timestamp=T800K_US),
    |                                                         ^^^^^^^^ F821
264 |             Keystroke(char="j", expected="j", timestamp=T900K_US),
265 |             Keystroke(char="k", expected="k", timestamp=T1000K_US),
    |

tests\models\test_ngram_error.py:264:57: F821 Undefined name `T900K_US`
    |
262 |             Keystroke(char="h", expected="h", timestamp=T700K_US),
263 |             Keystroke(char="i", expected="i", timestamp=T800K_US),
264 |             Keystroke(char="j", expected="j", timestamp=T900K_US),
    |                                                         ^^^^^^^^ F821
265 |             Keystroke(char="k", expected="k", timestamp=T1000K_US),
266 |             Keystroke(char="l", expected="l", timestamp=T1100K_US),
    |

tests\models\test_ngram_error.py:265:57: F821 Undefined name `T1000K_US`
    |
263 |             Keystroke(char="i", expected="i", timestamp=T800K_US),
264 |             Keystroke(char="j", expected="j", timestamp=T900K_US),
265 |             Keystroke(char="k", expected="k", timestamp=T1000K_US),
    |                                                         ^^^^^^^^^ F821
266 |             Keystroke(char="l", expected="l", timestamp=T1100K_US),
267 |             Keystroke(char="m", expected="m", timestamp=T1200K_US),
    |

tests\models\test_ngram_error.py:266:57: F821 Undefined name `T1100K_US`
    |
264 |             Keystroke(char="j", expected="j", timestamp=T900K_US),
265 |             Keystroke(char="k", expected="k", timestamp=T1000K_US),
266 |             Keystroke(char="l", expected="l", timestamp=T1100K_US),
    |                                                         ^^^^^^^^^ F821
267 |             Keystroke(char="m", expected="m", timestamp=T1200K_US),
268 |             Keystroke(char="n", expected="n", timestamp=T1300K_US),
    |

tests\models\test_ngram_error.py:267:57: F821 Undefined name `T1200K_US`
    |
265 |             Keystroke(char="k", expected="k", timestamp=T1000K_US),
266 |             Keystroke(char="l", expected="l", timestamp=T1100K_US),
267 |             Keystroke(char="m", expected="m", timestamp=T1200K_US),
    |                                                         ^^^^^^^^^ F821
268 |             Keystroke(char="n", expected="n", timestamp=T1300K_US),
269 |             Keystroke(char="o", expected="o", timestamp=T1400K_US),
    |

tests\models\test_ngram_error.py:268:57: F821 Undefined name `T1300K_US`
    |
266 |             Keystroke(char="l", expected="l", timestamp=T1100K_US),
267 |             Keystroke(char="m", expected="m", timestamp=T1200K_US),
268 |             Keystroke(char="n", expected="n", timestamp=T1300K_US),
    |                                                         ^^^^^^^^^ F821
269 |             Keystroke(char="o", expected="o", timestamp=T1400K_US),
270 |             Keystroke(char="p", expected="p", timestamp=T1500K_US),
    |

tests\models\test_ngram_error.py:269:57: F821 Undefined name `T1400K_US`
    |
267 |             Keystroke(char="m", expected="m", timestamp=T1200K_US),
268 |             Keystroke(char="n", expected="n", timestamp=T1300K_US),
269 |             Keystroke(char="o", expected="o", timestamp=T1400K_US),
    |                                                         ^^^^^^^^^ F821
270 |             Keystroke(char="p", expected="p", timestamp=T1500K_US),
271 |             Keystroke(char="q", expected="q", timestamp=T1600K_US),
    |

tests\models\test_ngram_error.py:270:57: F821 Undefined name `T1500K_US`
    |
268 |             Keystroke(char="n", expected="n", timestamp=T1300K_US),
269 |             Keystroke(char="o", expected="o", timestamp=T1400K_US),
270 |             Keystroke(char="p", expected="p", timestamp=T1500K_US),
    |                                                         ^^^^^^^^^ F821
271 |             Keystroke(char="q", expected="q", timestamp=T1600K_US),
272 |             Keystroke(char="r", expected="r", timestamp=T1700K_US),
    |

tests\models\test_ngram_error.py:271:57: F821 Undefined name `T1600K_US`
    |
269 |             Keystroke(char="o", expected="o", timestamp=T1400K_US),
270 |             Keystroke(char="p", expected="p", timestamp=T1500K_US),
271 |             Keystroke(char="q", expected="q", timestamp=T1600K_US),
    |                                                         ^^^^^^^^^ F821
272 |             Keystroke(char="r", expected="r", timestamp=T1700K_US),
273 |             Keystroke(char="s", expected="s", timestamp=T1800K_US),
    |

tests\models\test_ngram_error.py:272:57: F821 Undefined name `T1700K_US`
    |
270 |             Keystroke(char="p", expected="p", timestamp=T1500K_US),
271 |             Keystroke(char="q", expected="q", timestamp=T1600K_US),
272 |             Keystroke(char="r", expected="r", timestamp=T1700K_US),
    |                                                         ^^^^^^^^^ F821
273 |             Keystroke(char="s", expected="s", timestamp=T1800K_US),
274 |             Keystroke(char="T", expected="t", timestamp=T1900K_US),
    |

tests\models\test_ngram_error.py:273:57: F821 Undefined name `T1800K_US`
    |
271 |             Keystroke(char="q", expected="q", timestamp=T1600K_US),
272 |             Keystroke(char="r", expected="r", timestamp=T1700K_US),
273 |             Keystroke(char="s", expected="s", timestamp=T1800K_US),
    |                                                         ^^^^^^^^^ F821
274 |             Keystroke(char="T", expected="t", timestamp=T1900K_US),
275 |             Keystroke(char="u", expected="u", timestamp=T2000K_US),
    |

tests\models\test_ngram_error.py:274:57: F821 Undefined name `T1900K_US`
    |
272 |             Keystroke(char="r", expected="r", timestamp=T1700K_US),
273 |             Keystroke(char="s", expected="s", timestamp=T1800K_US),
274 |             Keystroke(char="T", expected="t", timestamp=T1900K_US),
    |                                                         ^^^^^^^^^ F821
275 |             Keystroke(char="u", expected="u", timestamp=T2000K_US),
276 |             Keystroke(char="v", expected="v", timestamp=T2100K_US),
    |

tests\models\test_ngram_error.py:275:57: F821 Undefined name `T2000K_US`
    |
273 |             Keystroke(char="s", expected="s", timestamp=T1800K_US),
274 |             Keystroke(char="T", expected="t", timestamp=T1900K_US),
275 |             Keystroke(char="u", expected="u", timestamp=T2000K_US),
    |                                                         ^^^^^^^^^ F821
276 |             Keystroke(char="v", expected="v", timestamp=T2100K_US),
277 |         ],
    |

tests\models\test_ngram_error.py:276:57: F821 Undefined name `T2100K_US`
    |
274 |             Keystroke(char="T", expected="t", timestamp=T1900K_US),
275 |             Keystroke(char="u", expected="u", timestamp=T2000K_US),
276 |             Keystroke(char="v", expected="v", timestamp=T2100K_US),
    |                                                         ^^^^^^^^^ F821
277 |         ],
278 |         20,
    |

tests\models\test_ngram_error.py:284:57: F821 Undefined name `T0`
    |
282 |     (
283 |         [
284 |             Keystroke(char="a", expected="a", timestamp=T0),
    |                                                         ^^ F821
285 |             Keystroke(char="b", expected="b", timestamp=T100K_US),
286 |             Keystroke(char="c", expected="c", timestamp=T200K_US),
    |

tests\models\test_ngram_error.py:285:57: F821 Undefined name `T100K_US`
    |
283 |         [
284 |             Keystroke(char="a", expected="a", timestamp=T0),
285 |             Keystroke(char="b", expected="b", timestamp=T100K_US),
    |                                                         ^^^^^^^^ F821
286 |             Keystroke(char="c", expected="c", timestamp=T200K_US),
287 |             Keystroke(char="d", expected="d", timestamp=T300K_US),
    |

tests\models\test_ngram_error.py:286:57: F821 Undefined name `T200K_US`
    |
284 |             Keystroke(char="a", expected="a", timestamp=T0),
285 |             Keystroke(char="b", expected="b", timestamp=T100K_US),
286 |             Keystroke(char="c", expected="c", timestamp=T200K_US),
    |                                                         ^^^^^^^^ F821
287 |             Keystroke(char="d", expected="d", timestamp=T300K_US),
288 |             Keystroke(char="e", expected="e", timestamp=T400K_US),
    |

tests\models\test_ngram_error.py:287:57: F821 Undefined name `T300K_US`
    |
285 |             Keystroke(char="b", expected="b", timestamp=T100K_US),
286 |             Keystroke(char="c", expected="c", timestamp=T200K_US),
287 |             Keystroke(char="d", expected="d", timestamp=T300K_US),
    |                                                         ^^^^^^^^ F821
288 |             Keystroke(char="e", expected="e", timestamp=T400K_US),
289 |             Keystroke(char="f", expected="f", timestamp=T500K_US),
    |

tests\models\test_ngram_error.py:288:57: F821 Undefined name `T400K_US`
    |
286 |             Keystroke(char="c", expected="c", timestamp=T200K_US),
287 |             Keystroke(char="d", expected="d", timestamp=T300K_US),
288 |             Keystroke(char="e", expected="e", timestamp=T400K_US),
    |                                                         ^^^^^^^^ F821
289 |             Keystroke(char="f", expected="f", timestamp=T500K_US),
290 |             Keystroke(char="g", expected="g", timestamp=T600K_US),
    |

tests\models\test_ngram_error.py:289:57: F821 Undefined name `T500K_US`
    |
287 |             Keystroke(char="d", expected="d", timestamp=T300K_US),
288 |             Keystroke(char="e", expected="e", timestamp=T400K_US),
289 |             Keystroke(char="f", expected="f", timestamp=T500K_US),
    |                                                         ^^^^^^^^ F821
290 |             Keystroke(char="g", expected="g", timestamp=T600K_US),
291 |             Keystroke(char="h", expected="h", timestamp=T700K_US),
    |

tests\models\test_ngram_error.py:290:57: F821 Undefined name `T600K_US`
    |
288 |             Keystroke(char="e", expected="e", timestamp=T400K_US),
289 |             Keystroke(char="f", expected="f", timestamp=T500K_US),
290 |             Keystroke(char="g", expected="g", timestamp=T600K_US),
    |                                                         ^^^^^^^^ F821
291 |             Keystroke(char="h", expected="h", timestamp=T700K_US),
292 |             Keystroke(char="i", expected="i", timestamp=T800K_US),
    |

tests\models\test_ngram_error.py:291:57: F821 Undefined name `T700K_US`
    |
289 |             Keystroke(char="f", expected="f", timestamp=T500K_US),
290 |             Keystroke(char="g", expected="g", timestamp=T600K_US),
291 |             Keystroke(char="h", expected="h", timestamp=T700K_US),
    |                                                         ^^^^^^^^ F821
292 |             Keystroke(char="i", expected="i", timestamp=T800K_US),
293 |             Keystroke(char="j", expected="j", timestamp=T900K_US),
    |

tests\models\test_ngram_error.py:292:57: F821 Undefined name `T800K_US`
    |
290 |             Keystroke(char="g", expected="g", timestamp=T600K_US),
291 |             Keystroke(char="h", expected="h", timestamp=T700K_US),
292 |             Keystroke(char="i", expected="i", timestamp=T800K_US),
    |                                                         ^^^^^^^^ F821
293 |             Keystroke(char="j", expected="j", timestamp=T900K_US),
294 |             Keystroke(char="k", expected="k", timestamp=T1000K_US),
    |

tests\models\test_ngram_error.py:293:57: F821 Undefined name `T900K_US`
    |
291 |             Keystroke(char="h", expected="h", timestamp=T700K_US),
292 |             Keystroke(char="i", expected="i", timestamp=T800K_US),
293 |             Keystroke(char="j", expected="j", timestamp=T900K_US),
    |                                                         ^^^^^^^^ F821
294 |             Keystroke(char="k", expected="k", timestamp=T1000K_US),
295 |             Keystroke(char="l", expected="l", timestamp=T1100K_US),
    |

tests\models\test_ngram_error.py:294:57: F821 Undefined name `T1000K_US`
    |
292 |             Keystroke(char="i", expected="i", timestamp=T800K_US),
293 |             Keystroke(char="j", expected="j", timestamp=T900K_US),
294 |             Keystroke(char="k", expected="k", timestamp=T1000K_US),
    |                                                         ^^^^^^^^^ F821
295 |             Keystroke(char="l", expected="l", timestamp=T1100K_US),
296 |             Keystroke(char="m", expected="m", timestamp=T1200K_US),
    |

tests\models\test_ngram_error.py:295:57: F821 Undefined name `T1100K_US`
    |
293 |             Keystroke(char="j", expected="j", timestamp=T900K_US),
294 |             Keystroke(char="k", expected="k", timestamp=T1000K_US),
295 |             Keystroke(char="l", expected="l", timestamp=T1100K_US),
    |                                                         ^^^^^^^^^ F821
296 |             Keystroke(char="m", expected="m", timestamp=T1200K_US),
297 |             Keystroke(char="n", expected="n", timestamp=T1300K_US),
    |

tests\models\test_ngram_error.py:296:57: F821 Undefined name `T1200K_US`
    |
294 |             Keystroke(char="k", expected="k", timestamp=T1000K_US),
295 |             Keystroke(char="l", expected="l", timestamp=T1100K_US),
296 |             Keystroke(char="m", expected="m", timestamp=T1200K_US),
    |                                                         ^^^^^^^^^ F821
297 |             Keystroke(char="n", expected="n", timestamp=T1300K_US),
298 |             Keystroke(char="o", expected="o", timestamp=T1400K_US),
    |

tests\models\test_ngram_error.py:297:57: F821 Undefined name `T1300K_US`
    |
295 |             Keystroke(char="l", expected="l", timestamp=T1100K_US),
296 |             Keystroke(char="m", expected="m", timestamp=T1200K_US),
297 |             Keystroke(char="n", expected="n", timestamp=T1300K_US),
    |                                                         ^^^^^^^^^ F821
298 |             Keystroke(char="o", expected="o", timestamp=T1400K_US),
299 |             Keystroke(char="p", expected="p", timestamp=T1500K_US),
    |

tests\models\test_ngram_error.py:298:57: F821 Undefined name `T1400K_US`
    |
296 |             Keystroke(char="m", expected="m", timestamp=T1200K_US),
297 |             Keystroke(char="n", expected="n", timestamp=T1300K_US),
298 |             Keystroke(char="o", expected="o", timestamp=T1400K_US),
    |                                                         ^^^^^^^^^ F821
299 |             Keystroke(char="p", expected="p", timestamp=T1500K_US),
300 |             Keystroke(char="q", expected="q", timestamp=T1600K_US),
    |

tests\models\test_ngram_error.py:299:57: F821 Undefined name `T1500K_US`
    |
297 |             Keystroke(char="n", expected="n", timestamp=T1300K_US),
298 |             Keystroke(char="o", expected="o", timestamp=T1400K_US),
299 |             Keystroke(char="p", expected="p", timestamp=T1500K_US),
    |                                                         ^^^^^^^^^ F821
300 |             Keystroke(char="q", expected="q", timestamp=T1600K_US),
301 |             Keystroke(char="r", expected="r", timestamp=T1700K_US),
    |

tests\models\test_ngram_error.py:300:57: F821 Undefined name `T1600K_US`
    |
298 |             Keystroke(char="o", expected="o", timestamp=T1400K_US),
299 |             Keystroke(char="p", expected="p", timestamp=T1500K_US),
300 |             Keystroke(char="q", expected="q", timestamp=T1600K_US),
    |                                                         ^^^^^^^^^ F821
301 |             Keystroke(char="r", expected="r", timestamp=T1700K_US),
302 |             Keystroke(char="s", expected="s", timestamp=T1800K_US),
    |

tests\models\test_ngram_error.py:301:57: F821 Undefined name `T1700K_US`
    |
299 |             Keystroke(char="p", expected="p", timestamp=T1500K_US),
300 |             Keystroke(char="q", expected="q", timestamp=T1600K_US),
301 |             Keystroke(char="r", expected="r", timestamp=T1700K_US),
    |                                                         ^^^^^^^^^ F821
302 |             Keystroke(char="s", expected="s", timestamp=T1800K_US),
303 |             Keystroke(char="T", expected="t", timestamp=T1900K_US),
    |

tests\models\test_ngram_error.py:302:57: F821 Undefined name `T1800K_US`
    |
300 |             Keystroke(char="q", expected="q", timestamp=T1600K_US),
301 |             Keystroke(char="r", expected="r", timestamp=T1700K_US),
302 |             Keystroke(char="s", expected="s", timestamp=T1800K_US),
    |                                                         ^^^^^^^^^ F821
303 |             Keystroke(char="T", expected="t", timestamp=T1900K_US),
304 |             Keystroke(char="u", expected="u", timestamp=T2000K_US),
    |

tests\models\test_ngram_error.py:303:57: F821 Undefined name `T1900K_US`
    |
301 |             Keystroke(char="r", expected="r", timestamp=T1700K_US),
302 |             Keystroke(char="s", expected="s", timestamp=T1800K_US),
303 |             Keystroke(char="T", expected="t", timestamp=T1900K_US),
    |                                                         ^^^^^^^^^ F821
304 |             Keystroke(char="u", expected="u", timestamp=T2000K_US),
305 |             Keystroke(char="v", expected="v", timestamp=T2100K_US),
    |

tests\models\test_ngram_error.py:304:57: F821 Undefined name `T2000K_US`
    |
302 |             Keystroke(char="s", expected="s", timestamp=T1800K_US),
303 |             Keystroke(char="T", expected="t", timestamp=T1900K_US),
304 |             Keystroke(char="u", expected="u", timestamp=T2000K_US),
    |                                                         ^^^^^^^^^ F821
305 |             Keystroke(char="v", expected="v", timestamp=T2100K_US),
306 |         ],
    |

tests\models\test_ngram_error.py:305:57: F821 Undefined name `T2100K_US`
    |
303 |             Keystroke(char="T", expected="t", timestamp=T1900K_US),
304 |             Keystroke(char="u", expected="u", timestamp=T2000K_US),
305 |             Keystroke(char="v", expected="v", timestamp=T2100K_US),
    |                                                         ^^^^^^^^^ F821
306 |         ],
307 |         21,
    |

tests\models\test_ngram_error.py:364:89: E501 Line too long (92 > 88)
    |
362 |     # Generate ngrams and analyze
363 |     ngram_manager = NGramManager(db_manager=None)  # Instantiate real NGramManager
364 |     generated_ngrams = ngram_manager.generate_ngrams_from_keystrokes(keystrokes, ngram_size)
    |                                                                                         ^^^^ E501
365 |
366 |     # Debug output for each generated ngram
    |

tests\models\test_ngram_error.py:382:89: E501 Line too long (99 > 88)
    |
381 |     # Get result for assertion
382 |     error_true_ngram_texts_generated = [ngram.text for ngram in generated_ngrams if ngram.is_error]
    |                                                                                         ^^^^^^^^^^^ E501
383 |     print("\nResults - NGrams with is_error=True:")
384 |     print(f"  Expected: {sorted(expected_ngram_texts_with_error_true)}")
    |

tests\models\test_ngram_manager.py:59:9: ANN204 Missing return type annotation for special method `__init__`
   |
57 |     """Mock database for testing."""
58 |
59 |     def __init__(self, results=None):
   |         ^^^^^^^^ ANN204
60 |         self.results = results or []
61 |         self.last_query = None
   |
   = help: Add return type annotation: `None`

tests\models\test_ngram_manager.py:59:24: ANN001 Missing type annotation for function argument `results`
   |
57 |     """Mock database for testing."""
58 |
59 |     def __init__(self, results=None):
   |                        ^^^^^^^ ANN001
60 |         self.results = results or []
61 |         self.last_query = None
   |

tests\models\test_ngram_manager.py:65:9: ANN201 Missing return type annotation for public function `fetchall`
   |
63 |         self.execute = MagicMock()
64 |
65 |     def fetchall(self, query, params=()):
   |         ^^^^^^^^ ANN201
66 |         self.last_query = query
67 |         self.last_params = params
   |
   = help: Add return type annotation

tests\models\test_ngram_manager.py:65:24: ANN001 Missing type annotation for function argument `query`
   |
63 |         self.execute = MagicMock()
64 |
65 |     def fetchall(self, query, params=()):
   |                        ^^^^^ ANN001
66 |         self.last_query = query
67 |         self.last_params = params
   |

tests\models\test_ngram_manager.py:65:31: ANN001 Missing type annotation for function argument `params`
   |
63 |         self.execute = MagicMock()
64 |
65 |     def fetchall(self, query, params=()):
   |                               ^^^^^^ ANN001
66 |         self.last_query = query
67 |         self.last_params = params
   |

tests\models\test_ngram_manager.py:72:5: ANN201 Missing return type annotation for public function `mock_db`
   |
71 | @pytest.fixture
72 | def mock_db():
   |     ^^^^^^^ ANN201
73 |     """Create a mock database with test data."""
74 |     db = MockDB()
   |
   = help: Add return type annotation

tests\models\test_ngram_manager.py:79:5: ANN201 Missing return type annotation for public function `ngram_manager`
   |
78 | @pytest.fixture
79 | def ngram_manager(mock_db):
   |     ^^^^^^^^^^^^^ ANN201
80 |     """Create an NGramManager instance with a mock database."""
81 |     return NGramManager(mock_db)
   |
   = help: Add return type annotation

tests\models\test_ngram_manager.py:79:19: ANN001 Missing type annotation for function argument `mock_db`
   |
78 | @pytest.fixture
79 | def ngram_manager(mock_db):
   |                   ^^^^^^^ ANN001
80 |     """Create an NGramManager instance with a mock database."""
81 |     return NGramManager(mock_db)
   |

tests\models\test_ngram_manager.py:84:5: ANN201 Missing return type annotation for public function `test_slowest_n_basic`
   |
84 | def test_slowest_n_basic(ngram_manager, mock_db):
   |     ^^^^^^^^^^^^^^^^^^^^ ANN201
85 |     """Test basic functionality of slowest_n method."""
86 |     # Setup
   |
   = help: Add return type annotation: `None`

tests\models\test_ngram_manager.py:84:26: ANN001 Missing type annotation for function argument `ngram_manager`
   |
84 | def test_slowest_n_basic(ngram_manager, mock_db):
   |                          ^^^^^^^^^^^^^ ANN001
85 |     """Test basic functionality of slowest_n method."""
86 |     # Setup
   |

tests\models\test_ngram_manager.py:84:41: ANN001 Missing type annotation for function argument `mock_db`
   |
84 | def test_slowest_n_basic(ngram_manager, mock_db):
   |                                         ^^^^^^^ ANN001
85 |     """Test basic functionality of slowest_n method."""
86 |     # Setup
   |

tests\models\test_ngram_manager.py:131:5: ANN201 Missing return type annotation for public function `test_error_n_basic`
    |
131 | def test_error_n_basic(ngram_manager, mock_db):
    |     ^^^^^^^^^^^^^^^^^^ ANN201
132 |     """Test basic functionality of error_n method."""
133 |     # Setup
    |
    = help: Add return type annotation: `None`

tests\models\test_ngram_manager.py:131:24: ANN001 Missing type annotation for function argument `ngram_manager`
    |
131 | def test_error_n_basic(ngram_manager, mock_db):
    |                        ^^^^^^^^^^^^^ ANN001
132 |     """Test basic functionality of error_n method."""
133 |     # Setup
    |

tests\models\test_ngram_manager.py:131:39: ANN001 Missing type annotation for function argument `mock_db`
    |
131 | def test_error_n_basic(ngram_manager, mock_db):
    |                                       ^^^^^^^ ANN001
132 |     """Test basic functionality of error_n method."""
133 |     # Setup
    |

tests\models\test_ngram_manager.py:171:5: ANN201 Missing return type annotation for public function `test_slowest_n_empty_result`
    |
171 | def test_slowest_n_empty_result(ngram_manager, mock_db):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
172 |     """Test slowest_n with no results."""
173 |     # Setup
    |
    = help: Add return type annotation: `None`

tests\models\test_ngram_manager.py:171:33: ANN001 Missing type annotation for function argument `ngram_manager`
    |
171 | def test_slowest_n_empty_result(ngram_manager, mock_db):
    |                                 ^^^^^^^^^^^^^ ANN001
172 |     """Test slowest_n with no results."""
173 |     # Setup
    |

tests\models\test_ngram_manager.py:171:48: ANN001 Missing type annotation for function argument `mock_db`
    |
171 | def test_slowest_n_empty_result(ngram_manager, mock_db):
    |                                                ^^^^^^^ ANN001
172 |     """Test slowest_n with no results."""
173 |     # Setup
    |

tests\models\test_ngram_manager.py:189:5: ANN201 Missing return type annotation for public function `test_error_n_custom_lookback`
    |
189 | def test_error_n_custom_lookback(ngram_manager, mock_db):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
190 |     """Test error_n with custom lookback distance."""
191 |     # Setup
    |
    = help: Add return type annotation: `None`

tests\models\test_ngram_manager.py:189:34: ANN001 Missing type annotation for function argument `ngram_manager`
    |
189 | def test_error_n_custom_lookback(ngram_manager, mock_db):
    |                                  ^^^^^^^^^^^^^ ANN001
190 |     """Test error_n with custom lookback distance."""
191 |     # Setup
    |

tests\models\test_ngram_manager.py:189:49: ANN001 Missing type annotation for function argument `mock_db`
    |
189 | def test_error_n_custom_lookback(ngram_manager, mock_db):
    |                                                 ^^^^^^^ ANN001
190 |     """Test error_n with custom lookback distance."""
191 |     # Setup
    |

tests\models\test_ngram_manager.py:203:5: ANN201 Missing return type annotation for public function `test_slowest_n_included_keys_basic`
    |
203 | def test_slowest_n_included_keys_basic(ngram_manager, mock_db):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
204 |     """Test objective: Test slowest_n with included_keys parameter basic functionality."""
205 |     # Setup
    |
    = help: Add return type annotation: `None`

tests\models\test_ngram_manager.py:203:40: ANN001 Missing type annotation for function argument `ngram_manager`
    |
203 | def test_slowest_n_included_keys_basic(ngram_manager, mock_db):
    |                                        ^^^^^^^^^^^^^ ANN001
204 |     """Test objective: Test slowest_n with included_keys parameter basic functionality."""
205 |     # Setup
    |

tests\models\test_ngram_manager.py:203:55: ANN001 Missing type annotation for function argument `mock_db`
    |
203 | def test_slowest_n_included_keys_basic(ngram_manager, mock_db):
    |                                                       ^^^^^^^ ANN001
204 |     """Test objective: Test slowest_n with included_keys parameter basic functionality."""
205 |     # Setup
    |

tests\models\test_ngram_manager.py:204:89: E501 Line too long (90 > 88)
    |
203 | def test_slowest_n_included_keys_basic(ngram_manager, mock_db):
204 |     """Test objective: Test slowest_n with included_keys parameter basic functionality."""
    |                                                                                         ^^ E501
205 |     # Setup
206 |     mock_db.results = [
    |

tests\models\test_ngram_manager.py:244:5: ANN201 Missing return type annotation for public function `test_slowest_n_included_keys_no_filter`
    |
244 | def test_slowest_n_included_keys_no_filter(ngram_manager, mock_db):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
245 |     """Test objective: Test slowest_n with included_keys=None (no filtering)."""
246 |     # Setup
    |
    = help: Add return type annotation: `None`

tests\models\test_ngram_manager.py:244:44: ANN001 Missing type annotation for function argument `ngram_manager`
    |
244 | def test_slowest_n_included_keys_no_filter(ngram_manager, mock_db):
    |                                            ^^^^^^^^^^^^^ ANN001
245 |     """Test objective: Test slowest_n with included_keys=None (no filtering)."""
246 |     # Setup
    |

tests\models\test_ngram_manager.py:244:59: ANN001 Missing type annotation for function argument `mock_db`
    |
244 | def test_slowest_n_included_keys_no_filter(ngram_manager, mock_db):
    |                                                           ^^^^^^^ ANN001
245 |     """Test objective: Test slowest_n with included_keys=None (no filtering)."""
246 |     # Setup
    |

tests\models\test_ngram_manager.py:259:89: E501 Line too long (96 > 88)
    |
258 |     # Test with no included_keys filter
259 |     result = ngram_manager.slowest_n(2, TEST_KEYBOARD_ID, TEST_USER_ID, [3], included_keys=None)
    |                                                                                         ^^^^^^^^ E501
260 |
261 |     # Verify results
    |

tests\models\test_ngram_manager.py:270:5: ANN201 Missing return type annotation for public function `test_slowest_n_included_keys_empty_list`
    |
270 | def test_slowest_n_included_keys_empty_list(ngram_manager, mock_db):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
271 |     """Test objective: Test slowest_n with empty included_keys list."""
272 |     # Setup
    |
    = help: Add return type annotation: `None`

tests\models\test_ngram_manager.py:270:45: ANN001 Missing type annotation for function argument `ngram_manager`
    |
270 | def test_slowest_n_included_keys_empty_list(ngram_manager, mock_db):
    |                                             ^^^^^^^^^^^^^ ANN001
271 |     """Test objective: Test slowest_n with empty included_keys list."""
272 |     # Setup
    |

tests\models\test_ngram_manager.py:270:60: ANN001 Missing type annotation for function argument `mock_db`
    |
270 | def test_slowest_n_included_keys_empty_list(ngram_manager, mock_db):
    |                                                            ^^^^^^^ ANN001
271 |     """Test objective: Test slowest_n with empty included_keys list."""
272 |     # Setup
    |

tests\models\test_ngram_manager.py:276:89: E501 Line too long (94 > 88)
    |
275 |     # Test with empty included_keys list
276 |     result = ngram_manager.slowest_n(2, TEST_KEYBOARD_ID, TEST_USER_ID, [3], included_keys=[])
    |                                                                                         ^^^^^^ E501
277 |
278 |     # Verify results
    |

tests\models\test_ngram_manager.py:286:5: ANN201 Missing return type annotation for public function `test_error_n_included_keys_basic`
    |
286 | def test_error_n_included_keys_basic(ngram_manager, mock_db):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
287 |     """Test objective: Test error_n with included_keys parameter basic functionality."""
288 |     # Setup
    |
    = help: Add return type annotation: `None`

tests\models\test_ngram_manager.py:286:38: ANN001 Missing type annotation for function argument `ngram_manager`
    |
286 | def test_error_n_included_keys_basic(ngram_manager, mock_db):
    |                                      ^^^^^^^^^^^^^ ANN001
287 |     """Test objective: Test error_n with included_keys parameter basic functionality."""
288 |     # Setup
    |

tests\models\test_ngram_manager.py:286:53: ANN001 Missing type annotation for function argument `mock_db`
    |
286 | def test_error_n_included_keys_basic(ngram_manager, mock_db):
    |                                                     ^^^^^^^ ANN001
287 |     """Test objective: Test error_n with included_keys parameter basic functionality."""
288 |     # Setup
    |

tests\models\test_ngram_manager.py:325:5: ANN201 Missing return type annotation for public function `test_error_n_included_keys_no_filter`
    |
325 | def test_error_n_included_keys_no_filter(ngram_manager, mock_db):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
326 |     """Test objective: Test error_n with included_keys=None (no filtering)."""
327 |     # Setup
    |
    = help: Add return type annotation: `None`

tests\models\test_ngram_manager.py:325:42: ANN001 Missing type annotation for function argument `ngram_manager`
    |
325 | def test_error_n_included_keys_no_filter(ngram_manager, mock_db):
    |                                          ^^^^^^^^^^^^^ ANN001
326 |     """Test objective: Test error_n with included_keys=None (no filtering)."""
327 |     # Setup
    |

tests\models\test_ngram_manager.py:325:57: ANN001 Missing type annotation for function argument `mock_db`
    |
325 | def test_error_n_included_keys_no_filter(ngram_manager, mock_db):
    |                                                         ^^^^^^^ ANN001
326 |     """Test objective: Test error_n with included_keys=None (no filtering)."""
327 |     # Setup
    |

tests\models\test_ngram_manager.py:339:89: E501 Line too long (94 > 88)
    |
338 |     # Test with no included_keys filter
339 |     result = ngram_manager.error_n(2, TEST_KEYBOARD_ID, TEST_USER_ID, [3], included_keys=None)
    |                                                                                         ^^^^^^ E501
340 |
341 |     # Verify results
    |

tests\models\test_ngram_manager.py:350:5: ANN201 Missing return type annotation for public function `test_error_n_included_keys_empty_list`
    |
350 | def test_error_n_included_keys_empty_list(ngram_manager, mock_db):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
351 |     """Test objective: Test error_n with empty included_keys list."""
352 |     # Setup
    |
    = help: Add return type annotation: `None`

tests\models\test_ngram_manager.py:350:43: ANN001 Missing type annotation for function argument `ngram_manager`
    |
350 | def test_error_n_included_keys_empty_list(ngram_manager, mock_db):
    |                                           ^^^^^^^^^^^^^ ANN001
351 |     """Test objective: Test error_n with empty included_keys list."""
352 |     # Setup
    |

tests\models\test_ngram_manager.py:350:58: ANN001 Missing type annotation for function argument `mock_db`
    |
350 | def test_error_n_included_keys_empty_list(ngram_manager, mock_db):
    |                                                          ^^^^^^^ ANN001
351 |     """Test objective: Test error_n with empty included_keys list."""
352 |     # Setup
    |

tests\models\test_ngram_manager.py:356:89: E501 Line too long (92 > 88)
    |
355 |     # Test with empty included_keys list
356 |     result = ngram_manager.error_n(2, TEST_KEYBOARD_ID, TEST_USER_ID, [3], included_keys=[])
    |                                                                                         ^^^^ E501
357 |
358 |     # Verify results
    |

tests\models\test_ngram_manager.py:369:9: ANN201 Missing return type annotation for public function `test_delete_all_ngrams_success`
    |
367 |     """Test cases for NGramManager class."""
368 |
369 |     def test_delete_all_ngrams_success(self, mock_db):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
370 |         """Test that delete_all_ngrams deletes all n-gram data."""
371 |         # Setup
    |
    = help: Add return type annotation: `None`

tests\models\test_ngram_manager.py:369:46: ANN001 Missing type annotation for function argument `mock_db`
    |
367 |     """Test cases for NGramManager class."""
368 |
369 |     def test_delete_all_ngrams_success(self, mock_db):
    |                                              ^^^^^^^ ANN001
370 |         """Test that delete_all_ngrams deletes all n-gram data."""
371 |         # Setup
    |

tests\models\test_ngram_manager.py:386:9: ANN201 Missing return type annotation for public function `test_delete_all_ngrams_error`
    |
384 |         assert "DELETE FROM session_ngram_errors" in calls
385 |
386 |     def test_delete_all_ngrams_error(self, mock_db):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
387 |         """Test that delete_all_ngrams handles database errors."""
388 |         # Setup
    |
    = help: Add return type annotation: `None`

tests\models\test_ngram_manager.py:386:44: ANN001 Missing type annotation for function argument `mock_db`
    |
384 |         assert "DELETE FROM session_ngram_errors" in calls
385 |
386 |     def test_delete_all_ngrams_error(self, mock_db):
    |                                            ^^^^^^^ ANN001
387 |         """Test that delete_all_ngrams handles database errors."""
388 |         # Setup
    |

tests\models\test_ngram_models.py:67:89: E501 Line too long (90 > 88)
   |
65 | #     snippet_id = str(uuid.uuid4())
66 | #     temp_db_file.execute(
67 | #         "INSERT INTO snippets (snippet_id, category_id, snippet_name) VALUES (?, ?, ?)",
   |                                                                                         ^^ E501
68 | #         (snippet_id, sample_category, "Test Snippet"),
69 | #     )
   |

tests\models\test_ngram_models.py:78:89: E501 Line too long (216 > 88)
   |
76 | ΓÇª
77 | ΓÇª
78 | ΓÇªrt, snippet_index_end, content, start_time, end_time, actual_chars, errors, ms_per_keystroke) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)",
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
79 | ΓÇª
80 | ΓÇª
   |

tests\models\test_ngram_models.py:136:89: E501 Line too long (91 > 88)
    |
134 | # def test_practice_session(temp_db: DatabaseManager) -> Session:
135 | #     """
136 | #     Test objective: Create a test session for NGram analysis using the new Session model.
    |                                                                                         ^^^ E501
137 |
138 | #     This fixture creates a minimal session suitable for testing, using only the new required fields.
    |

tests\models\test_ngram_models.py:138:89: E501 Line too long (102 > 88)
    |
136 | #     Test objective: Create a test session for NGram analysis using the new Session model.
137 |
138 | #     This fixture creates a minimal session suitable for testing, using only the new required fields.
    |                                                                                         ^^^^^^^^^^^^^^ E501
139 | #     It sets up all required database dependencies (category and snippet) using manager classes.
140 | #     """
    |

tests\models\test_ngram_models.py:139:89: E501 Line too long (97 > 88)
    |
138 | #     This fixture creates a minimal session suitable for testing, using only the new required fields.
139 | #     It sets up all required database dependencies (category and snippet) using manager classes.
    |                                                                                         ^^^^^^^^^ E501
140 | #     """
141 | #     # Create a category using CategoryManager
    |

tests\models\test_ngram_models.py:179:89: E501 Line too long (99 > 88)
    |
178 | # @pytest.fixture
179 | # def test_keystrokes(temp_db: DatabaseManager, test_practice_session: Session) -> List[Keystroke]:
    |                                                                                         ^^^^^^^^^^^ E501
180 | #     """
181 | #     Test objective: Create test keystrokes for NGram analysis.
    |

tests\models\test_ngram_models.py:183:89: E501 Line too long (98 > 88)
    |
181 | #     Test objective: Create test keystrokes for NGram analysis.
182 |
183 | #     This fixture creates two keystrokes associated with the test session using KeystrokeManager.
    |                                                                                         ^^^^^^^^^^ E501
184 | #     """
185 | #     # Create two keystrokes with the session_id
    |

tests\models\test_ngram_models.py:216:89: E501 Line too long (100 > 88)
    |
215 | # @pytest.fixture
216 | # def single_keystroke(temp_db: DatabaseManager, test_practice_session: Session) -> List[Keystroke]:
    |                                                                                         ^^^^^^^^^^^^ E501
217 | #     """
218 | #     Test objective: Create a single keystroke for testing no n-gram scenario.
    |

tests\models\test_ngram_models.py:238:89: E501 Line too long (114 > 88)
    |
236 | #         """
237 | #         INSERT INTO session_keystrokes
238 | #         (session_id, keystroke_id, keystroke_time, keystroke_char, expected_char, is_error, time_since_previous)
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
239 | #         VALUES (?, ?, ?, ?, ?, ?, ?)
240 | #         """,
    |

tests\models\test_ngram_models.py:293:89: E501 Line too long (118 > 88)
    |
291 | #             """
292 | #             INSERT INTO session_keystrokes
293 | #             (session_id, keystroke_id, keystroke_time, keystroke_char, expected_char, is_error, time_since_previous)
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
294 | #             VALUES (?, ?, ?, ?, ?, ?, ?)
295 | #             """,
    |

tests\models\test_ngram_models.py:350:89: E501 Line too long (118 > 88)
    |
348 | #             """
349 | #             INSERT INTO session_keystrokes
350 | #             (session_id, keystroke_id, keystroke_time, keystroke_char, expected_char, is_error, time_since_previous)
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
351 | #             VALUES (?, ?, ?, ?, ?, ?, ?)
352 | #             """,
    |

tests\models\test_ngram_models.py:407:89: E501 Line too long (118 > 88)
    |
405 | #             """
406 | #             INSERT INTO session_keystrokes
407 | #             (session_id, keystroke_id, keystroke_time, keystroke_char, expected_char, is_error, time_since_previous)
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
408 | #             VALUES (?, ?, ?, ?, ?, ?, ?)
409 | #             """,
    |

tests\models\test_ngram_models.py:429:89: E501 Line too long (92 > 88)
    |
427 | # ) -> List[Keystroke]:
428 | #     """
429 | #     Test objective: Create three correct keystrokes for testing multiple n-gram formation.
    |                                                                                         ^^^^ E501
430 |
431 | #     This fixture creates three keystrokes ('T', 'h', and 'e') with no errors and
    |

tests\models\test_ngram_models.py:458:89: E501 Line too long (92 > 88)
    |
456 | #             session_id=test_practice_session.session_id,
457 | #             keystroke_id=str(uuid.uuid4()),
458 | #             keystroke_time=now + datetime.timedelta(milliseconds=1500),  # 1500 from start
    |                                                                                         ^^^^ E501
459 | #             keystroke_char="e",
460 | #             expected_char="e",
    |

tests\models\test_ngram_models.py:471:89: E501 Line too long (118 > 88)
    |
469 | #             """
470 | #             INSERT INTO session_keystrokes
471 | #             (session_id, keystroke_id, keystroke_time, keystroke_char, expected_char, is_error, time_since_previous)
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
472 | #             VALUES (?, ?, ?, ?, ?, ?, ?)
473 | #             """,
    |

tests\models\test_ngram_models.py:490:89: E501 Line too long (95 > 88)
    |
488 | # @pytest.fixture
489 | # def three_keystrokes_error_at_first(
490 | #     temp_db: DatabaseManager, test_practice_session: Session, three_keystrokes_error_at_first
    |                                                                                         ^^^^^^^ E501
491 | # ) -> None:
492 | #     """
    |

tests\models\test_ngram_models.py:493:89: E501 Line too long (111 > 88)
    |
491 | # ) -> None:
492 | #     """
493 | #     Test objective: Verify that three keystrokes with an error on the first keystroke are analyzed correctly.
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^ E501
494 |
495 | #     Scenario:
    |

tests\models\test_ngram_models.py:513:89: E501 Line too long (89 > 88)
    |
511 | #     # No speed n-grams should be present
512 | #     for size in range(2, 6):
513 | #         assert size not in manager.speed_ngrams or len(manager.speed_ngrams[size]) == 0
    |                                                                                         ^ E501
514 |
515 | #     # Error n-grams: bigram 'Gh', trigram 'Ghe'
    |

tests\models\test_ngram_models.py:530:89: E501 Line too long (118 > 88)
    |
528 | #     )[0] == 0
529 | #     db_errors = temp_db.fetchall(
530 | #         "SELECT ngram_size, ngram FROM session_ngram_errors WHERE session_id = ? ORDER BY ngram_size", (session_id,)
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
531 | #     )
532 | #     assert len(db_errors) == 2
    |

tests\models\test_ngram_models.py:538:89: E501 Line too long (96 > 88)
    |
537 | # def test_three_keystrokes_error_at_second(
538 | #     temp_db: DatabaseManager, test_practice_session: Session, three_keystrokes_error_at_second
    |                                                                                         ^^^^^^^^ E501
539 | # ) -> None:
540 | #     """
    |

tests\models\test_ngram_models.py:541:89: E501 Line too long (112 > 88)
    |
539 | # ) -> None:
540 | #     """
541 | #     Test objective: Verify that three keystrokes with an error on the second keystroke are analyzed correctly.
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^ E501
542 |
543 | #     Scenario:
    |

tests\models\test_ngram_models.py:561:89: E501 Line too long (89 > 88)
    |
559 | #     # No speed n-grams
560 | #     for size in range(2, 6):
561 | #         assert size not in manager.speed_ngrams or len(manager.speed_ngrams[size]) == 0
    |                                                                                         ^ E501
562 | #     # Error n-grams: only 'Tb'
563 | #     assert 2 in manager.error_ngrams and len(manager.error_ngrams[2]) == 1
    |

tests\models\test_ngram_models.py:572:89: E501 Line too long (97 > 88)
    |
570 | #     assert manager.save_to_database() is True
571 | #     db_speed = temp_db.fetchall(
572 | #         "SELECT ngram_size, ngram FROM session_ngram_speed WHERE session_id = ?", (session_id,)
    |                                                                                         ^^^^^^^^^ E501
573 | #     )
574 | #     db_errors = temp_db.fetchall(
    |

tests\models\test_ngram_models.py:575:89: E501 Line too long (98 > 88)
    |
573 | #     )
574 | #     db_errors = temp_db.fetchall(
575 | #         "SELECT ngram_size, ngram FROM session_ngram_errors WHERE session_id = ?", (session_id,)
    |                                                                                         ^^^^^^^^^^ E501
576 | #     )
577 | #     assert len(db_speed) == 0
    |

tests\models\test_ngram_models.py:582:89: E501 Line too long (95 > 88)
    |
581 | # def test_three_keystrokes_error_at_third(
582 | #     temp_db: DatabaseManager, test_practice_session: Session, three_keystrokes_error_at_third
    |                                                                                         ^^^^^^^ E501
583 | # ) -> None:
584 | #     """
    |

tests\models\test_ngram_models.py:585:89: E501 Line too long (111 > 88)
    |
583 | # ) -> None:
584 | #     """
585 | #     Test objective: Verify that three keystrokes with an error on the third keystroke are analyzed correctly.
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^ E501
586 |
587 | #     Scenario:
    |

tests\models\test_ngram_models.py:619:89: E501 Line too long (97 > 88)
    |
617 | #     assert manager.save_to_database() is True
618 | #     db_speed = temp_db.fetchall(
619 | #         "SELECT ngram_size, ngram FROM session_ngram_speed WHERE session_id = ?", (session_id,)
    |                                                                                         ^^^^^^^^^ E501
620 | #     )
621 | #     db_errors = temp_db.fetchall(
    |

tests\models\test_ngram_models.py:622:89: E501 Line too long (98 > 88)
    |
620 | #     )
621 | #     db_errors = temp_db.fetchall(
622 | #         "SELECT ngram_size, ngram FROM session_ngram_errors WHERE session_id = ?", (session_id,)
    |                                                                                         ^^^^^^^^^^ E501
623 | #     )
624 | #     assert len(db_speed) == 1 and db_speed[0][1] == 'Th'
    |

tests\models\test_ngram_models.py:652:89: E501 Line too long (94 > 88)
    |
651 | #         # Assert session and keystroke setup
652 | #         assert test_practice_session.session_id is not None, "Session ID should not be None"
    |                                                                                         ^^^^^^ E501
653 | #         assert len(test_keystrokes) == 2, "Should have exactly 2 keystrokes"
654 | #         # Verify keystrokes have correct properties
    |

tests\models\test_ngram_models.py:655:89: E501 Line too long (90 > 88)
    |
653 | #         assert len(test_keystrokes) == 2, "Should have exactly 2 keystrokes"
654 | #         # Verify keystrokes have correct properties
655 | #         assert test_keystrokes[0].keystroke_char == "t", "First keystroke should be 't'"
    |                                                                                         ^^ E501
656 | #         assert test_keystrokes[1].keystroke_char == "e", "Second keystroke should be 'e'"
    |

tests\models\test_ngram_models.py:656:89: E501 Line too long (91 > 88)
    |
654 | #         # Verify keystrokes have correct properties
655 | #         assert test_keystrokes[0].keystroke_char == "t", "First keystroke should be 't'"
656 | #         assert test_keystrokes[1].keystroke_char == "e", "Second keystroke should be 'e'"
    |                                                                                         ^^^ E501
657 |
658 | #     def test_single_keystroke_no_ngrams(
    |

tests\models\test_ngram_models.py:695:89: E501 Line too long (93 > 88)
    |
693 | #         # Assert no n-grams found
694 | #         for size in range(2, 6):
695 | #             assert size not in manager.speed_ngrams or len(manager.speed_ngrams[size]) == 0
    |                                                                                         ^^^^^ E501
696 | #             assert size not in manager.error_ngrams or len(manager.error_ngrams[size]) == 0
697 | #         # Save to DB and check
    |

tests\models\test_ngram_models.py:696:89: E501 Line too long (93 > 88)
    |
694 | #         for size in range(2, 6):
695 | #             assert size not in manager.speed_ngrams or len(manager.speed_ngrams[size]) == 0
696 | #             assert size not in manager.error_ngrams or len(manager.error_ngrams[size]) == 0
    |                                                                                         ^^^^^ E501
697 | #         # Save to DB and check
698 | #         assert manager.save_to_database() is True
    |

tests\models\test_ngram_models.py:700:89: E501 Line too long (107 > 88)
    |
698 | #         assert manager.save_to_database() is True
699 | #         assert temp_db_file.fetchone(
700 | #             "SELECT COUNT(*) FROM session_ngram_speed WHERE session_id = ?", (sample_session.session_id,)
    |                                                                                         ^^^^^^^^^^^^^^^^^^^ E501
701 | #         )[0] == 0
702 | #         assert temp_db_file.fetchone(
    |

tests\models\test_ngram_models.py:703:89: E501 Line too long (108 > 88)
    |
701 | #         )[0] == 0
702 | #         assert temp_db_file.fetchone(
703 | #             "SELECT COUNT(*) FROM session_ngram_errors WHERE session_id = ?", (sample_session.session_id,)
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^ E501
704 | #         )[0] == 0
    |

tests\models\test_ngram_models.py:710:89: E501 Line too long (97 > 88)
    |
708 | #     ):
709 | #         """
710 | #         Test objective: Verify that two keystrokes produce a single bigram with correct timing.
    |                                                                                         ^^^^^^^^^ E501
711 | #         """
712 | #         now = datetime.datetime.now()
    |

tests\models\test_ngram_models.py:761:89: E501 Line too long (102 > 88)
    |
759 | #         assert manager.save_to_database() is True
760 | #         db_bigrams = temp_db_file.fetchall(
761 | #             "SELECT ngram_size, ngram, ngram_time_ms FROM session_ngram_speed WHERE session_id = ?",
    |                                                                                         ^^^^^^^^^^^^^^ E501
762 | #             (sample_session.session_id,)
763 | #         )
    |

tests\models\test_ngram_models.py:768:89: E501 Line too long (108 > 88)
    |
766 | #         assert db_bigrams[0][2] == 250
767 | #         assert temp_db_file.fetchone(
768 | #             "SELECT COUNT(*) FROM session_ngram_errors WHERE session_id = ?", (sample_session.session_id,)
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^ E501
769 | #         )[0] == 0
    |

tests\models\test_ngram_models.py:775:89: E501 Line too long (113 > 88)
    |
773 | #     ):
774 | #         """
775 | #         Test objective: Verify that two keystrokes with an error on the first keystroke are analyzed correctly.
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^ E501
776 | #         """
777 | #         now = datetime.datetime.now()
    |

tests\models\test_ngram_models.py:820:89: E501 Line too long (107 > 88)
    |
818 | #         assert manager.save_to_database() is True
819 | #         assert temp_db_file.fetchone(
820 | #             "SELECT COUNT(*) FROM session_ngram_speed WHERE session_id = ?", (sample_session.session_id,)
    |                                                                                         ^^^^^^^^^^^^^^^^^^^ E501
821 | #         )[0] == 0
822 | #         assert temp_db_file.fetchone(
    |

tests\models\test_ngram_models.py:823:89: E501 Line too long (108 > 88)
    |
821 | #         )[0] == 0
822 | #         assert temp_db_file.fetchone(
823 | #             "SELECT COUNT(*) FROM session_ngram_errors WHERE session_id = ?", (sample_session.session_id,)
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^ E501
824 | #         )[0] == 0
    |

tests\models\test_ngram_models.py:830:89: E501 Line too long (114 > 88)
    |
828 | #     ):
829 | #         """
830 | #         Test objective: Verify that two keystrokes with an error on the second keystroke are analyzed correctly.
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
831 | #         """
832 | #         now = datetime.datetime.now()
    |

tests\models\test_ngram_models.py:887:89: E501 Line too long (107 > 88)
    |
885 | #         assert db_errors[0][1] == "Tb"
886 | #         assert temp_db_file.fetchone(
887 | #             "SELECT COUNT(*) FROM session_ngram_speed WHERE session_id = ?", (sample_session.session_id,)
    |                                                                                         ^^^^^^^^^^^^^^^^^^^ E501
888 | #         )[0] == 0
    |

tests\models\test_ngram_models.py:894:89: E501 Line too long (110 > 88)
    |
892 | #     ):
893 | #         """
894 | #         Test objective: Verify that three keystrokes produce correct bigrams and trigram with proper timing.
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^ E501
895 | #         """
896 | #         now = datetime.datetime.now()
    |

tests\models\test_ngram_models.py:946:89: E501 Line too long (89 > 88)
    |
944 | #         assert 2 in manager.speed_ngrams and len(manager.speed_ngrams[2]) == 2
945 | #         assert 3 in manager.speed_ngrams and len(manager.speed_ngrams[3]) == 1
946 | #         bigram1 = next((ng for ng in manager.speed_ngrams[2] if ng.text == "Th"), None)
    |                                                                                         ^ E501
947 | #         bigram2 = next((ng for ng in manager.speed_ngrams[2] if ng.text == "he"), None)
948 | #         trigram = manager.speed_ngrams[3][0]
    |

tests\models\test_ngram_models.py:947:89: E501 Line too long (89 > 88)
    |
945 | #         assert 3 in manager.speed_ngrams and len(manager.speed_ngrams[3]) == 1
946 | #         bigram1 = next((ng for ng in manager.speed_ngrams[2] if ng.text == "Th"), None)
947 | #         bigram2 = next((ng for ng in manager.speed_ngrams[2] if ng.text == "he"), None)
    |                                                                                         ^ E501
948 | #         trigram = manager.speed_ngrams[3][0]
949 | #         assert bigram1 is not None and bigram1.total_time_ms == 500
    |

tests\models\test_ngram_models.py:952:89: E501 Line too long (93 > 88)
    |
950 | #         assert bigram2 is not None and bigram2.total_time_ms == 1000
951 | #         assert trigram.text == "The" and trigram.total_time_ms == 1500
952 | #         assert all(ng.is_clean for ng in manager.speed_ngrams[2] + manager.speed_ngrams[3])
    |                                                                                         ^^^^^ E501
953 | #         assert manager.save_to_database() is True
954 | #         db_speed = temp_db_file.fetchall(
    |

tests\models\test_ngram_models.py:955:89: E501 Line too long (102 > 88)
    |
953 | #         assert manager.save_to_database() is True
954 | #         db_speed = temp_db_file.fetchall(
955 | #             "SELECT ngram_size, ngram, ngram_time_ms FROM session_ngram_speed WHERE session_id = ?",
    |                                                                                         ^^^^^^^^^^^^^^ E501
956 | #             (sample_session.session_id,)
957 | #         )
    |

tests\models\test_ngram_models.py:960:89: E501 Line too long (108 > 88)
    |
958 | #         assert len(db_speed) == 3
959 | #         assert temp_db_file.fetchone(
960 | #             "SELECT COUNT(*) FROM session_ngram_errors WHERE session_id = ?", (sample_session.session_id,)
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^ E501
961 | #         )[0] == 0
    |

tests\models\test_ngram_models.py:970:89: E501 Line too long (115 > 88)
    |
968 | #     ) -> None:
969 | #         """
970 | #         Test objective: Verify that three keystrokes with an error on the first keystroke are analyzed correctly.
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
971 |
972 | #         This test checks a scenario where:
    |

tests\models\test_ngram_models.py:992:89: E501 Line too long (91 > 88)
    |
991 | #         # Verify analysis was completed
992 | #         assert manager.analysis_complete is True, "Analysis should be marked as complete"
    |                                                                                         ^^^ E501
993 |
994 | #         # VERIFY OBJECT STATE:
    |

tests\models\test_ngram_models.py:1003:89: E501 Line too long (98 > 88)
     |
1002 | #         # 2. Verify exactly one error bigram was identified
1003 | #         assert 2 in manager.error_ngrams, "Error n-grams dictionary should have key for bigrams"
     |                                                                                         ^^^^^^^^^^ E501
1004 | #         assert len(manager.error_ngrams[2]) == 1, "Should be exactly one error bigram"
     |

tests\models\test_ngram_models.py:1016:89: E501 Line too long (91 > 88)
     |
1014 | #         )
1015 | #         assert error_bigram.size == 2, "Error bigram size should be 2"
1016 | #         assert len(error_bigram.keystrokes) == 2, "Error bigram should have 2 keystrokes"
     |                                                                                         ^^^ E501
1017 | #         assert error_bigram.total_time_ms == 500, "Error bigram 'Gh' time should be 500ms"
     |

tests\models\test_ngram_models.py:1017:89: E501 Line too long (92 > 88)
     |
1015 | #         assert error_bigram.size == 2, "Error bigram size should be 2"
1016 | #         assert len(error_bigram.keystrokes) == 2, "Error bigram should have 2 keystrokes"
1017 | #         assert error_bigram.total_time_ms == 500, "Error bigram 'Gh' time should be 500ms"
     |                                                                                         ^^^^ E501
1018 |
1019 | #         # 4. Verify error bigram properties
     |

tests\models\test_ngram_models.py:1021:89: E501 Line too long (91 > 88)
     |
1019 | #         # 4. Verify error bigram properties
1020 | #         assert error_bigram.is_clean is False, "Error bigram should not be clean"
1021 | #         assert error_bigram.is_error is True, "Error bigram should be marked as an error"
     |                                                                                         ^^^ E501
1022 |
1023 | #         # 5. Check that the error bigram is still valid for tracking despite having an error
     |

tests\models\test_ngram_models.py:1023:89: E501 Line too long (94 > 88)
     |
1021 | #         assert error_bigram.is_error is True, "Error bigram should be marked as an error"
1022 |
1023 | #         # 5. Check that the error bigram is still valid for tracking despite having an error
     |                                                                                         ^^^^^^ E501
1024 | #         # This might differ based on your implementation - adjust if needed
1025 | #         if not error_bigram.is_valid:
     |

tests\models\test_ngram_models.py:1027:89: E501 Line too long (101 > 88)
     |
1025 | #         if not error_bigram.is_valid:
1026 | #             print(
1027 | #                 "Note: In this implementation, error bigrams are not considered valid for tracking"
     |                                                                                         ^^^^^^^^^^^^^ E501
1028 | #             )
     |

tests\models\test_ngram_models.py:1038:89: E501 Line too long (89 > 88)
     |
1037 | #         # VERIFY DATABASE STATE:
1038 | #         # Save to database - temporarily skip this assertion to see if later tests work
     |                                                                                         ^ E501
1039 |
1040 | #         # We'll assert the database contents directly instead of relying on the save operation result
     |

tests\models\test_ngram_models.py:1040:89: E501 Line too long (103 > 88)
     |
1038 | #         # Save to database - temporarily skip this assertion to see if later tests work
1039 |
1040 | #         # We'll assert the database contents directly instead of relying on the save operation result
     |                                                                                         ^^^^^^^^^^^^^^^ E501
1041 |
1042 | #         # 1. Verify no n-grams were saved to the speed table
     |

tests\models\test_ngram_models.py:1044:89: E501 Line too long (92 > 88)
     |
1042 | #         # 1. Verify no n-grams were saved to the speed table
1043 | #         speed_ngrams_count = temp_db.fetchone(
1044 | #             "SELECT COUNT(*) FROM session_ngram_speed WHERE session_id = ?", (session_id,)
     |                                                                                         ^^^^ E501
1045 | #         )[0]
1046 | #         assert speed_ngrams_count == 0, "No speed n-grams should be saved to the database"
     |

tests\models\test_ngram_models.py:1046:89: E501 Line too long (92 > 88)
     |
1044 | #             "SELECT COUNT(*) FROM session_ngram_speed WHERE session_id = ?", (session_id,)
1045 | #         )[0]
1046 | #         assert speed_ngrams_count == 0, "No speed n-grams should be saved to the database"
     |                                                                                         ^^^^ E501
1047 |
1048 | #         # 2. Verify exactly one error n-gram was saved to the database
     |

tests\models\test_ngram_models.py:1057:89: E501 Line too long (93 > 88)
     |
1055 | #         )
1056 |
1057 | #         assert len(error_ngrams) == 1, "Should be exactly one error n-gram in the database"
     |                                                                                         ^^^^^ E501
1058 |
1059 | #         # Verify the error bigram (Gh)
     |

tests\models\test_ngram_models.py:1067:89: E501 Line too long (94 > 88)
     |
1066 | #         # VERIFY ANALYZER RETRIEVAL METHODS:
1067 | #         # 1. Get slowest n-grams - should return empty list since there are no speed n-grams
     |                                                                                         ^^^^^^ E501
1068 | #         slowest_bigrams = manager.get_slowest_ngrams(size=2)
1069 | #         assert len(slowest_bigrams) == 0, "Should be no slowest bigrams"
     |

tests\models\test_ngram_models.py:1081:89: E501 Line too long (93 > 88)
     |
1079 | #         for size in range(3, 6):  # Check sizes 3-5
1080 | #             slowest_ngrams = manager.get_slowest_ngrams(size=size)
1081 | #             assert len(slowest_ngrams) == 0, f"Should be no slowest n-grams of size {size}"
     |                                                                                         ^^^^^ E501
1082 |
1083 | #             error_prone_ngrams = manager.get_most_error_prone_ngrams(size=size)
     |

tests\models\test_ngram_models.py:1084:89: E501 Line too long (101 > 88)
     |
1083 | #             error_prone_ngrams = manager.get_most_error_prone_ngrams(size=size)
1084 | #             assert len(error_prone_ngrams) == 0, f"Should be no error-prone n-grams of size {size}"
     |                                                                                         ^^^^^^^^^^^^^ E501
1085 |
1086 | #     def test_three_keystrokes_error_at_second(
     |

tests\models\test_ngram_models.py:1093:89: E501 Line too long (92 > 88)
     |
1091 | #     ) -> None:
1092 | #         """
1093 | #         Test objective: Verify that three keystrokes with an error on the second keystroke
     |                                                                                         ^^^^ E501
1094 | #         are analyzed correctly.
     |

tests\models\test_ngram_models.py:1116:89: E501 Line too long (91 > 88)
     |
1115 | #         # Verify analysis was completed
1116 | #         assert manager.analysis_complete is True, "Analysis should be marked as complete"
     |                                                                                         ^^^ E501
1117 |
1118 | #         # VERIFY OBJECT STATE:
     |

tests\models\test_ngram_models.py:1127:89: E501 Line too long (98 > 88)
     |
1126 | #         # 2. Verify exactly one error bigram was identified
1127 | #         assert 2 in manager.error_ngrams, "Error n-grams dictionary should have key for bigrams"
     |                                                                                         ^^^^^^^^^^ E501
1128 | #         assert len(manager.error_ngrams[2]) == 1, "Should be exactly one error bigram"
     |

tests\models\test_ngram_models.py:1140:89: E501 Line too long (91 > 88)
     |
1138 | #         )
1139 | #         assert error_bigram.size == 2, "Error bigram size should be 2"
1140 | #         assert len(error_bigram.keystrokes) == 2, "Error bigram should have 2 keystrokes"
     |                                                                                         ^^^ E501
1141 | #         assert error_bigram.total_time_ms == 500, "Error bigram 'Tb' time should be 500ms"
     |

tests\models\test_ngram_models.py:1141:89: E501 Line too long (92 > 88)
     |
1139 | #         assert error_bigram.size == 2, "Error bigram size should be 2"
1140 | #         assert len(error_bigram.keystrokes) == 2, "Error bigram should have 2 keystrokes"
1141 | #         assert error_bigram.total_time_ms == 500, "Error bigram 'Tb' time should be 500ms"
     |                                                                                         ^^^^ E501
1142 |
1143 | #         # 4. Verify error bigram properties
     |

tests\models\test_ngram_models.py:1145:89: E501 Line too long (91 > 88)
     |
1143 | #         # 4. Verify error bigram properties
1144 | #         assert error_bigram.is_clean is False, "Error bigram should not be clean"
1145 | #         assert error_bigram.is_error is True, "Error bigram should be marked as an error"
     |                                                                                         ^^^ E501
1146 |
1147 | #         # 5. Check that the error bigram is still valid for tracking despite having an error
     |

tests\models\test_ngram_models.py:1147:89: E501 Line too long (94 > 88)
     |
1145 | #         assert error_bigram.is_error is True, "Error bigram should be marked as an error"
1146 |
1147 | #         # 5. Check that the error bigram is still valid for tracking despite having an error
     |                                                                                         ^^^^^^ E501
1148 | #         # This might differ based on your implementation - adjust if needed
1149 | #         if not error_bigram.is_valid:
     |

tests\models\test_ngram_models.py:1151:89: E501 Line too long (101 > 88)
     |
1149 | #         if not error_bigram.is_valid:
1150 | #             print(
1151 | #                 "Note: In this implementation, error bigrams are not considered valid for tracking"
     |                                                                                         ^^^^^^^^^^^^^ E501
1152 | #             )
     |

tests\models\test_ngram_models.py:1162:89: E501 Line too long (89 > 88)
     |
1161 | #         # VERIFY DATABASE STATE:
1162 | #         # Save to database - temporarily skip this assertion to see if later tests work
     |                                                                                         ^ E501
1163 |
1164 | #         # We'll assert the database contents directly instead of relying on the save operation result
     |

tests\models\test_ngram_models.py:1164:89: E501 Line too long (103 > 88)
     |
1162 | #         # Save to database - temporarily skip this assertion to see if later tests work
1163 |
1164 | #         # We'll assert the database contents directly instead of relying on the save operation result
     |                                                                                         ^^^^^^^^^^^^^^^ E501
1165 |
1166 | #         # 1. Verify no n-grams were saved to the speed table
     |

tests\models\test_ngram_models.py:1168:89: E501 Line too long (92 > 88)
     |
1166 | #         # 1. Verify no n-grams were saved to the speed table
1167 | #         speed_ngrams_count = temp_db.fetchone(
1168 | #             "SELECT COUNT(*) FROM session_ngram_speed WHERE session_id = ?", (session_id,)
     |                                                                                         ^^^^ E501
1169 | #         )[0]
1170 | #         assert speed_ngrams_count == 0, "No speed n-grams should be saved to the database"
     |

tests\models\test_ngram_models.py:1170:89: E501 Line too long (92 > 88)
     |
1168 | #             "SELECT COUNT(*) FROM session_ngram_speed WHERE session_id = ?", (session_id,)
1169 | #         )[0]
1170 | #         assert speed_ngrams_count == 0, "No speed n-grams should be saved to the database"
     |                                                                                         ^^^^ E501
1171 |
1172 | #         # 2. Verify exactly one error n-gram was saved to the database
     |

tests\models\test_ngram_models.py:1181:89: E501 Line too long (93 > 88)
     |
1179 | #         )
1180 |
1181 | #         assert len(error_ngrams) == 1, "Should be exactly one error n-gram in the database"
     |                                                                                         ^^^^^ E501
1182 |
1183 | #         # Verify the error bigram (Tb)
     |

tests\models\test_ngram_models.py:1191:89: E501 Line too long (94 > 88)
     |
1190 | #         # VERIFY ANALYZER RETRIEVAL METHODS:
1191 | #         # 1. Get slowest n-grams - should return empty list since there are no speed n-grams
     |                                                                                         ^^^^^^ E501
1192 | #         slowest_bigrams = manager.get_slowest_ngrams(size=2)
1193 | #         assert len(slowest_bigrams) == 0, "Should be no slowest bigrams"
     |

tests\models\test_ngram_models.py:1205:89: E501 Line too long (93 > 88)
     |
1203 | #         for size in range(3, 6):  # Check sizes 3-5
1204 | #             slowest_ngrams = manager.get_slowest_ngrams(size=size)
1205 | #             assert len(slowest_ngrams) == 0, f"Should be no slowest n-grams of size {size}"
     |                                                                                         ^^^^^ E501
1206 |
1207 | #             error_prone_ngrams = manager.get_most_error_prone_ngrams(size=size)
     |

tests\models\test_ngram_models.py:1208:89: E501 Line too long (101 > 88)
     |
1207 | #             error_prone_ngrams = manager.get_most_error_prone_ngrams(size=size)
1208 | #             assert len(error_prone_ngrams) == 0, f"Should be no error-prone n-grams of size {size}"
     |                                                                                         ^^^^^^^^^^^^^ E501
1209 |
1210 | #     def test_three_keystrokes_error_at_third(
     |

tests\models\test_ngram_models.py:1217:89: E501 Line too long (91 > 88)
     |
1215 | #     ) -> None:
1216 | #         """
1217 | #         Test objective: Verify that three keystrokes with an error on the third keystroke
     |                                                                                         ^^^ E501
1218 | #         are analyzed correctly.
     |

tests\models\test_ngram_models.py:1226:89: E501 Line too long (98 > 88)
     |
1225 | #         Expected outcomes:
1226 | #         - One bigram of length 2 ("Th") should be valid, as the first two keystrokes are correct
     |                                                                                         ^^^^^^^^^^ E501
1227 | #         - One bigram of length 2 ("hd") with an error, time is 500ms
1228 | #         - No valid trigrams or quadgrams due to the error
     |

tests\models\test_ngram_models.py:1242:89: E501 Line too long (91 > 88)
     |
1241 | #         # Verify analysis was completed
1242 | #         assert manager.analysis_complete is True, "Analysis should be marked as complete"
     |                                                                                         ^^^ E501
1243 |
1244 | #         # VERIFY OBJECT STATE:
     |

tests\models\test_ngram_models.py:1246:89: E501 Line too long (98 > 88)
     |
1244 | #         # VERIFY OBJECT STATE:
1245 | #         # 1. Check that speed n-grams were identified correctly
1246 | #         assert 2 in manager.speed_ngrams, "Speed n-grams dictionary should have key for bigrams"
     |                                                                                         ^^^^^^^^^^ E501
1247 | #         assert len(manager.speed_ngrams[2]) == 1, "Should find exactly one speed bigram"
     |

tests\models\test_ngram_models.py:1247:89: E501 Line too long (90 > 88)
     |
1245 | #         # 1. Check that speed n-grams were identified correctly
1246 | #         assert 2 in manager.speed_ngrams, "Speed n-grams dictionary should have key for bigrams"
1247 | #         assert len(manager.speed_ngrams[2]) == 1, "Should find exactly one speed bigram"
     |                                                                                         ^^ E501
1248 |
1249 | #         # Validate the speed bigram 'Th'
     |

tests\models\test_ngram_models.py:1254:89: E501 Line too long (100 > 88)
     |
1252 | #         # Retrieve the bigram using the helper function
1253 | #         speed_bigram = _find_ngram_in_list(manager.speed_ngrams[2], speed_bigram_text)
1254 | #         assert speed_bigram is not None, f"Bigram '{speed_bigram_text}' not found in speed_ngrams"
     |                                                                                         ^^^^^^^^^^^^ E501
1255 | #         assert speed_bigram.text == speed_bigram_text, (
1256 | #             f"Bigram text should be '{speed_bigram_text}'"
     |

tests\models\test_ngram_models.py:1262:89: E501 Line too long (98 > 88)
     |
1261 | #         # 2. Verify error n-grams - should find the error bigram "hd"
1262 | #         assert 2 in manager.error_ngrams, "Error n-grams dictionary should have key for bigrams"
     |                                                                                         ^^^^^^^^^^ E501
1263 | #         assert len(manager.error_ngrams[2]) == 1, "Should find exactly one error bigram"
     |

tests\models\test_ngram_models.py:1263:89: E501 Line too long (90 > 88)
     |
1261 | #         # 2. Verify error n-grams - should find the error bigram "hd"
1262 | #         assert 2 in manager.error_ngrams, "Error n-grams dictionary should have key for bigrams"
1263 | #         assert len(manager.error_ngrams[2]) == 1, "Should find exactly one error bigram"
     |                                                                                         ^^ E501
1264 |
1265 | #         # Validate the error bigram 'hd'
     |

tests\models\test_ngram_models.py:1268:89: E501 Line too long (90 > 88)
     |
1266 | #         error_bigram_text = "hd"  # 'h' (correct) + 'd' (error, should be 'e')
1267 | #         error_bigram = _find_ngram_in_list(manager.error_ngrams[2], error_bigram_text)
1268 | #         assert error_bigram is not None, f"Error bigram '{error_bigram_text}' not found"
     |                                                                                         ^^ E501
1269 | #         assert error_bigram.text == error_bigram_text, (
1270 | #             f"Error bigram text should be '{error_bigram_text}'"
     |

tests\models\test_ngram_models.py:1272:89: E501 Line too long (94 > 88)
     |
1270 | #             f"Error bigram text should be '{error_bigram_text}'"
1271 | #         )
1272 | #         assert error_bigram.total_time_ms == 1000, "Error bigram 'hd' time should be 1000ms"
     |                                                                                         ^^^^^^ E501
1273 | #         assert error_bigram.is_error is True, "Error bigram should be marked as an error"
     |

tests\models\test_ngram_models.py:1273:89: E501 Line too long (91 > 88)
     |
1271 | #         )
1272 | #         assert error_bigram.total_time_ms == 1000, "Error bigram 'hd' time should be 1000ms"
1273 | #         assert error_bigram.is_error is True, "Error bigram should be marked as an error"
     |                                                                                         ^^^ E501
1274 |
1275 | #         # 3. Verify error trigram "Thd"
     |

tests\models\test_ngram_models.py:1276:89: E501 Line too long (99 > 88)
     |
1275 | #         # 3. Verify error trigram "Thd"
1276 | #         assert 3 in manager.error_ngrams, "Error n-grams dictionary should have key for trigrams"
     |                                                                                         ^^^^^^^^^^^ E501
1277 | #         assert len(manager.error_ngrams[3]) == 1, "Should find exactly one error trigram"
     |

tests\models\test_ngram_models.py:1277:89: E501 Line too long (91 > 88)
     |
1275 | #         # 3. Verify error trigram "Thd"
1276 | #         assert 3 in manager.error_ngrams, "Error n-grams dictionary should have key for trigrams"
1277 | #         assert len(manager.error_ngrams[3]) == 1, "Should find exactly one error trigram"
     |                                                                                         ^^^ E501
1278 |
1279 | #         # Validate the error trigram 'Thd'
     |

tests\models\test_ngram_models.py:1281:89: E501 Line too long (90 > 88)
     |
1279 | #         # Validate the error trigram 'Thd'
1280 | #         error_trigram_text = "Thd"
1281 | #         error_trigram = _find_ngram_in_list(manager.error_ngrams[3], error_trigram_text)
     |                                                                                         ^^ E501
1282 | #         assert error_trigram is not None, f"Error trigram '{error_trigram_text}' not found"
1283 | #         assert error_trigram.text == error_trigram_text, (
     |

tests\models\test_ngram_models.py:1282:89: E501 Line too long (93 > 88)
     |
1280 | #         error_trigram_text = "Thd"
1281 | #         error_trigram = _find_ngram_in_list(manager.error_ngrams[3], error_trigram_text)
1282 | #         assert error_trigram is not None, f"Error trigram '{error_trigram_text}' not found"
     |                                                                                         ^^^^^ E501
1283 | #         assert error_trigram.text == error_trigram_text, (
1284 | #             f"Error trigram text should be '{error_trigram_text}'"
     |

tests\models\test_ngram_models.py:1286:89: E501 Line too long (97 > 88)
     |
1284 | #             f"Error trigram text should be '{error_trigram_text}'"
1285 | #         )
1286 | #         assert error_trigram.total_time_ms == 1500, "Error trigram 'Thd' time should be 1500ms"
     |                                                                                         ^^^^^^^^^ E501
1287 |
1288 | #         # 4. Verify no quadgrams were identified
     |

tests\models\test_ngram_models.py:1308:89: E501 Line too long (103 > 88)
     |
1306 | #             for ngram in ngrams:
1307 | #                 temp_db.execute(
1308 | #                     "INSERT INTO session_ngram_speed (session_id, ngram_size, ngram, ngram_time_ms) "
     |                                                                                         ^^^^^^^^^^^^^^^ E501
1309 | #                     "VALUES (?, ?, ?, ?)",
1310 | #                     (session_id, size, ngram.text, ngram.avg_time_per_char_ms),
     |

tests\models\test_ngram_models.py:1316:89: E501 Line too long (89 > 88)
     |
1314 | #             for ngram in ngrams:
1315 | #                 temp_db.execute(
1316 | #                     "INSERT INTO session_ngram_errors (session_id, ngram_size, ngram) "
     |                                                                                         ^ E501
1317 | #                     "VALUES (?, ?, ?)",
1318 | #                     (session_id, size, ngram.text),
     |

tests\models\test_ngram_models.py:1326:89: E501 Line too long (122 > 88)
     |
1324 | #         # 1. Check the speed n-grams in database
1325 | #         speed_ngrams = temp_db.fetchall(
1326 | #             "SELECT ngram_size, ngram, ngram_time_ms FROM session_ngram_speed WHERE session_id = ? ORDER BY ngram_size",
     |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
1327 | #             (session_id,),
1328 | #         )
     |

tests\models\test_ngram_models.py:1329:89: E501 Line too long (91 > 88)
     |
1327 | #             (session_id,),
1328 | #         )
1329 | #         assert len(speed_ngrams) == 1, "Should find exactly one speed n-gram in database"
     |                                                                                         ^^^ E501
1330 | #         assert speed_ngrams[0][0] == 2, "Speed n-gram should be size 2"
1331 | #         assert speed_ngrams[0][1] == "Th", "Speed n-gram should be 'Th'"
     |

tests\models\test_ngram_models.py:1332:89: E501 Line too long (99 > 88)
     |
1330 | #         assert speed_ngrams[0][0] == 2, "Speed n-gram should be size 2"
1331 | #         assert speed_ngrams[0][1] == "Th", "Speed n-gram should be 'Th'"
1332 | #         assert speed_ngrams[0][2] == 250, "Speed n-gram time should be 250ms (avg per character)"
     |                                                                                         ^^^^^^^^^^^ E501
1333 |
1334 | #         # 2. Check the error n-grams in database
     |

tests\models\test_ngram_models.py:1336:89: E501 Line too long (115 > 88)
     |
1334 | #         # 2. Check the error n-grams in database
1335 | #         error_ngrams = temp_db.fetchall(
1336 | #             "SELECT ngram_size, ngram FROM session_ngram_errors WHERE session_id = ? ORDER BY ngram_size, ngram",
     |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
1337 | #             (session_id,),
1338 | #         )
     |

tests\models\test_ngram_models.py:1339:89: E501 Line too long (94 > 88)
     |
1337 | #             (session_id,),
1338 | #         )
1339 | #         assert len(error_ngrams) == 2, "Should be exactly two error n-grams in the database"
     |                                                                                         ^^^^^^ E501
1340 |
1341 | #         # Find and verify the error bigram
     |

tests\models\test_ngram_models.py:1359:89: E501 Line too long (102 > 88)
     |
1357 | #         # 1. Check speed n-grams (should only have 'Th')
1358 | #         speed_ngrams = temp_db.fetchall(
1359 | #             "SELECT ngram_size, ngram, ngram_time_ms FROM session_ngram_speed WHERE session_id = ?",
     |                                                                                         ^^^^^^^^^^^^^^ E501
1360 | #             (session_id,),
1361 | #         )
     |

tests\models\test_ngram_models.py:1362:89: E501 Line too long (93 > 88)
     |
1360 | #             (session_id,),
1361 | #         )
1362 | #         assert len(speed_ngrams) == 1, "Should be exactly one speed n-gram in the database"
     |                                                                                         ^^^^^ E501
1363 | #         assert speed_ngrams[0][0] == 2, "Speed n-gram size should be 2 (bigram)"
1364 | #         assert speed_ngrams[0][1] == "Th", "Speed n-gram should be 'Th'"
     |

tests\models\test_ngram_models.py:1365:89: E501 Line too long (99 > 88)
     |
1363 | #         assert speed_ngrams[0][0] == 2, "Speed n-gram size should be 2 (bigram)"
1364 | #         assert speed_ngrams[0][1] == "Th", "Speed n-gram should be 'Th'"
1365 | #         assert speed_ngrams[0][2] == 250, "Speed n-gram time should be 250ms (avg per character)"
     |                                                                                         ^^^^^^^^^^^ E501
1366 |
1367 | #         # 2. Check error n-grams (should have 'hd' and 'Thd')
     |

tests\models\test_ngram_models.py:1369:89: E501 Line too long (115 > 88)
     |
1367 | #         # 2. Check error n-grams (should have 'hd' and 'Thd')
1368 | #         error_ngrams = temp_db.fetchall(
1369 | #             "SELECT ngram_size, ngram FROM session_ngram_errors WHERE session_id = ? ORDER BY ngram_size, ngram",
     |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
1370 | #             (session_id,),
1371 | #         )
     |

tests\models\test_ngram_models.py:1372:89: E501 Line too long (94 > 88)
     |
1370 | #             (session_id,),
1371 | #         )
1372 | #         assert len(error_ngrams) == 2, "Should be exactly two error n-grams in the database"
     |                                                                                         ^^^^^^ E501
1373 |
1374 | #         # Verify 'hd' bigram
     |

tests\models\test_ngram_models.py:1387:89: E501 Line too long (89 > 88)
     |
1385 | #         error_prone_bigrams = manager.get_most_error_prone_ngrams(size=2)
1386 | #         assert len(error_prone_bigrams) == 1, "Should be one error-prone bigram"
1387 | #         assert error_prone_bigrams[0].text == "hd", "Error-prone bigram should be 'hd'"
     |                                                                                         ^ E501
1388 |
1389 | #         error_prone_trigrams = manager.get_most_error_prone_ngrams(size=3)
     |

tests\models\test_ngram_models.py:1391:89: E501 Line too long (93 > 88)
     |
1389 | #         error_prone_trigrams = manager.get_most_error_prone_ngrams(size=3)
1390 | #         assert len(error_prone_trigrams) == 1, "Should be one error-prone trigram"
1391 | #         assert error_prone_trigrams[0].text == "Thd", "Error-prone trigram should be 'Thd'"
     |                                                                                         ^^^^^ E501
1392 |
1393 | #         # Check get_slowest_ngrams (should only return clean n-grams)
     |

tests\models\test_ngram_models_p2.py:82:89: E501 Line too long (90 > 88)
   |
80 | #     snippet_id = str(uuid.uuid4())
81 | #     temp_db.execute(
82 | #         "INSERT INTO snippets (snippet_id, category_id, snippet_name) VALUES (?, ?, ?)",
   |                                                                                         ^^ E501
83 | #         (snippet_id, category_id, "Test Snippet"),
84 | #     )
   |

tests\models\test_ngram_models_p2.py:89:89: E501 Line too long (102 > 88)
   |
87 | #     part_id = str(uuid.uuid4())
88 | #     temp_db.execute(
89 | #         "INSERT INTO snippet_parts (part_id, snippet_id, part_number, content) VALUES (?, ?, ?, ?)",
   |                                                                                         ^^^^^^^^^^^^^^ E501
90 | #         (part_id, snippet_id, 1, "test typing content"),
91 | #     )
   |

tests\models\test_ngram_models_p2.py:154:89: E501 Line too long (92 > 88)
    |
152 | #             keystroke_id=str(uuid.uuid4()),
153 | #             session_id=test_practice_session.session_id,
154 | #             keystroke_time=now + datetime.timedelta(milliseconds=1500),  # 1500 from start
    |                                                                                         ^^^^ E501
155 | #             keystroke_char="e",
156 | #             expected_char="e",
    |

tests\models\test_ngram_models_p2.py:163:89: E501 Line too long (92 > 88)
    |
161 | #             keystroke_id=str(uuid.uuid4()),
162 | #             session_id=test_practice_session.session_id,
163 | #             keystroke_time=now + datetime.timedelta(milliseconds=1800),  # 1800 from start
    |                                                                                         ^^^^ E501
164 | #             keystroke_char="n",
165 | #             expected_char="n",
    |

tests\models\test_ngram_models_p2.py:176:89: E501 Line too long (120 > 88)
    |
174 | #             """
175 | #             INSERT INTO session_keystrokes
176 | #             (session_id, keystroke_id, keystroke_time, keystroke_char, expected_char, is_correct, time_since_previous)
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
177 | #             VALUES (?, ?, ?, ?, ?, ?, ?)
178 | #             """,
    |

tests\models\test_ngram_models_p2.py:256:89: E501 Line too long (120 > 88)
    |
254 | #             """
255 | #             INSERT INTO session_keystrokes
256 | #             (session_id, keystroke_id, keystroke_time, keystroke_char, expected_char, is_correct, time_since_previous)
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
257 | #             VALUES (?, ?, ?, ?, ?, ?, ?)
258 | #             """,
    |

tests\models\test_ngram_models_p2.py:336:89: E501 Line too long (120 > 88)
    |
334 | #             """
335 | #             INSERT INTO session_keystrokes
336 | #             (session_id, keystroke_id, keystroke_time, keystroke_char, expected_char, is_correct, time_since_previous)
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
337 | #             VALUES (?, ?, ?, ?, ?, ?, ?)
338 | #             """,
    |

tests\models\test_ngram_models_p2.py:416:89: E501 Line too long (120 > 88)
    |
414 | #             """
415 | #             INSERT INTO session_keystrokes
416 | #             (session_id, keystroke_id, keystroke_time, keystroke_char, expected_char, is_correct, time_since_previous)
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
417 | #             VALUES (?, ?, ?, ?, ?, ?, ?)
418 | #             """,
    |

tests\models\test_ngram_models_p2.py:496:89: E501 Line too long (120 > 88)
    |
494 | #             """
495 | #             INSERT INTO session_keystrokes
496 | #             (session_id, keystroke_id, keystroke_time, keystroke_char, expected_char, is_correct, time_since_previous)
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
497 | #             VALUES (?, ?, ?, ?, ?, ?, ?)
498 | #             """,
    |

tests\models\test_ngram_models_p2.py:513:89: E501 Line too long (91 > 88)
    |
513 | # # All test NGram objects and dicts in this file should include ngram_id as a UUID string.
    |                                                                                         ^^^ E501
514 | # class TestNGramModelsExtended:
515 | #     """Extended test suite for NGram model and analyzer functionality with longer sequences."""
    |

tests\models\test_ngram_models_p2.py:515:89: E501 Line too long (97 > 88)
    |
513 | # # All test NGram objects and dicts in this file should include ngram_id as a UUID string.
514 | # class TestNGramModelsExtended:
515 | #     """Extended test suite for NGram model and analyzer functionality with longer sequences."""
    |                                                                                         ^^^^^^^^^ E501
516 |
517 | #     def test_four_keystrokes_no_errors(
    |

tests\models\test_ngram_models_p3.py:109:89: E501 Line too long (90 > 88)
    |
107 | #     snippet_id = str(uuid.uuid4())
108 | #     temp_db.execute(
109 | #         "INSERT INTO snippets (snippet_id, category_id, snippet_name) VALUES (?, ?, ?)",
    |                                                                                         ^^ E501
110 | #         (snippet_id, category_id, "Test Snippet"),
111 | #     )
    |

tests\models\test_ngram_models_p3.py:116:89: E501 Line too long (102 > 88)
    |
114 | #     part_id = str(uuid.uuid4())
115 | #     temp_db.execute(
116 | #         "INSERT INTO snippet_parts (part_id, snippet_id, part_number, content) VALUES (?, ?, ?, ?)",
    |                                                                                         ^^^^^^^^^^^^^^ E501
117 | #         (part_id, snippet_id, 1, "Then"),
118 | #     )
    |

tests\models\test_ngram_models_p3.py:239:89: E501 Line too long (104 > 88)
    |
237 | #     ) -> None:
238 | #         """
239 | #         Test objective: Verify that keystrokes with a backspace after an error are analyzed correctly.
    |                                                                                         ^^^^^^^^^^^^^^^^ E501
240 |
241 | #         This test checks a scenario where:
    |

tests\models\test_ngram_models_p3.py:254:89: E501 Line too long (90 > 88)
    |
252 | #         - In database: 3 rows in session_ngram_speed, 0 rows in session_ngram_errors
253 |
254 | #         This test is important for validation of the modernized n-gram analysis approach
    |                                                                                         ^^ E501
255 | #         that supports flexible n-gram sizes from 2-8 and correctly handles editing actions
256 | #         like backspaces while still producing valid speed and error statistics.
    |

tests\models\test_ngram_models_p3.py:255:89: E501 Line too long (92 > 88)
    |
254 | #         This test is important for validation of the modernized n-gram analysis approach
255 | #         that supports flexible n-gram sizes from 2-8 and correctly handles editing actions
    |                                                                                         ^^^^ E501
256 | #         like backspaces while still producing valid speed and error statistics.
257 | #         """
    |

tests\models\test_ngram_models_p3.py:261:89: E501 Line too long (97 > 88)
    |
260 | #         # Create and analyze the NGramManager
261 | #         analyzer = NGramManager(test_practice_session, five_keystrokes_with_backspace, temp_db)
    |                                                                                         ^^^^^^^^^ E501
262 | #         analyzer.analyze(min_size=2, max_size=5)
    |

tests\models\test_ngram_models_p3.py:267:89: E501 Line too long (98 > 88)
    |
265 | #         # Uncomment for troubleshooting if needed
266 | #         # print(f"\nBackspace handling test details:")
267 | #         # print(f"All keystrokes: {[k.keystroke_char for k in five_keystrokes_with_backspace]}")
    |                                                                                         ^^^^^^^^^^ E501
268 | #         # print(f"Speed ngrams of length 2: {len(analyzer.speed_ngrams[2])}")
269 | #         # for ngram in analyzer.speed_ngrams[2]:
    |

tests\models\test_ngram_models_p3.py:270:89: E501 Line too long (107 > 88)
    |
268 | #         # print(f"Speed ngrams of length 2: {len(analyzer.speed_ngrams[2])}")
269 | #         # for ngram in analyzer.speed_ngrams[2]:
270 | #         #     print(f"  Bigram: {ngram.text}, time: {ngram.total_time_ms}ms, is_clean: {ngram.is_clean}")
    |                                                                                         ^^^^^^^^^^^^^^^^^^^ E501
271 | #         #
272 | #         # print(f"Speed ngrams of length 3: {len(analyzer.speed_ngrams[3])}")
    |

tests\models\test_ngram_models_p3.py:274:89: E501 Line too long (108 > 88)
    |
272 | #         # print(f"Speed ngrams of length 3: {len(analyzer.speed_ngrams[3])}")
273 | #         # for ngram in analyzer.speed_ngrams[3]:
274 | #         #     print(f"  Trigram: {ngram.text}, time: {ngram.total_time_ms}ms, is_clean: {ngram.is_clean}")
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^ E501
275 |
276 | #         # Verify correct number of n-grams found
    |

tests\models\test_ngram_models_p3.py:286:89: E501 Line too long (91 > 88)
    |
285 | #         # Length 4 and 5 n-grams (should be none)
286 | #         assert len(analyzer.speed_ngrams[4]) == 0, "Should find 0 valid length-4 n-grams"
    |                                                                                         ^^^ E501
287 | #         assert len(analyzer.speed_ngrams[5]) == 0, "Should find 0 valid length-5 n-grams"
    |

tests\models\test_ngram_models_p3.py:287:89: E501 Line too long (91 > 88)
    |
285 | #         # Length 4 and 5 n-grams (should be none)
286 | #         assert len(analyzer.speed_ngrams[4]) == 0, "Should find 0 valid length-4 n-grams"
287 | #         assert len(analyzer.speed_ngrams[5]) == 0, "Should find 0 valid length-5 n-grams"
    |                                                                                         ^^^ E501
288 |
289 | #         # Verify the bigram "Th"
    |

tests\models\test_ngram_models_p3.py:317:89: E501 Line too long (97 > 88)
    |
315 | #         assert trigram_the.size == 3, "Trigram size should be 3"
316 | #         assert len(trigram_the.keystrokes) == 3, "Trigram should have 3 keystrokes"
317 | #         assert trigram_the.total_time_ms == 470, "Trigram 'The' time should be 470ms (300+170)"
    |                                                                                         ^^^^^^^^^ E501
318 | #         assert trigram_the.is_clean is True, "Trigram should be clean (no errors)"
319 | #         assert trigram_the.is_error is False, "Trigram should not be an error trigram"
    |

tests\models\test_ngram_models_p3.py:343:89: E501 Line too long (90 > 88)
    |
342 | #         # First should be bigram "Th" with avg 150ms per char
343 | #         assert speed_ngrams[0][0] == 2, "First database entry should be bigram (size 2)"
    |                                                                                         ^^ E501
344 | #         assert speed_ngrams[0][1] == "Th", "First database entry should be bigram 'Th'"
345 | #         assert speed_ngrams[0][2] == 150, "Database 'Th' time should be 150ms avg (300ms/2)"
    |

tests\models\test_ngram_models_p3.py:344:89: E501 Line too long (89 > 88)
    |
342 | #         # First should be bigram "Th" with avg 150ms per char
343 | #         assert speed_ngrams[0][0] == 2, "First database entry should be bigram (size 2)"
344 | #         assert speed_ngrams[0][1] == "Th", "First database entry should be bigram 'Th'"
    |                                                                                         ^ E501
345 | #         assert speed_ngrams[0][2] == 150, "Database 'Th' time should be 150ms avg (300ms/2)"
    |

tests\models\test_ngram_models_p3.py:345:89: E501 Line too long (94 > 88)
    |
343 | #         assert speed_ngrams[0][0] == 2, "First database entry should be bigram (size 2)"
344 | #         assert speed_ngrams[0][1] == "Th", "First database entry should be bigram 'Th'"
345 | #         assert speed_ngrams[0][2] == 150, "Database 'Th' time should be 150ms avg (300ms/2)"
    |                                                                                         ^^^^^^ E501
346 |
347 | #         # Second should be bigram "he" with avg 85ms per char
    |

tests\models\test_ngram_models_p3.py:348:89: E501 Line too long (91 > 88)
    |
347 | #         # Second should be bigram "he" with avg 85ms per char
348 | #         assert speed_ngrams[1][0] == 2, "Second database entry should be bigram (size 2)"
    |                                                                                         ^^^ E501
349 | #         assert speed_ngrams[1][1] == "he", "Second database entry should be bigram 'he'"
350 | #         assert speed_ngrams[1][2] == 85, "Database 'he' time should be 85ms avg (170ms/2)"
    |

tests\models\test_ngram_models_p3.py:349:89: E501 Line too long (90 > 88)
    |
347 | #         # Second should be bigram "he" with avg 85ms per char
348 | #         assert speed_ngrams[1][0] == 2, "Second database entry should be bigram (size 2)"
349 | #         assert speed_ngrams[1][1] == "he", "Second database entry should be bigram 'he'"
    |                                                                                         ^^ E501
350 | #         assert speed_ngrams[1][2] == 85, "Database 'he' time should be 85ms avg (170ms/2)"
    |

tests\models\test_ngram_models_p3.py:350:89: E501 Line too long (92 > 88)
    |
348 | #         assert speed_ngrams[1][0] == 2, "Second database entry should be bigram (size 2)"
349 | #         assert speed_ngrams[1][1] == "he", "Second database entry should be bigram 'he'"
350 | #         assert speed_ngrams[1][2] == 85, "Database 'he' time should be 85ms avg (170ms/2)"
    |                                                                                         ^^^^ E501
351 |
352 | #         # Third should be trigram "The" with avg time of ~156.67ms per char
    |

tests\models\test_ngram_models_p3.py:353:89: E501 Line too long (91 > 88)
    |
352 | #         # Third should be trigram "The" with avg time of ~156.67ms per char
353 | #         assert speed_ngrams[2][0] == 3, "Third database entry should be trigram (size 3)"
    |                                                                                         ^^^ E501
354 | #         assert speed_ngrams[2][1] == "The", "Third database entry should be trigram 'The'"
355 | #         # We expect 470ms / 3 = ~156.67ms per char
    |

tests\models\test_ngram_models_p3.py:354:89: E501 Line too long (92 > 88)
    |
352 | #         # Third should be trigram "The" with avg time of ~156.67ms per char
353 | #         assert speed_ngrams[2][0] == 3, "Third database entry should be trigram (size 3)"
354 | #         assert speed_ngrams[2][1] == "The", "Third database entry should be trigram 'The'"
    |                                                                                         ^^^^ E501
355 | #         # We expect 470ms / 3 = ~156.67ms per char
356 | #         expected_avg_time = 470 / 3
    |

tests\models\test_ngram_models_p3.py:363:89: E501 Line too long (93 > 88)
    |
361 | #         # Verify no error n-grams were saved
362 | #         error_ngrams_count = temp_db.fetchone(
363 | #             "SELECT COUNT(*) FROM session_ngram_errors WHERE session_id = ?", (session_id,)
    |                                                                                         ^^^^^ E501
364 | #         )[0]
365 | #         assert error_ngrams_count == 0, "No error n-grams should be saved to the database"
    |

tests\models\test_ngram_models_p3.py:365:89: E501 Line too long (92 > 88)
    |
363 | #             "SELECT COUNT(*) FROM session_ngram_errors WHERE session_id = ?", (session_id,)
364 | #         )[0]
365 | #         assert error_ngrams_count == 0, "No error n-grams should be saved to the database"
    |                                                                                         ^^^^ E501
366 |
367 | #         # Verify the slowest and error-prone n-grams
    |

tests\models\test_ngram_models_p3.py:381:89: E501 Line too long (119 > 88)
    |
379 | #     ):
380 | #         """
381 | #         Test objective: Verify that keystrokes with a backspace after a second-position error are analyzed correctly.
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
382 |
383 | #         This test checks a scenario where:
    |

tests\models\test_ngram_models_p3.py:411:89: E501 Line too long (89 > 88)
    |
410 | #         # Length 3+ n-grams (should be none)
411 | #         assert len(analyzer.speed_ngrams[3]) == 0, "Should find 0 valid speed trigrams"
    |                                                                                         ^ E501
412 | #         assert len(analyzer.speed_ngrams[4]) == 0, "Should find 0 valid length-4 n-grams"
413 | #         assert len(analyzer.speed_ngrams[5]) == 0, "Should find 0 valid length-5 n-grams"
    |

tests\models\test_ngram_models_p3.py:412:89: E501 Line too long (91 > 88)
    |
410 | #         # Length 3+ n-grams (should be none)
411 | #         assert len(analyzer.speed_ngrams[3]) == 0, "Should find 0 valid speed trigrams"
412 | #         assert len(analyzer.speed_ngrams[4]) == 0, "Should find 0 valid length-4 n-grams"
    |                                                                                         ^^^ E501
413 | #         assert len(analyzer.speed_ngrams[5]) == 0, "Should find 0 valid length-5 n-grams"
    |

tests\models\test_ngram_models_p3.py:413:89: E501 Line too long (91 > 88)
    |
411 | #         assert len(analyzer.speed_ngrams[3]) == 0, "Should find 0 valid speed trigrams"
412 | #         assert len(analyzer.speed_ngrams[4]) == 0, "Should find 0 valid length-4 n-grams"
413 | #         assert len(analyzer.speed_ngrams[5]) == 0, "Should find 0 valid length-5 n-grams"
    |                                                                                         ^^^ E501
414 |
415 | #         # Verify the speed bigram "he"
    |

tests\models\test_ngram_models_p3.py:450:89: E501 Line too long (91 > 88)
    |
448 | #         )
449 |
450 | #         assert len(speed_ngrams) == 1, "Should be exactly 1 speed n-gram in the database"
    |                                                                                         ^^^ E501
451 |
452 | #         # Check the speed bigram "he"
    |

tests\models\test_ngram_models_p3.py:467:89: E501 Line too long (91 > 88)
    |
465 | #         )
466 |
467 | #         assert len(error_ngrams) == 1, "Should be exactly 1 error n-gram in the database"
    |                                                                                         ^^^ E501
468 |
469 | #         # Check the error bigram "Tg"
    |

tests\models\test_ngram_models_p3.py:475:89: E501 Line too long (93 > 88)
    |
474 | #     def test_five_keystrokes_backspace_at_third_no_mistake(
475 | #         self, temp_db, test_practice_session, five_keystrokes_backspace_at_third_no_mistake
    |                                                                                         ^^^^^ E501
476 | #     ):
477 | #         """
    |

tests\models\test_ngram_models_p3.py:478:89: E501 Line too long (126 > 88)
    |
476 | #     ):
477 | #         """
478 | #         Test objective: Verify that keystrokes with a backspace at third position (no prior mistake) are analyzed correctly.
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
479 |
480 | #         This test checks a scenario where:
    |

tests\models\test_ngram_models_p3.py:499:89: E501 Line too long (91 > 88)
    |
497 | #         # Create and analyze the NGramManager
498 | #         analyzer = NGramManager(
499 | #             test_practice_session, five_keystrokes_backspace_at_third_no_mistake, temp_db
    |                                                                                         ^^^ E501
500 | #         )
501 | #         analyzer.analyze(min_size=2, max_size=5)
    |

tests\models\test_ngram_models_p3.py:509:89: E501 Line too long (89 > 88)
    |
508 | #         # Length 3+ n-grams (should be none)
509 | #         assert len(analyzer.speed_ngrams[3]) == 0, "Should find 0 valid speed trigrams"
    |                                                                                         ^ E501
510 | #         assert len(analyzer.speed_ngrams[4]) == 0, "Should find 0 valid length-4 n-grams"
511 | #         assert len(analyzer.speed_ngrams[5]) == 0, "Should find 0 valid length-5 n-grams"
    |

tests\models\test_ngram_models_p3.py:510:89: E501 Line too long (91 > 88)
    |
508 | #         # Length 3+ n-grams (should be none)
509 | #         assert len(analyzer.speed_ngrams[3]) == 0, "Should find 0 valid speed trigrams"
510 | #         assert len(analyzer.speed_ngrams[4]) == 0, "Should find 0 valid length-4 n-grams"
    |                                                                                         ^^^ E501
511 | #         assert len(analyzer.speed_ngrams[5]) == 0, "Should find 0 valid length-5 n-grams"
    |

tests\models\test_ngram_models_p3.py:511:89: E501 Line too long (91 > 88)
    |
509 | #         assert len(analyzer.speed_ngrams[3]) == 0, "Should find 0 valid speed trigrams"
510 | #         assert len(analyzer.speed_ngrams[4]) == 0, "Should find 0 valid length-4 n-grams"
511 | #         assert len(analyzer.speed_ngrams[5]) == 0, "Should find 0 valid length-5 n-grams"
    |                                                                                         ^^^ E501
512 |
513 | #         # Verify the speed bigram "Th"
    |

tests\models\test_ngram_models_p3.py:548:89: E501 Line too long (92 > 88)
    |
546 | #         )
547 |
548 | #         assert len(speed_ngrams) == 2, "Should be exactly 2 speed n-grams in the database"
    |                                                                                         ^^^^ E501
549 |
550 | #         # Check each n-gram's data in the database
    |

tests\models\test_ngram_models_p3.py:552:89: E501 Line too long (90 > 88)
    |
550 | #         # Check each n-gram's data in the database
551 | #         # Check the speed bigram "Th"
552 | #         assert speed_ngrams[0][0] == 2, "First database entry should be bigram (size 2)"
    |                                                                                         ^^ E501
553 | #         assert speed_ngrams[0][1] == "Th", "First database entry should be bigram 'Th'"
554 | #         assert speed_ngrams[0][2] == 250, "Database 'Th' time should be 250ms avg (500ms/2)"
    |

tests\models\test_ngram_models_p3.py:553:89: E501 Line too long (89 > 88)
    |
551 | #         # Check the speed bigram "Th"
552 | #         assert speed_ngrams[0][0] == 2, "First database entry should be bigram (size 2)"
553 | #         assert speed_ngrams[0][1] == "Th", "First database entry should be bigram 'Th'"
    |                                                                                         ^ E501
554 | #         assert speed_ngrams[0][2] == 250, "Database 'Th' time should be 250ms avg (500ms/2)"
    |

tests\models\test_ngram_models_p3.py:554:89: E501 Line too long (94 > 88)
    |
552 | #         assert speed_ngrams[0][0] == 2, "First database entry should be bigram (size 2)"
553 | #         assert speed_ngrams[0][1] == "Th", "First database entry should be bigram 'Th'"
554 | #         assert speed_ngrams[0][2] == 250, "Database 'Th' time should be 250ms avg (500ms/2)"
    |                                                                                         ^^^^^^ E501
555 |
556 | #         # Check the speed bigram "he"
    |

tests\models\test_ngram_models_p3.py:557:89: E501 Line too long (91 > 88)
    |
556 | #         # Check the speed bigram "he"
557 | #         assert speed_ngrams[1][0] == 2, "Second database entry should be bigram (size 2)"
    |                                                                                         ^^^ E501
558 | #         assert speed_ngrams[1][1] == "he", "Second database entry should be bigram 'he'"
559 | #         assert speed_ngrams[1][2] == 85, "Database 'he' time should be 85ms avg (170ms/2)"
    |

tests\models\test_ngram_models_p3.py:558:89: E501 Line too long (90 > 88)
    |
556 | #         # Check the speed bigram "he"
557 | #         assert speed_ngrams[1][0] == 2, "Second database entry should be bigram (size 2)"
558 | #         assert speed_ngrams[1][1] == "he", "Second database entry should be bigram 'he'"
    |                                                                                         ^^ E501
559 | #         assert speed_ngrams[1][2] == 85, "Database 'he' time should be 85ms avg (170ms/2)"
    |

tests\models\test_ngram_models_p3.py:559:89: E501 Line too long (92 > 88)
    |
557 | #         assert speed_ngrams[1][0] == 2, "Second database entry should be bigram (size 2)"
558 | #         assert speed_ngrams[1][1] == "he", "Second database entry should be bigram 'he'"
559 | #         assert speed_ngrams[1][2] == 85, "Database 'he' time should be 85ms avg (170ms/2)"
    |                                                                                         ^^^^ E501
560 |
561 | #         # Verify no error n-grams were saved
    |

tests\models\test_ngram_models_p3.py:563:89: E501 Line too long (93 > 88)
    |
561 | #         # Verify no error n-grams were saved
562 | #         error_ngrams_count = temp_db.fetchone(
563 | #             "SELECT COUNT(*) FROM session_ngram_errors WHERE session_id = ?", (session_id,)
    |                                                                                         ^^^^^ E501
564 | #         )[0]
565 | #         assert error_ngrams_count == 0, "No error n-grams should be saved to the database"
    |

tests\models\test_ngram_models_p3.py:565:89: E501 Line too long (92 > 88)
    |
563 | #             "SELECT COUNT(*) FROM session_ngram_errors WHERE session_id = ?", (session_id,)
564 | #         )[0]
565 | #         assert error_ngrams_count == 0, "No error n-grams should be saved to the database"
    |                                                                                         ^^^^ E501
566 |
567 | #     def test_five_keystrokes_space_at_third(
    |

tests\models\test_ngram_models_p3.py:571:89: E501 Line too long (103 > 88)
    |
569 | #     ):
570 | #         """
571 | #         Test objective: Verify that keystrokes with a space at third position are analyzed correctly.
    |                                                                                         ^^^^^^^^^^^^^^^ E501
572 |
573 | #         This test checks a scenario where:
    |

tests\models\test_ngram_models_p3.py:587:89: E501 Line too long (97 > 88)
    |
586 | #         # Create and analyze the NGramManager
587 | #         analyzer = NGramManager(test_practice_session, five_keystrokes_space_at_third, temp_db)
    |                                                                                         ^^^^^^^^^ E501
588 | #         analyzer.analyze(min_size=2, max_size=5)
    |

tests\models\test_ngram_models_p3.py:596:89: E501 Line too long (89 > 88)
    |
595 | #         # Length 3+ n-grams (should be none)
596 | #         assert len(analyzer.speed_ngrams[3]) == 0, "Should find 0 valid speed trigrams"
    |                                                                                         ^ E501
597 | #         assert len(analyzer.speed_ngrams[4]) == 0, "Should find 0 valid length-4 n-grams"
598 | #         assert len(analyzer.speed_ngrams[5]) == 0, "Should find 0 valid length-5 n-grams"
    |

tests\models\test_ngram_models_p3.py:597:89: E501 Line too long (91 > 88)
    |
595 | #         # Length 3+ n-grams (should be none)
596 | #         assert len(analyzer.speed_ngrams[3]) == 0, "Should find 0 valid speed trigrams"
597 | #         assert len(analyzer.speed_ngrams[4]) == 0, "Should find 0 valid length-4 n-grams"
    |                                                                                         ^^^ E501
598 | #         assert len(analyzer.speed_ngrams[5]) == 0, "Should find 0 valid length-5 n-grams"
    |

tests\models\test_ngram_models_p3.py:598:89: E501 Line too long (91 > 88)
    |
596 | #         assert len(analyzer.speed_ngrams[3]) == 0, "Should find 0 valid speed trigrams"
597 | #         assert len(analyzer.speed_ngrams[4]) == 0, "Should find 0 valid length-4 n-grams"
598 | #         assert len(analyzer.speed_ngrams[5]) == 0, "Should find 0 valid length-5 n-grams"
    |                                                                                         ^^^ E501
599 |
600 | #         # Verify the speed bigram "Th"
    |

tests\models\test_ngram_models_p3.py:635:89: E501 Line too long (92 > 88)
    |
633 | #         )
634 |
635 | #         assert len(speed_ngrams) == 2, "Should be exactly 2 speed n-grams in the database"
    |                                                                                         ^^^^ E501
636 |
637 | #         # Check each n-gram's data in the database
    |

tests\models\test_ngram_models_p3.py:639:89: E501 Line too long (90 > 88)
    |
637 | #         # Check each n-gram's data in the database
638 | #         # Check the speed bigram "Th"
639 | #         assert speed_ngrams[0][0] == 2, "First database entry should be bigram (size 2)"
    |                                                                                         ^^ E501
640 | #         assert speed_ngrams[0][1] == "Th", "First database entry should be bigram 'Th'"
641 | #         assert speed_ngrams[0][2] == 250, "Database 'Th' time should be 250ms avg (500ms/2)"
    |

tests\models\test_ngram_models_p3.py:640:89: E501 Line too long (89 > 88)
    |
638 | #         # Check the speed bigram "Th"
639 | #         assert speed_ngrams[0][0] == 2, "First database entry should be bigram (size 2)"
640 | #         assert speed_ngrams[0][1] == "Th", "First database entry should be bigram 'Th'"
    |                                                                                         ^ E501
641 | #         assert speed_ngrams[0][2] == 250, "Database 'Th' time should be 250ms avg (500ms/2)"
    |

tests\models\test_ngram_models_p3.py:641:89: E501 Line too long (94 > 88)
    |
639 | #         assert speed_ngrams[0][0] == 2, "First database entry should be bigram (size 2)"
640 | #         assert speed_ngrams[0][1] == "Th", "First database entry should be bigram 'Th'"
641 | #         assert speed_ngrams[0][2] == 250, "Database 'Th' time should be 250ms avg (500ms/2)"
    |                                                                                         ^^^^^^ E501
642 |
643 | #         # Check the speed bigram "en"
    |

tests\models\test_ngram_models_p3.py:644:89: E501 Line too long (91 > 88)
    |
643 | #         # Check the speed bigram "en"
644 | #         assert speed_ngrams[1][0] == 2, "Second database entry should be bigram (size 2)"
    |                                                                                         ^^^ E501
645 | #         assert speed_ngrams[1][1] == "en", "Second database entry should be bigram 'en'"
646 | #         assert speed_ngrams[1][2] == 85, "Database 'en' time should be 85ms avg (170ms/2)"
    |

tests\models\test_ngram_models_p3.py:645:89: E501 Line too long (90 > 88)
    |
643 | #         # Check the speed bigram "en"
644 | #         assert speed_ngrams[1][0] == 2, "Second database entry should be bigram (size 2)"
645 | #         assert speed_ngrams[1][1] == "en", "Second database entry should be bigram 'en'"
    |                                                                                         ^^ E501
646 | #         assert speed_ngrams[1][2] == 85, "Database 'en' time should be 85ms avg (170ms/2)"
    |

tests\models\test_ngram_models_p3.py:646:89: E501 Line too long (92 > 88)
    |
644 | #         assert speed_ngrams[1][0] == 2, "Second database entry should be bigram (size 2)"
645 | #         assert speed_ngrams[1][1] == "en", "Second database entry should be bigram 'en'"
646 | #         assert speed_ngrams[1][2] == 85, "Database 'en' time should be 85ms avg (170ms/2)"
    |                                                                                         ^^^^ E501
647 |
648 | #         # Verify no error n-grams were saved
    |

tests\models\test_ngram_models_p3.py:650:89: E501 Line too long (93 > 88)
    |
648 | #         # Verify no error n-grams were saved
649 | #         error_ngrams_count = temp_db.fetchone(
650 | #             "SELECT COUNT(*) FROM session_ngram_errors WHERE session_id = ?", (session_id,)
    |                                                                                         ^^^^^ E501
651 | #         )[0]
652 | #         assert error_ngrams_count == 0, "No error n-grams should be saved to the database"
    |

tests\models\test_ngram_models_p3.py:652:89: E501 Line too long (92 > 88)
    |
650 | #             "SELECT COUNT(*) FROM session_ngram_errors WHERE session_id = ?", (session_id,)
651 | #         )[0]
652 | #         assert error_ngrams_count == 0, "No error n-grams should be saved to the database"
    |                                                                                         ^^^^ E501
653 |
654 | #     def test_five_keystrokes_space_at_second(
    |

tests\models\test_ngram_models_p3.py:658:89: E501 Line too long (104 > 88)
    |
656 | #     ):
657 | #         """
658 | #         Test objective: Verify that keystrokes with a space at second position are analyzed correctly.
    |                                                                                         ^^^^^^^^^^^^^^^^ E501
659 |
660 | #         This test checks a scenario where:
    |

tests\models\test_ngram_models_p3.py:674:89: E501 Line too long (98 > 88)
    |
673 | #         # Create and analyze the NGramManager
674 | #         analyzer = NGramManager(test_practice_session, five_keystrokes_space_at_second, temp_db)
    |                                                                                         ^^^^^^^^^^ E501
675 | #         analyzer.analyze(min_size=2, max_size=5)
    |

tests\models\test_ngram_models_p3.py:687:89: E501 Line too long (91 > 88)
    |
686 | #         # Length 4+ n-grams (should be none)
687 | #         assert len(analyzer.speed_ngrams[4]) == 0, "Should find 0 valid length-4 n-grams"
    |                                                                                         ^^^ E501
688 | #         assert len(analyzer.speed_ngrams[5]) == 0, "Should find 0 valid length-5 n-grams"
    |

tests\models\test_ngram_models_p3.py:688:89: E501 Line too long (91 > 88)
    |
686 | #         # Length 4+ n-grams (should be none)
687 | #         assert len(analyzer.speed_ngrams[4]) == 0, "Should find 0 valid length-4 n-grams"
688 | #         assert len(analyzer.speed_ngrams[5]) == 0, "Should find 0 valid length-5 n-grams"
    |                                                                                         ^^^ E501
689 |
690 | #         # Verify the speed bigram "ca"
    |

tests\models\test_ngram_models_p3.py:736:89: E501 Line too long (92 > 88)
    |
734 | #         )
735 |
736 | #         assert len(speed_ngrams) == 3, "Should be exactly 3 speed n-grams in the database"
    |                                                                                         ^^^^ E501
737 |
738 | #         # Check the speed bigrams and trigram
    |

tests\models\test_ngram_models_p3.py:740:89: E501 Line too long (90 > 88)
    |
738 | #         # Check the speed bigrams and trigram
739 | #         # Check the speed bigram "at"
740 | #         assert speed_ngrams[0][0] == 2, "First database entry should be bigram (size 2)"
    |                                                                                         ^^ E501
741 | #         assert speed_ngrams[0][1] == "at", "First database entry should be bigram 'at'"
742 | #         assert speed_ngrams[0][2] == 85, "Database 'at' time should be 85ms avg (170ms/2)"
    |

tests\models\test_ngram_models_p3.py:741:89: E501 Line too long (89 > 88)
    |
739 | #         # Check the speed bigram "at"
740 | #         assert speed_ngrams[0][0] == 2, "First database entry should be bigram (size 2)"
741 | #         assert speed_ngrams[0][1] == "at", "First database entry should be bigram 'at'"
    |                                                                                         ^ E501
742 | #         assert speed_ngrams[0][2] == 85, "Database 'at' time should be 85ms avg (170ms/2)"
    |

tests\models\test_ngram_models_p3.py:742:89: E501 Line too long (92 > 88)
    |
740 | #         assert speed_ngrams[0][0] == 2, "First database entry should be bigram (size 2)"
741 | #         assert speed_ngrams[0][1] == "at", "First database entry should be bigram 'at'"
742 | #         assert speed_ngrams[0][2] == 85, "Database 'at' time should be 85ms avg (170ms/2)"
    |                                                                                         ^^^^ E501
743 |
744 | #         # Check the speed bigram "ca"
    |

tests\models\test_ngram_models_p3.py:745:89: E501 Line too long (91 > 88)
    |
744 | #         # Check the speed bigram "ca"
745 | #         assert speed_ngrams[1][0] == 2, "Second database entry should be bigram (size 2)"
    |                                                                                         ^^^ E501
746 | #         assert speed_ngrams[1][1] == "ca", "Second database entry should be bigram 'ca'"
747 | #         assert speed_ngrams[1][2] == 150, "Database 'ca' time should be 150ms avg (300ms/2)"
    |

tests\models\test_ngram_models_p3.py:746:89: E501 Line too long (90 > 88)
    |
744 | #         # Check the speed bigram "ca"
745 | #         assert speed_ngrams[1][0] == 2, "Second database entry should be bigram (size 2)"
746 | #         assert speed_ngrams[1][1] == "ca", "Second database entry should be bigram 'ca'"
    |                                                                                         ^^ E501
747 | #         assert speed_ngrams[1][2] == 150, "Database 'ca' time should be 150ms avg (300ms/2)"
    |

tests\models\test_ngram_models_p3.py:747:89: E501 Line too long (94 > 88)
    |
745 | #         assert speed_ngrams[1][0] == 2, "Second database entry should be bigram (size 2)"
746 | #         assert speed_ngrams[1][1] == "ca", "Second database entry should be bigram 'ca'"
747 | #         assert speed_ngrams[1][2] == 150, "Database 'ca' time should be 150ms avg (300ms/2)"
    |                                                                                         ^^^^^^ E501
748 |
749 | #         # Check the speed trigram "cat"
    |

tests\models\test_ngram_models_p3.py:750:89: E501 Line too long (91 > 88)
    |
749 | #         # Check the speed trigram "cat"
750 | #         assert speed_ngrams[2][0] == 3, "Third database entry should be trigram (size 3)"
    |                                                                                         ^^^ E501
751 | #         assert speed_ngrams[2][1] == "cat", "Third database entry should be trigram 'cat'"
752 | #         # The average is 470/3 = 156.67ms, rounded depending on DB implementation
    |

tests\models\test_ngram_models_p3.py:751:89: E501 Line too long (92 > 88)
    |
749 | #         # Check the speed trigram "cat"
750 | #         assert speed_ngrams[2][0] == 3, "Third database entry should be trigram (size 3)"
751 | #         assert speed_ngrams[2][1] == "cat", "Third database entry should be trigram 'cat'"
    |                                                                                         ^^^^ E501
752 | #         # The average is 470/3 = 156.67ms, rounded depending on DB implementation
753 | #         assert abs(speed_ngrams[2][2] - 156.67) < 0.5, (
    |

tests\models\test_ngram_models_p3.py:754:89: E501 Line too long (96 > 88)
    |
752 | #         # The average is 470/3 = 156.67ms, rounded depending on DB implementation
753 | #         assert abs(speed_ngrams[2][2] - 156.67) < 0.5, (
754 | #             f"Database 'cat' time should be ~156.67ms avg (470ms/3), got {speed_ngrams[2][2]}"
    |                                                                                         ^^^^^^^^ E501
755 | #         )
    |

tests\models\test_ngram_models_p3.py:759:89: E501 Line too long (93 > 88)
    |
757 | #         # Verify no error n-grams were saved
758 | #         error_ngrams_count = temp_db.fetchone(
759 | #             "SELECT COUNT(*) FROM session_ngram_errors WHERE session_id = ?", (session_id,)
    |                                                                                         ^^^^^ E501
760 | #         )[0]
761 | #         assert error_ngrams_count == 0, "No error n-grams should be saved to the database"
    |

tests\models\test_ngram_models_p3.py:761:89: E501 Line too long (92 > 88)
    |
759 | #             "SELECT COUNT(*) FROM session_ngram_errors WHERE session_id = ?", (session_id,)
760 | #         )[0]
761 | #         assert error_ngrams_count == 0, "No error n-grams should be saved to the database"
    |                                                                                         ^^^^ E501
762 |
763 | #     def test_five_keystrokes_space_at_fifth(
    |

tests\models\test_ngram_models_p3.py:767:89: E501 Line too long (103 > 88)
    |
765 | #     ):
766 | #         """
767 | #         Test objective: Verify that keystrokes with a space at fifth position are analyzed correctly.
    |                                                                                         ^^^^^^^^^^^^^^^ E501
768 |
769 | #         This test checks a scenario where:
    |

tests\models\test_ngram_models_p3.py:784:89: E501 Line too long (97 > 88)
    |
783 | #         # Create and analyze the NGramManager
784 | #         analyzer = NGramManager(test_practice_session, five_keystrokes_space_at_fifth, temp_db)
    |                                                                                         ^^^^^^^^^ E501
785 | #         analyzer.analyze(min_size=2, max_size=5)
    |

tests\models\test_ngram_models_p3.py:793:89: E501 Line too long (89 > 88)
    |
792 | #         # Length 3 n-grams (trigrams)
793 | #         assert len(analyzer.speed_ngrams[3]) == 2, "Should find 2 valid speed trigrams"
    |                                                                                         ^ E501
794 | #         assert len(analyzer.error_ngrams[3]) == 0, "Should find 0 error trigrams"
    |

tests\models\test_ngram_models_p3.py:797:89: E501 Line too long (90 > 88)
    |
796 | #         # Length 4 n-grams
797 | #         assert len(analyzer.speed_ngrams[4]) == 1, "Should find 1 valid length-4 n-gram"
    |                                                                                         ^^ E501
798 | #         assert len(analyzer.error_ngrams[4]) == 0, "Should find 0 error length-4 n-grams"
    |

tests\models\test_ngram_models_p3.py:798:89: E501 Line too long (91 > 88)
    |
796 | #         # Length 4 n-grams
797 | #         assert len(analyzer.speed_ngrams[4]) == 1, "Should find 1 valid length-4 n-gram"
798 | #         assert len(analyzer.error_ngrams[4]) == 0, "Should find 0 error length-4 n-grams"
    |                                                                                         ^^^ E501
799 |
800 | #         # Length 5 n-grams (should be none)
    |

tests\models\test_ngram_models_p3.py:801:89: E501 Line too long (91 > 88)
    |
800 | #         # Length 5 n-grams (should be none)
801 | #         assert len(analyzer.speed_ngrams[5]) == 0, "Should find 0 valid length-5 n-grams"
    |                                                                                         ^^^ E501
802 |
803 | #         # Verify the speed bigram "Th"
    |

tests\models\test_ngram_models_p3.py:842:89: E501 Line too long (89 > 88)
    |
840 | #         assert trigram_the.size == 3, "Trigram size should be 3"
841 | #         assert len(trigram_the.keystrokes) == 3, "Trigram should have 3 keystrokes"
842 | #         assert trigram_the.total_time_ms == 1500, "Trigram 'The' time should be 1500ms"
    |                                                                                         ^ E501
843 | #         assert trigram_the.is_clean is True, "Trigram should be clean (no errors)"
844 | #         assert trigram_the.is_error is False, "Trigram should not be an error trigram"
    |

tests\models\test_ngram_models_p3.py:853:89: E501 Line too long (89 > 88)
    |
851 | #         assert trigram_hen.size == 3, "Trigram size should be 3"
852 | #         assert len(trigram_hen.keystrokes) == 3, "Trigram should have 3 keystrokes"
853 | #         assert trigram_hen.total_time_ms == 1300, "Trigram 'hen' time should be 1300ms"
    |                                                                                         ^ E501
854 | #         assert trigram_hen.is_clean is True, "Trigram should be clean (no errors)"
855 | #         assert trigram_hen.is_error is False, "Trigram should not be an error trigram"
    |

tests\models\test_ngram_models_p3.py:864:89: E501 Line too long (91 > 88)
    |
862 | #         assert fourgram_then.size == 4, "4-gram size should be 4"
863 | #         assert len(fourgram_then.keystrokes) == 4, "4-gram should have 4 keystrokes"
864 | #         assert fourgram_then.total_time_ms == 1800, "4-gram 'Then' time should be 1800ms"
    |                                                                                         ^^^ E501
865 | #         assert fourgram_then.is_clean is True, "4-gram should be clean (no errors)"
866 | #         assert fourgram_then.is_error is False, "4-gram should not be an error n-gram"
    |

tests\models\test_ngram_models_p3.py:882:89: E501 Line too long (92 > 88)
    |
880 | #         )
881 |
882 | #         assert len(speed_ngrams) == 6, "Should be exactly 6 speed n-grams in the database"
    |                                                                                         ^^^^ E501
883 |
884 | #         # Check the bigrams (first 3 entries should be size 2)
    |

tests\models\test_ngram_models_p3.py:885:89: E501 Line too long (90 > 88)
    |
884 | #         # Check the bigrams (first 3 entries should be size 2)
885 | #         assert speed_ngrams[0][0] == 2, "First database entry should be bigram (size 2)"
    |                                                                                         ^^ E501
886 | #         assert speed_ngrams[0][1] in ["Th", "en", "he"], "First bigram entry has correct text"
    |

tests\models\test_ngram_models_p3.py:886:89: E501 Line too long (96 > 88)
    |
884 | #         # Check the bigrams (first 3 entries should be size 2)
885 | #         assert speed_ngrams[0][0] == 2, "First database entry should be bigram (size 2)"
886 | #         assert speed_ngrams[0][1] in ["Th", "en", "he"], "First bigram entry has correct text"
    |                                                                                         ^^^^^^^^ E501
887 |
888 | #         assert speed_ngrams[1][0] == 2, "Second database entry should be bigram (size 2)"
    |

tests\models\test_ngram_models_p3.py:888:89: E501 Line too long (91 > 88)
    |
886 | #         assert speed_ngrams[0][1] in ["Th", "en", "he"], "First bigram entry has correct text"
887 |
888 | #         assert speed_ngrams[1][0] == 2, "Second database entry should be bigram (size 2)"
    |                                                                                         ^^^ E501
889 | #         assert speed_ngrams[1][1] in ["Th", "en", "he"], "Second bigram entry has correct text"
    |

tests\models\test_ngram_models_p3.py:889:89: E501 Line too long (97 > 88)
    |
888 | #         assert speed_ngrams[1][0] == 2, "Second database entry should be bigram (size 2)"
889 | #         assert speed_ngrams[1][1] in ["Th", "en", "he"], "Second bigram entry has correct text"
    |                                                                                         ^^^^^^^^^ E501
890 |
891 | #         assert speed_ngrams[2][0] == 2, "Third database entry should be bigram (size 2)"
    |

tests\models\test_ngram_models_p3.py:891:89: E501 Line too long (90 > 88)
    |
889 | #         assert speed_ngrams[1][1] in ["Th", "en", "he"], "Second bigram entry has correct text"
890 |
891 | #         assert speed_ngrams[2][0] == 2, "Third database entry should be bigram (size 2)"
    |                                                                                         ^^ E501
892 | #         assert speed_ngrams[2][1] in ["Th", "en", "he"], "Third bigram entry has correct text"
    |

tests\models\test_ngram_models_p3.py:892:89: E501 Line too long (96 > 88)
    |
891 | #         assert speed_ngrams[2][0] == 2, "Third database entry should be bigram (size 2)"
892 | #         assert speed_ngrams[2][1] in ["Th", "en", "he"], "Third bigram entry has correct text"
    |                                                                                         ^^^^^^^^ E501
893 |
894 | #         # Check the trigrams (next 2 entries should be size 3)
    |

tests\models\test_ngram_models_p3.py:895:89: E501 Line too long (92 > 88)
    |
894 | #         # Check the trigrams (next 2 entries should be size 3)
895 | #         assert speed_ngrams[3][0] == 3, "Fourth database entry should be trigram (size 3)"
    |                                                                                         ^^^^ E501
896 | #         assert speed_ngrams[3][1] in ["The", "hen"], "Fourth entry should be a valid trigram"
    |

tests\models\test_ngram_models_p3.py:896:89: E501 Line too long (95 > 88)
    |
894 | #         # Check the trigrams (next 2 entries should be size 3)
895 | #         assert speed_ngrams[3][0] == 3, "Fourth database entry should be trigram (size 3)"
896 | #         assert speed_ngrams[3][1] in ["The", "hen"], "Fourth entry should be a valid trigram"
    |                                                                                         ^^^^^^^ E501
897 |
898 | #         assert speed_ngrams[4][0] == 3, "Fifth database entry should be trigram (size 3)"
    |

tests\models\test_ngram_models_p3.py:898:89: E501 Line too long (91 > 88)
    |
896 | #         assert speed_ngrams[3][1] in ["The", "hen"], "Fourth entry should be a valid trigram"
897 |
898 | #         assert speed_ngrams[4][0] == 3, "Fifth database entry should be trigram (size 3)"
    |                                                                                         ^^^ E501
899 | #         assert speed_ngrams[4][1] in ["The", "hen"], "Fifth entry should be a valid trigram"
    |

tests\models\test_ngram_models_p3.py:899:89: E501 Line too long (94 > 88)
    |
898 | #         assert speed_ngrams[4][0] == 3, "Fifth database entry should be trigram (size 3)"
899 | #         assert speed_ngrams[4][1] in ["The", "hen"], "Fifth entry should be a valid trigram"
    |                                                                                         ^^^^^^ E501
900 |
901 | #         # Check the 4-gram (last entry should be size 4)
    |

tests\models\test_ngram_models_p3.py:902:89: E501 Line too long (90 > 88)
    |
901 | #         # Check the 4-gram (last entry should be size 4)
902 | #         assert speed_ngrams[5][0] == 4, "Sixth database entry should be 4-gram (size 4)"
    |                                                                                         ^^ E501
903 | #         assert speed_ngrams[5][1] == "Then", "Sixth entry should be 4-gram 'Then'"
904 | #         # The average is 1800/4 = 450ms, allowing for small rounding differences
    |

tests\models\test_ngram_models_p3.py:906:89: E501 Line too long (95 > 88)
    |
904 | #         # The average is 1800/4 = 450ms, allowing for small rounding differences
905 | #         assert abs(speed_ngrams[5][2] - 450) < 0.5, (
906 | #             f"Database 'Then' time should be ~450ms avg (1800ms/4), got {speed_ngrams[5][2]}"
    |                                                                                         ^^^^^^^ E501
907 | #         )
    |

tests\models\test_ngram_models_p3.py:911:89: E501 Line too long (93 > 88)
    |
909 | #         # Verify no error n-grams were saved
910 | #         error_ngrams_count = temp_db.fetchone(
911 | #             "SELECT COUNT(*) FROM session_ngram_errors WHERE session_id = ?", (session_id,)
    |                                                                                         ^^^^^ E501
912 | #         )[0]
913 | #         assert error_ngrams_count == 0, "No error n-grams should be saved to the database"
    |

tests\models\test_ngram_models_p3.py:913:89: E501 Line too long (92 > 88)
    |
911 | #             "SELECT COUNT(*) FROM session_ngram_errors WHERE session_id = ?", (session_id,)
912 | #         )[0]
913 | #         assert error_ngrams_count == 0, "No error n-grams should be saved to the database"
    |                                                                                         ^^^^ E501
914 |
915 | #     def test_five_keystrokes_th_space_th(temp_db, test_practice_session) -> List[Keystroke]:
    |

tests\models\test_ngram_models_p3.py:915:89: E501 Line too long (94 > 88)
    |
913 | #         assert error_ngrams_count == 0, "No error n-grams should be saved to the database"
914 |
915 | #     def test_five_keystrokes_th_space_th(temp_db, test_practice_session) -> List[Keystroke]:
    |                                                                                         ^^^^^^ E501
916 | #         """
917 | #         Test objective: Create five keystrokes representing 'T-h-space-T-h'.
    |

tests\models\test_ngram_models_p3.py:933:89: E501 Line too long (90 > 88)
    |
931 | #         - Fifth keystroke (h): 300ms after T
932 |
933 | #         This represents the situation where a user types 'Th Th' with consistent timing.
    |                                                                                         ^^ E501
934 | #         The analyzer should create two separate 'Th' ngrams.
935 | #         """
    |

tests\models\test_ngram_models_p3.py:989:89: E501 Line too long (91 > 88)
    |
989 | # def test_th_space_th_ngrams(temp_db, test_practice_session, five_keystrokes_th_space_th):
    |                                                                                         ^^^ E501
990 | #     """
991 | #     Test objective: Verify that 'T-h-space-T-h' creates exactly 2 ngrams.
    |

tests\models\test_ngram_persist.py:60:89: E501 Line too long (94 > 88)
   |
58 |     user_id = str(uuid.uuid4())
59 |     db_with_tables.execute(
60 |         "INSERT INTO users (user_id, first_name, surname, email_address) VALUES (?, ?, ?, ?)",
   |                                                                                         ^^^^^^ E501
61 |         (user_id, "Test", "User", f"testuser_{user_id[:8]}@example.com"),
62 |     )
   |

tests\models\test_ngram_persist.py:79:89: E501 Line too long (94 > 88)
   |
77 | @pytest.fixture
78 | def test_session(
79 |     db_with_tables: DatabaseManager, test_snippet: Snippet, test_user: str, test_keyboard: str
   |                                                                                         ^^^^^^ E501
80 | ) -> Session:
81 |     """Create a test session for tests with valid user_id and keyboard_id."""
   |

tests\models\test_ngram_persist.py:148:89: E501 Line too long (109 > 88)
    |
147 | # Test cases for testing ngram persistence
148 | # Format: (keystrokes, expected, error_indices, ngram_size, expected_in_speed_table, expected_in_error_table)
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^ E501
149 | NGRAM_PERSIST_TEST_CASES = [
150 |     # Case 1: Simple clean, valid ngram of size 2
    |

tests\models\test_ngram_persist.py:172:89: E501 Line too long (96 > 88)
    |
170 |         [("abc", 3)],  # <-- expected-text, not actual
171 |     ),
172 |     # Case 5: Trigram with error in middle (not at last position) - should not be saved anywhere
    |                                                                                         ^^^^^^^^ E501
173 |     ("aBc", "abc", [1], 3, [], []),
174 |     # Case 6: Longer sequence, size 4, clean
    |

tests\models\test_ngram_persist.py:183:89: E501 Line too long (97 > 88)
    |
181 |     ("abcdefghijk", "abcdefghijk", [], 11, [("abcdefghijk", 11)], []),
182 |     # Case 10: Size 20 ngram (maximum allowed size, should be saved)
183 |     ("abcdefghijklmnopqrst", "abcdefghijklmnopqrst", [], 20, [("abcdefghijklmnopqrst", 20)], []),
    |                                                                                         ^^^^^^^^^ E501
184 |     # Case 11: Size 21 ngram (exceeds max size, should not be saved)
185 |     ("abcdefghijklmnopqrstu", "abcdefghijklmnopqrstu", [], 21, [], []),
    |

tests\models\test_ngram_persist.py:186:89: E501 Line too long (97 > 88)
    |
184 |     # Case 11: Size 21 ngram (exceeds max size, should not be saved)
185 |     ("abcdefghijklmnopqrstu", "abcdefghijklmnopqrstu", [], 21, [], []),
186 |     # Case 13: Zero duration (two consecutive keystrokes with same timestamp) should not be saved
    |                                                                                         ^^^^^^^^^ E501
187 |     (
188 |         "xy",
    |

tests\models\test_ngram_persist.py:239:89: E501 Line too long (90 > 88)
    |
237 |     # Special case for test 10: zero duration
238 |     if chars == "xy" and expected == "xy" and not error_indices and ngram_size == 2:
239 |         # Create keystrokes with the EXACT same timestamp object for testing zero duration
    |                                                                                         ^^ E501
240 |         ts = datetime.now()
241 |         keystrokes = [
    |

tests\models\test_ngram_persist.py:248:89: E501 Line too long (99 > 88)
    |
246 |     else:
247 |         # Create normal keystroke sequence
248 |         keystrokes = create_keystroke_sequence(chars, expected, datetime.now(), 100, error_indices)
    |                                                                                         ^^^^^^^^^^^ E501
249 |
250 |     # Generate ngrams
    |

tests\models\test_ngram_persist.py:277:89: E501 Line too long (91 > 88)
    |
276 |     assert sorted(actual_speed_ngrams) == sorted(exp_speed_ngrams), (
277 |         f"Speed ngrams don't match: expected {exp_speed_ngrams}, got {actual_speed_ngrams}"
    |                                                                                         ^^^ E501
278 |     )
    |

tests\models\test_ngram_persist.py:287:89: E501 Line too long (91 > 88)
    |
285 |     actual_error_ngrams = [(row[0], row[1]) for row in error_ngrams]
286 |     assert sorted(actual_error_ngrams) == sorted(exp_error_ngrams), (
287 |         f"Error ngrams don't match: expected {exp_error_ngrams}, got {actual_error_ngrams}"
    |                                                                                         ^^^ E501
288 |     )
    |

tests\models\test_ngram_persist.py:307:89: E501 Line too long (92 > 88)
    |
305 |     start_time = datetime.now()
306 |     keystrokes = [
307 |         Keystroke(char="T", expected="T", timestamp=start_time + timedelta(milliseconds=0)),
    |                                                                                         ^^^^ E501
308 |         Keystroke(char="h", expected="h", timestamp=start_time + timedelta(milliseconds=100)),
309 |         Keystroke(char="e", expected="e", timestamp=start_time + timedelta(milliseconds=200)),
    |

tests\models\test_ngram_persist.py:308:89: E501 Line too long (94 > 88)
    |
306 |     keystrokes = [
307 |         Keystroke(char="T", expected="T", timestamp=start_time + timedelta(milliseconds=0)),
308 |         Keystroke(char="h", expected="h", timestamp=start_time + timedelta(milliseconds=100)),
    |                                                                                         ^^^^^^ E501
309 |         Keystroke(char="e", expected="e", timestamp=start_time + timedelta(milliseconds=200)),
310 |         Keystroke(char=" ", expected=" ", timestamp=start_time + timedelta(milliseconds=300)),
    |

tests\models\test_ngram_persist.py:309:89: E501 Line too long (94 > 88)
    |
307 |         Keystroke(char="T", expected="T", timestamp=start_time + timedelta(milliseconds=0)),
308 |         Keystroke(char="h", expected="h", timestamp=start_time + timedelta(milliseconds=100)),
309 |         Keystroke(char="e", expected="e", timestamp=start_time + timedelta(milliseconds=200)),
    |                                                                                         ^^^^^^ E501
310 |         Keystroke(char=" ", expected=" ", timestamp=start_time + timedelta(milliseconds=300)),
311 |         Keystroke(char="q", expected="q", timestamp=start_time + timedelta(milliseconds=400)),
    |

tests\models\test_ngram_persist.py:310:89: E501 Line too long (94 > 88)
    |
308 |         Keystroke(char="h", expected="h", timestamp=start_time + timedelta(milliseconds=100)),
309 |         Keystroke(char="e", expected="e", timestamp=start_time + timedelta(milliseconds=200)),
310 |         Keystroke(char=" ", expected=" ", timestamp=start_time + timedelta(milliseconds=300)),
    |                                                                                         ^^^^^^ E501
311 |         Keystroke(char="q", expected="q", timestamp=start_time + timedelta(milliseconds=400)),
312 |         Keystroke(char="u", expected="u", timestamp=start_time + timedelta(milliseconds=500)),
    |

tests\models\test_ngram_persist.py:311:89: E501 Line too long (94 > 88)
    |
309 |         Keystroke(char="e", expected="e", timestamp=start_time + timedelta(milliseconds=200)),
310 |         Keystroke(char=" ", expected=" ", timestamp=start_time + timedelta(milliseconds=300)),
311 |         Keystroke(char="q", expected="q", timestamp=start_time + timedelta(milliseconds=400)),
    |                                                                                         ^^^^^^ E501
312 |         Keystroke(char="u", expected="u", timestamp=start_time + timedelta(milliseconds=500)),
313 |         Keystroke(char="i", expected="i", timestamp=start_time + timedelta(milliseconds=600)),
    |

tests\models\test_ngram_persist.py:312:89: E501 Line too long (94 > 88)
    |
310 |         Keystroke(char=" ", expected=" ", timestamp=start_time + timedelta(milliseconds=300)),
311 |         Keystroke(char="q", expected="q", timestamp=start_time + timedelta(milliseconds=400)),
312 |         Keystroke(char="u", expected="u", timestamp=start_time + timedelta(milliseconds=500)),
    |                                                                                         ^^^^^^ E501
313 |         Keystroke(char="i", expected="i", timestamp=start_time + timedelta(milliseconds=600)),
314 |         Keystroke(char="c", expected="c", timestamp=start_time + timedelta(milliseconds=700)),
    |

tests\models\test_ngram_persist.py:313:89: E501 Line too long (94 > 88)
    |
311 |         Keystroke(char="q", expected="q", timestamp=start_time + timedelta(milliseconds=400)),
312 |         Keystroke(char="u", expected="u", timestamp=start_time + timedelta(milliseconds=500)),
313 |         Keystroke(char="i", expected="i", timestamp=start_time + timedelta(milliseconds=600)),
    |                                                                                         ^^^^^^ E501
314 |         Keystroke(char="c", expected="c", timestamp=start_time + timedelta(milliseconds=700)),
315 |         Keystroke(char="k", expected="k", timestamp=start_time + timedelta(milliseconds=800)),
    |

tests\models\test_ngram_persist.py:314:89: E501 Line too long (94 > 88)
    |
312 |         Keystroke(char="u", expected="u", timestamp=start_time + timedelta(milliseconds=500)),
313 |         Keystroke(char="i", expected="i", timestamp=start_time + timedelta(milliseconds=600)),
314 |         Keystroke(char="c", expected="c", timestamp=start_time + timedelta(milliseconds=700)),
    |                                                                                         ^^^^^^ E501
315 |         Keystroke(char="k", expected="k", timestamp=start_time + timedelta(milliseconds=800)),
316 |         Keystroke(char=" ", expected=" ", timestamp=start_time + timedelta(milliseconds=900)),
    |

tests\models\test_ngram_persist.py:315:89: E501 Line too long (94 > 88)
    |
313 |         Keystroke(char="i", expected="i", timestamp=start_time + timedelta(milliseconds=600)),
314 |         Keystroke(char="c", expected="c", timestamp=start_time + timedelta(milliseconds=700)),
315 |         Keystroke(char="k", expected="k", timestamp=start_time + timedelta(milliseconds=800)),
    |                                                                                         ^^^^^^ E501
316 |         Keystroke(char=" ", expected=" ", timestamp=start_time + timedelta(milliseconds=900)),
317 |         # Error here (uppercase B instead of lowercase)
    |

tests\models\test_ngram_persist.py:316:89: E501 Line too long (94 > 88)
    |
314 |         Keystroke(char="c", expected="c", timestamp=start_time + timedelta(milliseconds=700)),
315 |         Keystroke(char="k", expected="k", timestamp=start_time + timedelta(milliseconds=800)),
316 |         Keystroke(char=" ", expected=" ", timestamp=start_time + timedelta(milliseconds=900)),
    |                                                                                         ^^^^^^ E501
317 |         # Error here (uppercase B instead of lowercase)
318 |         Keystroke(char="B", expected="b", timestamp=start_time + timedelta(milliseconds=1000)),
    |

tests\models\test_ngram_persist.py:318:89: E501 Line too long (95 > 88)
    |
316 |         Keystroke(char=" ", expected=" ", timestamp=start_time + timedelta(milliseconds=900)),
317 |         # Error here (uppercase B instead of lowercase)
318 |         Keystroke(char="B", expected="b", timestamp=start_time + timedelta(milliseconds=1000)),
    |                                                                                         ^^^^^^^ E501
319 |         Keystroke(char="r", expected="r", timestamp=start_time + timedelta(milliseconds=1100)),
320 |         Keystroke(char="o", expected="o", timestamp=start_time + timedelta(milliseconds=1200)),
    |

tests\models\test_ngram_persist.py:319:89: E501 Line too long (95 > 88)
    |
317 |         # Error here (uppercase B instead of lowercase)
318 |         Keystroke(char="B", expected="b", timestamp=start_time + timedelta(milliseconds=1000)),
319 |         Keystroke(char="r", expected="r", timestamp=start_time + timedelta(milliseconds=1100)),
    |                                                                                         ^^^^^^^ E501
320 |         Keystroke(char="o", expected="o", timestamp=start_time + timedelta(milliseconds=1200)),
321 |         Keystroke(char="w", expected="w", timestamp=start_time + timedelta(milliseconds=1300)),
    |

tests\models\test_ngram_persist.py:320:89: E501 Line too long (95 > 88)
    |
318 |         Keystroke(char="B", expected="b", timestamp=start_time + timedelta(milliseconds=1000)),
319 |         Keystroke(char="r", expected="r", timestamp=start_time + timedelta(milliseconds=1100)),
320 |         Keystroke(char="o", expected="o", timestamp=start_time + timedelta(milliseconds=1200)),
    |                                                                                         ^^^^^^^ E501
321 |         Keystroke(char="w", expected="w", timestamp=start_time + timedelta(milliseconds=1300)),
322 |         Keystroke(char="n", expected="n", timestamp=start_time + timedelta(milliseconds=1400)),
    |

tests\models\test_ngram_persist.py:321:89: E501 Line too long (95 > 88)
    |
319 |         Keystroke(char="r", expected="r", timestamp=start_time + timedelta(milliseconds=1100)),
320 |         Keystroke(char="o", expected="o", timestamp=start_time + timedelta(milliseconds=1200)),
321 |         Keystroke(char="w", expected="w", timestamp=start_time + timedelta(milliseconds=1300)),
    |                                                                                         ^^^^^^^ E501
322 |         Keystroke(char="n", expected="n", timestamp=start_time + timedelta(milliseconds=1400)),
323 |         Keystroke(char=" ", expected=" ", timestamp=start_time + timedelta(milliseconds=1500)),
    |

tests\models\test_ngram_persist.py:322:89: E501 Line too long (95 > 88)
    |
320 |         Keystroke(char="o", expected="o", timestamp=start_time + timedelta(milliseconds=1200)),
321 |         Keystroke(char="w", expected="w", timestamp=start_time + timedelta(milliseconds=1300)),
322 |         Keystroke(char="n", expected="n", timestamp=start_time + timedelta(milliseconds=1400)),
    |                                                                                         ^^^^^^^ E501
323 |         Keystroke(char=" ", expected=" ", timestamp=start_time + timedelta(milliseconds=1500)),
324 |         Keystroke(char="f", expected="f", timestamp=start_time + timedelta(milliseconds=1600)),
    |

tests\models\test_ngram_persist.py:323:89: E501 Line too long (95 > 88)
    |
321 |         Keystroke(char="w", expected="w", timestamp=start_time + timedelta(milliseconds=1300)),
322 |         Keystroke(char="n", expected="n", timestamp=start_time + timedelta(milliseconds=1400)),
323 |         Keystroke(char=" ", expected=" ", timestamp=start_time + timedelta(milliseconds=1500)),
    |                                                                                         ^^^^^^^ E501
324 |         Keystroke(char="f", expected="f", timestamp=start_time + timedelta(milliseconds=1600)),
325 |         Keystroke(char="o", expected="o", timestamp=start_time + timedelta(milliseconds=1700)),
    |

tests\models\test_ngram_persist.py:324:89: E501 Line too long (95 > 88)
    |
322 |         Keystroke(char="n", expected="n", timestamp=start_time + timedelta(milliseconds=1400)),
323 |         Keystroke(char=" ", expected=" ", timestamp=start_time + timedelta(milliseconds=1500)),
324 |         Keystroke(char="f", expected="f", timestamp=start_time + timedelta(milliseconds=1600)),
    |                                                                                         ^^^^^^^ E501
325 |         Keystroke(char="o", expected="o", timestamp=start_time + timedelta(milliseconds=1700)),
326 |         Keystroke(char="x", expected="x", timestamp=start_time + timedelta(milliseconds=1800)),
    |

tests\models\test_ngram_persist.py:325:89: E501 Line too long (95 > 88)
    |
323 |         Keystroke(char=" ", expected=" ", timestamp=start_time + timedelta(milliseconds=1500)),
324 |         Keystroke(char="f", expected="f", timestamp=start_time + timedelta(milliseconds=1600)),
325 |         Keystroke(char="o", expected="o", timestamp=start_time + timedelta(milliseconds=1700)),
    |                                                                                         ^^^^^^^ E501
326 |         Keystroke(char="x", expected="x", timestamp=start_time + timedelta(milliseconds=1800)),
327 |     ]
    |

tests\models\test_ngram_persist.py:326:89: E501 Line too long (95 > 88)
    |
324 |         Keystroke(char="f", expected="f", timestamp=start_time + timedelta(milliseconds=1600)),
325 |         Keystroke(char="o", expected="o", timestamp=start_time + timedelta(milliseconds=1700)),
326 |         Keystroke(char="x", expected="x", timestamp=start_time + timedelta(milliseconds=1800)),
    |                                                                                         ^^^^^^^ E501
327 |     ]
    |

tests\models\test_ngram_persist.py:344:89: E501 Line too long (93 > 88)
    |
342 |     # Check speed table (clean trigrams, no spaces)
343 |     speed_ngrams = db_with_tables.fetchall(
344 |         "SELECT ngram_text FROM session_ngram_speed WHERE session_id = ? AND ngram_size = ?",
    |                                                                                         ^^^^^ E501
345 |         (test_session.session_id, ngram_size),
346 |     )
    |

tests\models\test_ngram_persist.py:348:89: E501 Line too long (96 > 88)
    |
346 |     )
347 |     actual_speed_ngrams = [row[0] for row in speed_ngrams]
348 |     expected_speed_trigrams = ["The", "qui", "uic", "ick", "rown", "own", "wn f", "n fo", "fox"]
    |                                                                                         ^^^^^^^^ E501
349 |
350 |     # Verify each expected trigram is in the actual results
    |

tests\models\test_ngram_persist.py:359:89: E501 Line too long (94 > 88)
    |
357 |     # Check error table (should have no trigram errors with error only at last position)
358 |     error_ngrams = db_with_tables.fetchall(
359 |         "SELECT ngram_text FROM session_ngram_errors WHERE session_id = ? AND ngram_size = ?",
    |                                                                                         ^^^^^^ E501
360 |         (test_session.session_id, ngram_size),
361 |     )
    |

tests\models\test_ngram_persist.py:363:89: E501 Line too long (95 > 88)
    |
361 |     )
362 |     actual_error_ngrams = [row[0] for row in error_ngrams]
363 |     # The only trigram with an error at the last position would be if a trigram ended with 'B',
    |                                                                                         ^^^^^^^ E501
364 |     # but that would be " qB" which isn't valid due to the space
365 |     assert len(actual_error_ngrams) == 0, (
    |

tests\models\test_ngram_size.py:62:89: E501 Line too long (99 > 88)
   |
60 |     # Convert keystroke objects to ngram_manager.Keystroke format
61 |     converted_keystrokes = [
62 |         NGramKeystroke(char=k.keystroke_char, expected=k.expected_char, timestamp=k.keystroke_time)
   |                                                                                         ^^^^^^^^^^^ E501
63 |         for k in km.keystroke_list
64 |     ]
   |

tests\models\test_ngram_size.py:72:89: E501 Line too long (94 > 88)
   |
70 |     # Check n-gram counts for sizes 2-10
71 |     for n in range(2, 11):
72 |         query = "SELECT COUNT(*) FROM session_ngram_speed WHERE session_id=? AND ngram_size=?"
   |                                                                                         ^^^^^^ E501
73 |         result = db_with_tables.fetchone(query, (test_session.session_id, n))
74 |         count = list(result.values())[0] if result else 0
   |

tests\models\test_ngram_size.py:100:89: E501 Line too long (96 > 88)
    |
 98 |     cat_id = str(uuid.uuid4())
 99 |     db_with_tables.execute(
100 |         "INSERT INTO categories (category_id, category_name) VALUES (?, ?)", (cat_id, "TestCat")
    |                                                                                         ^^^^^^^^ E501
101 |     )
102 |     # Create snippet
    |

tests\models\test_ngram_size.py:118:89: E501 Line too long (94 > 88)
    |
116 |     keyboard_id = str(uuid.uuid4())
117 |     db_with_tables.execute(
118 |         "INSERT INTO users (user_id, first_name, surname, email_address) VALUES (?, ?, ?, ?)",
    |                                                                                         ^^^^^^ E501
119 |         (user_id, "Test", "User", f"testuser_{user_id[:8]}@example.com"),
120 |     )
    |

tests\models\test_ngram_size.py:129:89: E501 Line too long (94 > 88)
    |
127 |         "INSERT INTO practice_sessions (session_id, snippet_id, user_id, keyboard_id, "
128 |         "snippet_index_start, snippet_index_end, content, start_time, end_time, "
129 |         "actual_chars, errors, ms_per_keystroke) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)",
    |                                                                                         ^^^^^^ E501
130 |         (
131 |             sess_id,
    |

tests\models\test_ngram_size.py:163:89: E501 Line too long (99 > 88)
    |
161 |     # Convert keystroke objects to ngram_manager.Keystroke format
162 |     converted_keystrokes = [
163 |         NGramKeystroke(char=k.keystroke_char, expected=k.expected_char, timestamp=k.keystroke_time)
    |                                                                                         ^^^^^^^^^^^ E501
164 |         for k in km.keystroke_list
165 |     ]
    |

tests\models\test_ngram_size.py:172:89: E501 Line too long (94 > 88)
    |
170 |     # Check n-gram counts for sizes 2-10
171 |     for n in range(2, 11):
172 |         query = "SELECT COUNT(*) FROM session_ngram_speed WHERE session_id=? AND ngram_size=?"
    |                                                                                         ^^^^^^ E501
173 |         row = db_with_tables.fetchone(query, (sess_id, n))
174 |         count = list(row.values())[0] if row else 0
    |

tests\models\test_ngram_size.py:177:89: E501 Line too long (91 > 88)
    |
175 |         expected = expected_ngram_count_with_filtering(test_string, n)
176 |         assert count == expected, (
177 |             f"N-gram size {n}: expected {expected}, got {count} for string '{test_string}'"
    |                                                                                         ^^^ E501
178 |         )
    |

tests\models\test_ngram_speed.py:34:89: E501 Line too long (99 > 88)
   |
32 |     if not (MIN_NGRAM_SIZE <= n <= MAX_NGRAM_SIZE):
33 |         return []
34 |     if n > len(keystrokes) or n < 2:  # n < 2 would lead to division by zero or undefined for speed
   |                                                                                         ^^^^^^^^^^^ E501
35 |         return []
   |

tests\models\test_ngram_speed.py:201:89: E501 Line too long (96 > 88)
    |
199 | ) -> None:
200 |     """
201 |     Test objective: Verify n-gram speed calculation for various keystroke sequences and n-sizes.
    |                                                                                         ^^^^^^^^ E501
202 |     This test uses the test_session_setup fixture as requested, though the fixture's
203 |     outputs are not directly used by generate_ngrams_with_speed itself.
    |

tests\models\test_ngram_speed.py:205:89: E501 Line too long (93 > 88)
    |
203 |     outputs are not directly used by generate_ngrams_with_speed itself.
204 |     """
205 |     # session_id, snippet_id, category_id = test_session_setup # Unused in this specific test
    |                                                                                         ^^^^^ E501
206 |
207 |     actual_ngrams_with_speed = generate_ngrams_with_speed(keystrokes, n)
    |

tests\models\test_ngram_speed.py:210:89: E501 Line too long (100 > 88)
    |
209 |     # For float comparisons, it's often better to use pytest.approx
210 |     # However, for this specific calculation, direct comparison should be fine if inputs are simple.
    |                                                                                         ^^^^^^^^^^^^ E501
211 |     # If issues arise, convert expected speeds to
212 |     # pytest.approx(speed, rel=1e-5)
    |

tests\models\test_ngram_speed.py:220:89: E501 Line too long (99 > 88)
    |
218 |     )
219 |
220 |     for actual, expected in zip(actual_ngrams_with_speed, expected_ngrams_with_speed, strict=True):
    |                                                                                         ^^^^^^^^^^^ E501
221 |         assert actual[0] == expected[0], (
222 |             f"For keystrokes={keystrokes}, n={n}: Ngram text mismatch. "
    |

tests\models\test_ngram_valid.py:142:89: E501 Line too long (91 > 88)
    |
140 |     (
141 |         [
142 |             Keystroke(char="a", expected="a", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
    |                                                                                         ^^^ E501
143 |             Keystroke(char="b", expected="b", timestamp=datetime(2023, 1, 1, 12, 0, 0, 1000)),
144 |             Keystroke(char="c", expected="c", timestamp=datetime(2023, 1, 1, 12, 0, 0, 1000)),
    |

tests\models\test_ngram_valid.py:143:89: E501 Line too long (94 > 88)
    |
141 |         [
142 |             Keystroke(char="a", expected="a", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
143 |             Keystroke(char="b", expected="b", timestamp=datetime(2023, 1, 1, 12, 0, 0, 1000)),
    |                                                                                         ^^^^^^ E501
144 |             Keystroke(char="c", expected="c", timestamp=datetime(2023, 1, 1, 12, 0, 0, 1000)),
145 |         ],
    |

tests\models\test_ngram_valid.py:144:89: E501 Line too long (94 > 88)
    |
142 |             Keystroke(char="a", expected="a", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
143 |             Keystroke(char="b", expected="b", timestamp=datetime(2023, 1, 1, 12, 0, 0, 1000)),
144 |             Keystroke(char="c", expected="c", timestamp=datetime(2023, 1, 1, 12, 0, 0, 1000)),
    |                                                                                         ^^^^^^ E501
145 |         ],
146 |         3,
    |

tests\models\test_ngram_valid.py:153:89: E501 Line too long (91 > 88)
    |
151 |     (
152 |         [
153 |             Keystroke(char=" ", expected=" ", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
    |                                                                                         ^^^ E501
154 |             Keystroke(char="b", expected="b", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
155 |         ],
    |

tests\models\test_ngram_valid.py:154:89: E501 Line too long (96 > 88)
    |
152 |         [
153 |             Keystroke(char=" ", expected=" ", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
154 |             Keystroke(char="b", expected="b", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
    |                                                                                         ^^^^^^^^ E501
155 |         ],
156 |         2,
    |

tests\models\test_ngram_valid.py:162:89: E501 Line too long (91 > 88)
    |
160 |     (
161 |         [
162 |             Keystroke(char="a", expected="a", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
    |                                                                                         ^^^ E501
163 |             Keystroke(char=" ", expected=" ", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
164 |         ],
    |

tests\models\test_ngram_valid.py:163:89: E501 Line too long (96 > 88)
    |
161 |         [
162 |             Keystroke(char="a", expected="a", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
163 |             Keystroke(char=" ", expected=" ", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
    |                                                                                         ^^^^^^^^ E501
164 |         ],
165 |         2,
    |

tests\models\test_ngram_valid.py:171:89: E501 Line too long (91 > 88)
    |
169 |     (
170 |         [
171 |             Keystroke(char="a", expected="a", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
    |                                                                                         ^^^ E501
172 |             Keystroke(char=" ", expected=" ", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
173 |             Keystroke(char="c", expected="c", timestamp=datetime(2023, 1, 1, 12, 0, 0, 200000)),
    |

tests\models\test_ngram_valid.py:172:89: E501 Line too long (96 > 88)
    |
170 |         [
171 |             Keystroke(char="a", expected="a", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
172 |             Keystroke(char=" ", expected=" ", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
    |                                                                                         ^^^^^^^^ E501
173 |             Keystroke(char="c", expected="c", timestamp=datetime(2023, 1, 1, 12, 0, 0, 200000)),
174 |         ],
    |

tests\models\test_ngram_valid.py:173:89: E501 Line too long (96 > 88)
    |
171 |             Keystroke(char="a", expected="a", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
172 |             Keystroke(char=" ", expected=" ", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
173 |             Keystroke(char="c", expected="c", timestamp=datetime(2023, 1, 1, 12, 0, 0, 200000)),
    |                                                                                         ^^^^^^^^ E501
174 |         ],
175 |         3,
    |

tests\models\test_ngram_valid.py:182:89: E501 Line too long (91 > 88)
    |
180 |     (
181 |         [
182 |             Keystroke(char="a", expected="X", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
    |                                                                                         ^^^ E501
183 |             Keystroke(char=" ", expected=" ", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
184 |             Keystroke(char="c", expected="c", timestamp=datetime(2023, 1, 1, 12, 0, 0, 200000)),
    |

tests\models\test_ngram_valid.py:183:89: E501 Line too long (96 > 88)
    |
181 |         [
182 |             Keystroke(char="a", expected="X", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
183 |             Keystroke(char=" ", expected=" ", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
    |                                                                                         ^^^^^^^^ E501
184 |             Keystroke(char="c", expected="c", timestamp=datetime(2023, 1, 1, 12, 0, 0, 200000)),
185 |         ],
    |

tests\models\test_ngram_valid.py:184:89: E501 Line too long (96 > 88)
    |
182 |             Keystroke(char="a", expected="X", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
183 |             Keystroke(char=" ", expected=" ", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
184 |             Keystroke(char="c", expected="c", timestamp=datetime(2023, 1, 1, 12, 0, 0, 200000)),
    |                                                                                         ^^^^^^^^ E501
185 |         ],
186 |         3,
    |

tests\models\test_ngram_valid.py:192:89: E501 Line too long (91 > 88)
    |
190 |     (
191 |         [
192 |             Keystroke(char="a", expected="a", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
    |                                                                                         ^^^ E501
193 |             Keystroke(char="b", expected="b", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
194 |             Keystroke(char="\b", expected="\b", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
    |

tests\models\test_ngram_valid.py:193:89: E501 Line too long (91 > 88)
    |
191 |         [
192 |             Keystroke(char="a", expected="a", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
193 |             Keystroke(char="b", expected="b", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
    |                                                                                         ^^^ E501
194 |             Keystroke(char="\b", expected="\b", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
195 |         ],
    |

tests\models\test_ngram_valid.py:194:89: E501 Line too long (98 > 88)
    |
192 |             Keystroke(char="a", expected="a", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
193 |             Keystroke(char="b", expected="b", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
194 |             Keystroke(char="\b", expected="\b", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
    |                                                                                         ^^^^^^^^^^ E501
195 |         ],
196 |         3,
    |

tests\models\test_ngram_valid.py:203:89: E501 Line too long (91 > 88)
    |
201 |     (
202 |         [
203 |             Keystroke(char="t", expected="t", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
    |                                                                                         ^^^ E501
204 |             Keystroke(char="h", expected="h", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
205 |             Keystroke(char="e", expected="e", timestamp=datetime(2023, 1, 1, 12, 0, 0, 200000)),
    |

tests\models\test_ngram_valid.py:204:89: E501 Line too long (96 > 88)
    |
202 |         [
203 |             Keystroke(char="t", expected="t", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
204 |             Keystroke(char="h", expected="h", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
    |                                                                                         ^^^^^^^^ E501
205 |             Keystroke(char="e", expected="e", timestamp=datetime(2023, 1, 1, 12, 0, 0, 200000)),
206 |             Keystroke(char="n", expected="N", timestamp=datetime(2023, 1, 1, 12, 0, 0, 300000)),
    |

tests\models\test_ngram_valid.py:205:89: E501 Line too long (96 > 88)
    |
203 |             Keystroke(char="t", expected="t", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
204 |             Keystroke(char="h", expected="h", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
205 |             Keystroke(char="e", expected="e", timestamp=datetime(2023, 1, 1, 12, 0, 0, 200000)),
    |                                                                                         ^^^^^^^^ E501
206 |             Keystroke(char="n", expected="N", timestamp=datetime(2023, 1, 1, 12, 0, 0, 300000)),
207 |         ],
    |

tests\models\test_ngram_valid.py:206:89: E501 Line too long (96 > 88)
    |
204 |             Keystroke(char="h", expected="h", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
205 |             Keystroke(char="e", expected="e", timestamp=datetime(2023, 1, 1, 12, 0, 0, 200000)),
206 |             Keystroke(char="n", expected="N", timestamp=datetime(2023, 1, 1, 12, 0, 0, 300000)),
    |                                                                                         ^^^^^^^^ E501
207 |         ],
208 |         2,
    |

tests\models\test_ngram_valid.py:214:89: E501 Line too long (91 > 88)
    |
212 |     (
213 |         [
214 |             Keystroke(char="q", expected="q", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
    |                                                                                         ^^^ E501
215 |             Keystroke(char="u", expected="X", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
216 |             Keystroke(char="i", expected="i", timestamp=datetime(2023, 1, 1, 12, 0, 0, 200000)),
    |

tests\models\test_ngram_valid.py:215:89: E501 Line too long (96 > 88)
    |
213 |         [
214 |             Keystroke(char="q", expected="q", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
215 |             Keystroke(char="u", expected="X", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
    |                                                                                         ^^^^^^^^ E501
216 |             Keystroke(char="i", expected="i", timestamp=datetime(2023, 1, 1, 12, 0, 0, 200000)),
217 |             Keystroke(char="c", expected="c", timestamp=datetime(2023, 1, 1, 12, 0, 0, 300000)),
    |

tests\models\test_ngram_valid.py:216:89: E501 Line too long (96 > 88)
    |
214 |             Keystroke(char="q", expected="q", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
215 |             Keystroke(char="u", expected="X", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
216 |             Keystroke(char="i", expected="i", timestamp=datetime(2023, 1, 1, 12, 0, 0, 200000)),
    |                                                                                         ^^^^^^^^ E501
217 |             Keystroke(char="c", expected="c", timestamp=datetime(2023, 1, 1, 12, 0, 0, 300000)),
218 |             Keystroke(char="k", expected="k", timestamp=datetime(2023, 1, 1, 12, 0, 0, 400000)),
    |

tests\models\test_ngram_valid.py:217:89: E501 Line too long (96 > 88)
    |
215 |             Keystroke(char="u", expected="X", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
216 |             Keystroke(char="i", expected="i", timestamp=datetime(2023, 1, 1, 12, 0, 0, 200000)),
217 |             Keystroke(char="c", expected="c", timestamp=datetime(2023, 1, 1, 12, 0, 0, 300000)),
    |                                                                                         ^^^^^^^^ E501
218 |             Keystroke(char="k", expected="k", timestamp=datetime(2023, 1, 1, 12, 0, 0, 400000)),
219 |         ],
    |

tests\models\test_ngram_valid.py:218:89: E501 Line too long (96 > 88)
    |
216 |             Keystroke(char="i", expected="i", timestamp=datetime(2023, 1, 1, 12, 0, 0, 200000)),
217 |             Keystroke(char="c", expected="c", timestamp=datetime(2023, 1, 1, 12, 0, 0, 300000)),
218 |             Keystroke(char="k", expected="k", timestamp=datetime(2023, 1, 1, 12, 0, 0, 400000)),
    |                                                                                         ^^^^^^^^ E501
219 |         ],
220 |         3,
    |

tests\models\test_ngram_valid.py:226:89: E501 Line too long (91 > 88)
    |
224 |     (
225 |         [
226 |             Keystroke(char="a", expected="a", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
    |                                                                                         ^^^ E501
227 |             Keystroke(char="\b", expected="\b", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
228 |             Keystroke(char="c", expected="c", timestamp=datetime(2023, 1, 1, 12, 0, 0, 200000)),
    |

tests\models\test_ngram_valid.py:227:89: E501 Line too long (98 > 88)
    |
225 |         [
226 |             Keystroke(char="a", expected="a", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
227 |             Keystroke(char="\b", expected="\b", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
    |                                                                                         ^^^^^^^^^^ E501
228 |             Keystroke(char="c", expected="c", timestamp=datetime(2023, 1, 1, 12, 0, 0, 200000)),
229 |             Keystroke(char="d", expected="d", timestamp=datetime(2023, 1, 1, 12, 0, 0, 300000)),
    |

tests\models\test_ngram_valid.py:228:89: E501 Line too long (96 > 88)
    |
226 |             Keystroke(char="a", expected="a", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
227 |             Keystroke(char="\b", expected="\b", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
228 |             Keystroke(char="c", expected="c", timestamp=datetime(2023, 1, 1, 12, 0, 0, 200000)),
    |                                                                                         ^^^^^^^^ E501
229 |             Keystroke(char="d", expected="d", timestamp=datetime(2023, 1, 1, 12, 0, 0, 300000)),
230 |         ],
    |

tests\models\test_ngram_valid.py:229:89: E501 Line too long (96 > 88)
    |
227 |             Keystroke(char="\b", expected="\b", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
228 |             Keystroke(char="c", expected="c", timestamp=datetime(2023, 1, 1, 12, 0, 0, 200000)),
229 |             Keystroke(char="d", expected="d", timestamp=datetime(2023, 1, 1, 12, 0, 0, 300000)),
    |                                                                                         ^^^^^^^^ E501
230 |         ],
231 |         2,
    |

tests\models\test_ngram_valid.py:237:89: E501 Line too long (91 > 88)
    |
235 |     (
236 |         [
237 |             Keystroke(char="f", expected="f", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
    |                                                                                         ^^^ E501
238 |             Keystroke(char=" ", expected=" ", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
239 |             Keystroke(char="g", expected="g", timestamp=datetime(2023, 1, 1, 12, 0, 0, 200000)),
    |

tests\models\test_ngram_valid.py:238:89: E501 Line too long (96 > 88)
    |
236 |         [
237 |             Keystroke(char="f", expected="f", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
238 |             Keystroke(char=" ", expected=" ", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
    |                                                                                         ^^^^^^^^ E501
239 |             Keystroke(char="g", expected="g", timestamp=datetime(2023, 1, 1, 12, 0, 0, 200000)),
240 |             Keystroke(char="h", expected="H", timestamp=datetime(2023, 1, 1, 12, 0, 0, 300000)),
    |

tests\models\test_ngram_valid.py:239:89: E501 Line too long (96 > 88)
    |
237 |             Keystroke(char="f", expected="f", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
238 |             Keystroke(char=" ", expected=" ", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
239 |             Keystroke(char="g", expected="g", timestamp=datetime(2023, 1, 1, 12, 0, 0, 200000)),
    |                                                                                         ^^^^^^^^ E501
240 |             Keystroke(char="h", expected="H", timestamp=datetime(2023, 1, 1, 12, 0, 0, 300000)),
241 |         ],
    |

tests\models\test_ngram_valid.py:240:89: E501 Line too long (96 > 88)
    |
238 |             Keystroke(char=" ", expected=" ", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
239 |             Keystroke(char="g", expected="g", timestamp=datetime(2023, 1, 1, 12, 0, 0, 200000)),
240 |             Keystroke(char="h", expected="H", timestamp=datetime(2023, 1, 1, 12, 0, 0, 300000)),
    |                                                                                         ^^^^^^^^ E501
241 |         ],
242 |         2,
    |

tests\models\test_ngram_valid.py:244:89: E501 Line too long (90 > 88)
    |
242 |         2,
243 |         ["gH"],
244 |         "Sequence: 'f ghH', bigrams, 'f ', ' g' invalid, 'gh' is valid with error at end",
    |                                                                                         ^^ E501
245 |     ),
246 |     (
    |

tests\models\test_ngram_valid.py:283:89: E501 Line too long (90 > 88)
    |
282 | @pytest.mark.parametrize(
283 |     "keystrokes, ngram_size, expected_valid_ngram_texts, description", VALIDITY_TEST_CASES
    |                                                                                         ^^ E501
284 | )
285 | def test_ngram_validity(
    |

tests\models\test_ngram_valid.py:299:89: E501 Line too long (99 > 88)
    |
297 |         for i, k in enumerate(keystrokes):
298 |             print(
299 |                 f"Keystroke {i}: char='{k.char}', expected='{k.expected}', timestamp={k.timestamp}"
    |                                                                                         ^^^^^^^^^^^ E501
300 |             )
301 |         print(f"Expected valid ngrams: {expected_valid_ngram_texts}")
    |

tests\models\test_ngram_valid.py:304:89: E501 Line too long (92 > 88)
    |
303 |     ngram_manager = NGramManager(db_manager=None)  # Instantiate NGramManager
304 |     generated_ngrams = ngram_manager.generate_ngrams_from_keystrokes(keystrokes, ngram_size)
    |                                                                                         ^^^^ E501
305 |
306 |     if debug_mode:
    |

tests\models\test_practice_session_extensions.py:1:89: E501 Line too long (100 > 88)
  |
1 | # This file is now obsolete. All session logic is consolidated in session.py and session_manager.py.
  |                                                                                         ^^^^^^^^^^^^ E501
2 | # Please use test_session.py and test_session_manager.py for all session-related tests.
  |

tests\models\test_session.py:200:89: E501 Line too long (89 > 88)
    |
199 | # --- Extra/Calculated Fields ---
200 | def test_from_dict_ignores_calculated_fields(valid_session_dict: dict[str, Any]) -> None:
    |                                                                                         ^ E501
201 |     d = valid_session_dict.copy()
202 |     d["total_time"] = 123
    |

tests\models\test_session_manager.py:17:89: E501 Line too long (98 > 88)
   |
17 | def make_session(snippet_id: str, user_id: str, keyboard_id: str, **overrides: object) -> Session:
   |                                                                                         ^^^^^^^^^^ E501
18 |     now = datetime.datetime(2023, 1, 1, 12, 0, 0)
19 |     data = {
   |

tests\models\test_session_manager.py:53:89: E501 Line too long (92 > 88)
   |
51 | @pytest.fixture
52 | def sample_category(category_mgr: CategoryManager) -> Category:
53 |     category = Category(category_name="Test Category", description="A category for testing")
   |                                                                                         ^^^^ E501
54 |     category_mgr.save_category(category)
55 |     return category
   |

tests\models\test_setting.py:47:89: E501 Line too long (110 > 88)
   |
45 |         ],
46 |     )
47 |     def test_setting_type_id_validation(self, setting_type_id: str, expected_error_message_part: str) -> None:
   |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^ E501
48 |         """
49 |         Test objective: Verify Setting model's type_id validation for format, length, and ASCII.
   |

tests\models\test_setting.py:49:89: E501 Line too long (96 > 88)
   |
47 |     def test_setting_type_id_validation(self, setting_type_id: str, expected_error_message_part: str) -> None:
48 |         """
49 |         Test objective: Verify Setting model's type_id validation for format, length, and ASCII.
   |                                                                                         ^^^^^^^^ E501
50 |         """
51 |         with pytest.raises(ValidationError) as exc_info:
   |

tests\models\test_setting.py:139:89: E501 Line too long (97 > 88)
    |
137 |             ("setting_type_id", "ABC", "setting_type_id must be exactly 6 characters"),
138 |             ("related_entity_id", None, "Input should be a valid string"),
139 |             ("related_entity_id", "not-a-uuid", "related_entity_id must be a valid UUID string"),
    |                                                                                         ^^^^^^^^^ E501
140 |             ("updated_at", None, "Input should be a valid string"),
141 |             ("updated_at", "not-iso-format", "updated_at must be a valid ISO datetime string"),
    |

tests\models\test_setting.py:141:89: E501 Line too long (95 > 88)
    |
139 |             ("related_entity_id", "not-a-uuid", "related_entity_id must be a valid UUID string"),
140 |             ("updated_at", None, "Input should be a valid string"),
141 |             ("updated_at", "not-iso-format", "updated_at must be a valid ISO datetime string"),
    |                                                                                         ^^^^^^^ E501
142 |         ],
143 |     )
    |

tests\models\test_setting_manager.py:25:89: E501 Line too long (97 > 88)
   |
24 | class TestSettingManager:
25 |     """Test suite for SettingManager covering all CRUD, validation logic and history tracking."""
   |                                                                                         ^^^^^^^^^ E501
26 |
27 |     def test_create_setting_valid(self, setting_mgr: SettingManager) -> None:
   |

tests\models\test_setting_manager.py:77:89: E501 Line too long (95 > 88)
   |
75 |         assert err_msg_part.lower() in str(e.value).lower()
76 |
77 |     def test_update_existing_setting_with_new_value(self, setting_mgr: SettingManager) -> None:
   |                                                                                         ^^^^^^^ E501
78 |         """
79 |         Test objective: Verify that saving a setting with an existing type_id and entity_id updates
   |

tests\models\test_setting_manager.py:79:89: E501 Line too long (99 > 88)
   |
77 |     def test_update_existing_setting_with_new_value(self, setting_mgr: SettingManager) -> None:
78 |         """
79 |         Test objective: Verify that saving a setting with an existing type_id and entity_id updates
   |                                                                                         ^^^^^^^^^^^ E501
80 |         the setting value and creates a new history entry.
81 |         """
   |

tests\models\test_setting_manager.py:151:89: E501 Line too long (89 > 88)
    |
149 |     def test_get_setting_with_default(self, setting_mgr: SettingManager) -> None:
150 |         """
151 |         Test objective: Test get_setting with a default value when setting doesn't exist.
    |                                                                                         ^ E501
152 |         """
153 |         setting_type_id = "DEFVAL"
    |

tests\models\test_setting_manager.py:158:89: E501 Line too long (92 > 88)
    |
157 |         # Get with default - should return a new setting with the default value
158 |         setting = setting_mgr.get_setting(setting_type_id, related_entity_id, default_value)
    |                                                                                         ^^^^ E501
159 |         assert setting.setting_type_id == setting_type_id
160 |         assert setting.setting_value == default_value
    |

tests\models\test_simple.py:5:5: ANN201 Missing return type annotation for public function `test_simple`
  |
3 | """
4 |
5 | def test_simple():
  |     ^^^^^^^^^^^ ANN201
6 |     """A simple test that should always pass."""
7 |     assert 1 + 1 == 2
  |
  = help: Add return type annotation: `None`

tests\models\test_snippet.py:61:89: E501 Line too long (100 > 88)
   |
59 |     """Test validation fails with non-ASCII name."""
60 |     with pytest.raises(ValidationError):
61 |         Snippet(category_id=str(uuid.uuid4()), snippet_name="InvalidName├⌐", content="Valid content")
   |                                                                                         ^^^^^^^^^^^^ E501
   |

tests\models\test_snippet.py:136:89: E501 Line too long (100 > 88)
    |
134 |     if expect_success:
135 |         try:
136 |             snip = Snippet(category_id=snippet_category_fixture, snippet_name=name, content=content)
    |                                                                                         ^^^^^^^^^^^^ E501
137 |             snippet_manager.save_snippet(snip)
138 |             loaded = snippet_manager.get_snippet_by_id(snip.snippet_id)
    |

tests\models\test_snippet.py:146:89: E501 Line too long (100 > 88)
    |
144 |     else:
145 |         with pytest.raises(ValidationError):
146 |             snip = Snippet(category_id=snippet_category_fixture, snippet_name=name, content=content)
    |                                                                                         ^^^^^^^^^^^^ E501
147 |             snippet_manager.save_snippet(snip)
    |

tests\models\test_snippet.py:164:89: E501 Line too long (89 > 88)
    |
162 |     should_succeed: bool,
163 | ) -> None:
164 |     s1 = Snippet(category_id=snippet_category_fixture, snippet_name=name1, content="abc")
    |                                                                                         ^ E501
165 |     snippet_manager.save_snippet(s1)
166 |     if should_succeed:
    |

tests\models\test_snippet.py:167:89: E501 Line too long (93 > 88)
    |
165 |     snippet_manager.save_snippet(s1)
166 |     if should_succeed:
167 |         s2 = Snippet(category_id=snippet_category_fixture, snippet_name=name2, content="def")
    |                                                                                         ^^^^^ E501
168 |         snippet_manager.save_snippet(s2)
169 |     else:
    |

tests\models\test_snippet.py:171:89: E501 Line too long (97 > 88)
    |
169 |     else:
170 |         with pytest.raises(ConstraintError):
171 |             s2 = Snippet(category_id=snippet_category_fixture, snippet_name=name2, content="def")
    |                                                                                         ^^^^^^^^^ E501
172 |             snippet_manager.save_snippet(s2)
    |

tests\models\test_snippet.py:204:89: E501 Line too long (97 > 88)
    |
202 |     # Using the created fixture's category_id but ensuring no snippets
203 |     # are added to it for this test, or using a deliberately non-existent one.
204 |     # For this test, let's assume we want to test listing for an existing category that is empty.
    |                                                                                         ^^^^^^^^^ E501
205 |     # The fixture `snippet_category_fixture` provides a category.
206 |     # We just don't add snippets to it here.
    |

tests\models\test_snippet.py:222:89: E501 Line too long (90 > 88)
    |
220 | ) -> None:
221 |     snip1 = Snippet(
222 |         category_id=snippet_category_fixture, snippet_name="Snippet1", content="Content 1"
    |                                                                                         ^^ E501
223 |     )
224 |     snip2 = Snippet(
    |

tests\models\test_snippet.py:225:89: E501 Line too long (90 > 88)
    |
223 |     )
224 |     snip2 = Snippet(
225 |         category_id=snippet_category_fixture, snippet_name="Snippet2", content="Content 2"
    |                                                                                         ^^ E501
226 |     )
227 |     snip3 = Snippet(
    |

tests\models\test_snippet.py:228:89: E501 Line too long (90 > 88)
    |
226 |     )
227 |     snip3 = Snippet(
228 |         category_id=snippet_category_fixture, snippet_name="Snippet3", content="Content 3"
    |                                                                                         ^^ E501
229 |     )
230 |     snippet_manager.save_snippet(snip1)
    |

tests\models\test_snippet.py:260:89: E501 Line too long (96 > 88)
    |
260 | def test_snippet_update(snippet_category_fixture: str, snippet_manager: SnippetManager) -> None:
    |                                                                                         ^^^^^^^^ E501
261 |     from models.snippet import Snippet
    |

tests\models\test_snippet.py:263:89: E501 Line too long (96 > 88)
    |
261 |     from models.snippet import Snippet
262 |
263 |     snip = Snippet(category_id=snippet_category_fixture, snippet_name="ToUpdate", content="abc")
    |                                                                                         ^^^^^^^^ E501
264 |     snippet_manager.save_snippet(snip)
265 |     snip.snippet_name = "UpdatedName"
    |

tests\models\test_snippet.py:308:89: E501 Line too long (96 > 88)
    |
308 | def test_snippet_delete(snippet_category_fixture: str, snippet_manager: SnippetManager) -> None:
    |                                                                                         ^^^^^^^^ E501
309 |     from models.snippet import Snippet
    |

tests\models\test_snippet.py:311:89: E501 Line too long (96 > 88)
    |
309 |     from models.snippet import Snippet
310 |
311 |     snip = Snippet(category_id=snippet_category_fixture, snippet_name="ToDelete", content="abc")
    |                                                                                         ^^^^^^^^ E501
312 |     snippet_manager.save_snippet(snip)
313 |     snippet_manager.delete_snippet(snip.snippet_id)
    |

tests\models\test_snippet.py:340:89: E501 Line too long (89 > 88)
    |
338 |     new_category_id = new_category.category_id
339 |     snippet = Snippet(
340 |         category_id=original_category_id, snippet_name="SnippetToMove", content="Content"
    |                                                                                         ^ E501
341 |     )
342 |     snippet_manager.save_snippet(snippet)
    |

tests\models\test_snippet.py:371:89: E501 Line too long (93 > 88)
    |
369 |     inj = "Robert'); DROP TABLE snippets;--"
370 |     with pytest.raises(ValueError):
371 |         snip = Snippet(category_id=snippet_category_fixture, snippet_name=inj, content="abc")
    |                                                                                         ^^^^^ E501
372 |         snippet_manager.save_snippet(snip)
    |

tests\models\test_snippet.py:380:89: E501 Line too long (99 > 88)
    |
378 |     inj = "Content with SQL injection: DROP TABLE snippets; --"
379 |     with pytest.raises(ValueError):
380 |         snip = Snippet(category_id=snippet_category_fixture, snippet_name="ValidName", content=inj)
    |                                                                                         ^^^^^^^^^^^ E501
381 |         snippet_manager.save_snippet(snip)
    |

tests\models\test_snippet.py:389:89: E501 Line too long (94 > 88)
    |
387 |     long_content = "x" * 2000
388 |     snip = Snippet(
389 |         category_id=snippet_category_fixture, snippet_name="LongContent", content=long_content
    |                                                                                         ^^^^^^ E501
390 |     )
391 |     snippet_manager.save_snippet(snip)
    |

tests\models\test_snippet.py:403:89: E501 Line too long (95 > 88)
    |
401 |     exact_content = "x" * snippet_manager.MAX_PART_LENGTH
402 |     snip = Snippet(
403 |         category_id=snippet_category_fixture, snippet_name="ExactLength", content=exact_content
    |                                                                                         ^^^^^^^ E501
404 |     )
405 |     snippet_manager.save_snippet(snip)
    |

tests\models\test_snippet.py:412:89: E501 Line too long (98 > 88)
    |
410 |     just_over_content = "y" * (snippet_manager.MAX_PART_LENGTH + 1)
411 |     snip_over = Snippet(
412 |         category_id=snippet_category_fixture, snippet_name="OverLength", content=just_over_content
    |                                                                                         ^^^^^^^^^^ E501
413 |     )
414 |     snippet_manager.save_snippet(snip_over)
    |

tests\models\test_snippet.py:424:89: E501 Line too long (100 > 88)
    |
422 |     non_existent_snippet_id = str(uuid.uuid4())
423 |     with pytest.raises(ForeignKeyError):
424 |         snip = Snippet(category_id=str(uuid.uuid4()), snippet_name="NewName", content="New content")
    |                                                                                         ^^^^^^^^^^^^ E501
425 |         snip.snippet_id = non_existent_snippet_id
426 |         snippet_manager.save_snippet(snip)
    |

tests\models\test_snippet.py:445:89: E501 Line too long (90 > 88)
    |
443 |     snippet_id_1 = snip1.snippet_id
444 |     snippet_name_2 = f"Test Part Number Sequence 2 {random_id}"
445 |     content_2 = "This is another test snippet to verify that part_number works correctly."
    |                                                                                         ^^ E501
446 |     snip2 = Snippet(
447 |         category_id=snippet_category_fixture,
    |

tests\models\test_snippet.py:505:89: E501 Line too long (94 > 88)
    |
503 |     # Use a valid UUID for category_id
504 |     model = Snippet(
505 |         category_id=str(uuid.uuid4()), snippet_name="Test Python Snippet", content=python_code
    |                                                                                         ^^^^^^ E501
506 |     )
507 |     assert model.content == python_code
    |

tests\models\test_snippet.py:540:89: E501 Line too long (100 > 88)
    |
538 |     content = "This tests that operations are handled correctly."
539 |
540 |     snip = Snippet(category_id=snippet_category_fixture, snippet_name=snippet_name, content=content)
    |                                                                                         ^^^^^^^^^^^^ E501
541 |     snippet_manager.save_snippet(snip)
542 |     assert snip is not None and snip.snippet_id is not None
    |

tests\models\test_snippet.py:563:89: E501 Line too long (96 > 88)
    |
563 | def test_delete_snippet(snippet_category_fixture: str, snippet_manager: SnippetManager) -> None:
    |                                                                                         ^^^^^^^^ E501
564 |     """Test deleting an existing snippet."""
565 |     snip = Snippet(
    |

tests\models\test_snippet.py:580:89: E501 Line too long (91 > 88)
    |
580 | def test_create_snippet_with_nonexistent_category(snippet_manager: SnippetManager) -> None:
    |                                                                                         ^^^ E501
581 |     """Test creating a snippet with a category_id that does not exist."""
582 |     # Use a valid UUID for category_id
    |

tests\models\test_snippet.py:593:5: F811 Redefinition of unused `test_update_nonexistent_snippet` from line 421
    |
593 | def test_update_nonexistent_snippet(snippet_manager: SnippetManager) -> None:
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ F811
594 |     """Test updating a snippet that does not exist."""
595 |     non_existent_snippet_id = str(uuid.uuid4())
    |
    = help: Remove definition: `test_update_nonexistent_snippet`

tests\models\test_snippet.py:597:89: E501 Line too long (100 > 88)
    |
595 |     non_existent_snippet_id = str(uuid.uuid4())
596 |     with pytest.raises(ForeignKeyError):
597 |         snip = Snippet(category_id=str(uuid.uuid4()), snippet_name="NewName", content="New content")
    |                                                                                         ^^^^^^^^^^^^ E501
598 |         snip.snippet_id = non_existent_snippet_id
599 |         snippet_manager.save_snippet(snip)
    |

tests\models\test_snippet.py:643:89: E501 Line too long (100 > 88)
    |
641 |     snippet_name = "NoChangeSnippet"
642 |     content = "NoChangeContent"
643 |     snip = Snippet(category_id=snippet_category_fixture, snippet_name=snippet_name, content=content)
    |                                                                                         ^^^^^^^^^^^^ E501
644 |     snippet_manager.save_snippet(snip)
645 |     assert snip is not None and snip.snippet_id is not None
    |

tests\models\test_snippet.py:676:89: E501 Line too long (90 > 88)
    |
674 |     )
675 |     snippet_manager.save_snippet(snip)
676 |     # Create another snippet with the same name in a different category (if schema allows)
    |                                                                                         ^^ E501
677 |     # For now, assume unique within category is the target.
    |

tests\models\test_snippet.py:679:89: E501 Line too long (99 > 88)
    |
677 |     # For now, assume unique within category is the target.
678 |
679 |     retrieved_snippet = snippet_manager.get_snippet_by_name(snippet_name, snippet_category_fixture)
    |                                                                                         ^^^^^^^^^^^ E501
680 |     assert retrieved_snippet is not None
681 |     assert retrieved_snippet.snippet_name == snippet_name
    |

tests\models\test_snippet.py:689:89: E501 Line too long (99 > 88)
    |
687 | ) -> None:
688 |     """Test retrieving a non-existent snippet by name."""
689 |     assert snippet_manager.get_snippet_by_name("NonExistentName", snippet_category_fixture) is None
    |                                                                                         ^^^^^^^^^^^ E501
    |

tests\models\test_snippet.py:695:89: E501 Line too long (89 > 88)
    |
693 |     category_manager: CategoryManager, snippet_manager: SnippetManager
694 | ) -> None:
695 |     """Test retrieving snippets by name when same name exists in different categories."""
    |                                                                                         ^ E501
696 |     from models.category import Category
    |

tests\models\test_snippet.py:706:89: E501 Line too long (91 > 88)
    |
704 |     common_name = "SharedName"
705 |
706 |     snip1 = Snippet(category_id=cat1_id, snippet_name=common_name, content="Content Alpha")
    |                                                                                         ^^^ E501
707 |     snippet_manager.save_snippet(snip1)
708 |     snip2 = Snippet(category_id=cat2_id, snippet_name=common_name, content="Content Beta")
    |

tests\models\test_snippet.py:708:89: E501 Line too long (90 > 88)
    |
706 |     snip1 = Snippet(category_id=cat1_id, snippet_name=common_name, content="Content Alpha")
707 |     snippet_manager.save_snippet(snip1)
708 |     snip2 = Snippet(category_id=cat2_id, snippet_name=common_name, content="Content Beta")
    |                                                                                         ^^ E501
709 |     snippet_manager.save_snippet(snip2)
    |

tests\models\test_snippet.py:727:89: E501 Line too long (97 > 88)
    |
727 | def test_search_snippets(snippet_category_fixture: str, snippet_manager: SnippetManager) -> None:
    |                                                                                         ^^^^^^^^^ E501
728 |     """Test searching for snippets by a query string."""
729 |     snip1 = Snippet(
    |

tests\models\test_snippet.py:742:89: E501 Line too long (98 > 88)
    |
740 |     snippet_manager.save_snippet(snip2)
741 |     snip3 = Snippet(
742 |         category_id=snippet_category_fixture, snippet_name="ThirdOne", content="Different content"
    |                                                                                         ^^^^^^^^^^ E501
743 |     )
744 |     snippet_manager.save_snippet(snip3)
    |

tests\models\test_snippet.py:771:89: E501 Line too long (93 > 88)
    |
769 |     snippet_category_fixture: str, snippet_manager: SnippetManager
770 | ) -> None:
771 |     """Test against SQL injection in snippet name during creation via Pydantic validation."""
    |                                                                                         ^^^^^ E501
772 |     malicious_name = "Robert'); DROP TABLE snippets; --"
773 |     with pytest.raises(ValueError):
    |

tests\models\test_snippet.py:787:89: E501 Line too long (98 > 88)
    |
785 |     """Test against SQL injection in snippet content during creation."""
786 |     malicious_content = "text'); DROP TABLE snippets; --"
787 |     with pytest.raises(ValueError, match="Value contains potentially unsafe pattern: DROP TABLE"):
    |                                                                                         ^^^^^^^^^^ E501
788 |         snip = Snippet(
789 |             category_id=snippet_category_fixture,
    |

tests\models\test_snippet.py:799:89: E501 Line too long (97 > 88)
    |
797 |     snippet_category_fixture: str, snippet_manager: SnippetManager
798 | ) -> None:
799 |     """Test against SQL injection in snippet name during creation with specific error message."""
    |                                                                                         ^^^^^^^^^ E501
800 |     malicious_name = "Name'); DROP TABLE categories; --"
801 |     with pytest.raises(ValueError):
    |

tests\models\test_snippet.py:819:89: E501 Line too long (98 > 88)
    |
817 |     )
818 |     snippet_manager.save_snippet(snip)
819 |     with pytest.raises(ValueError, match="Value contains potentially unsafe pattern: DROP TABLE"):
    |                                                                                         ^^^^^^^^^^ E501
820 |         snip.content = "text'); DROP TABLE snippets; --"
821 |         snippet_manager.save_snippet(snip)
    |

tests\models\test_snippet.py:833:89: E501 Line too long (98 > 88)
    |
831 |     )
832 |     snippet_manager.save_snippet(snip)
833 |     with pytest.raises(ValueError, match="Value contains potentially unsafe pattern: DROP TABLE"):
    |                                                                                         ^^^^^^^^^^ E501
834 |         snip.snippet_name = "Name'); DROP TABLE categories; --"
835 |         snippet_manager.save_snippet(snip)
    |

tests\models\test_snippet.py:841:89: E501 Line too long (90 > 88)
    |
839 |     snippet_category_fixture: str, snippet_manager: SnippetManager
840 | ) -> None:
841 |     """Test that deleting a snippet multiple times raises ValueError on second attempt."""
    |                                                                                         ^^ E501
842 |     snip = Snippet(
843 |         category_id=snippet_category_fixture,
    |

tests\models\test_snippet.py:855:89: E501 Line too long (92 > 88)
    |
854 | def test_snippet_manager_handles_db_errors_gracefully_on_create(
855 |     snippet_manager: SnippetManager, snippet_category_fixture: str, monkeypatch: MonkeyPatch
    |                                                                                         ^^^^ E501
856 | ) -> None:
857 |     def mock_execute_raises(*args: object, **kwargs: object) -> None:
    |

tests\models\test_snippet.py:884:89: E501 Line too long (92 > 88)
    |
883 | def test_snippet_manager_handles_db_errors_gracefully_on_update(
884 |     snippet_manager: SnippetManager, snippet_category_fixture: str, monkeypatch: MonkeyPatch
    |                                                                                         ^^^^ E501
885 | ) -> None:
886 |     real_snippet = Snippet(
    |

tests\models\test_snippet.py:911:89: E501 Line too long (92 > 88)
    |
910 | def test_snippet_manager_handles_db_errors_gracefully_on_delete(
911 |     snippet_manager: SnippetManager, snippet_category_fixture: str, monkeypatch: MonkeyPatch
    |                                                                                         ^^^^ E501
912 | ) -> None:
913 |     real_snippet = Snippet(
    |

tests\models\test_snippet.py:926:89: E501 Line too long (93 > 88)
    |
924 |             raise DatabaseError("Simulated DB error on delete")
925 |         if (
926 |             "SELECT snippet_id, category_id, snippet_name FROM snippets WHERE snippet_id = ?"
    |                                                                                         ^^^^^ E501
927 |             in query
928 |         ):
    |

tests\models\test_snippet.py:936:89: E501 Line too long (100 > 88)
    |
934 |             )
935 |             return mock_cursor
936 |         elif "SELECT content FROM snippet_parts WHERE snippet_id = ? ORDER BY part_number" in query:
    |                                                                                         ^^^^^^^^^^^^ E501
937 |             mock_cursor = MagicMock()
938 |             mock_cursor.fetchall.return_value = [("content",)]
    |

tests\models\test_snippet.py:949:89: E501 Line too long (92 > 88)
    |
948 | def test_snippet_manager_handles_db_errors_gracefully_on_list(
949 |     snippet_manager: SnippetManager, snippet_category_fixture: str, monkeypatch: MonkeyPatch
    |                                                                                         ^^^^ E501
950 | ) -> None:
951 |     def mock_execute_raises(*args: object, **kwargs: object) -> None:
    |

tests\models\test_snippet.py:975:89: E501 Line too long (100 > 88)
    |
973 |     snippet_manager: SnippetManager, snippet_category_fixture: str
974 | ) -> None:
975 |     """Test that Pydantic validation errors in Snippet model are caught and raised as ValueError."""
    |                                                                                         ^^^^^^^^^^^^ E501
976 |     # Test empty name
977 |     with pytest.raises(ValueError, match="Value cannot be empty or whitespace"):
    |

tests\models\test_snippet.py:986:89: E501 Line too long (94 > 88)
    |
984 |     # Test name too long
985 |     long_name = "a" * 129
986 |     with pytest.raises(ValueError, match="Snippet name must be between 1 and 128 characters"):
    |                                                                                         ^^^^^^ E501
987 |         snip = Snippet(
988 |             category_id=snippet_category_fixture,
    |

tests\models\test_snippet_manager.py:41:89: E501 Line too long (94 > 88)
   |
39 |     """Fixture to create and provide a sample category for snippet tests."""
40 |     try:
41 |         # Attempt to retrieve if it exists from a previous failed test run in the same session
   |                                                                                         ^^^^^^ E501
42 |         return category_mgr.get_category_by_name("Test Category for Snippets")
43 |     except CategoryNotFound:
   |

tests\models\test_snippet_manager.py:76:89: E501 Line too long (100 > 88)
   |
74 |         self, snippet_mgr: SnippetManager, sample_category: Category
75 |     ) -> None:
76 |         """Test objective: Verify content is correctly split into parts based on MAX_PART_LENGTH."""
   |                                                                                         ^^^^^^^^^^^^ E501
77 |         max_len = SnippetManager.MAX_PART_LENGTH  # Typically 500
   |

tests\models\test_snippet_manager.py:97:89: E501 Line too long (94 > 88)
   |
96 |             parts_cursor = snippet_mgr.db.execute(
97 |                 "SELECT content FROM snippet_parts WHERE snippet_id = ? ORDER BY part_number",
   |                                                                                         ^^^^^^ E501
98 |                 (snippet.snippet_id,),
99 |             )
   |

tests\models\test_snippet_manager.py:105:89: E501 Line too long (89 > 88)
    |
103 |             )
104 |             retrieved_content = "".join(part_row[0] for part_row in content_parts_rows)
105 |             assert retrieved_content == content, f"Retrieved content mismatch for {name}"
    |                                                                                         ^ E501
106 |
107 |             for i, part_row in enumerate(content_parts_rows):
    |

tests\models\test_snippet_manager.py:115:89: E501 Line too long (94 > 88)
    |
113 |         self, snippet_mgr: SnippetManager, sample_category: Category
114 |     ) -> None:
115 |         """Test objective: Verify error on duplicate snippet name within the same category."""
    |                                                                                         ^^^^^^ E501
116 |         from db.exceptions import ConstraintError
    |

tests\models\test_snippet_manager.py:137:89: E501 Line too long (99 > 88)
    |
136 |     def test_create_snippet_duplicate_name_different_category(
137 |         self, snippet_mgr: SnippetManager, category_mgr: CategoryManager, sample_category: Category
    |                                                                                         ^^^^^^^^^^^ E501
138 |     ) -> None:
139 |         """Test objective: Verify successful creation with same name in different category."""
    |

tests\models\test_snippet_manager.py:139:89: E501 Line too long (94 > 88)
    |
137 |         self, snippet_mgr: SnippetManager, category_mgr: CategoryManager, sample_category: Category
138 |     ) -> None:
139 |         """Test objective: Verify successful creation with same name in different category."""
    |                                                                                         ^^^^^^ E501
140 |         other_category_name = "Another Snippet Category For Test"
141 |         try:
    |

tests\models\test_snippet_manager.py:145:89: E501 Line too long (96 > 88)
    |
143 |         except CategoryNotFound:
144 |             other_category = Category(
145 |                 category_id=str(uuid.uuid4()), category_name=other_category_name, description=""
    |                                                                                         ^^^^^^^^ E501
146 |             )
147 |             category_mgr.save_category(other_category)
    |

tests\models\test_snippet_manager.py:200:89: E501 Line too long (91 > 88)
    |
198 |             ("ValidName", "Invalid├çontent", ValueError),
199 |             ("DROP TABLE Users;", "Content", ValueError),
200 |             # Snippet content SQLi check is less strict, but some patterns are still caught
    |                                                                                         ^^^ E501
201 |             # by Snippet model
202 |             ("ValidName", "SELECT * FROM Users; -- comment", ValueError),
    |

tests\models\test_snippet_manager.py:213:89: E501 Line too long (93 > 88)
    |
211 |         error_type: type,
212 |     ) -> None:
213 |         """Test objective: Verify Pydantic validation errors for snippet name and content."""
    |                                                                                         ^^^^^ E501
214 |         with pytest.raises(error_type):
215 |             snippet = Snippet(
    |

tests\models\test_snippet_manager.py:223:89: E501 Line too long (95 > 88)
    |
221 |             snippet_mgr.save_snippet(snippet)
222 |
223 |     def test_create_snippet_internal_empty_content_check_unreachable_with_valid_pydantic_input(
    |                                                                                         ^^^^^^^ E501
224 |         self, snippet_mgr: SnippetManager, sample_category: Category
225 |     ) -> None:
    |

tests\models\test_snippet_manager.py:227:89: E501 Line too long (93 > 88)
    |
225 |     ) -> None:
226 |         """
227 |         Test objective: Ensure SnippetManager's internal check for empty content parts is not
    |                                                                                         ^^^^^ E501
228 |         triggered if Pydantic validation (content min_length=1) is effective.
229 |         """
    |

tests\models\test_snippet_manager.py:240:89: E501 Line too long (94 > 88)
    |
238 |             snippet_mgr.save_snippet(snippet)
239 |         except ValueError as e:
240 |             # This specific error from SnippetManager should not be raised if Pydantic ensures
    |                                                                                         ^^^^^^ E501
241 |             # content is not empty and _split_content_into_parts works.
242 |             assert "Content cannot be empty after splitting" not in str(e), (
    |

tests\models\test_snippet_manager.py:243:89: E501 Line too long (98 > 88)
    |
241 |             # content is not empty and _split_content_into_parts works.
242 |             assert "Content cannot be empty after splitting" not in str(e), (
243 |                 "The internal 'Content cannot be empty after splitting' ValueError should not be "
    |                                                                                         ^^^^^^^^^^ E501
244 |                 "raised with valid Pydantic input."
245 |             )
    |

tests\models\test_snippet_manager.py:247:89: E501 Line too long (92 > 88)
    |
245 |             )
246 |         except Exception:
247 |             # Catch any other exception to fail the test if it's not the specific ValueError
    |                                                                                         ^^^^ E501
248 |             pass
    |

tests\models\test_snippet_manager.py:286:89: E501 Line too long (98 > 88)
    |
284 |         # Insert user and keyboard for FK
285 |         snippet_mgr.db.execute(
286 |             "INSERT INTO users (user_id, first_name, surname, email_address) VALUES (?, ?, ?, ?)",
    |                                                                                         ^^^^^^^^^^ E501
287 |             (user_id, "Test", "User", f"{user_id}@example.com"),
288 |         )
    |

tests\models\test_snippet_manager.py:290:89: E501 Line too long (91 > 88)
    |
288 |         )
289 |         snippet_mgr.db.execute(
290 |             "INSERT INTO keyboards (keyboard_id, user_id, keyboard_name) VALUES (?, ?, ?)",
    |                                                                                         ^^^ E501
291 |             (keyboard_id, user_id, "Test Keyboard"),
292 |         )
    |

tests\models\test_snippet_manager.py:306:89: E501 Line too long (91 > 88)
    |
304 |         )
305 |         session_mgr.save_session(session)
306 |         idx = snippet_mgr.get_starting_index(str(snippet.snippet_id), user_id, keyboard_id)
    |                                                                                         ^^^ E501
307 |         assert idx == 3  # Next should be 'd'
    |

tests\models\test_snippet_manager.py:325:89: E501 Line too long (98 > 88)
    |
323 |         keyboard_id = str(uuid.uuid4())
324 |         snippet_mgr.db.execute(
325 |             "INSERT INTO users (user_id, first_name, surname, email_address) VALUES (?, ?, ?, ?)",
    |                                                                                         ^^^^^^^^^^ E501
326 |             (user_id, "Test", "User", f"{user_id}@example.com"),
327 |         )
    |

tests\models\test_snippet_manager.py:329:89: E501 Line too long (91 > 88)
    |
327 |         )
328 |         snippet_mgr.db.execute(
329 |             "INSERT INTO keyboards (keyboard_id, user_id, keyboard_name) VALUES (?, ?, ?)",
    |                                                                                         ^^^ E501
330 |             (keyboard_id, user_id, "Test Keyboard"),
331 |         )
    |

tests\models\test_snippet_manager.py:345:89: E501 Line too long (91 > 88)
    |
343 |         )
344 |         session_mgr.save_session(session)
345 |         idx = snippet_mgr.get_starting_index(str(snippet.snippet_id), user_id, keyboard_id)
    |                                                                                         ^^^ E501
346 |         # Should wrap to 0 since last index is >= len(content)-1
347 |         assert idx == 0
    |

tests\models\test_snippet_manager.py:365:89: E501 Line too long (98 > 88)
    |
363 |         keyboard_id = str(uuid.uuid4())
364 |         snippet_mgr.db.execute(
365 |             "INSERT INTO users (user_id, first_name, surname, email_address) VALUES (?, ?, ?, ?)",
    |                                                                                         ^^^^^^^^^^ E501
366 |             (user_id, "Test", "User", f"{user_id}@example.com"),
367 |         )
    |

tests\models\test_snippet_manager.py:369:89: E501 Line too long (91 > 88)
    |
367 |         )
368 |         snippet_mgr.db.execute(
369 |             "INSERT INTO keyboards (keyboard_id, user_id, keyboard_name) VALUES (?, ?, ?)",
    |                                                                                         ^^^ E501
370 |             (keyboard_id, user_id, "Test Keyboard"),
371 |         )
    |

tests\models\test_snippet_manager.py:385:89: E501 Line too long (91 > 88)
    |
383 |         )
384 |         session_mgr.save_session(session)
385 |         idx = snippet_mgr.get_starting_index(str(snippet.snippet_id), user_id, keyboard_id)
    |                                                                                         ^^^ E501
386 |         # Should wrap to 0 since end index is out of bounds
387 |         assert idx == 0
    |

tests\models\test_snippet_manager.py:407:89: E501 Line too long (98 > 88)
    |
405 |         keyboard_id2 = str(uuid.uuid4())
406 |         snippet_mgr.db.execute(
407 |             "INSERT INTO users (user_id, first_name, surname, email_address) VALUES (?, ?, ?, ?)",
    |                                                                                         ^^^^^^^^^^ E501
408 |             (user_id1, "Test", "User", f"{user_id1}@example.com"),
409 |         )
    |

tests\models\test_snippet_manager.py:411:89: E501 Line too long (91 > 88)
    |
409 |         )
410 |         snippet_mgr.db.execute(
411 |             "INSERT INTO keyboards (keyboard_id, user_id, keyboard_name) VALUES (?, ?, ?)",
    |                                                                                         ^^^ E501
412 |             (keyboard_id1, user_id1, "Test Keyboard 1"),
413 |         )
    |

tests\models\test_snippet_manager.py:415:89: E501 Line too long (98 > 88)
    |
413 |         )
414 |         snippet_mgr.db.execute(
415 |             "INSERT INTO users (user_id, first_name, surname, email_address) VALUES (?, ?, ?, ?)",
    |                                                                                         ^^^^^^^^^^ E501
416 |             (user_id2, "Test", "User", f"{user_id2}@example.com"),
417 |         )
    |

tests\models\test_snippet_manager.py:419:89: E501 Line too long (91 > 88)
    |
417 |         )
418 |         snippet_mgr.db.execute(
419 |             "INSERT INTO keyboards (keyboard_id, user_id, keyboard_name) VALUES (?, ?, ?)",
    |                                                                                         ^^^ E501
420 |             (keyboard_id2, user_id2, "Test Keyboard 2"),
421 |         )
    |

tests\models\test_snippet_manager.py:448:89: E501 Line too long (94 > 88)
    |
446 |         session_mgr.save_session(session1)
447 |         session_mgr.save_session(session2)
448 |         idx1 = snippet_mgr.get_starting_index(str(snippet.snippet_id), user_id1, keyboard_id1)
    |                                                                                         ^^^^^^ E501
449 |         idx2 = snippet_mgr.get_starting_index(str(snippet.snippet_id), user_id2, keyboard_id2)
450 |         assert idx1 == 3  # user1/keyboard1: last end=2, so next=3
    |

tests\models\test_snippet_manager.py:449:89: E501 Line too long (94 > 88)
    |
447 |         session_mgr.save_session(session2)
448 |         idx1 = snippet_mgr.get_starting_index(str(snippet.snippet_id), user_id1, keyboard_id1)
449 |         idx2 = snippet_mgr.get_starting_index(str(snippet.snippet_id), user_id2, keyboard_id2)
    |                                                                                         ^^^^^^ E501
450 |         assert idx1 == 3  # user1/keyboard1: last end=2, so next=3
451 |         assert idx2 == 5  # user2/keyboard2: last end=4, so next=5
    |

tests\models\test_user.py:68:89: E501 Line too long (91 > 88)
   |
66 |     def test_create_user_with_minimal_fields(self) -> None:
67 |         """Test creating a user with minimal required fields."""
68 |         user = User(first_name="John", surname="Doe", email_address="john.doe@example.com")
   |                                                                                         ^^^ E501
69 |         assert user.first_name == "John"
70 |         assert user.surname == "Doe"
   |

tests\models\test_user.py:82:89: E501 Line too long (99 > 88)
   |
80 |         test_id = str(uuid4())
81 |         user = User(
82 |             user_id=test_id, first_name="John", surname="Doe", email_address="john.doe@example.com"
   |                                                                                         ^^^^^^^^^^^ E501
83 |         )
84 |         assert user.user_id == test_id
   |

tests\models\test_user.py:132:89: E501 Line too long (94 > 88)
    |
130 |         """Test that whitespace is properly stripped from string fields."""
131 |         user = User(
132 |             first_name="  John  ", surname="  Doe  ", email_address="  john.doe@example.com  "
    |                                                                                         ^^^^^^ E501
133 |         )
134 |         assert user.first_name == "John"
    |

tests\models\test_user.py:140:89: E501 Line too long (92 > 88)
    |
138 |     def test_case_insensitive_email(self) -> None:
139 |         """Test that email addresses are case-insensitive."""
140 |         user1 = User(first_name="John", surname="Doe", email_address="John.Doe@Example.COM")
    |                                                                                         ^^^^ E501
141 |         user2 = User(first_name="John", surname="Doe", email_address="john.doe@example.com")
142 |         assert user1.email_address.lower() == user2.email_address.lower()
    |

tests\models\test_user.py:141:89: E501 Line too long (92 > 88)
    |
139 |         """Test that email addresses are case-insensitive."""
140 |         user1 = User(first_name="John", surname="Doe", email_address="John.Doe@Example.COM")
141 |         user2 = User(first_name="John", surname="Doe", email_address="john.doe@example.com")
    |                                                                                         ^^^^ E501
142 |         assert user1.email_address.lower() == user2.email_address.lower()
    |

tests\models\test_user.py:146:89: E501 Line too long (91 > 88)
    |
144 |     def test_to_dict(self) -> None:
145 |         """Test conversion to dictionary."""
146 |         user = User(first_name="John", surname="Doe", email_address="john.doe@example.com")
    |                                                                                         ^^^ E501
147 |         user_dict = user.to_dict()
148 |         assert user_dict["first_name"] == "John"
    |

tests\models\test_user.py:181:89: E501 Line too long (100 > 88)
    |
179 |         """Test that empty user_id raises ValueError."""
180 |         with pytest.raises(ValueError) as excinfo:
181 |             User(user_id="", first_name="John", surname="Doe", email_address="john.doe@example.com")
    |                                                                                         ^^^^^^^^^^^^ E501
182 |         assert "user_id must not be empty" in str(excinfo.value)
    |

tests\models\test_user.py:198:89: E501 Line too long (90 > 88)
    |
196 |         """Test various forms of IP address domains in emails."""
197 |         # Test bracketed IP address domain
198 |         user1 = User(first_name="John", surname="Doe", email_address="john@[192.168.1.1]")
    |                                                                                         ^^ E501
199 |         assert "@[192.168.1.1]" in user1.email_address
    |

tests\models\test_user.py:208:89: E501 Line too long (89 > 88)
    |
206 |         """Test special cases for domain validation."""
207 |         # Valid domain with hyphen
208 |         user = User(first_name="John", surname="Doe", email_address="john@my-domain.com")
    |                                                                                         ^ E501
209 |         assert user.email_address == "john@my-domain.com"
    |

tests\models\test_user.py:213:89: E501 Line too long (99 > 88)
    |
211 |         # Test domains with invalid characters
212 |         with pytest.raises(ValueError):
213 |             User(first_name="John", surname="Doe", email_address="john@domain_with_underscore.com")
    |                                                                                         ^^^^^^^^^^^ E501
214 |
215 |         # Test domain with invalid TLD (too short)
    |

tests\models\test_user_manager.py:12:89: E501 Line too long (96 > 88)
   |
11 | # Test data
12 | TEST_USER_1 = User(first_name="Alice", surname="Smith", email_address="alice.smith@example.com")
   |                                                                                         ^^^^^^^^ E501
13 |
14 | TEST_USER_2 = User(first_name="Bob", surname="Johnson", email_address="bob.johnson@example.com")
   |

tests\models\test_user_manager.py:14:89: E501 Line too long (96 > 88)
   |
12 | TEST_USER_1 = User(first_name="Alice", surname="Smith", email_address="alice.smith@example.com")
13 |
14 | TEST_USER_2 = User(first_name="Bob", surname="Johnson", email_address="bob.johnson@example.com")
   |                                                                                         ^^^^^^^^ E501
15 |
16 | TEST_USER_UPDATED = User(
   |

tests\models\test_user_manager.py:17:89: E501 Line too long (94 > 88)
   |
16 | TEST_USER_UPDATED = User(
17 |     first_name="Alicia", surname="Smith-Jones", email_address="alicia.smith-jones@example.com"
   |                                                                                         ^^^^^^ E501
18 | )
   |

tests\models\test_user_manager.py:102:89: E501 Line too long (90 > 88)
    |
100 |             first_name="AliceB",  # Valid name without digits
101 |             surname="SmithB",  # Valid name without digits
102 |             email_address=TEST_USER_1.email_address.upper(),  # Same email, different case
    |                                                                                         ^^ E501
103 |         )
    |

tests\models\test_user_manager.py:105:89: E501 Line too long (95 > 88)
    |
103 |         )
104 |
105 |         # UserManager should raise UserValidationError when trying to save with duplicate email
    |                                                                                         ^^^^^^^ E501
106 |         with pytest.raises(UserValidationError) as excinfo:
107 |             user_manager.save_user(duplicate_email_user)
    |

tests\models\test_user_manager.py:111:89: E501 Line too long (90 > 88)
    |
110 |         # Try to update a user to use an existing email
111 |         user2 = User(first_name="Bob", surname="Johnson", email_address="bob@example.com")
    |                                                                                         ^^ E501
112 |         user_manager.save_user(user2)
    |

tests\models\test_user_manager.py:120:89: E501 Line too long (101 > 88)
    |
118 |             first_name=user2.first_name,
119 |             surname=user2.surname,
120 |             email_address=TEST_USER_1.email_address.title(),  # Title case to test case insensitivity
    |                                                                                         ^^^^^^^^^^^^^ E501
121 |         )
    |

tests\models\test_user_manager.py:163:89: E501 Line too long (94 > 88)
    |
161 |         # Create user with mixed case email
162 |         user = User(
163 |             first_name="Case", surname="Sensitive", email_address="Case.Sensitive@Example.COM"
    |                                                                                         ^^^^^^ E501
164 |         )
165 |         user_manager.save_user(user)
    |

tests\models\test_user_manager.py:172:89: E501 Line too long (100 > 88)
    |
171 |         # Should be stored in lowercase
172 |         assert user_manager.get_user_by_id(user.user_id).email_address == user.email_address.lower()
    |                                                                                         ^^^^^^^^^^^^ E501
173 |
174 |     def test_empty_database_operations(self, user_manager: UserManager) -> None:
    |

tests\models\test_user_manager_fixes.py:6:1: I001 [*] Import block is un-sorted or un-formatted
   |
 4 |   """
 5 |
 6 | / import pytest
 7 | | from unittest.mock import Mock, MagicMock
 8 | | from typing import Dict, Any, List
 9 | | import uuid
10 | |
11 | | from models.user_manager import UserManager, UserNotFound, UserValidationError
12 | | from models.user import User
   | |____________________________^ I001
   |
   = help: Organize imports

tests\models\test_user_manager_fixes.py:7:33: F401 [*] `unittest.mock.MagicMock` imported but unused
  |
6 | import pytest
7 | from unittest.mock import Mock, MagicMock
  |                                 ^^^^^^^^^ F401
8 | from typing import Dict, Any, List
9 | import uuid
  |
  = help: Remove unused import: `unittest.mock.MagicMock`

tests\models\test_user_manager_fixes.py:12:25: F401 [*] `models.user.User` imported but unused
   |
11 | from models.user_manager import UserManager, UserNotFound, UserValidationError
12 | from models.user import User
   |                         ^^^^ F401
   |
   = help: Remove unused import: `models.user.User`

tests\models\test_user_manager_fixes.py:114:89: E501 Line too long (89 > 88)
    |
113 |         test_user_id = str(uuid.uuid4())
114 |         with pytest.raises(UserNotFound, match=f"User with ID {test_user_id} not found"):
    |                                                                                         ^ E501
115 |             user_manager.get_user_by_id(test_user_id)
    |

tests\models\test_user_manager_fixes.py:145:89: E501 Line too long (95 > 88)
    |
143 |         mock_db_manager.fetchone.return_value = None
144 |         
145 |         with pytest.raises(UserNotFound, match="User with email 'test@example.com' not found"):
    |                                                                                         ^^^^^^^ E501
146 |             user_manager.get_user_by_email("test@example.com")
    |

tests\models\test_user_manager_fixes.py:292:89: E501 Line too long (110 > 88)
    |
290 |         mock_db_manager.fetchone.return_value = {"1": 1}  # Duplicate found
291 |         
292 |         with pytest.raises(UserValidationError, match="Email address 'duplicate@example.com' must be unique"):
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^ E501
293 |             user_manager._validate_email_uniqueness("duplicate@example.com")
    |

Found 1201 errors.
[*] 19 fixable with the `--fix` option (180 hidden fixes can be enabled with the `--unsafe-fixes` option).
