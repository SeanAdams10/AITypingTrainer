models\category.py:11: error: Cannot find implementation or library stub for module named "pydantic"  [import-not-found]
models\category.py:11: note: See https://mypy.readthedocs.io/en/stable/running_mypy.html#missing-imports
models\category.py: error: Source file found twice under different module names: "AITypingTrainer.models.category" and "models.category"
models\category.py: note: See https://mypy.readthedocs.io/en/stable/running_mypy.html#mapping-file-paths-to-modules for more info
models\category.py: note: Common resolutions include: a) adding `__init__.py` somewhere, b) using `--explicit-package-bases` or adjusting MYPYPATH
Found 2 errors in 1 file (errors prevented further checking)
services\library_service.py:1: error: Cannot find implementation or library stub for module named "sqlalchemy"  [import-not-found]
services\library_service.py:9: error: Cannot find implementation or library stub for module named "sqlalchemy.orm"  [import-not-found]
services\library_service.py:23: error: Variable "AITypingTrainer.services.library_service.Base" is not valid as a type  [valid-type]
services\library_service.py:23: note: See https://mypy.readthedocs.io/en/stable/common_issues.html#variables-vs-type-aliases
services\library_service.py:23: error: Invalid base class "Base"  [misc]
services\library_service.py:32: error: Variable "AITypingTrainer.services.library_service.Base" is not valid as a type  [valid-type]
services\library_service.py:32: note: See https://mypy.readthedocs.io/en/stable/common_issues.html#variables-vs-type-aliases
services\library_service.py:32: error: Invalid base class "Base"  [misc]
services\library_service.py:47: error: Function is missing a type annotation  [no-untyped-def]
services\library_service.py:51: error: Function is missing a type annotation  [no-untyped-def]
services\library_service.py:60: error: Function is missing a return type annotation  [no-untyped-def]
services\library_service.py:63: error: Function is missing a type annotation  [no-untyped-def]
services\library_service.py:78: error: Function is missing a type annotation  [no-untyped-def]
services\library_service.py:85: error: Function is missing a type annotation  [no-untyped-def]
services\library_service.py:100: error: Function is missing a type annotation  [no-untyped-def]
services\library_service.py:103: error: Function is missing a type annotation  [no-untyped-def]
services\library_service.py:129: error: Function is missing a type annotation  [no-untyped-def]
models\snippet.py:10: error: Cannot find implementation or library stub for module named "pydantic"  [import-not-found]
models\snippet.py:97: error: Class cannot subclass "BaseModel" (has type "Any")  [misc]
models\snippet.py:118: error: Untyped decorator makes function "ensure_snippet_id" untyped  [misc]
models\snippet.py:120: error: Missing type parameters for generic type "dict"  [type-arg]
models\snippet.py:125: error: Untyped decorator makes function "validate_ids" untyped  [misc]
models\snippet.py:136: error: Untyped decorator makes function "validate_snippet_name" untyped  [misc]
models\snippet.py:146: error: Untyped decorator makes function "validate_content" untyped  [misc]
models\snippet.py:157: error: Returning Any from function declared to return "dict[str, Any]"  [no-any-return]
models\ngram.py:10: error: Cannot find implementation or library stub for module named "pydantic"  [import-not-found]
models\ngram.py:13: error: Class cannot subclass "BaseModel" (has type "Any")  [misc]
models\ngram.py:45: error: Returning Any from function declared to return "dict[str, Any]"  [no-any-return]
models\session.py:14: error: Cannot find implementation or library stub for module named "pydantic"  [import-not-found]
models\session.py:17: error: Class cannot subclass "BaseModel" (has type "Any")  [misc]
models\session.py:40: error: Untyped decorator makes function "validate_uuid" untyped  [misc]
models\session.py:46: error: Untyped decorator makes function "validate_indices" untyped  [misc]
models\session.py:53: error: Untyped decorator makes function "check_indices_and_times" untyped  [misc]
models\session.py:108: error: Returning Any from function declared to return "dict[str, Any]"  [no-any-return]
models\session.py:127: error: Returning Any from function declared to return "Session"  [no-any-return]
db\database_manager.py:16: error: Cannot find implementation or library stub for module named "boto3"  [import-not-found]
db\database_manager.py:17: error: Library stubs not installed for "psycopg2"  [import-untyped]
db\database_manager.py:17: note: Hint: "python3 -m pip install types-psycopg2"
db\database_manager.py:17: note: (or run "mypy --install-types" to install all missing stub packages)
models\keystroke.py:10: error: Cannot find implementation or library stub for module named "pydantic"  [import-not-found]
models\keystroke.py:17: error: Class cannot subclass "BaseModel" (has type "Any")  [misc]
models\ngram_manager.py:17: error: Cannot find implementation or library stub for module named "pydantic"  [import-not-found]
models\ngram_manager.py:43: error: Class cannot subclass "BaseModel" (has type "Any")  [misc]
models\snippet_manager.py:429: error: Returning Any from function declared to return "Snippet"  [no-any-return]
models\snippet_manager.py:429: error: "SnippetManager" has no attribute "create_snippet"; maybe "delete_snippet", "create_dynamic_snippet", or "save_snippet"?  [attr-defined]
models\snippet_manager.py:470: error: Returning Any from function declared to return "int"  [no-any-return]
services\database_viewer_service.py:14: error: Cannot find implementation or library stub for module named "pydantic"  [import-not-found]
services\database_viewer_service.py:14: note: See https://mypy.readthedocs.io/en/stable/running_mypy.html#missing-imports
services\database_viewer_service.py:34: error: Class cannot subclass "BaseModel" (has type "Any")  [misc]
services\database_viewer_service.py:77: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
services\database_viewer_service.py:103: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
services\database_viewer_service.py:104: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
services\database_viewer_service.py:105: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
services\database_viewer_service.py:106: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
services\database_viewer_service.py:107: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
services\database_viewer_service.py:108: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
services\database_viewer_service.py:201: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
services\database_viewer_service.py:211: error: Value of type "dict[str, Any] | None" is not indexable  [index]
services\database_viewer_service.py:211: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
services\database_viewer_service.py:260: error: Incompatible types in assignment (expression has type "TextIO", variable has type "TextIOWrapper[_WrappedBuffer]")  [assignment]
models\keystroke_manager.py:125: error: Incompatible return value type (got "str", expected "int")  [return-value]
models\session_manager.py:212: error: Returning Any from function declared to return "bool"  [no-any-return]
Found 57 errors in 11 files (checked 4 source files)
helpers\error_utils.py:11: error: Cannot find implementation or library stub for module named "PyQt5.QtWidgets"  [import-not-found]
helpers\error_utils.py:11: note: See https://mypy.readthedocs.io/en/stable/running_mypy.html#missing-imports
helpers\error_utils.py:17: error: Function is missing a type annotation for one or more arguments  [no-untyped-def]
Found 2 errors in 1 file (checked 2 source files)
desktop_ui\dynamic_config.py:523: error: expected 'except' or 'finally' block  [syntax]
Found 1 error in 1 file (errors prevented further checking)
models\snippet.py:10: error: Cannot find implementation or library stub for module named "pydantic"  [import-not-found]
models\snippet.py:97: error: Class cannot subclass "BaseModel" (has type "Any")  [misc]
models\snippet.py:118: error: Untyped decorator makes function "ensure_snippet_id" untyped  [misc]
models\snippet.py:120: error: Missing type parameters for generic type "dict"  [type-arg]
models\snippet.py:125: error: Untyped decorator makes function "validate_ids" untyped  [misc]
models\snippet.py:136: error: Untyped decorator makes function "validate_snippet_name" untyped  [misc]
models\snippet.py:146: error: Untyped decorator makes function "validate_content" untyped  [misc]
models\snippet.py:157: error: Returning Any from function declared to return "dict[str, Any]"  [no-any-return]
models\category.py:11: error: Cannot find implementation or library stub for module named "pydantic"  [import-not-found]
models\category.py:14: error: Class cannot subclass "BaseModel" (has type "Any")  [misc]
models\category.py:30: error: Untyped decorator makes function "validate_name_format" untyped  [misc]
models\category.py:55: error: Untyped decorator makes function "ensure_category_id" untyped  [misc]
models\category.py:57: error: Missing type parameters for generic type "dict"  [type-arg]
models\category.py:62: error: Untyped decorator makes function "validate_category_id" untyped  [misc]
models\category.py:80: error: Returning Any from function declared to return "dict[str, Any]"  [no-any-return]
models\ngram.py:10: error: Cannot find implementation or library stub for module named "pydantic"  [import-not-found]
models\ngram.py:13: error: Class cannot subclass "BaseModel" (has type "Any")  [misc]
models\ngram.py:45: error: Returning Any from function declared to return "dict[str, Any]"  [no-any-return]
models\session.py:14: error: Cannot find implementation or library stub for module named "pydantic"  [import-not-found]
models\session.py:17: error: Class cannot subclass "BaseModel" (has type "Any")  [misc]
models\session.py:40: error: Untyped decorator makes function "validate_uuid" untyped  [misc]
models\session.py:46: error: Untyped decorator makes function "validate_indices" untyped  [misc]
models\session.py:53: error: Untyped decorator makes function "check_indices_and_times" untyped  [misc]
models\session.py:108: error: Returning Any from function declared to return "dict[str, Any]"  [no-any-return]
models\session.py:127: error: Returning Any from function declared to return "Session"  [no-any-return]
api\category_graphql.py:13: error: Cannot find implementation or library stub for module named "graphene"  [import-not-found]
api\category_graphql.py:14: error: Cannot find implementation or library stub for module named "flask"  [import-not-found]
api\category_graphql.py:18: error: Module "models.category" has no attribute "CategoryManager"  [attr-defined]
api\category_graphql.py:18: error: Module "models.category" has no attribute "CategoryNotFound"  [attr-defined]
api\category_graphql.py:18: error: Module "models.category" has no attribute "CategoryValidationError"  [attr-defined]
api\category_graphql.py:55: error: Returning Any from function declared to return "list[Category]"  [no-any-return]
api\category_graphql.py:69: error: Returning Any from function declared to return "Category | None"  [no-any-return]
api\category_graphql.py:198: error: Untyped decorator makes function "graphql_api" untyped  [misc]
db\database_manager.py:16: error: Cannot find implementation or library stub for module named "boto3"  [import-not-found]
db\database_manager.py:17: error: Library stubs not installed for "psycopg2"  [import-untyped]
db\database_manager.py:17: note: Hint: "python3 -m pip install types-psycopg2"
db\database_manager.py:17: note: (or run "mypy --install-types" to install all missing stub packages)
api\session_api.py:1: error: Cannot find implementation or library stub for module named "flask"  [import-not-found]
api\session_api.py:2: error: Cannot find implementation or library stub for module named "pydantic"  [import-not-found]
api\session_api.py:9: error: Class cannot subclass "BaseModel" (has type "Any")  [misc]
api\session_api.py:16: error: Function is missing a return type annotation  [no-untyped-def]
api\session_api.py:34: error: Function is missing a return type annotation  [no-untyped-def]
api\session_api.py:48: error: Function is missing a type annotation  [no-untyped-def]
api\session_api.py:56: error: Function is missing a type annotation  [no-untyped-def]
models\ngram_manager.py:17: error: Cannot find implementation or library stub for module named "pydantic"  [import-not-found]
models\ngram_manager.py:43: error: Class cannot subclass "BaseModel" (has type "Any")  [misc]
models\snippet_manager.py:429: error: Returning Any from function declared to return "Snippet"  [no-any-return]
models\snippet_manager.py:429: error: "SnippetManager" has no attribute "create_snippet"; maybe "delete_snippet", "create_dynamic_snippet", or "save_snippet"?  [attr-defined]
models\snippet_manager.py:470: error: Returning Any from function declared to return "int"  [no-any-return]
models\category_manager.py:195: error: Returning Any from function declared to return "bool"  [no-any-return]
models\keystroke.py:10: error: Cannot find implementation or library stub for module named "pydantic"  [import-not-found]
models\keystroke.py:17: error: Class cannot subclass "BaseModel" (has type "Any")  [misc]
services\database_viewer_service.py:14: error: Cannot find implementation or library stub for module named "pydantic"  [import-not-found]
services\database_viewer_service.py:34: error: Class cannot subclass "BaseModel" (has type "Any")  [misc]
services\database_viewer_service.py:77: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
services\database_viewer_service.py:103: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
services\database_viewer_service.py:104: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
services\database_viewer_service.py:105: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
services\database_viewer_service.py:106: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
services\database_viewer_service.py:107: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
services\database_viewer_service.py:108: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
services\database_viewer_service.py:201: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
services\database_viewer_service.py:211: error: Value of type "dict[str, Any] | None" is not indexable  [index]
services\database_viewer_service.py:211: error: Invalid index type "int" for "dict[str, Any]"; expected type "str"  [index]
services\database_viewer_service.py:260: error: Incompatible types in assignment (expression has type "TextIO", variable has type "TextIOWrapper[_WrappedBuffer]")  [assignment]
api\unified_graphql.py:21: error: Cannot find implementation or library stub for module named "graphene"  [import-not-found]
api\unified_graphql.py:22: error: Cannot find implementation or library stub for module named "flask"  [import-not-found]
api\unified_graphql.py:26: error: Module "models.category" has no attribute "CategoryManager"  [attr-defined]
api\unified_graphql.py:26: error: Module "models.category" has no attribute "CategoryNotFound"  [attr-defined]
api\unified_graphql.py:26: error: Module "models.category" has no attribute "CategoryValidationError"  [attr-defined]
api\unified_graphql.py:34: error: Module "models.snippet" has no attribute "SnippetManager"  [attr-defined]
api\unified_graphql.py:34: error: Module "models.snippet" has no attribute "SnippetModel"  [attr-defined]
api\unified_graphql.py:66: error: Returning Any from function declared to return "DatabaseManager"  [no-any-return]
api\unified_graphql.py:68: error: Returning Any from function declared to return "DatabaseManager"  [no-any-return]
api\unified_graphql.py:365: error: Returning Any from function declared to return "list[Any]"  [no-any-return]
api\unified_graphql.py:379: error: Returning Any from function declared to return "list[Category]"  [no-any-return]
api\unified_graphql.py:386: error: Returning Any from function declared to return "Category | None"  [no-any-return]
api\unified_graphql.py:416: error: Untyped decorator makes function "graphql_api" untyped  [misc]
api\snippet_api.py:9: error: Cannot find implementation or library stub for module named "flask"  [import-not-found]
api\snippet_api.py:12: error: Cannot find implementation or library stub for module named "models.practice_generator"  [import-not-found]
api\snippet_api.py:13: error: Module "models.snippet" has no attribute "SnippetManager"  [attr-defined]
api\snippet_api.py:13: error: Module "models.snippet" has no attribute "SnippetModel"  [attr-defined]
api\snippet_api.py:18: error: Untyped decorator makes function "get_snippet" untyped  [misc]
api\snippet_api.py:19: error: Function is missing a return type annotation  [no-untyped-def]
api\snippet_api.py:50: error: Function is missing a return type annotation  [no-untyped-def]
api\snippet_api.py:87: error: Function is missing a return type annotation  [no-untyped-def]
api\snippet_api.py:107: error: Function is missing a return type annotation  [no-untyped-def]
api\snippet_api.py:199: error: Untyped decorator makes function "edit_snippet" untyped  [misc]
api\snippet_api.py:200: error: Function is missing a return type annotation  [no-untyped-def]
api\snippet_api.py:252: error: Untyped decorator makes function "delete_snippet" untyped  [misc]
api\snippet_api.py:253: error: Function is missing a return type annotation  [no-untyped-def]
api\category_api.py:3: error: Cannot find implementation or library stub for module named "flask"  [import-not-found]
api\category_api.py:3: note: See https://mypy.readthedocs.io/en/stable/running_mypy.html#missing-imports
api\category_api.py:4: error: Cannot find implementation or library stub for module named "pydantic"  [import-not-found]
api\category_api.py:7: error: Module "models.category" has no attribute "CategoryManager"  [attr-defined]
api\category_api.py:10: error: Class cannot subclass "BaseModel" (has type "Any")  [misc]
api\category_api.py:14: error: Class cannot subclass "BaseModel" (has type "Any")  [misc]
api\category_api.py:21: error: Untyped decorator makes function "list_categories_api" untyped  [misc]
api\category_api.py:23: error: "type[DatabaseManager]" has no attribute "get_instance"  [attr-defined]
api\category_api.py:27: error: Untyped decorator makes function "add_category_api" untyped  [misc]
api\category_api.py:32: error: "type[DatabaseManager]" has no attribute "get_instance"  [attr-defined]
api\category_api.py:42: error: Untyped decorator makes function "delete_category_api" untyped  [misc]
api\category_api.py:45: error: "type[DatabaseManager]" has no attribute "get_instance"  [attr-defined]
api\category_api.py:56: error: Untyped decorator makes function "rename_category_api" untyped  [misc]
api\category_api.py:61: error: "type[DatabaseManager]" has no attribute "get_instance"  [attr-defined]
models\keystroke_manager.py:125: error: Incompatible return value type (got "str", expected "int")  [return-value]
api\keystroke_api.py:1: error: Cannot find implementation or library stub for module named "flask"  [import-not-found]
api\keystroke_api.py:2: error: Cannot find implementation or library stub for module named "pydantic"  [import-not-found]
api\keystroke_api.py:11: error: Class cannot subclass "BaseModel" (has type "Any")  [misc]
api\keystroke_api.py:22: error: Function is missing a return type annotation  [no-untyped-def]
api\keystroke_api.py:71: error: Function is missing a return type annotation  [no-untyped-def]
api\dbviewer_api.py:13: error: Cannot find implementation or library stub for module named "flask"  [import-not-found]
api\dbviewer_api.py:34: error: Function is missing a return type annotation  [no-untyped-def]
api\dbviewer_api.py:52: error: Function is missing a return type annotation  [no-untyped-def]
api\dbviewer_api.py:101: error: Function is missing a return type annotation  [no-untyped-def]
models\session_manager.py:212: error: Returning Any from function declared to return "bool"  [no-any-return]
api\run_library_api.py:8: error: Cannot find implementation or library stub for module named "flask"  [import-not-found]
api\run_library_api.py:14: error: Cannot find implementation or library stub for module named "library_graphql"  [import-not-found]
api\run_library_api.py:26: error: Function is missing a return type annotation  [no-untyped-def]
api\run_library_api.py:26: note: Use "-> None" if function does not return a value
api\run_library_api.py:59: error: Call to untyped function "init_db" in typed context  [no-untyped-call]
api\library_graphql.py:6: error: Cannot find implementation or library stub for module named "graphene"  [import-not-found]
api\library_graphql.py:7: error: Cannot find implementation or library stub for module named "flask"  [import-not-found]
api\library_graphql.py:18: error: Function is missing a return type annotation  [no-untyped-def]
api\library_graphql.py:26: error: Class cannot subclass "ObjectType" (has type "Any")  [misc]
api\library_graphql.py:31: error: Class cannot subclass "ObjectType" (has type "Any")  [misc]
api\library_graphql.py:38: error: Class cannot subclass "ObjectType" (has type "Any")  [misc]
api\library_graphql.py:46: error: Class cannot subclass "ObjectType" (has type "Any")  [misc]
api\library_graphql.py:52: error: Function is missing a type annotation  [no-untyped-def]
api\library_graphql.py:53: error: Call to untyped function "get_library_manager" in typed context  [no-untyped-call]
api\library_graphql.py:56: error: Function is missing a type annotation  [no-untyped-def]
api\library_graphql.py:57: error: Call to untyped function "get_library_manager" in typed context  [no-untyped-call]
api\library_graphql.py:60: error: Function is missing a type annotation  [no-untyped-def]
api\library_graphql.py:61: error: Call to untyped function "get_library_manager" in typed context  [no-untyped-call]
api\library_graphql.py:68: error: Function is missing a type annotation  [no-untyped-def]
api\library_graphql.py:69: error: Call to untyped function "get_library_manager" in typed context  [no-untyped-call]
api\library_graphql.py:74: error: Class cannot subclass "Mutation" (has type "Any")  [misc]
api\library_graphql.py:82: error: Function is missing a type annotation  [no-untyped-def]
api\library_graphql.py:83: error: Call to untyped function "get_library_manager" in typed context  [no-untyped-call]
api\library_graphql.py:93: error: Class cannot subclass "Mutation" (has type "Any")  [misc]
api\library_graphql.py:101: error: Function is missing a type annotation  [no-untyped-def]
api\library_graphql.py:102: error: Call to untyped function "get_library_manager" in typed context  [no-untyped-call]
api\library_graphql.py:110: error: Class cannot subclass "Mutation" (has type "Any")  [misc]
api\library_graphql.py:117: error: Function is missing a type annotation  [no-untyped-def]
api\library_graphql.py:118: error: Call to untyped function "get_library_manager" in typed context  [no-untyped-call]
api\library_graphql.py:126: error: Class cannot subclass "Mutation" (has type "Any")  [misc]
api\library_graphql.py:136: error: Function is missing a type annotation  [no-untyped-def]
api\library_graphql.py:137: error: Call to untyped function "get_library_manager" in typed context  [no-untyped-call]
api\library_graphql.py:147: error: Class cannot subclass "Mutation" (has type "Any")  [misc]
api\library_graphql.py:157: error: Function is missing a type annotation  [no-untyped-def]
api\library_graphql.py:158: error: Call to untyped function "get_library_manager" in typed context  [no-untyped-call]
api\library_graphql.py:166: error: Class cannot subclass "Mutation" (has type "Any")  [misc]
api\library_graphql.py:173: error: Function is missing a type annotation  [no-untyped-def]
api\library_graphql.py:174: error: Call to untyped function "get_library_manager" in typed context  [no-untyped-call]
api\library_graphql.py:182: error: Name "Mutation" already defined (possibly by an import)  [no-redef]
api\library_graphql.py:182: error: Class cannot subclass "ObjectType" (has type "Any")  [misc]
api\library_graphql.py:195: error: Function is missing a return type annotation  [no-untyped-def]
Found 153 errors in 21 files (checked 10 source files)
tests\helpers\db_helpers.py: error: Source file found twice under different module names: "AITypingTrainer.tests.helpers.db_helpers" and "tests.helpers.db_helpers"
tests\helpers\db_helpers.py: note: See https://mypy.readthedocs.io/en/stable/running_mypy.html#mapping-file-paths-to-modules for more info
tests\helpers\db_helpers.py: note: Common resolutions include: a) adding `__init__.py` somewhere, b) using `--explicit-package-bases` or adjusting MYPYPATH
Found 1 error in 1 file (errors prevented further checking)
models\category_manager.py:116:89: E501 Line too long (99 > 88)
    |
114 |             "SELECT category_id, category_name FROM categories ORDER BY category_name"
115 |         ).fetchall()
116 |         return [Category(category_id=row[0], category_name=row[1], description="") for row in rows]
    |                                                                                         ^^^^^^^^^^^ E501
117 |
118 |     def save_category(self, category: Category) -> bool:
    |

models\dynamic_content_manager.py:3:89: E501 Line too long (91 > 88)
  |
1 | """
2 | Dynamic Content Manager for generating typing practice content.
3 | Handles different generation modes (NGramOnly, WordsOnly, Mixed) for customizable practice.
  |                                                                                         ^^^ E501
4 | """
  |

models\dynamic_content_manager.py:23:89: E501 Line too long (89 > 88)
   |
21 | class DynamicContentManager:
22 |     """
23 |     Manager for generating dynamic typing practice content based on specified parameters.
   |                                                                                         ^ E501
24 |
25 |     Supports different content generation modes:
   |

models\dynamic_content_manager.py:43:89: E501 Line too long (99 > 88)
   |
42 |         Args:
43 |             in_scope_keys: List of characters (keyboard keys) that are allowed in generated content
   |                                                                                         ^^^^^^^^^^^ E501
44 |             practice_length: Maximum length of generated content (1-1000 characters)
45 |             ngram_focus_list: List of ngrams to focus on in the generated content
   |

models\dynamic_content_manager.py:76:17: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
   |
74 |             except ValueError:
75 |                 valid_modes = [m.value for m in ContentMode]
76 |                 raise ValueError(f"Invalid mode. Must be one of: {', '.join(valid_modes)}")
   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ B904
77 |         elif isinstance(value, ContentMode):
78 |             self._mode = value
   |

models\dynamic_content_manager.py:76:89: E501 Line too long (91 > 88)
   |
74 |             except ValueError:
75 |                 valid_modes = [m.value for m in ContentMode]
76 |                 raise ValueError(f"Invalid mode. Must be one of: {', '.join(valid_modes)}")
   |                                                                                         ^^^ E501
77 |         elif isinstance(value, ContentMode):
78 |             self._mode = value
   |

models\dynamic_content_manager.py:87:89: E501 Line too long (97 > 88)
   |
85 |             raise ValueError("Ngram focus list cannot be empty")
86 |
87 |         if self.mode in (ContentMode.WORDS_ONLY, ContentMode.MIXED) and self.llm_service is None:
   |                                                                                         ^^^^^^^^^ E501
88 |             raise ValueError("LLM service is required for WordsOnly and Mixed modes")
   |

models\dynamic_content_manager.py:106:89: E501 Line too long (99 > 88)
    |
104 |             # Check if ngram uses only in-scope keys
105 |             if all(char in self.in_scope_keys for char in ngram):
106 |                 weighted_ngrams.extend([ngram] * 3)  # Add multiple copies for better randomization
    |                                                                                         ^^^^^^^^^^^ E501
107 |
108 |         if not weighted_ngrams:
    |

models\dynamic_content_manager.py:125:89: E501 Line too long (93 > 88)
    |
123 |             # Check if adding this ngram (plus delimiter) would exceed max_length
124 |             result.append(next_ngram)
125 |             current_length += len(next_ngram) + (len(delimiter) if current_length > 0 else 0)
    |                                                                                         ^^^^^ E501
126 |
127 |         random.shuffle(result)
    |

models\dynamic_content_manager.py:136:89: E501 Line too long (94 > 88)
    |
134 |     def _generate_words_content(self, max_length: int, delimiter: str) -> str:
135 |         """
136 |         Generate content using words that contain the focus ngrams and only use in-scope keys.
    |                                                                                         ^^^^^^ E501
137 |         Requires the LLM service.
138 |         """
    |

models\dynamic_content_manager.py:143:89: E501 Line too long (97 > 88)
    |
142 |         # Get words from the LLM service
143 |         raw_words = self.llm_service.get_words_with_ngrams(self.ngram_focus_list, max_length * 2)
    |                                                                                         ^^^^^^^^^ E501
144 |
145 |         # Filter words to ensure they only use in-scope keys and contain at least one ngram
    |

models\dynamic_content_manager.py:145:89: E501 Line too long (91 > 88)
    |
143 |         raw_words = self.llm_service.get_words_with_ngrams(self.ngram_focus_list, max_length * 2)
144 |
145 |         # Filter words to ensure they only use in-scope keys and contain at least one ngram
    |                                                                                         ^^^ E501
146 |         valid_words = []
147 |         for word in raw_words.split():
    |

models\dynamic_content_manager.py:173:89: E501 Line too long (93 > 88)
    |
171 |                 break
172 |
173 |         # If we haven't reached max_length and have used all words, repeat from the beginning
    |                                                                                         ^^^^^ E501
174 |         if current_length < max_length and valid_words:
175 |             random.shuffle(valid_words)
    |

models\keyboard.py:20:89: E501 Line too long (92 > 88)
   |
18 |         user_id: UUID string, foreign key to user table.
19 |         keyboard_name: Name of the keyboard (ASCII, 1-64 chars).
20 |         target_ms_per_keystroke: Target milliseconds per keystroke for speed goal (integer).
   |                                                                                         ^^^^ E501
21 |     """
   |

models\keyboard.py:52:89: E501 Line too long (94 > 88)
   |
50 |             raise ValueError("Target milliseconds per keystroke must be an integer.")
51 |         if v < 50 or v > 5000:
52 |             raise ValueError("Target milliseconds per keystroke must be between 50 and 5000.")
   |                                                                                         ^^^^^^ E501
53 |         return v
   |

models\keystroke.py:88:89: E501 Line too long (97 > 88)
   |
86 |             "session_id": self.session_id,
87 |             "keystroke_id": self.keystroke_id,
88 |             "keystroke_time": (self.keystroke_time.isoformat() if self.keystroke_time else None),
   |                                                                                         ^^^^^^^^^ E501
89 |             "keystroke_char": self.keystroke_char,
90 |             "expected_char": self.expected_char,
   |

models\keystroke_manager.py:81:89: E501 Line too long (94 > 88)
   |
79 |             import sys
80 |
81 |             print(f"Error deleting keystrokes for session {session_id}: {e}", file=sys.stderr)
   |                                                                                         ^^^^^^ E501
82 |             import traceback
   |

models\llm_ngram_service.py:20:89: E501 Line too long (99 > 88)
   |
18 |     def __init__(self, api_key: str) -> None:
19 |         if not api_key:
20 |             raise LLMMissingAPIKeyError("OpenAI API key must be provided as an explicit argument.")
   |                                                                                         ^^^^^^^^^^^ E501
21 |         self.api_key: str = api_key
22 |         if OpenAI is not None:
   |

models\llm_ngram_service.py:44:89: E501 Line too long (100 > 88)
   |
42 |             f"Each word must:\n\n"
43 |             f'ΓÇó "Contain at least one of the following substrings: {ngram_str}"\n\n'
44 |             f'ΓÇó "Only use letters from this set: {include_chars} (no other characters allowed)"\n\n'
   |                                                                                         ^^^^^^^^^^^^ E501
45 |             f'ΓÇó "Be an actual English word, or one of the listed ngrams"\n\n'
46 |             f"Additional constraints:\n\n"
   |

models\llm_ngram_service.py:47:89: E501 Line too long (113 > 88)
   |
45 |             f'ΓÇó "Be an actual English word, or one of the listed ngrams"\n\n'
46 |             f"Additional constraints:\n\n"
47 |             f'ΓÇó "Maximize variety ΓÇö do not repeat the same word unless necessary to reach the target length"\n\n'
   |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^ E501
48 |             f'ΓÇó "You may include the raw ngrams (e.g., {ngram_str}) once or twice but avoid overusing them"\n\n'
49 |             f'ΓÇó "Return the result as a single space-delimited string with no punctuation, quotes, or line breaks"\n\n'
   |

models\llm_ngram_service.py:48:89: E501 Line too long (112 > 88)
   |
46 |             f"Additional constraints:\n\n"
47 |             f'ΓÇó "Maximize variety ΓÇö do not repeat the same word unless necessary to reach the target length"\n\n'
48 |             f'ΓÇó "You may include the raw ngrams (e.g., {ngram_str}) once or twice but avoid overusing them"\n\n'
   |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^ E501
49 |             f'ΓÇó "Return the result as a single space-delimited string with no punctuation, quotes, or line breaks"\n\n'
50 |             f'ΓÇó "Stop generating as soon as the string reaches {max_length} characters (not more)"'
   |

models\llm_ngram_service.py:49:89: E501 Line too long (119 > 88)
   |
47 |             f'ΓÇó "Maximize variety ΓÇö do not repeat the same word unless necessary to reach the target length"\n\n'
48 |             f'ΓÇó "You may include the raw ngrams (e.g., {ngram_str}) once or twice but avoid overusing them"\n\n'
49 |             f'ΓÇó "Return the result as a single space-delimited string with no punctuation, quotes, or line breaks"\n\n'
   |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
50 |             f'ΓÇó "Stop generating as soon as the string reaches {max_length} characters (not more)"'
51 |         )
   |

models\llm_ngram_service.py:50:89: E501 Line too long (99 > 88)
   |
48 |             f'ΓÇó "You may include the raw ngrams (e.g., {ngram_str}) once or twice but avoid overusing them"\n\n'
49 |             f'ΓÇó "Return the result as a single space-delimited string with no punctuation, quotes, or line breaks"\n\n'
50 |             f'ΓÇó "Stop generating as soon as the string reaches {max_length} characters (not more)"'
   |                                                                                         ^^^^^^^^^^^ E501
51 |         )
   |

models\llm_ngram_service.py:60:89: E501 Line too long (102 > 88)
   |
58 |             model=model,
59 |             messages=[
60 |                 {"role": "system", "content": "You are an expert in English words and lexicography."},
   |                                                                                         ^^^^^^^^^^^^^^ E501
61 |                 {"role": "user", "content": prompt}
62 |             ],
   |

models\ngram_manager.py:95:89: E501 Line too long (92 > 88)
   |
94 |         if ngram_sizes is None:
95 |             ngram_sizes = list(range(MIN_NGRAM_SIZE, MAX_NGRAM_SIZE + 1))  # Default to 2-10
   |                                                                                         ^^^^ E501
96 |
97 |         if not ngram_sizes:
   |

models\ngram_manager.py:140:89: E501 Line too long (97 > 88)
    |
138 |                 avg_speed=row["avg_time_ms"] if row["avg_time_ms"] > 0 else 0,
139 |                 total_occurrences=row["occurrences"],
140 |                 last_used=datetime.fromisoformat(row["last_used"]) if row["last_used"] else None,
    |                                                                                         ^^^^^^^^^ E501
141 |                 ngram_score=row["avg_time_ms"] * log(row["occurrences"]),
142 |             )
    |

models\ngram_manager.py:173:89: E501 Line too long (92 > 88)
    |
172 |         if ngram_sizes is None:
173 |             ngram_sizes = list(range(MIN_NGRAM_SIZE, MAX_NGRAM_SIZE + 1))  # Default to 2-10
    |                                                                                         ^^^^ E501
174 |
175 |         if not ngram_sizes:
    |

models\ngram_manager.py:213:89: E501 Line too long (97 > 88)
    |
211 |                 avg_speed=0,  # Not applicable for error count
212 |                 total_occurrences=row["error_count"],
213 |                 last_used=datetime.fromisoformat(row["last_used"]) if row["last_used"] else None,
    |                                                                                         ^^^^^^^^^ E501
214 |                 ngram_score=0,
215 |             )
    |

models\ngram_manager.py:261:89: E501 Line too long (96 > 88)
    |
259 |         # Helper functions to handle different Keystroke field naming conventions
260 |         def get_expected_char(k: object) -> str:
261 |             """Get expected character, supporting both 'expected' and 'expected_char' fields."""
    |                                                                                         ^^^^^^^^ E501
262 |             return getattr(k, "expected", getattr(k, "expected_char", ""))
    |

models\ngram_manager.py:265:89: E501 Line too long (91 > 88)
    |
264 |         def get_actual_char(k: object) -> str:
265 |             """Get actual character, supporting both 'char' and 'keystroke_char' fields."""
    |                                                                                         ^^^ E501
266 |             return getattr(k, "char", getattr(k, "keystroke_char", ""))
    |

models\ngram_manager.py:269:89: E501 Line too long (89 > 88)
    |
268 |         def get_time(k: object) -> Optional[datetime]:
269 |             """Get timestamp, supporting both 'timestamp' and 'keystroke_time' fields."""
    |                                                                                         ^ E501
270 |             return getattr(k, "timestamp", getattr(k, "keystroke_time", None))
    |

models\ngram_manager.py:274:89: E501 Line too long (100 > 88)
    |
272 |         for i in range(len(keystrokes) - ngram_size + 1):
273 |             current_keystroke_sequence = keystrokes[i : i + ngram_size]
274 |             # Filtering: skip n-grams containing space, backspace, newline, or tab in expected chars
    |                                                                                         ^^^^^^^^^^^^ E501
275 |             if any(
276 |                 (
    |

models\ngram_manager.py:294:89: E501 Line too long (123 > 88)
    |
292 |             if ngram_size > 1 and total_time_ms == 0.0:
293 |                 continue
294 |             # Additional filtering: skip if any consecutive keystrokes have the same timestamp (zero duration for any part)
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
295 |             has_zero_part = any(
296 |                 get_time(current_keystroke_sequence[j])
    |

models\ngram_manager.py:304:89: E501 Line too long (94 > 88)
    |
303 |             errors_in_sequence = [
304 |                 get_actual_char(k) != get_expected_char(k) for k in current_keystroke_sequence
    |                                                                                         ^^^^^^ E501
305 |             ]
306 |             err_not_at_end = any(errors_in_sequence[:-1])
    |

models\ngram_manager.py:309:89: E501 Line too long (94 > 88)
    |
307 |             # Clean: all chars correct, no space/backspace, time>0
308 |             is_clean_ngram = all(
309 |                 get_actual_char(k) == get_expected_char(k) for k in current_keystroke_sequence
    |                                                                                         ^^^^^^ E501
310 |             )
311 |             # Error: only last char is error, all others correct, no space/backspace, time>0
    |

models\ngram_manager.py:311:89: E501 Line too long (92 > 88)
    |
309 |                 get_actual_char(k) == get_expected_char(k) for k in current_keystroke_sequence
310 |             )
311 |             # Error: only last char is error, all others correct, no space/backspace, time>0
    |                                                                                         ^^^^ E501
312 |             ngram_is_error_flag = (not any(errors_in_sequence[:-1])) and errors_in_sequence[-1]
313 |             # Valid: not error in non-last, no space/backspace, time>0
    |

models\ngram_manager.py:312:89: E501 Line too long (95 > 88)
    |
310 |             )
311 |             # Error: only last char is error, all others correct, no space/backspace, time>0
312 |             ngram_is_error_flag = (not any(errors_in_sequence[:-1])) and errors_in_sequence[-1]
    |                                                                                         ^^^^^^^ E501
313 |             # Valid: not error in non-last, no space/backspace, time>0
314 |             is_valid_ngram = not err_not_at_end
    |

models\ngram_manager.py:338:89: E501 Line too long (99 > 88)
    |
336 |         Per specification in ngram.md:
337 |         - Clean ngrams go to the session_ngram_speed table
338 |         - Ngrams with error flag (error only in last position) go to the session_ngram_errors table
    |                                                                                         ^^^^^^^^^^^ E501
339 |         - Only ngrams of size 2-10 are saved
    |

models\ngram_manager.py:355:89: E501 Line too long (120 > 88)
    |
353 |         if ngram.size < MIN_NGRAM_SIZE or ngram.size > MAX_NGRAM_SIZE:
354 |             logger.debug(
355 |                 f"Skipping ngram '{ngram.text}' as size {ngram.size} is outside range {MIN_NGRAM_SIZE}-{MAX_NGRAM_SIZE}"
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
356 |             )
357 |             return True  # Not an error, just skipping
    |

models\session.py:129:89: E501 Line too long (91 > 88)
    |
127 |             return cls.model_validate(data)
128 |         except ValueError as e:
129 |             # Re-raise with a more specific message while preserving the original exception
    |                                                                                         ^^^ E501
130 |             raise ValueError(f"Invalid session data: {str(e)}") from e
    |

models\session_manager.py:34:89: E501 Line too long (109 > 88)
   |
32 |             row = self.db_manager.execute(
33 |                 """
34 |                 SELECT session_id, snippet_id, user_id, keyboard_id, snippet_index_start, snippet_index_end,
   |                                                                                         ^^^^^^^^^^^^^^^^^^^^^ E501
35 |                        content, start_time, end_time, actual_chars, errors
36 |                 FROM practice_sessions WHERE session_id = ?
   |

models\session_manager.py:76:89: E501 Line too long (96 > 88)
   |
74 |             rows = self.db_manager.execute(
75 |                 (
76 |                     "SELECT session_id, snippet_id, user_id, keyboard_id, snippet_index_start, "
   |                                                                                         ^^^^^^^^ E501
77 |                     "snippet_index_end, content, start_time, end_time, actual_chars, errors "
78 |                     "FROM practice_sessions WHERE snippet_id = ? "
   |

models\session_manager.py:77:89: E501 Line too long (93 > 88)
   |
75 |                 (
76 |                     "SELECT session_id, snippet_id, user_id, keyboard_id, snippet_index_start, "
77 |                     "snippet_index_end, content, start_time, end_time, actual_chars, errors "
   |                                                                                         ^^^^^ E501
78 |                     "FROM practice_sessions WHERE snippet_id = ? "
79 |                     "ORDER BY end_time DESC"
   |

models\session_manager.py:150:89: E501 Line too long (102 > 88)
    |
148 |             """
149 |             INSERT INTO practice_sessions (
150 |                 session_id, snippet_id, user_id, keyboard_id, snippet_index_start, snippet_index_end,
    |                                                                                         ^^^^^^^^^^^^^^ E501
151 |                 content, start_time, end_time, actual_chars, errors, ms_per_keystroke
152 |             ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    |

models\setting.py:19:89: E501 Line too long (90 > 88)
   |
18 |     This exception is raised for validation errors such as invalid format
19 |     or if a setting type ID that is not unique for a given entity is attempted to be used.
   |                                                                                         ^^ E501
20 |     """
   |

models\setting.py:46:89: E501 Line too long (93 > 88)
   |
44 |         setting_type_id: 6-character key identifying the setting type.
45 |         setting_value: The setting value stored as text.
46 |         related_entity_id: UUID string identifying the related entity (user, keyboard, etc.).
   |                                                                                         ^^^^^ E501
47 |         updated_at: ISO datetime indicating when the setting was last updated.
48 |     """
   |

models\setting_manager.py:43:89: E501 Line too long (92 > 88)
   |
41 |             SettingValidationError: If the combination is not unique.
42 |         """
43 |         query = "SELECT 1 FROM settings WHERE setting_type_id = ? AND related_entity_id = ?"
   |                                                                                         ^^^^ E501
44 |         params = [setting_type_id, related_entity_id]
45 |         if setting_id is not None:
   |

models\setting_manager.py:63:89: E501 Line too long (109 > 88)
   |
61 |         """
62 |         Retrieve a single setting by type ID and related entity ID.
63 |         If the setting doesn't exist and a default value is provided, returns a new setting with the default.
   |                                                                                         ^^^^^^^^^^^^^^^^^^^^^ E501
64 |
65 |         Args:
   |

models\setting_manager.py:74:89: E501 Line too long (100 > 88)
   |
73 |         Raises:
74 |             SettingNotFound: If no setting exists with the specified IDs and no default is provided.
   |                                                                                         ^^^^^^^^^^^^ E501
75 |         """
76 |         row = self.db_manager.execute(
   |

models\setting_manager.py:78:89: E501 Line too long (93 > 88)
   |
76 |         row = self.db_manager.execute(
77 |             """
78 |             SELECT setting_id, setting_type_id, setting_value, related_entity_id, updated_at
   |                                                                                         ^^^^^ E501
79 |             FROM settings
80 |             WHERE setting_type_id = ? AND related_entity_id = ?
   |

models\setting_manager.py:102:89: E501 Line too long (90 > 88)
    |
100 |                 updated_at=datetime.datetime.now().isoformat(),
101 |             )
102 |             # We don't save it to the database yet - that would be handled by save_setting
    |                                                                                         ^^ E501
103 |             return new_setting
104 |         else:
    |

models\setting_manager.py:106:89: E501 Line too long (101 > 88)
    |
104 |         else:
105 |             raise SettingNotFound(
106 |                 f"Setting with type '{setting_type_id}' for entity '{related_entity_id}' not found. "
    |                                                                                         ^^^^^^^^^^^^^ E501
107 |                 "Please ensure the setting exists or provide a default value."
108 |             )
    |

models\setting_manager.py:122:89: E501 Line too long (93 > 88)
    |
120 |         rows = self.db_manager.execute(
121 |             """
122 |             SELECT setting_id, setting_type_id, setting_value, related_entity_id, updated_at
    |                                                                                         ^^^^^ E501
123 |             FROM settings
124 |             WHERE related_entity_id = ?
    |

models\setting_manager.py:160:89: E501 Line too long (98 > 88)
    |
158 |         # Check if a setting with this type and entity already exists
159 |         existing_setting_row = self.db_manager.execute(
160 |             "SELECT setting_id FROM settings WHERE setting_type_id = ? AND related_entity_id = ?",
    |                                                                                         ^^^^^^^^^^ E501
161 |             (setting.setting_type_id, setting.related_entity_id)
162 |         ).fetchone()
    |

models\setting_manager.py:195:89: E501 Line too long (100 > 88)
    |
193 |             """
194 |             INSERT INTO settings_history
195 |             (history_id, setting_id, setting_type_id, setting_value, related_entity_id, updated_at)
    |                                                                                         ^^^^^^^^^^^^ E501
196 |             VALUES (?, ?, ?, ?, ?, ?)
197 |             """,
    |

models\setting_manager.py:234:89: E501 Line too long (94 > 88)
    |
232 |             """
233 |             UPDATE settings
234 |             SET setting_type_id = ?, setting_value = ?, related_entity_id = ?, updated_at = ?
    |                                                                                         ^^^^^^ E501
235 |             WHERE setting_id = ?
236 |             """,
    |

models\setting_manager.py:273:89: E501 Line too long (91 > 88)
    |
271 |             # Now delete the setting
272 |             self.db_manager.execute(
273 |                 "DELETE FROM settings WHERE setting_type_id = ? AND related_entity_id = ?",
    |                                                                                         ^^^ E501
274 |                 (setting_type_id, related_entity_id),
275 |             )
    |

models\snippet.py:33:89: E501 Line too long (93 > 88)
   |
31 |     Args:
32 |         value: The string to check
33 |         is_content: Whether this is snippet content (code/text) that may legitimately contain
   |                                                                                         ^^^^^ E501
34 |                     quotes and equals signs
35 |     """
   |

models\snippet.py:45:89: E501 Line too long (95 > 88)
   |
43 |         ("INSERT INTO", r"INSERT\s+INTO"),
44 |         ("UPDATE SET", r"UPDATE\s+.*\s+SET"),
45 |         ("SELECT FROM", r"SELECT\s+.*\s+FROM"),  # Catches SELECT * FROM, SELECT col FROM, etc.
   |                                                                                         ^^^^^^^ E501
46 |         ("OR 1=1", r"OR\s+1\s*=\s*1"),
47 |         ("' OR '", r"'\s*OR\s*'"),
   |

models\snippet.py:61:89: E501 Line too long (90 > 88)
   |
59 |     for pattern_name, pattern_regex in core_patterns:
60 |         if re.search(pattern_regex, value, re.IGNORECASE):
61 |             raise ValueError(f"Value contains potentially unsafe pattern: {pattern_name}")
   |                                                                                         ^^ E501
62 |
63 |     # Only check extended patterns if not validating content (code/text)
   |

models\snippet.py:67:89: E501 Line too long (89 > 88)
   |
65 |         for pattern in extended_patterns:
66 |             if pattern.lower() in value.lower():
67 |                 raise ValueError(f"Value contains potentially unsafe pattern: {pattern}")
   |                                                                                         ^ E501
68 |
69 |     return value
   |

models\snippet.py:76:89: E501 Line too long (92 > 88)
   |
75 |     Args:
76 |         value: The value to validate, which can be an int or string representation of an int
   |                                                                                         ^^^^ E501
77 |
78 |     Returns:
   |

models\snippet.py:87:89: E501 Line too long (99 > 88)
   |
85 |         if isinstance(value, str):
86 |             # Ensure string is a valid representation of an integer
87 |             if not value.strip().isdigit() and not (value.startswith("-") and value[1:].isdigit()):
   |                                                                                         ^^^^^^^^^^^ E501
88 |                 raise ValueError("String must represent a valid integer")
89 |             return int(value)
   |

models\snippet.py:167:89: E501 Line too long (90 > 88)
    |
166 |             errors = [
167 |                 ErrorWrapper(ValueError(f"Extra field not permitted: {field}"), loc=field)
    |                                                                                         ^^ E501
168 |                 for field in extra
169 |             ]
    |

models\snippet_manager.py:75:89: E501 Line too long (93 > 88)
   |
73 |         if exists:
74 |             self.db.execute(
75 |                 "UPDATE snippets SET category_id = ?, snippet_name = ? WHERE snippet_id = ?",
   |                                                                                         ^^^^^ E501
76 |                 (snippet.category_id, snippet.snippet_name, snippet.snippet_id),
77 |             )
   |

models\snippet_manager.py:78:89: E501 Line too long (100 > 88)
   |
76 |                 (snippet.category_id, snippet.snippet_name, snippet.snippet_id),
77 |             )
78 |             self.db.execute("DELETE FROM snippet_parts WHERE snippet_id = ?", (snippet.snippet_id,))
   |                                                                                         ^^^^^^^^^^^^ E501
79 |         else:
80 |             self.db.execute(
   |

models\snippet_manager.py:81:89: E501 Line too long (96 > 88)
   |
79 |         else:
80 |             self.db.execute(
81 |                 "INSERT INTO snippets (snippet_id, category_id, snippet_name) VALUES (?, ?, ?)",
   |                                                                                         ^^^^^^^^ E501
82 |                 (snippet.snippet_id, snippet.category_id, snippet.snippet_name),
83 |             )
   |

models\snippet_manager.py:89:89: E501 Line too long (96 > 88)
   |
87 |         for i, part_content in enumerate(content_parts):
88 |             self.db.execute(
89 |                 "INSERT INTO snippet_parts (snippet_id, part_number, content) VALUES (?, ?, ?)",
   |                                                                                         ^^^^^^^^ E501
90 |                 (snippet.snippet_id, i, part_content),
91 |             )
   |

models\snippet_manager.py:108:89: E501 Line too long (98 > 88)
    |
106 |         try:
107 |             cursor = self.db.execute(
108 |                 "SELECT snippet_id, category_id, snippet_name FROM snippets WHERE snippet_id = ?",
    |                                                                                         ^^^^^^^^^^ E501
109 |                 (snippet_id,),
110 |             )
    |

models\snippet_manager.py:121:89: E501 Line too long (94 > 88)
    |
120 |             parts_cursor = self.db.execute(
121 |                 "SELECT content FROM snippet_parts WHERE snippet_id = ? ORDER BY part_number",
    |                                                                                         ^^^^^^ E501
122 |                 (snippet_id,),
123 |             )
    |

models\snippet_manager.py:136:89: E501 Line too long (93 > 88)
    |
134 |             logging.error(f"Unexpected error retrieving snippet ID {snippet_id}: {e}")
135 |             raise DatabaseError(
136 |                 f"An unexpected error occurred while retrieving snippet ID {snippet_id}: {e}"
    |                                                                                         ^^^^^ E501
137 |             ) from e
    |

models\snippet_manager.py:139:89: E501 Line too long (92 > 88)
    |
137 |             ) from e
138 |
139 |     def get_snippet_by_name(self, snippet_name: str, category_id: str) -> Optional[Snippet]:
    |                                                                                         ^^^^ E501
140 |         """Retrieves a snippet by its name and category UUID.
    |

models\snippet_manager.py:154:89: E501 Line too long (93 > 88)
    |
152 |         try:
153 |             cursor = self.db.execute(
154 |                 "SELECT snippet_id FROM snippets WHERE snippet_name = ? AND category_id = ?",
    |                                                                                         ^^^^^ E501
155 |                 (snippet_name, category_id),
156 |             )
    |

models\snippet_manager.py:208:89: E501 Line too long (98 > 88)
    |
207 |                 parts_cursor = self.db.execute(
208 |                     "SELECT content FROM snippet_parts WHERE snippet_id = ? ORDER BY part_number",
    |                                                                                         ^^^^^^^^^^ E501
209 |                     (current_snippet_id,),
210 |                 )
    |

models\snippet_manager.py:218:89: E501 Line too long (91 > 88)
    |
216 |             return snippets
217 |         except DatabaseError as e:
218 |             logging.error(f"Database error listing snippets for cat ID {category_id}: {e}")
    |                                                                                         ^^^ E501
219 |             raise
220 |         except Exception as e:
    |

models\snippet_manager.py:221:89: E501 Line too long (93 > 88)
    |
219 |             raise
220 |         except Exception as e:
221 |             logging.error(f"Unexpected error listing snippets for cat ID {category_id}: {e}")
    |                                                                                         ^^^^^ E501
222 |             raise DatabaseError(
223 |                 f"An unexpected error occurred while listing snippets for cat ID {category_id}: {e}"
    |

models\snippet_manager.py:223:89: E501 Line too long (100 > 88)
    |
221 |             logging.error(f"Unexpected error listing snippets for cat ID {category_id}: {e}")
222 |             raise DatabaseError(
223 |                 f"An unexpected error occurred while listing snippets for cat ID {category_id}: {e}"
    |                                                                                         ^^^^^^^^^^^^ E501
224 |             ) from e
    |

models\snippet_manager.py:226:89: E501 Line too long (94 > 88)
    |
224 |             ) from e
225 |
226 |     def search_snippets(self, query: str, category_id: Optional[int] = None) -> List[Snippet]:
    |                                                                                         ^^^^^^ E501
227 |         """Searches for snippets by a query string in their name or content.
    |

models\snippet_manager.py:258:89: E501 Line too long (99 > 88)
    |
256 |             rows = cursor.fetchall()
257 |
258 |             snippet_ids = [row[0] if isinstance(row, tuple) else row["snippet_id"] for row in rows]
    |                                                                                         ^^^^^^^^^^^ E501
259 |
260 |             snippets: List[Snippet] = []
    |

models\snippet_manager.py:267:89: E501 Line too long (89 > 88)
    |
265 |             return snippets
266 |         except DatabaseError as e:
267 |             logging.error(f"Database error searching snippets with query '{query}': {e}")
    |                                                                                         ^ E501
268 |             raise
269 |         except Exception as e:
    |

models\snippet_manager.py:270:89: E501 Line too long (91 > 88)
    |
268 |             raise
269 |         except Exception as e:
270 |             logging.error(f"Unexpected error searching snippets with query '{query}': {e}")
    |                                                                                         ^^^ E501
271 |             raise DatabaseError(
272 |                 f"An unexpected error occurred while searching snippets: {e}"
    |

models\snippet_manager.py:289:89: E501 Line too long (89 > 88)
    |
287 |         """
288 |         if not self.get_snippet_by_id(snippet_id):
289 |             raise ValueError(f"Snippet ID {snippet_id} not exist and cannot be deleted.")
    |                                                                                         ^ E501
290 |
291 |         try:
    |

models\snippet_manager.py:292:89: E501 Line too long (92 > 88)
    |
291 |         try:
292 |             self.db.execute("DELETE FROM snippet_parts WHERE snippet_id = ?", (snippet_id,))
    |                                                                                         ^^^^ E501
293 |             self.db.execute("DELETE FROM snippets WHERE snippet_id = ?", (snippet_id,))
294 |             return True
    |

models\snippet_manager.py:305:89: E501 Line too long (91 > 88)
    |
304 |     def snippet_exists(
305 |         self, category_id: str, snippet_name: str, exclude_snippet_id: Optional[str] = None
    |                                                                                         ^^^ E501
306 |     ) -> bool:
307 |         """Checks if a snippet with the given name already exists in the category (by UUID).
    |

models\snippet_manager.py:307:89: E501 Line too long (92 > 88)
    |
305 |         self, category_id: str, snippet_name: str, exclude_snippet_id: Optional[str] = None
306 |     ) -> bool:
307 |         """Checks if a snippet with the given name already exists in the category (by UUID).
    |                                                                                         ^^^^ E501
308 |
309 |         Args:
    |

models\snippet_manager.py:312:89: E501 Line too long (93 > 88)
    |
310 |             category_id: The UUID of the category to check within.
311 |             snippet_name: The name of the snippet to check for.
312 |             exclude_snippet_id: Optional. If provided, exclude this snippet ID from the check
    |                                                                                         ^^^^^ E501
313 |                                 (used when updating an existing snippet's name).
    |

models\snippet_manager.py:344:89: E501 Line too long (92 > 88)
    |
343 |         Returns:
344 |             A list of dictionaries, each with 'snippet_id', 'snippet_name', 'category_name'.
    |                                                                                         ^^^^ E501
345 |
346 |         Raises:
    |

models\snippet_manager.py:364:89: E501 Line too long (90 > 88)
    |
362 |             logging.error(f"Unexpected error retrieving all snippets summary: {e}")
363 |             raise DatabaseError(
364 |                 f"An unexpected error occurred while retrieving all snippets summary: {e}"
    |                                                                                         ^^ E501
365 |             ) from e
    |

models\snippet_manager.py:370:89: E501 Line too long (93 > 88)
    |
368 |         """Lists all snippets in the database with full content."""
369 |         try:
370 |             cursor = self.db.execute("SELECT snippet_id FROM snippets ORDER BY snippet_name")
    |                                                                                         ^^^^^ E501
371 |             rows = cursor.fetchall()
372 |             snippets = []
    |

models\snippet_manager.py:399:89: E501 Line too long (94 > 88)
    |
397 |         """
398 |         if not self.get_snippet_by_id(snippet_id):
399 |             raise ValueError(f"Snippet ID {snippet_id} does not exist and cannot be deleted.")
    |                                                                                         ^^^^^^ E501
400 |
401 |         try:
    |

models\snippet_manager.py:402:89: E501 Line too long (92 > 88)
    |
401 |         try:
402 |             self.db.execute("DELETE FROM snippet_parts WHERE snippet_id = ?", (snippet_id,))
    |                                                                                         ^^^^ E501
403 |             self.db.execute("DELETE FROM snippets WHERE snippet_id = ?", (snippet_id,))
404 |         except DatabaseError as e:
    |

models\snippet_manager.py:410:89: E501 Line too long (91 > 88)
    |
408 |             logging.error(f"Unexpected error deleting snippet ID {snippet_id}: {e}")
409 |             raise DatabaseError(
410 |                 f"An unexpected error occurred while deleting snippet ID {snippet_id}: {e}"
    |                                                                                         ^^^ E501
411 |             ) from e
    |

models\snippet_manager.py:433:89: E501 Line too long (89 > 88)
    |
431 |         )
432 |
433 |     def get_starting_index(self, snippet_id: str, user_id: str, keyboard_id: str) -> int:
    |                                                                                         ^ E501
434 |         """
435 |         Returns the next starting index for a snippet for a given user and keyboard.
    |

models\snippet_manager.py:451:89: E501 Line too long (111 > 88)
    |
449 |                     session_id,
450 |                     snippet_index_end as end_index,
451 |                     rank() over (partition by snippet_id, user_id, keyboard_id order by start_time desc) as rnk
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^ E501
452 |                 from practice_sessions
453 |                 where
    |

models\user.py:76:89: E501 Line too long (95 > 88)
   |
74 |             raise ValueError("Name contains invalid control characters.")
75 |
76 |         # Check for invalid characters (only letters, spaces, hyphens, and apostrophes allowed)
   |                                                                                         ^^^^^^^ E501
77 |         if not all(c.isalpha() or c.isspace() or c in "-.'" for c in stripped_v):
78 |             raise ValueError("Name contains invalid characters.")
   |

models\user.py:82:89: E501 Line too long (93 > 88)
   |
80 |         # Check for leading/trailing spaces, hyphens, or apostrophes
81 |         if stripped_v[0] in " -'" or stripped_v[-1] in " -'":
82 |             raise ValueError("Name cannot start or end with a space, hyphen, or apostrophe.")
   |                                                                                         ^^^^^ E501
83 |
84 |         # Check for consecutive spaces, hyphens, or apostrophes
   |

models\user.py:87:89: E501 Line too long (100 > 88)
   |
85 |         for i in range(len(stripped_v) - 1):
86 |             if stripped_v[i] in " -'" and stripped_v[i + 1] in " -'":
87 |                 raise ValueError("Name cannot contain consecutive spaces, hyphens, or apostrophes.")
   |                                                                                         ^^^^^^^^^^^^ E501
88 |
89 |         return stripped_v
   |

models\user.py:147:89: E501 Line too long (89 > 88)
    |
145 |                 # Check for invalid characters in domain parts
146 |                 if not all(c.isalnum() or c == "-" for c in part):
147 |                     raise ValueError(f"Domain part '{part}' contains invalid characters")
    |                                                                                         ^ E501
148 |
149 |                 # Check for parts starting or ending with a hyphen
    |

models\user.py:161:89: E501 Line too long (90 > 88)
    |
159 |             if len(tld) < 2 or not tld.isalpha():
160 |                 raise ValueError(
161 |                     "Top-level domain must be at least 2 letters and contain only letters"
    |                                                                                         ^^ E501
162 |                 )
    |

models\user_manager.py:28:89: E501 Line too long (100 > 88)
   |
26 |         self.db_manager: DatabaseManager = db_manager
27 |
28 |     def _validate_email_uniqueness(self, email_address: str, user_id: Optional[str] = None) -> None:
   |                                                                                         ^^^^^^^^^^^^ E501
29 |         # Always use lowercase for email comparisons
30 |         email_address_lower = email_address.lower()
   |

models\user_manager.py:37:89: E501 Line too long (89 > 88)
   |
35 |             params.append(user_id)
36 |         if self.db_manager.execute(query, tuple(params)).fetchone():
37 |             raise UserValidationError(f"Email address '{email_address}' must be unique.")
   |                                                                                         ^ E501
38 |
39 |     def get_user_by_id(self, user_id: str) -> User:
   |

models\user_manager.py:41:89: E501 Line too long (94 > 88)
   |
39 |     def get_user_by_id(self, user_id: str) -> User:
40 |         row = self.db_manager.execute(
41 |             "SELECT user_id, first_name, surname, email_address FROM users WHERE user_id = ?",
   |                                                                                         ^^^^^^ E501
42 |             (user_id,),
43 |         ).fetchone()
   |

models\user_manager.py:46:89: E501 Line too long (92 > 88)
   |
44 |         if not row:
45 |             raise UserNotFound(f"User with ID {user_id} not found.")
46 |         return User(user_id=row[0], first_name=row[1], surname=row[2], email_address=row[3])
   |                                                                                         ^^^^ E501
47 |
48 |     def get_user_by_email(self, email_address: str) -> User:
   |

models\user_manager.py:51:89: E501 Line too long (114 > 88)
   |
49 |         # Use case-insensitive comparison for email retrieval
50 |         row = self.db_manager.execute(
51 |             "SELECT user_id, first_name, surname, email_address FROM users WHERE LOWER(email_address) = LOWER(?)",
   |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
52 |             (email_address.lower(),),
53 |         ).fetchone()
   |

models\user_manager.py:56:89: E501 Line too long (92 > 88)
   |
54 |         if not row:
55 |             raise UserNotFound(f"User with email '{email_address}' not found.")
56 |         return User(user_id=row[0], first_name=row[1], surname=row[2], email_address=row[3])
   |                                                                                         ^^^^ E501
57 |
58 |     def list_all_users(self) -> List[User]:
   |

models\user_manager.py:60:89: E501 Line too long (104 > 88)
   |
58 |     def list_all_users(self) -> List[User]:
59 |         rows = self.db_manager.execute(
60 |             "SELECT user_id, first_name, surname, email_address FROM users ORDER BY surname, first_name"
   |                                                                                         ^^^^^^^^^^^^^^^^ E501
61 |         ).fetchall()
62 |         return [
   |

models\user_manager.py:63:89: E501 Line too long (89 > 88)
   |
61 |         ).fetchall()
62 |         return [
63 |             User(user_id=row[0], first_name=row[1], surname=row[2], email_address=row[3])
   |                                                                                         ^ E501
64 |             for row in rows
65 |         ]
   |

models\user_manager.py:82:89: E501 Line too long (98 > 88)
   |
80 |     def __insert_user(self, user: User) -> bool:
81 |         self.db_manager.execute(
82 |             "INSERT INTO users (user_id, first_name, surname, email_address) VALUES (?, ?, ?, ?)",
   |                                                                                         ^^^^^^^^^^ E501
83 |             (user.user_id, user.first_name, user.surname, user.email_address.lower()),
84 |         )
   |

models\user_manager.py:89:89: E501 Line too long (96 > 88)
   |
87 |     def __update_user(self, user: User) -> bool:
88 |         self.db_manager.execute(
89 |             "UPDATE users SET first_name = ?, surname = ?, email_address = ? WHERE user_id = ?",
   |                                                                                         ^^^^^^^^ E501
90 |             (user.first_name, user.surname, user.email_address.lower(), user.user_id),
91 |         )
   |

Found 109 errors.
services\__init__.py:44:89: E501 Line too long (94 > 88)
   |
42 |         db_manager.close()
43 |         raise ImportError(
44 |             "Failed to initialize services. Please ensure all required modules are available."
   |                                                                                         ^^^^^^ E501
45 |         ) from e
   |

services\database_viewer_service.py:50:89: E501 Line too long (94 > 88)
   |
48 |     sorting, filtering), and export to CSV.
49 |
50 |     This service provides a read-only interface to inspect database tables and their contents.
   |                                                                                         ^^^^^^ E501
51 |     It handles pagination, sorting, and filtering of data, as well as exporting to CSV format.
52 |     All operations are performed in a secure, read-only manner with proper input validation.
   |

services\database_viewer_service.py:51:89: E501 Line too long (94 > 88)
   |
50 |     This service provides a read-only interface to inspect database tables and their contents.
51 |     It handles pagination, sorting, and filtering of data, as well as exporting to CSV format.
   |                                                                                         ^^^^^^ E501
52 |     All operations are performed in a secure, read-only manner with proper input validation.
53 |     """
   |

services\database_viewer_service.py:52:89: E501 Line too long (92 > 88)
   |
50 |     This service provides a read-only interface to inspect database tables and their contents.
51 |     It handles pagination, sorting, and filtering of data, as well as exporting to CSV format.
52 |     All operations are performed in a secure, read-only manner with proper input validation.
   |                                                                                         ^^^^ E501
53 |     """
   |

services\database_viewer_service.py:55:9: ANN204 Missing return type annotation for special method `__init__`
   |
53 |     """
54 |
55 |     def __init__(self, db_manager: DatabaseManager):
   |         ^^^^^^^^ ANN204
56 |         """
57 |         Initialize the DatabaseViewerService with a database manager.
   |
   = help: Add return type annotation: `None`

services\database_viewer_service.py:157:89: E501 Line too long (101 > 88)
    |
155 |         # Validate sort_by if provided
156 |         if sort_by and sort_by not in columns:
157 |             raise InvalidParameterError(f"Sort column '{sort_by}' not found in table '{table_name}'")
    |                                                                                         ^^^^^^^^^^^^^ E501
158 |
159 |         # Validate filter_column if provided
    |

services\database_viewer_service.py:161:89: E501 Line too long (109 > 88)
    |
159 |         # Validate filter_column if provided
160 |         if filter_column and filter_column not in columns:
161 |             raise InvalidParameterError(f"Filter column '{filter_column}' not found in table '{table_name}'")
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^ E501
162 |
163 |         # Build query
    |

services\library_service.py:47:9: ANN204 Missing return type annotation for special method `__init__`
   |
45 |     metadata = metadata
46 |
47 |     def __init__(self, session):
   |         ^^^^^^^^ ANN204
48 |         self.session = session
   |
   = help: Add return type annotation: `None`

services\library_service.py:47:24: ANN001 Missing type annotation for function argument `session`
   |
45 |     metadata = metadata
46 |
47 |     def __init__(self, session):
   |                        ^^^^^^^ ANN001
48 |         self.session = session
   |

services\library_service.py:51:9: ANN201 Missing return type annotation for public function `add_category`
   |
50 |     # Category methods
51 |     def add_category(self, name):
   |         ^^^^^^^^^^^^ ANN201
52 |         if not name or len(name) > 50 or not name.isascii():
53 |             raise ValidationError("Invalid category name")
   |
   = help: Add return type annotation

services\library_service.py:51:28: ANN001 Missing type annotation for function argument `name`
   |
50 |     # Category methods
51 |     def add_category(self, name):
   |                            ^^^^ ANN001
52 |         if not name or len(name) > 50 or not name.isascii():
53 |             raise ValidationError("Invalid category name")
   |

services\library_service.py:60:9: ANN201 Missing return type annotation for public function `get_categories`
   |
58 |         return cat
59 |
60 |     def get_categories(self):
   |         ^^^^^^^^^^^^^^ ANN201
61 |         return self.session.query(Category).all()
   |
   = help: Add return type annotation

services\library_service.py:63:9: ANN201 Missing return type annotation for public function `edit_category`
   |
61 |         return self.session.query(Category).all()
62 |
63 |     def edit_category(self, category_id, new_name):
   |         ^^^^^^^^^^^^^ ANN201
64 |         if not new_name or len(new_name) > 50 or not new_name.isascii():
65 |             raise ValidationError("Invalid category name")
   |
   = help: Add return type annotation

services\library_service.py:63:29: ANN001 Missing type annotation for function argument `category_id`
   |
61 |         return self.session.query(Category).all()
62 |
63 |     def edit_category(self, category_id, new_name):
   |                             ^^^^^^^^^^^ ANN001
64 |         if not new_name or len(new_name) > 50 or not new_name.isascii():
65 |             raise ValidationError("Invalid category name")
   |

services\library_service.py:63:42: ANN001 Missing type annotation for function argument `new_name`
   |
61 |         return self.session.query(Category).all()
62 |
63 |     def edit_category(self, category_id, new_name):
   |                                          ^^^^^^^^ ANN001
64 |         if not new_name or len(new_name) > 50 or not new_name.isascii():
65 |             raise ValidationError("Invalid category name")
   |

services\library_service.py:78:9: ANN201 Missing return type annotation for public function `delete_category`
   |
76 |         return cat
77 |
78 |     def delete_category(self, category_id):
   |         ^^^^^^^^^^^^^^^ ANN201
79 |         cat = self.session.query(Category).filter_by(category_id=category_id).first()
80 |         if not cat:
   |
   = help: Add return type annotation: `None`

services\library_service.py:78:31: ANN001 Missing type annotation for function argument `category_id`
   |
76 |         return cat
77 |
78 |     def delete_category(self, category_id):
   |                               ^^^^^^^^^^^ ANN001
79 |         cat = self.session.query(Category).filter_by(category_id=category_id).first()
80 |         if not cat:
   |

services\library_service.py:85:9: ANN201 Missing return type annotation for public function `add_snippet`
   |
84 |     # Snippet methods
85 |     def add_snippet(self, category_id, name, content):
   |         ^^^^^^^^^^^ ANN201
86 |         if not name or len(name) > 50 or not name.isascii():
87 |             raise ValidationError("Invalid snippet name")
   |
   = help: Add return type annotation

services\library_service.py:85:27: ANN001 Missing type annotation for function argument `category_id`
   |
84 |     # Snippet methods
85 |     def add_snippet(self, category_id, name, content):
   |                           ^^^^^^^^^^^ ANN001
86 |         if not name or len(name) > 50 or not name.isascii():
87 |             raise ValidationError("Invalid snippet name")
   |

services\library_service.py:85:40: ANN001 Missing type annotation for function argument `name`
   |
84 |     # Snippet methods
85 |     def add_snippet(self, category_id, name, content):
   |                                        ^^^^ ANN001
86 |         if not name or len(name) > 50 or not name.isascii():
87 |             raise ValidationError("Invalid snippet name")
   |

services\library_service.py:85:46: ANN001 Missing type annotation for function argument `content`
   |
84 |     # Snippet methods
85 |     def add_snippet(self, category_id, name, content):
   |                                              ^^^^^^^ ANN001
86 |         if not name or len(name) > 50 or not name.isascii():
87 |             raise ValidationError("Invalid snippet name")
   |

services\library_service.py:100:9: ANN201 Missing return type annotation for public function `get_snippets`
    |
 98 |         return snip
 99 |
100 |     def get_snippets(self, category_id):
    |         ^^^^^^^^^^^^ ANN201
101 |         return self.session.query(Snippet).filter_by(category_id=category_id).all()
    |
    = help: Add return type annotation

services\library_service.py:100:28: ANN001 Missing type annotation for function argument `category_id`
    |
 98 |         return snip
 99 |
100 |     def get_snippets(self, category_id):
    |                            ^^^^^^^^^^^ ANN001
101 |         return self.session.query(Snippet).filter_by(category_id=category_id).all()
    |

services\library_service.py:103:9: ANN201 Missing return type annotation for public function `edit_snippet`
    |
101 |         return self.session.query(Snippet).filter_by(category_id=category_id).all()
102 |
103 |     def edit_snippet(self, snippet_id, new_name, new_content, new_category_id=None):
    |         ^^^^^^^^^^^^ ANN201
104 |         if not new_name or len(new_name) > 50 or not new_name.isascii():
105 |             raise ValidationError("Invalid snippet name")
    |
    = help: Add return type annotation

services\library_service.py:103:28: ANN001 Missing type annotation for function argument `snippet_id`
    |
101 |         return self.session.query(Snippet).filter_by(category_id=category_id).all()
102 |
103 |     def edit_snippet(self, snippet_id, new_name, new_content, new_category_id=None):
    |                            ^^^^^^^^^^ ANN001
104 |         if not new_name or len(new_name) > 50 or not new_name.isascii():
105 |             raise ValidationError("Invalid snippet name")
    |

services\library_service.py:103:40: ANN001 Missing type annotation for function argument `new_name`
    |
101 |         return self.session.query(Snippet).filter_by(category_id=category_id).all()
102 |
103 |     def edit_snippet(self, snippet_id, new_name, new_content, new_category_id=None):
    |                                        ^^^^^^^^ ANN001
104 |         if not new_name or len(new_name) > 50 or not new_name.isascii():
105 |             raise ValidationError("Invalid snippet name")
    |

services\library_service.py:103:50: ANN001 Missing type annotation for function argument `new_content`
    |
101 |         return self.session.query(Snippet).filter_by(category_id=category_id).all()
102 |
103 |     def edit_snippet(self, snippet_id, new_name, new_content, new_category_id=None):
    |                                                  ^^^^^^^^^^^ ANN001
104 |         if not new_name or len(new_name) > 50 or not new_name.isascii():
105 |             raise ValidationError("Invalid snippet name")
    |

services\library_service.py:103:63: ANN001 Missing type annotation for function argument `new_category_id`
    |
101 |         return self.session.query(Snippet).filter_by(category_id=category_id).all()
102 |
103 |     def edit_snippet(self, snippet_id, new_name, new_content, new_category_id=None):
    |                                                               ^^^^^^^^^^^^^^^ ANN001
104 |         if not new_name or len(new_name) > 50 or not new_name.isascii():
105 |             raise ValidationError("Invalid snippet name")
    |

services\library_service.py:129:9: ANN201 Missing return type annotation for public function `delete_snippet`
    |
127 |         return snip
128 |
129 |     def delete_snippet(self, snippet_id):
    |         ^^^^^^^^^^^^^^ ANN201
130 |         snip = self.session.query(Snippet).filter_by(snippet_id=snippet_id).first()
131 |         if not snip:
    |
    = help: Add return type annotation: `None`

services\library_service.py:129:30: ANN001 Missing type annotation for function argument `snippet_id`
    |
127 |         return snip
128 |
129 |     def delete_snippet(self, snippet_id):
    |                              ^^^^^^^^^^ ANN001
130 |         snip = self.session.query(Snippet).filter_by(snippet_id=snippet_id).first()
131 |         if not snip:
    |

Found 30 errors.
No fixes available (4 hidden fixes can be enabled with the `--unsafe-fixes` option).
helpers\error_utils.py:21:5: ANN001 Missing type annotation for function argument `parent`
   |
19 |     title: str = "Error",
20 |     details: Optional[str] = None,
21 |     parent=None
   |     ^^^^^^ ANN001
22 | ) -> None:
23 |     """Display an error message box with the given error information.
   |

Found 1 error.
desktop_ui\api_key_dialog.py:52:89: E501 Line too long (92 > 88)
   |
50 |         self.setWindowTitle("API Key Configuration")
51 |         self.setMinimumWidth(500)
52 |         self.setWindowFlags(self.windowFlags() & ~Qt.WindowType.WindowContextHelpButtonHint)
   |                                                                                         ^^^^ E501
53 |
54 |         self.api_keys: Dict[str, str] = {}
   |

desktop_ui\api_key_dialog.py:95:89: E501 Line too long (89 > 88)
   |
93 |         api_info_label = QLabel(
94 |             "Your API key is required for word generation features.\n"
95 |             "The key is stored securely and never transmitted except to OpenAI services."
   |                                                                                         ^ E501
96 |         )
97 |         api_info_label.setWordWrap(True)
   |

desktop_ui\api_key_dialog.py:167:89: E501 Line too long (98 > 88)
    |
165 |                 self,
166 |                 "Security Library Missing",
167 |                 "The cryptography library is not installed. API keys will not be securely stored."
    |                                                                                         ^^^^^^^^^^ E501
168 |                 "\n\nPlease run: pip install cryptography"
169 |             )
    |

desktop_ui\api_key_dialog.py:201:89: E501 Line too long (89 > 88)
    |
199 |         # Check if cryptography is available for secure storage
200 |         if not CRYPTOGRAPHY_AVAILABLE:
201 |             # Even without cryptography, we can still set the env var for current session
    |                                                                                         ^ E501
202 |             openai_key = self.openai_key_input.text().strip()
203 |             if not openai_key:
    |

desktop_ui\api_key_dialog.py:215:89: E501 Line too long (98 > 88)
    |
213 |                 self,
214 |                 "Limited Security",
215 |                 "Your API key has been set for this session, but secure storage is not available."
    |                                                                                         ^^^^^^^^^^ E501
216 |                 "\n\nThe cryptography library is needed for secure storage."
217 |                 "\nPlease run: pip install cryptography"
    |

desktop_ui\api_key_dialog.py:283:89: E501 Line too long (89 > 88)
    |
281 |         # Get machine-specific data
282 |         # This creates a unique identifier for the current machine
283 |         # While not foolproof, it helps ensure keys can only be decrypted on this machine
    |                                                                                         ^ E501
284 |         try:
285 |             import platform
    |

desktop_ui\api_key_dialog.py:309:89: E501 Line too long (102 > 88)
    |
308 |     @classmethod
309 |     def get_api_key(cls, parent: Optional[QDialog] = None, key_type: str = "openai") -> Optional[str]:
    |                                                                                         ^^^^^^^^^^^^^^ E501
310 |         """
311 |         Class method to get an API key, showing the dialog if needed.
    |

desktop_ui\api_key_dialog.py:331:89: E501 Line too long (91 > 88)
    |
329 |             dialog_instance._load_api_keys()
330 |
331 |             if key_type in dialog_instance.api_keys and dialog_instance.api_keys[key_type]:
    |                                                                                         ^^^ E501
332 |                 return dialog_instance.api_keys[key_type]
    |

desktop_ui\api_key_dialog.py:349:5: I001 [*] Import block is un-sorted or un-formatted
    |
347 |   if __name__ == "__main__":
348 |       # Test the dialog
349 | /     import sys
350 | |     from PySide6.QtWidgets import QApplication
    | |______________________________________________^ I001
351 |
352 |       app = QApplication(sys.argv)
    |
    = help: Organize imports

desktop_ui\api_server_manager.py:53:89: E501 Line too long (93 > 88)
   |
51 |         try:
52 |             # Try to connect to the server
53 |             # Even if we get a 400 error (method not allowed), it means the server is running
   |                                                                                         ^^^^^ E501
54 |             response = requests.get(self._api_url, timeout=2)
55 |             return True
   |

desktop_ui\api_server_manager.py:54:13: F841 Local variable `response` is assigned to but never used
   |
52 |             # Try to connect to the server
53 |             # Even if we get a 400 error (method not allowed), it means the server is running
54 |             response = requests.get(self._api_url, timeout=2)
   |             ^^^^^^^^ F841
55 |             return True
56 |         except requests.exceptions.ConnectionError:
   |
   = help: Remove assignment to unused variable `response`

desktop_ui\api_server_manager.py:80:89: E501 Line too long (91 > 88)
   |
78 |             cmd = [python_executable, self._server_script_path]
79 |
80 |             # Start server as a separate process that won't die when the desktop app closes
   |                                                                                         ^^^ E501
81 |             self._server_process = subprocess.Popen(
82 |                 cmd,
   |

desktop_ui\category_model_tester.py:4:89: E501 Line too long (109 > 88)
  |
2 | Category Model Tester UI
3 | -----------------------
4 | A simple PySide6-based desktop UI for directly testing the Category object model (Category, CategoryManager).
  |                                                                                         ^^^^^^^^^^^^^^^^^^^^^ E501
5 |
6 | - List all categories
  |

desktop_ui\category_model_tester.py:12:89: E501 Line too long (93 > 88)
   |
10 | - Show validation and error messages
11 |
12 | Bypasses API and service layers; interacts directly with CategoryManager and DatabaseManager.
   |                                                                                         ^^^^^ E501
13 |
14 | Author: Cascade AI
   |

desktop_ui\db_viewer_dialog.py:50:89: E501 Line too long (101 > 88)
   |
48 |         super().__init__(parent)
49 |         self.service = service
50 |         self.current_table = ""  # Initialize with empty string, will be set when a table is selected
   |                                                                                         ^^^^^^^^^^^^^ E501
51 |         self.page = 1
52 |         self.page_size = 50
   |

desktop_ui\db_viewer_dialog.py:76:89: E501 Line too long (94 > 88)
   |
74 |         self.table_combo = QComboBox()
75 |         # Connecting a signal through a lambda ensures it works in tests
76 |         self.table_combo.currentTextChanged.connect(lambda text: self.on_table_selected(text))
   |                                                                                         ^^^^^^ E501
77 |         top_layout.addWidget(table_label)
78 |         top_layout.addWidget(self.table_combo)
   |

desktop_ui\db_viewer_dialog.py:97:89: E501 Line too long (98 > 88)
   |
95 |         # Table widget
96 |         self.table_widget = QTableWidget()
97 |         self.table_widget.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers)  # Read-only
   |                                                                                         ^^^^^^^^^^ E501
98 |
99 |         # Cast the header to ensure type safety
   |

desktop_ui\db_viewer_dialog.py:122:89: E501 Line too long (101 > 88)
    |
120 |             self.page_size_combo.addItem(str(size))
121 |         self.page_size_combo.setCurrentText(str(self.page_size))
122 |         self.page_size_combo.currentTextChanged.connect(lambda text: self.on_page_size_changed(text))
    |                                                                                         ^^^^^^^^^^^^^ E501
123 |
124 |         pagination_layout.addWidget(self.prev_btn)
    |

desktop_ui\db_viewer_dialog.py:209:89: E501 Line too long (90 > 88)
    |
208 |     def load_table_data(self) -> None:
209 |         """Load and display table data with current pagination, sorting, and filtering."""
    |                                                                                         ^^ E501
210 |         if not self.current_table:
211 |             return
    |

desktop_ui\db_viewer_dialog.py:231:89: E501 Line too long (95 > 88)
    |
229 |             data = results.get("rows", [])
230 |             self.total_rows = results.get("total_rows", 0)
231 |             self.total_pages = max(1, (self.total_rows + self.page_size - 1) // self.page_size)
    |                                                                                         ^^^^^^^ E501
232 |
233 |             # Configure table
    |

desktop_ui\db_viewer_dialog.py:306:24: F821 Undefined name `QProgressBar`
    |
305 |             # Show progress dialog
306 |             progress = QProgressBar(self)
    |                        ^^^^^^^^^^^^ F821
307 |             progress.setWindowTitle("Exporting data...")
308 |             progress.setRange(0, 0)  # Indeterminate
    |

desktop_ui\dialogs\keyboard_dialog.py:67:89: E501 Line too long (91 > 88)
   |
65 |         self.target_ms_spinbox.setSuffix(" ms")  # Add ms suffix
66 |         self.target_ms_spinbox.setAlignment(Qt.AlignmentFlag.AlignRight)
67 |         self.target_ms_spinbox.setToolTip("Target milliseconds per keystroke (speed goal)")
   |                                                                                         ^^^ E501
68 |         form_layout.addRow("Target Speed:", self.target_ms_spinbox)
   |

desktop_ui\dialogs\keyboard_dialog.py:98:89: E501 Line too long (98 > 88)
    |
 96 |         if target_ms < 50 or target_ms > 5000:
 97 |             QMessageBox.warning(
 98 |                 self, "Validation Error", "Target speed must be between 50 and 5000 milliseconds."
    |                                                                                         ^^^^^^^^^^ E501
 99 |             )
100 |             self.target_ms_spinbox.setFocus()
    |

desktop_ui\dialogs\user_dialog.py:99:89: E501 Line too long (96 > 88)
    |
 97 |         # Basic email validation
 98 |         if "@" not in email or "." not in email:
 99 |             QMessageBox.warning(self, "Validation Error", "Please enter a valid email address.")
    |                                                                                         ^^^^^^^^ E501
100 |             self.email_edit.setFocus()
101 |             return
    |

desktop_ui\drill_config.py:60:89: E501 Line too long (114 > 88)
   |
58 |         print("\n[DEBUG] ===== Starting DrillConfigDialog initialization =====")
59 |         print(
60 |             f"[DEBUG] Args - db_manager: {db_manager is not None}, user_id: {user_id}, keyboard_id: {keyboard_id}"
   |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
61 |         )
   |

desktop_ui\drill_config.py:70:89: E501 Line too long (104 > 88)
   |
68 |         self.user_id = user_id or ""
69 |         print(
70 |             f"[DEBUG] Set instance variables - user_id: {self.user_id}, keyboard_id: {self.keyboard_id}"
   |                                                                                         ^^^^^^^^^^^^^^^^ E501
71 |         )
   |

desktop_ui\drill_config.py:96:89: E501 Line too long (90 > 88)
   |
94 |                     print(f"\n[DEBUG] Attempting to load user with ID: {self.user_id}")
95 |                     try:
96 |                         self.current_user = self.user_manager.get_user_by_id(self.user_id)
   |                                                                                         ^^ E501
97 |                         print(f"[DEBUG] Successfully loaded user: {self.current_user}")
98 |                         print(f"[DEBUG] User type: {type(self.current_user)}")
   |

desktop_ui\drill_config.py:100:89: E501 Line too long (142 > 88)
    |
 98 | ΓÇªtype(self.current_user)}")
 99 | ΓÇª
100 | ΓÇªs: {vars(self.current_user) if hasattr(self.current_user, '__dict__') else 'No __dict__'}"
    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
101 | ΓÇª
102 | ΓÇª
    |

desktop_ui\drill_config.py:109:89: E501 Line too long (95 > 88)
    |
108 |                 if self.keyboard_id:
109 |                     print(f"\n[DEBUG] Attempting to load keyboard with ID: {self.keyboard_id}")
    |                                                                                         ^^^^^^^ E501
110 |                     try:
111 |                         self.current_keyboard = self.keyboard_manager.get_keyboard_by_id(
    |

desktop_ui\drill_config.py:111:89: E501 Line too long (89 > 88)
    |
109 |                     print(f"\n[DEBUG] Attempting to load keyboard with ID: {self.keyboard_id}")
110 |                     try:
111 |                         self.current_keyboard = self.keyboard_manager.get_keyboard_by_id(
    |                                                                                         ^ E501
112 |                             self.keyboard_id
113 |                         )
    |

desktop_ui\drill_config.py:114:89: E501 Line too long (95 > 88)
    |
112 |                             self.keyboard_id
113 |                         )
114 |                         print(f"[DEBUG] Successfully loaded keyboard: {self.current_keyboard}")
    |                                                                                         ^^^^^^^ E501
115 |                         print(f"[DEBUG] Keyboard type: {type(self.current_keyboard)}")
116 |                     except Exception as e:
    |

desktop_ui\drill_config.py:279:89: E501 Line too long (109 > 88)
    |
277 |             for i, category in enumerate(self.categories):
278 |                 print(
279 |                     f"[DEBUG] Adding category {i + 1}: {category.category_name} (ID: {category.category_id})"
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^ E501
280 |                 )
281 |                 self.category_selector.addItem(category.category_name, category)
    |

desktop_ui\drill_config.py:310:89: E501 Line too long (97 > 88)
    |
309 |         if index < 0 or not self.categories or not self.snippet_manager:
310 |             print("[DEBUG] No category selected, no categories available, or no snippet manager")
    |                                                                                         ^^^^^^^^^ E501
311 |             self.snippet_selector.clear()
312 |             self.snippet_selector.setEnabled(False)
    |

desktop_ui\drill_config.py:325:89: E501 Line too long (113 > 88)
    |
324 |         print(
325 |             f"[DEBUG] Selected category: {selected_category.category_name} (ID: {selected_category.category_id})"
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^ E501
326 |         )
    |

desktop_ui\drill_config.py:330:89: E501 Line too long (95 > 88)
    |
328 |         try:
329 |             # Load snippets for the selected category
330 |             print(f"[DEBUG] Loading snippets for category ID: {selected_category.category_id}")
    |                                                                                         ^^^^^^^ E501
331 |             self.snippets = self.snippet_manager.list_snippets_by_category(
332 |                 selected_category.category_id
    |

desktop_ui\drill_config.py:341:89: E501 Line too long (104 > 88)
    |
339 |             for i, snippet in enumerate(self.snippets):
340 |                 print(
341 |                     f"[DEBUG] Adding snippet {i + 1}: {snippet.snippet_name} (ID: {snippet.snippet_id})"
    |                                                                                         ^^^^^^^^^^^^^^^^ E501
342 |                 )
343 |                 self.snippet_selector.addItem(snippet.snippet_name, snippet)
    |

desktop_ui\drill_config.py:399:89: E501 Line too long (97 > 88)
    |
397 |                         try:
398 |                             start_idx = self.snippet_manager.get_starting_index(
399 |                                 str(snippet.snippet_id), str(self.user_id), str(self.keyboard_id)
    |                                                                                         ^^^^^^^^^ E501
400 |                             )
401 |                         except Exception as e:
    |

desktop_ui\drill_config.py:431:89: E501 Line too long (93 > 88)
    |
429 |         # Add user information if available
430 |         if self.current_user:
431 |             user_name = f"{self.current_user.first_name} {self.current_user.surname}".strip()
    |                                                                                         ^^^^^ E501
432 |             user_display = f"User: {user_name or self.current_user.user_id}"
433 |             status_parts.append(user_display)
    |

desktop_ui\drill_config.py:438:89: E501 Line too long (118 > 88)
    |
436 |         # Add keyboard information if available
437 |         if self.current_keyboard:
438 |             keyboard_display = f"Keyboard: {self.current_keyboard.keyboard_name or self.current_keyboard.keyboard_id}"
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
439 |             status_parts.append(keyboard_display)
440 |         else:
    |

desktop_ui\drill_config.py:465:89: E501 Line too long (103 > 88)
    |
463 |             new_end_index = content_length
464 |
465 |         print(f"[DEBUG] Start index changed: {new_start_index}, updating end index to {new_end_index}")
    |                                                                                         ^^^^^^^^^^^^^^^ E501
466 |
467 |         # Update end index
    |

desktop_ui\drill_config.py:494:89: E501 Line too long (105 > 88)
    |
492 |             new_end_index = content_length
493 |
494 |         print(f"[DEBUG] Drill length changed: {new_drill_length}, updating end index to {new_end_index}")
    |                                                                                         ^^^^^^^^^^^^^^^^^ E501
495 |
496 |         # Update end index
    |

desktop_ui\drill_config.py:509:89: E501 Line too long (90 > 88)
    |
507 |             # Load drill category (DRICAT)
508 |             try:
509 |                 cat_setting = self.setting_manager.get_setting("DRICAT", self.keyboard_id)
    |                                                                                         ^^ E501
510 |                 cat_name = cat_setting.setting_value
511 |                 for i in range(self.category_selector.count()):
    |

desktop_ui\drill_config.py:521:89: E501 Line too long (94 > 88)
    |
519 |             # Load drill snippet (DRISNP)
520 |             try:
521 |                 snippet_setting = self.setting_manager.get_setting("DRISNP", self.keyboard_id)
    |                                                                                         ^^^^^^ E501
522 |                 snippet_name = snippet_setting.setting_value
523 |                 for i in range(self.snippet_selector.count()):
    |

desktop_ui\drill_config.py:533:89: E501 Line too long (96 > 88)
    |
531 |             # Load drill length (DRILEN)
532 |             try:
533 |                 drill_len_setting = self.setting_manager.get_setting("DRILEN", self.keyboard_id)
    |                                                                                         ^^^^^^^^ E501
534 |                 self.drill_length.setValue(int(drill_len_setting.setting_value))
535 |             except Exception:
    |

desktop_ui\drill_config.py:678:89: E501 Line too long (91 > 88)
    |
676 |         # Store configuration for the typing drill screen
677 |         try:
678 |             # For custom text, adjust the start and end indices to match the custom content
    |                                                                                         ^^^ E501
679 |             if self.use_custom_text.isChecked():
680 |                 start_for_drill = 0
    |

desktop_ui\drill_config.py:713:89: E501 Line too long (90 > 88)
    |
712 |     def _on_cancel_clicked(self) -> None:
713 |         """Slot for Cancel button to ensure QDialog.reject is called for test patching."""
    |                                                                                         ^^ E501
714 |         self.reject()
    |

desktop_ui\drill_screen_tester.py:5:89: E501 Line too long (92 > 88)
  |
3 | ---------------------
4 | A minimal PySide6 UI for selecting between snippet-based or manual text input.
5 | - If 'Snippet Selection' is chosen: shows a dropdown of snippets and start/end index fields.
  |                                                                                         ^^^^ E501
6 | - If 'Manual Input' is chosen: shows a text box for manual entry.
7 | - A preview panel always shows the current text (subset or manual).
  |

desktop_ui\drill_screen_tester.py:20:1: E402 Module level import not at top of file
   |
18 |     sys.path.insert(0, project_root)
19 |
20 | import sys
   | ^^^^^^^^^^ E402
21 |
22 | from PySide6 import QtWidgets
   |

desktop_ui\drill_screen_tester.py:22:1: E402 Module level import not at top of file
   |
20 | import sys
21 |
22 | from PySide6 import QtWidgets
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
23 |
24 | # Dummy snippet data for demonstration
   |

desktop_ui\drill_screen_tester.py:161:89: E501 Line too long (89 > 88)
    |
159 |             print("Attempting to import from desktop_ui.typing_drill...")
160 |             from desktop_ui.typing_drill import TypingDrillScreen
161 |             print("Successfully imported TypingDrillScreen from desktop_ui.typing_drill")
    |                                                                                         ^ E501
162 |         except ModuleNotFoundError as e:
163 |             print(f"ModuleNotFoundError: {e}")
    |

desktop_ui\drill_screen_tester.py:180:89: E501 Line too long (90 > 88)
    |
178 |                 snippet_end = 0
179 |                 text = self.manual_text.toPlainText()
180 |                 print(f"Using manual text, length: {len(text)}, snippet_id: {snippet_id}")
    |                                                                                         ^^ E501
181 |             else:
182 |                 idx = self.snippet_combo.currentIndex()
    |

desktop_ui\drill_screen_tester.py:197:89: E501 Line too long (91 > 88)
    |
195 |                     snippet_end = len(snippet["content"])
196 |                 snippet_start = max(0, min(snippet_start, len(snippet["content"])))
197 |                 snippet_end = max(snippet_start, min(snippet_end, len(snippet["content"])))
    |                                                                                         ^^^ E501
198 |                 text = snippet["content"][snippet_start:snippet_end]
199 |                 print(f"Using snippet ID: {snippet_id}, start: {snippet_start}, end: {snippet_end}")
    |

desktop_ui\drill_screen_tester.py:199:89: E501 Line too long (100 > 88)
    |
197 |                 snippet_end = max(snippet_start, min(snippet_end, len(snippet["content"])))
198 |                 text = snippet["content"][snippet_start:snippet_end]
199 |                 print(f"Using snippet ID: {snippet_id}, start: {snippet_start}, end: {snippet_end}")
    |                                                                                         ^^^^^^^^^^^^ E501
200 |                 print(f"Content length: {len(text)}")
    |

desktop_ui\dynamic_config.py:85:89: E501 Line too long (97 > 88)
   |
83 |                     self.current_user = self.user_manager.get_user_by_id(user_id)
84 |                 if keyboard_id:
85 |                     self.current_keyboard = self.keyboard_manager.get_keyboard_by_id(keyboard_id)
   |                                                                                         ^^^^^^^^^ E501
86 |             except Exception as e:
87 |                 # Log the error but continue - status bar will show limited info
   |

desktop_ui\dynamic_config.py:92:89: E501 Line too long (92 > 88)
   |
90 |         self.setWindowTitle("Practice Weak Points")
91 |         self.setMinimumSize(700, 600)
92 |         self.setWindowFlags(self.windowFlags() & ~Qt.WindowType.WindowContextHelpButtonHint)
   |                                                                                         ^^^^ E501
93 |
94 |         self._setup_ui()
   |

desktop_ui\dynamic_config.py:108:89: E501 Line too long (93 > 88)
    |
106 |         if self.current_user:
107 |             # Use first_name and surname instead of username
108 |             user_name = f"{self.current_user.first_name} {self.current_user.surname}".strip()
    |                                                                                         ^^^^^ E501
109 |             user_display = f"User: {user_name or self.current_user.user_id}"
110 |             status_text += user_display
    |

desktop_ui\dynamic_config.py:117:89: E501 Line too long (100 > 88)
    |
115 |             if status_text:
116 |                 status_text += " | "
117 |             keyboard_name = self.current_keyboard.keyboard_name or self.current_keyboard.keyboard_id
    |                                                                                         ^^^^^^^^^^^^ E501
118 |             keyboard_display = f"Keyboard: {keyboard_name}"
119 |             status_text += keyboard_display
    |

desktop_ui\dynamic_config.py:213:89: E501 Line too long (104 > 88)
    |
211 |         analysis_layout = QtWidgets.QVBoxLayout(analysis_group)
212 |
213 |         # Will initially create with 5 rows, but columns and headers will be set in _load_ngram_analysis
    |                                                                                         ^^^^^^^^^^^^^^^^ E501
214 |         # 5 rows, up to 4 columns for speed focus
215 |         self.ngram_table = QtWidgets.QTableWidget(5, 4)
    |

desktop_ui\dynamic_config.py:230:89: E501 Line too long (97 > 88)
    |
228 |         self.content_preview = QtWidgets.QTextEdit()
229 |         self.content_preview.setReadOnly(True)
230 |         self.content_preview.setPlaceholderText("Generated practice content will appear here...")
    |                                                                                         ^^^^^^^^^ E501
231 |
232 |         # Button box
    |

desktop_ui\dynamic_config.py:241:89: E501 Line too long (89 > 88)
    |
240 |         # Set OK button text to "Start Drill"
241 |         start_drill_btn = button_box.button(QtWidgets.QDialogButtonBox.StandardButton.Ok)
    |                                                                                         ^ E501
242 |         start_drill_btn.setText("Start Drill")
243 |         start_drill_btn.setEnabled(False)  # Disabled until content is generated
    |

desktop_ui\dynamic_config.py:259:89: E501 Line too long (94 > 88)
    |
258 |         selected_size = self.ngram_size.currentText()
259 |         # If "All" is selected, use a list of sizes from 2-10, otherwise use the selected size
    |                                                                                         ^^^^^^ E501
260 |         if selected_size == "All":
261 |             ngram_sizes = list(range(2, 11))
    |

desktop_ui\dynamic_config.py:299:89: E501 Line too long (93 > 88)
    |
297 |                 self.ngram_table.setRowCount(len(ngram_stats))
298 |                 for row, stats in enumerate(ngram_stats):
299 |                     self.ngram_table.setItem(row, 0, QtWidgets.QTableWidgetItem(stats.ngram))
    |                                                                                         ^^^^^ E501
300 |                     self.ngram_table.setItem(
301 |                         row, 1, QtWidgets.QTableWidgetItem(f"{stats.avg_speed:.2f}")
    |

desktop_ui\dynamic_config.py:315:89: E501 Line too long (92 > 88)
    |
313 |                 self.ngram_table.setHorizontalHeaderLabels(["N-gram", "Error Count"])
314 |
315 |                 # Get the specified number of most error-prone n-grams of the specified size
    |                                                                                         ^^^^ E501
316 |                 ngram_stats = self.ngram_manager.error_n(
317 |                     n=top_n,  # Get top N
    |

desktop_ui\dynamic_config.py:327:89: E501 Line too long (92 > 88)
    |
325 |                 size_info = "various sizes" if selected_size == "All" else selected_size
326 |                 print(
327 |                     f"Retrieved {len(ngram_stats)} error-prone n-grams of size {size_info} "
    |                                                                                         ^^^^ E501
328 |                     f"(requested {top_n})"
329 |                 )
    |

desktop_ui\dynamic_config.py:334:89: E501 Line too long (93 > 88)
    |
332 |                 self.ngram_table.setRowCount(len(ngram_stats))
333 |                 for row, stats in enumerate(ngram_stats):
334 |                     self.ngram_table.setItem(row, 0, QtWidgets.QTableWidgetItem(stats.ngram))
    |                                                                                         ^^^^^ E501
335 |                     self.ngram_table.setItem(
336 |                         row, 1, QtWidgets.QTableWidgetItem(f"{stats.total_occurrences}")
    |

desktop_ui\dynamic_config.py:345:89: E501 Line too long (100 > 88)
    |
343 |             print(f"Error in _load_ngram_analysis: {error_details}")
344 |             QtWidgets.QMessageBox.warning(
345 |                 self, "Error Loading N-grams", f"Could not load n-gram analysis.\n\nError: {str(e)}"
    |                                                                                         ^^^^^^^^^^^^ E501
346 |             )
    |

desktop_ui\dynamic_config.py:437:89: E501 Line too long (91 > 88)
    |
435 |             button_box = self.findChild(QtWidgets.QDialogButtonBox)
436 |             if button_box:
437 |                 start_btn = button_box.button(QtWidgets.QDialogButtonBox.StandardButton.Ok)
    |                                                                                         ^^^ E501
438 |                 if start_btn:
439 |                     start_btn.setEnabled(True)
    |

desktop_ui\dynamic_config.py:450:89: E501 Line too long (90 > 88)
    |
448 |         except Exception as e:
449 |             QtWidgets.QMessageBox.critical(
450 |                 self, "Generation Error", f"Failed to generate practice content: {str(e)}"
    |                                                                                         ^^ E501
451 |             )
    |

desktop_ui\dynamic_config.py:457:89: E501 Line too long (97 > 88)
    |
455 |         if not self.generated_content.strip():
456 |             QtWidgets.QMessageBox.warning(
457 |                 self, "No Content", "Please generate practice content before starting the drill."
    |                                                                                         ^^^^^^^^^ E501
458 |             )
459 |             return
    |

desktop_ui\dynamic_config.py:523:9: SyntaxError: Expected `except` or `finally` after `try` block
    |
521 |                 snippet = new_snippet
522 |
523 |         try:
    |         ^
524 |             # Launch the typing drill with the new content
525 |             drill = TypingDrillScreen(
    |

desktop_ui\graphql_client.py:14:9: ANN204 Missing return type annotation for special method `__init__`
   |
13 | class GraphQLClient:
14 |     def __init__(self, api_url: str = API_URL):
   |         ^^^^^^^^ ANN204
15 |         self.api_url = api_url
   |
   = help: Add return type annotation: `None`

desktop_ui\library_main.py:24:5: F401 [*] `PySide6.QtWidgets.QSizePolicy` imported but unused
   |
22 |     QMessageBox,
23 |     QPushButton,
24 |     QSizePolicy,
   |     ^^^^^^^^^^^ F401
25 |     QSplitter,
26 |     QVBoxLayout,
   |
   = help: Remove unused import: `PySide6.QtWidgets.QSizePolicy`

desktop_ui\library_main.py:64:89: E501 Line too long (96 > 88)
   |
62 |             self.db_manager = db_manager
63 |         else:
64 |             db_path = os.path.join(os.path.dirname(os.path.dirname(__file__)), "typing_data.db")
   |                                                                                         ^^^^^^^^ E501
65 |             self.db_manager = DatabaseManager(db_path)
66 |         self.category_manager = CategoryManager(self.db_manager)
   |

desktop_ui\library_main.py:98:89: E501 Line too long (119 > 88)
    |
 96 |         self.categoryList = QListWidget()
 97 |         self.categoryList.setObjectName("CategoryList")
 98 |         self.categoryList.setSizePolicy(QtWidgets.QSizePolicy.Policy.Expanding, QtWidgets.QSizePolicy.Policy.Expanding)
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
 99 |         cat_layout.addWidget(self.categoryList)
100 |         # Category buttons
    |

desktop_ui\library_main.py:131:89: E501 Line too long (118 > 88)
    |
129 |         self.snippetList = QListWidget()
130 |         self.snippetList.setObjectName("SnippetList")
131 |         self.snippetList.setSizePolicy(QtWidgets.QSizePolicy.Policy.Expanding, QtWidgets.QSizePolicy.Policy.Expanding)
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
132 |         snip_layout.addWidget(self.snippetList)
133 |         # Snippet buttons
    |

desktop_ui\library_main.py:165:89: E501 Line too long (104 > 88)
    |
164 |     def load_data(self) -> None:
165 |         """Load categories and snippets into the UI. Ensures at least one category and snippet exist."""
    |                                                                                         ^^^^^^^^^^^^^^^^ E501
166 |         try:
167 |             self.categories = self.category_manager.list_all_categories()
    |

desktop_ui\library_main.py:216:89: E501 Line too long (110 > 88)
    |
214 |             self.snippetList.clear()
215 |             return
216 |         all_snippets = self.snippet_manager.list_snippets_by_category(str(self.selected_category.category_id))
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^ E501
217 |         filtered = [s for s in all_snippets if search_text.lower() in s.snippet_name.lower()]
218 |         self.snippetList.clear()
    |

desktop_ui\library_main.py:217:89: E501 Line too long (93 > 88)
    |
215 |             return
216 |         all_snippets = self.snippet_manager.list_snippets_by_category(str(self.selected_category.category_id))
217 |         filtered = [s for s in all_snippets if search_text.lower() in s.snippet_name.lower()]
    |                                                                                         ^^^^^ E501
218 |         self.snippetList.clear()
219 |         for snip in filtered:
    |

desktop_ui\library_main.py:312:89: E501 Line too long (95 > 88)
    |
310 |             "Delete Category",
311 |             f"Delete category '{cat.category_name}' and all its snippets?",
312 |             QtWidgets.QMessageBox.StandardButton.Yes | QtWidgets.QMessageBox.StandardButton.No,
    |                                                                                         ^^^^^^^ E501
313 |         )
314 |         if confirm != QtWidgets.QMessageBox.StandardButton.Yes:
    |

desktop_ui\library_main.py:381:89: E501 Line too long (95 > 88)
    |
379 |             "Delete Snippet",
380 |             f"Delete snippet '{snippet.snippet_name}'?",
381 |             QtWidgets.QMessageBox.StandardButton.Yes | QtWidgets.QMessageBox.StandardButton.No,
    |                                                                                         ^^^^^^^ E501
382 |         )
383 |         if confirm != QtWidgets.QMessageBox.StandardButton.Yes:
    |

desktop_ui\main_menu.py:9:1: I001 [*] Import block is un-sorted or un-formatted
   |
 7 |   sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), "..")))
 8 |
 9 | / from PySide6 import QtCore, QtWidgets
10 | |
11 | | from db.database_manager import DatabaseManager, ConnectionType
12 | | from desktop_ui.users_and_keyboards import UsersAndKeyboards
13 | | from models.keyboard import Keyboard
14 | | from models.keyboard_manager import KeyboardManager
15 | | from models.setting import Setting
16 | | from models.setting_manager import SettingManager
17 | | from models.user import User
18 | | from models.user_manager import UserManager
   | |___________________________________________^ I001
19 |
20 |   warnings.filterwarnings("ignore", message="sipPyTypeDict() is deprecated")
   |
   = help: Organize imports

desktop_ui\main_menu.py:33:89: E501 Line too long (136 > 88)
   |
31 | ΓÇª
32 | ΓÇª
33 | ΓÇªing_mode: bool = False, connection_type: ConnectionType = ConnectionType.CLOUD) -> None:
   |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
34 | ΓÇª
35 | ΓÇª
   |

desktop_ui\main_menu.py:39:89: E501 Line too long (96 > 88)
   |
37 |         self.testing_mode = testing_mode
38 |         if db_path is None:
39 |             db_path = os.path.join(os.path.dirname(os.path.dirname(__file__)), "typing_data.db")
   |                                                                                         ^^^^^^^^ E501
40 |         self.db_manager = DatabaseManager(db_path, connection_type=connection_type)
41 |         self.db_manager.init_tables()  # Ensure all tables are created/initialized
   |

desktop_ui\main_menu.py:107:89: E501 Line too long (93 > 88)
    |
105 |         if normal:
106 |             return (
107 |                 "QPushButton { background-color: #0d6efd; color: white; border-radius: 5px; "
    |                                                                                         ^^^^^ E501
108 |                 "font-size: 14px; }"
109 |                 "QPushButton:pressed { background-color: #0b5ed7; }"
    |

desktop_ui\main_menu.py:113:89: E501 Line too long (93 > 88)
    |
111 |         else:
112 |             return (
113 |                 "QPushButton { background-color: #f0f0f0; color: black; border-radius: 5px; "
    |                                                                                         ^^^^^ E501
114 |                 "font-size: 14px; }"
115 |             )
    |

desktop_ui\main_menu.py:176:89: E501 Line too long (89 > 88)
    |
174 |             users = self.user_manager.list_all_users()
175 |             for user in users:
176 |                 display_text = f"{user.first_name} {user.surname} ({user.email_address})"
    |                                                                                         ^ E501
177 |                 self.user_combo.addItem(display_text, user)
    |

desktop_ui\main_menu.py:184:89: E501 Line too long (98 > 88)
    |
182 |             else:
183 |                 QtWidgets.QMessageBox.warning(
184 |                     self, "No Users Found", "Please create a user before starting a typing drill."
    |                                                                                         ^^^^^^^^^^ E501
185 |                 )
186 |         except Exception as e:
    |

desktop_ui\main_menu.py:228:89: E501 Line too long (93 > 88)
    |
227 |                 this_setting = Setting(
228 |                     setting_type_id="LSTKBD", setting_value=kbd_id, related_entity_id=user_id
    |                                                                                         ^^^^^ E501
229 |                 )
230 |                 self.setting_manager.save_setting(this_setting)
    |

desktop_ui\main_menu.py:236:89: E501 Line too long (94 > 88)
    |
235 |     def _load_last_used_keyboard(self) -> None:
236 |         """Load the last used keyboard for the selected user using SettingManager (LSTKBD)."""
    |                                                                                         ^^^^^^ E501
237 |         from models.setting_manager import SettingNotFound
    |

desktop_ui\main_menu.py:243:89: E501 Line too long (96 > 88)
    |
241 |         try:
242 |             # related_entity_id is user_id, value is keyboard_id
243 |             setting = self.setting_manager.get_setting("LSTKBD", str(self.current_user.user_id))
    |                                                                                         ^^^^^^^^ E501
244 |             last_kbd_id = setting.setting_value
245 |             # Try to find this keyboard in the combo
    |

desktop_ui\main_menu.py:263:89: E501 Line too long (94 > 88)
    |
262 |     def _load_keyboards_for_user(self, user_id: str) -> None:
263 |         """Load keyboards for the selected user and select last used keyboard if available."""
    |                                                                                         ^^^^^^ E501
264 |         self.keyboard_combo.clear()
265 |         self.current_keyboard = None
    |

desktop_ui\main_menu.py:278:89: E501 Line too long (93 > 88)
    |
276 |                     self,
277 |                     "No Keyboards Found",
278 |                     "Please create a keyboard for this user before starting a typing drill.",
    |                                                                                         ^^^^^ E501
279 |                 )
280 |             else:
    |

desktop_ui\main_menu.py:295:89: E501 Line too long (96 > 88)
    |
293 |         if not self.current_user or not self.current_user.user_id:
294 |             QtWidgets.QMessageBox.warning(
295 |                 self, "No User Selected", "Please select a user before starting a typing drill."
    |                                                                                         ^^^^^^^^ E501
296 |             )
297 |             return
    |

desktop_ui\main_menu.py:298:89: E501 Line too long (89 > 88)
    |
296 |             )
297 |             return
298 |         if not self.keyboard_combo.isEnabled() or self.keyboard_combo.currentIndex() < 0:
    |                                                                                         ^ E501
299 |             QtWidgets.QMessageBox.warning(
300 |                 self,
    |

desktop_ui\main_menu.py:326:89: E501 Line too long (90 > 88)
    |
324 |         if not self.current_user or not self.current_user.user_id:
325 |             QtWidgets.QMessageBox.warning(
326 |                 self, "No User Selected", "Please select a user before starting practice."
    |                                                                                         ^^ E501
327 |             )
328 |             return
    |

desktop_ui\main_menu.py:329:89: E501 Line too long (89 > 88)
    |
327 |             )
328 |             return
329 |         if not self.keyboard_combo.isEnabled() or self.keyboard_combo.currentIndex() < 0:
    |                                                                                         ^ E501
330 |             QtWidgets.QMessageBox.warning(
331 |                 self, "No Keyboard Selected", "Please select a keyboard before starting practice."
    |

desktop_ui\main_menu.py:331:89: E501 Line too long (98 > 88)
    |
329 |         if not self.keyboard_combo.isEnabled() or self.keyboard_combo.currentIndex() < 0:
330 |             QtWidgets.QMessageBox.warning(
331 |                 self, "No Keyboard Selected", "Please select a keyboard before starting practice."
    |                                                                                         ^^^^^^^^^^ E501
332 |             )
333 |             return
    |

desktop_ui\main_menu.py:337:89: E501 Line too long (98 > 88)
    |
335 |         if not self.current_keyboard or not self.current_keyboard.keyboard_id:
336 |             QtWidgets.QMessageBox.warning(
337 |                 self, "No Keyboard Selected", "Please select a keyboard before starting practice."
    |                                                                                         ^^^^^^^^^^ E501
338 |             )
339 |             return
    |

desktop_ui\main_menu.py:352:89: E501 Line too long (93 > 88)
    |
350 |         except Exception as e:
351 |             QtWidgets.QMessageBox.critical(
352 |                 self, "Error", f"Could not open Practice Weak Points configuration: {str(e)}"
    |                                                                                         ^^^^^ E501
353 |             )
    |

desktop_ui\main_menu.py:379:89: E501 Line too long (95 > 88)
    |
377 |             "Reset Session Details",
378 |             "This will remove all session details - are you sure?",
379 |             QtWidgets.QMessageBox.StandardButton.Yes | QtWidgets.QMessageBox.StandardButton.No,
    |                                                                                         ^^^^^^^ E501
380 |             QtWidgets.QMessageBox.StandardButton.No,  # Default is No
381 |         )
    |

desktop_ui\main_menu.py:401:89: E501 Line too long (89 > 88)
    |
399 |         except Exception as e:
400 |             QtWidgets.QMessageBox.critical(
401 |                 self, "Error", f"An error occurred while removing session data: {str(e)}"
    |                                                                                         ^ E501
402 |             )
    |

desktop_ui\main_menu.py:443:89: E501 Line too long (97 > 88)
    |
442 |             dialog = QueryScreen(
443 |                 db_manager=self.db_manager, user_id=user_id, keyboard_id=keyboard_id, parent=self
    |                                                                                         ^^^^^^^^^ E501
444 |             )
445 |             dialog.exec()
    |

desktop_ui\main_menu.py:452:89: E501 Line too long (89 > 88)
    |
450 |         except Exception as e:
451 |             QtWidgets.QMessageBox.critical(
452 |                 self, "SQL Query Error", f"Could not open the SQL Query Screen: {str(e)}"
    |                                                                                         ^ E501
453 |             )
    |

desktop_ui\main_menu.py:456:89: E501 Line too long (95 > 88)
    |
455 |     def manage_users_keyboards(self) -> None:
456 |         """Open the Users and Keyboards management dialog and refresh dropdowns when closed."""
    |                                                                                         ^^^^^^^ E501
457 |         try:
458 |             dialog = UsersAndKeyboards(db_manager=self.db_manager, parent=self)
    |

desktop_ui\modern_dialogs.py:134:89: E501 Line too long (92 > 88)
    |
132 |     }
133 |     QPushButton {
134 |         background: qlineargradient(x1:0, y1:0, x2:0, y2:1, stop:0 #e8e8ef, stop:1 #d1d1e0);
    |                                                                                         ^^^^ E501
135 |         border-radius: 10px;
136 |         border: 1px solid #bfc8d6;
    |

desktop_ui\ngram_llm_screen.py:22:32: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `parent`
   |
21 | class NgramLLMScreen(QWidget):
22 |     def __init__(self, parent: Optional[Any] = None) -> None:
   |                                ^^^^^^^^^^^^^ ANN401
23 |         super().__init__(parent)
24 |         self.setWindowTitle("LLM N-Gram Word Generator")
   |

desktop_ui\query_screen.py:4:89: E501 Line too long (96 > 88)
  |
2 | SQL Query Screen for AI Typing Trainer (PySide6)
3 |
4 | This module provides a GUI for executing custom SQL queries on the database and viewing results.
  |                                                                                         ^^^^^^^^ E501
5 | """
  |

desktop_ui\query_screen.py:7:1: I001 [*] Import block is un-sorted or un-formatted
   |
 5 |   """
 6 |
 7 | / from typing import Any, Dict, List, Optional
 8 | |
 9 | | from PySide6 import QtWidgets
10 | | from PySide6.QtWidgets import (
11 | |     QDialog,
12 | |     QGridLayout,
13 | |     QHBoxLayout,
14 | |     QHeaderView,
15 | |     QLabel,
16 | |     QLineEdit,
17 | |     QMessageBox,
18 | |     QPushButton,
19 | |     QPlainTextEdit,
20 | |     QTableWidget,
21 | |     QTableWidgetItem,
22 | |     QVBoxLayout,
23 | | )
24 | |
25 | | from db.database_manager import DatabaseManager
   | |_______________________________________________^ I001
   |
   = help: Organize imports

desktop_ui\query_screen.py:110:89: E501 Line too long (99 > 88)
    |
109 |         self.results_table = QTableWidget()
110 |         self.results_table.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers)  # Read-only
    |                                                                                         ^^^^^^^^^^^ E501
111 |
112 |         # Set horizontal header to stretch
    |

desktop_ui\query_screen.py:138:89: E501 Line too long (94 > 88)
    |
137 |             if not results:
138 |                 self.status_label.setText("Query executed successfully. No results returned.")
    |                                                                                         ^^^^^^ E501
139 |                 self.results_table.setRowCount(0)
140 |                 self.results_table.setColumnCount(0)
    |

desktop_ui\query_screen.py:145:89: E501 Line too long (100 > 88)
    |
143 |             # Process results
144 |             self._populate_results_table(results)
145 |             self.status_label.setText(f"Query executed successfully. {len(results)} rows returned.")
    |                                                                                         ^^^^^^^^^^^^ E501
146 |
147 |         except Exception as e:
    |

desktop_ui\snippet_model_tester.py:4:89: E501 Line too long (111 > 88)
  |
2 | Snippet Model Tester UI
3 | ----------------------
4 | A simple PySide6-based desktop UI for directly testing the Snippet object model (SnippetModel, SnippetManager).
  |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^ E501
5 |
6 | - List all snippets (optionally filter by category)
  |

desktop_ui\snippet_model_tester.py:12:89: E501 Line too long (107 > 88)
   |
10 | - Show validation and error messages
11 |
12 | Bypasses API and service layers; interacts directly with SnippetManager, SnippetModel, and CategoryManager.
   |                                                                                         ^^^^^^^^^^^^^^^^^^^ E501
13 |
14 | Author: Cascade AI
   |

desktop_ui\snippet_model_tester.py:119:89: E501 Line too long (147 > 88)
    |
117 | ΓÇª
118 | ΓÇª
119 | ΓÇªtegory_id}] {snip.snippet_name} - {snip.content[:40]}{'...' if len(snip.content)>40 else ''}"
    |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
120 | ΓÇª
121 | ΓÇª
    |

desktop_ui\snippet_scaffold.py:20:41: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `snippet_manager`
   |
18 |     """
19 |
20 |     def __init__(self, snippet_manager: Any) -> None:
   |                                         ^^^ ANN401
21 |         super().__init__()
22 |         self.snippet_manager = snippet_manager
   |

desktop_ui\snippet_scaffold.py:105:89: E501 Line too long (93 > 88)
    |
103 |         # Display a status message while loading
104 |         self.snippet_list.addItem("Loading snippets...")
105 |         QtWidgets.QApplication.processEvents()  # Process events to update the UI immediately
    |                                                                                         ^^^^^ E501
106 |
107 |         # For demo: use category_id=1
    |

desktop_ui\splash.py:48:24: ANN001 Missing type annotation for function argument `graphql`
   |
46 |     """
47 |
48 |     def __init__(self, graphql=None, config: Optional[SplashConfig] = None) -> None:
   |                        ^^^^^^^ ANN001
49 |         super().__init__()
50 |         self.setWindowTitle("AI Typing Trainer")
   |

desktop_ui\splash.py:97:89: E501 Line too long (89 > 88)
   |
95 |         else:
96 |             # Real mode: use APIServerManager and GraphQLClient
97 |             # Use the class-level server manager if it exists, otherwise create a new one
   |                                                                                         ^ E501
98 |             if SplashScreen._api_server_manager is None:
99 |                 SplashScreen._api_server_manager = APIServerManager()
   |

desktop_ui\splash.py:143:89: E501 Line too long (89 > 88)
    |
141 |             if self.api_server_manager and not self.graphql:
142 |                 self.status_label.setText("Restarting GraphQL server...")
143 |                 self.api_server_manager.shutdown_server()  # Shutdown any failed instance
    |                                                                                         ^ E501
144 |                 started = self.api_server_manager.start_server()
145 |                 if started:
    |

desktop_ui\splash.py:156:30: F821 Undefined name `GraphQLServerThread`
    |
154 |     def _start_graphql_server(self) -> None:
155 |         self.status_label.setText("Starting up GraphQL")
156 |         self.server_thread = GraphQLServerThread()
    |                              ^^^^^^^^^^^^^^^^^^^ F821
157 |         self.server_thread.started_signal.connect(self._poll_graphql)
158 |         self.server_thread.start()
    |

desktop_ui\splash.py:183:89: E501 Line too long (118 > 88)
    |
181 |     def check_graphql_and_show_count(self) -> None:
182 |         """
183 |         Checks if GraphQL is running; if not, updates status. If running, fetches snippet count and shows message box.
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
184 |         """
185 |         count = 0
    |

desktop_ui\users_and_keyboards.py:41:89: E501 Line too long (94 > 88)
   |
39 |     """
40 |
41 |     def __init__(self, db_manager: DatabaseManager, parent: Optional[QWidget] = None) -> None:
   |                                                                                         ^^^^^^ E501
42 |         """
43 |         Initialize the Users and Keyboards dialog.
   |

desktop_ui\users_and_keyboards.py:144:89: E501 Line too long (98 > 88)
    |
142 |             users = self.user_manager.list_all_users()
143 |             for user in users:
144 |                 item = QListWidgetItem(f"{user.first_name} {user.surname} ({user.email_address})")
    |                                                                                         ^^^^^^^^^^ E501
145 |                 item.setData(Qt.ItemDataRole.UserRole, user.user_id)
146 |                 self.users_list.addItem(item)
    |

desktop_ui\users_and_keyboards.py:192:89: E501 Line too long (93 > 88)
    |
190 |             keyboard_id = selected_items[0].data(Qt.ItemDataRole.UserRole)
191 |             try:
192 |                 self.current_keyboard = self.keyboard_manager.get_keyboard_by_id(keyboard_id)
    |                                                                                         ^^^^^ E501
193 |             except KeyboardNotFound:
194 |                 QMessageBox.warning(self, "Not Found", "Selected keyboard not found.")
    |

desktop_ui\users_and_keyboards.py:305:89: E501 Line too long (91 > 88)
    |
303 |                 QMessageBox.warning(self, "Validation Error", str(e))
304 |             except Exception as e:
305 |                 QMessageBox.critical(self, "Error", f"Failed to update keyboard: {str(e)}")
    |                                                                                         ^^^ E501
306 |
307 |     def on_user_double_clicked(self, item: QListWidgetItem) -> None:
    |

desktop_ui\users_and_keyboards.py:338:89: E501 Line too long (91 > 88)
    |
336 |                 self.update_button_states()
337 |             except Exception as e:
338 |                 QMessageBox.critical(self, "Error", f"Failed to delete keyboard: {str(e)}")
    |                                                                                         ^^^ E501
    |

Found 126 errors.
[*] 4 fixable with the `--fix` option (2 hidden fixes can be enabled with the `--unsafe-fixes` option).
api\category_api.py:1:1: I001 [*] Import block is un-sorted or un-formatted
  |
1 | / from typing import Dict, List, Tuple, Union, Any
2 | |
3 | | from flask import Blueprint, jsonify, request, Response
4 | | from pydantic import BaseModel, ValidationError
5 | |
6 | | from db.database_manager import DatabaseManager
7 | | from models.category import CategoryManager
  | |___________________________________________^ I001
  |
  = help: Organize imports

api\category_api.py:1:20: F401 [*] `typing.Dict` imported but unused
  |
1 | from typing import Dict, List, Tuple, Union, Any
  |                    ^^^^ F401
2 |
3 | from flask import Blueprint, jsonify, request, Response
  |
  = help: Remove unused import

api\category_api.py:1:26: F401 [*] `typing.List` imported but unused
  |
1 | from typing import Dict, List, Tuple, Union, Any
  |                          ^^^^ F401
2 |
3 | from flask import Blueprint, jsonify, request, Response
  |
  = help: Remove unused import

api\category_api.py:1:46: F401 [*] `typing.Any` imported but unused
  |
1 | from typing import Dict, List, Tuple, Union, Any
  |                                              ^^^ F401
2 |
3 | from flask import Blueprint, jsonify, request, Response
  |
  = help: Remove unused import

api\category_graphql.py:45:41: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `_info`
   |
43 |     category = Field(CategoryType, category_id=Int(name="categoryId", required=True))
44 |
45 |     def resolve_categories(self, _info: Any) -> TypedList[Category]:
   |                                         ^^^ ANN401
46 |         """
47 |         Resolve all categories.
   |

api\category_graphql.py:57:39: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `_info`
   |
55 |         return CategoryManager.list_categories()
56 |
57 |     def resolve_category(self, _info: Any, category_id: int) -> Optional[Category]:
   |                                       ^^^ ANN401
58 |         """
59 |         Resolve a specific category by ID.
   |

api\category_graphql.py:85:29: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `_info`
   |
83 |     category = Field(lambda: CategoryType)
84 |
85 |     def mutate(self, _info: Any, category_name: str) -> "CreateCategory":
   |                             ^^^ ANN401
86 |         """
87 |         Create a new category with the provided name.
   |

api\category_graphql.py:105:13: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
    |
103 |         except (CategoryValidationError, ValueError) as e:
104 |             # Graphene will convert this to a proper GraphQL error
105 |             raise Exception(str(e))
    |             ^^^^^^^^^^^^^^^^^^^^^^^ B904
    |

api\category_graphql.py:121:22: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `_info`
    |
120 |     def mutate(
121 |         self, _info: Any, category_id: int, category_name: str
    |                      ^^^ ANN401
122 |     ) -> "UpdateCategory":
123 |         """
    |

api\category_graphql.py:143:13: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
    |
141 |         except (CategoryValidationError, CategoryNotFound, ValueError) as e:
142 |             # Graphene will convert this to a proper GraphQL error
143 |             raise Exception(str(e))
    |             ^^^^^^^^^^^^^^^^^^^^^^^ B904
    |

api\category_graphql.py:157:29: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `_info`
    |
155 |     ok = Boolean()
156 |
157 |     def mutate(self, _info: Any, category_id: int) -> "DeleteCategory":
    |                             ^^^ ANN401
158 |         """
159 |         Delete a category by ID.
    |

api\category_graphql.py:177:13: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
    |
175 |         except CategoryNotFound as e:
176 |             # Graphene will convert this to a proper GraphQL error
177 |             raise Exception(str(e))
    |             ^^^^^^^^^^^^^^^^^^^^^^^ B904
    |

api\dbviewer_api.py:34:5: ANN201 Missing return type annotation for public function `list_tables`
   |
33 | @dbviewer_api.route("/tables", methods=["GET"])
34 | def list_tables():
   |     ^^^^^^^^^^^ ANN201
35 |     """List all available database tables."""
36 |     try:
   |
   = help: Add return type annotation

api\dbviewer_api.py:52:5: ANN201 Missing return type annotation for public function `get_table_data`
   |
51 | @dbviewer_api.route("/table", methods=["GET"])
52 | def get_table_data():
   |     ^^^^^^^^^^^^^^ ANN201
53 |     """Get table data with pagination, sorting, and filtering.
   |
   = help: Add return type annotation

api\dbviewer_api.py:101:5: ANN201 Missing return type annotation for public function `export_table_to_csv`
    |
100 | @dbviewer_api.route("/export", methods=["GET"])
101 | def export_table_to_csv():
    |     ^^^^^^^^^^^^^^^^^^^ ANN201
102 |     """Export table data to CSV format.
    |
    = help: Add return type annotation

api\keystroke_api.py:8:1: E402 Module level import not at top of file
  |
6 | keystroke_api = Blueprint("keystroke_api", __name__)
7 |
8 | from typing import Optional
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
  |

api\keystroke_api.py:22:5: ANN201 Missing return type annotation for public function `api_record_keystroke`
   |
21 | @keystroke_api.route("/api/keystrokes", methods=["POST"])
22 | def api_record_keystroke():
   |     ^^^^^^^^^^^^^^^^^^^^ ANN201
23 |     import sys
   |
   = help: Add return type annotation

api\keystroke_api.py:54:89: E501 Line too long (92 > 88)
   |
52 |         exc_type, exc_value, _ = sys.exc_info()
53 |         print(
54 |             f"DEBUG: Keystroke save failed. Exception type: {exc_type}, value: {exc_value}",
   |                                                                                         ^^^^ E501
55 |             file=sys.stderr,
56 |         )
   |

api\keystroke_api.py:61:89: E501 Line too long (100 > 88)
   |
59 |                 jsonify(
60 |                     {
61 |                         "error": "Duplicate keystroke_id for session or unique constraint violation"
   |                                                                                         ^^^^^^^^^^^^ E501
62 |                     }
63 |                 ),
   |

api\keystroke_api.py:71:5: ANN201 Missing return type annotation for public function `api_list_keystrokes`
   |
70 | @keystroke_api.route("/api/keystrokes", methods=["GET"])
71 | def api_list_keystrokes():
   |     ^^^^^^^^^^^^^^^^^^^ ANN201
72 |     session_id = request.args.get("session_id")
73 |     if not session_id:
   |
   = help: Add return type annotation

api\library_graphql.py:18:5: ANN201 Missing return type annotation for public function `get_library_manager`
   |
18 | def get_library_manager():
   |     ^^^^^^^^^^^^^^^^^^^ ANN201
19 |     # Dependency injection for testability
20 |     db_manager = getattr(g, "db_manager", None)
   |
   = help: Add return type annotation

api\library_graphql.py:52:9: ANN201 Missing return type annotation for public function `resolve_categories`
   |
50 |     snippet_parts = List(SnippetPartType, snippet_id=Int(required=True))
51 |
52 |     def resolve_categories(self, info):
   |         ^^^^^^^^^^^^^^^^^^ ANN201
53 |         mgr = get_library_manager()
54 |         return mgr.list_categories()
   |
   = help: Add return type annotation

api\library_graphql.py:52:34: ANN001 Missing type annotation for function argument `info`
   |
50 |     snippet_parts = List(SnippetPartType, snippet_id=Int(required=True))
51 |
52 |     def resolve_categories(self, info):
   |                                  ^^^^ ANN001
53 |         mgr = get_library_manager()
54 |         return mgr.list_categories()
   |

api\library_graphql.py:56:9: ANN201 Missing return type annotation for public function `resolve_snippets`
   |
54 |         return mgr.list_categories()
55 |
56 |     def resolve_snippets(self, info, category_id):
   |         ^^^^^^^^^^^^^^^^ ANN201
57 |         mgr = get_library_manager()
58 |         return mgr.list_snippets(category_id)
   |
   = help: Add return type annotation

api\library_graphql.py:56:32: ANN001 Missing type annotation for function argument `info`
   |
54 |         return mgr.list_categories()
55 |
56 |     def resolve_snippets(self, info, category_id):
   |                                ^^^^ ANN001
57 |         mgr = get_library_manager()
58 |         return mgr.list_snippets(category_id)
   |

api\library_graphql.py:56:38: ANN001 Missing type annotation for function argument `category_id`
   |
54 |         return mgr.list_categories()
55 |
56 |     def resolve_snippets(self, info, category_id):
   |                                      ^^^^^^^^^^^ ANN001
57 |         mgr = get_library_manager()
58 |         return mgr.list_snippets(category_id)
   |

api\library_graphql.py:60:9: ANN201 Missing return type annotation for public function `resolve_snippet`
   |
58 |         return mgr.list_snippets(category_id)
59 |
60 |     def resolve_snippet(self, info, snippet_id):
   |         ^^^^^^^^^^^^^^^ ANN201
61 |         mgr = get_library_manager()
62 |         snippets = mgr.list_snippets(-1)  # Dummy call to get type
   |
   = help: Add return type annotation

api\library_graphql.py:60:31: ANN001 Missing type annotation for function argument `info`
   |
58 |         return mgr.list_snippets(category_id)
59 |
60 |     def resolve_snippet(self, info, snippet_id):
   |                               ^^^^ ANN001
61 |         mgr = get_library_manager()
62 |         snippets = mgr.list_snippets(-1)  # Dummy call to get type
   |

api\library_graphql.py:60:37: ANN001 Missing type annotation for function argument `snippet_id`
   |
58 |         return mgr.list_snippets(category_id)
59 |
60 |     def resolve_snippet(self, info, snippet_id):
   |                                     ^^^^^^^^^^ ANN001
61 |         mgr = get_library_manager()
62 |         snippets = mgr.list_snippets(-1)  # Dummy call to get type
   |

api\library_graphql.py:68:9: ANN201 Missing return type annotation for public function `resolve_snippet_parts`
   |
66 |         return None
67 |
68 |     def resolve_snippet_parts(self, info, snippet_id):
   |         ^^^^^^^^^^^^^^^^^^^^^ ANN201
69 |         mgr = get_library_manager()
70 |         return mgr.list_parts(snippet_id)
   |
   = help: Add return type annotation

api\library_graphql.py:68:37: ANN001 Missing type annotation for function argument `info`
   |
66 |         return None
67 |
68 |     def resolve_snippet_parts(self, info, snippet_id):
   |                                     ^^^^ ANN001
69 |         mgr = get_library_manager()
70 |         return mgr.list_parts(snippet_id)
   |

api\library_graphql.py:68:43: ANN001 Missing type annotation for function argument `snippet_id`
   |
66 |         return None
67 |
68 |     def resolve_snippet_parts(self, info, snippet_id):
   |                                           ^^^^^^^^^^ ANN001
69 |         mgr = get_library_manager()
70 |         return mgr.list_parts(snippet_id)
   |

api\library_graphql.py:82:9: ANN201 Missing return type annotation for public function `mutate`
   |
80 |     error = String()
81 |
82 |     def mutate(self, info, category_name):
   |         ^^^^^^ ANN201
83 |         mgr = get_library_manager()
84 |         try:
   |
   = help: Add return type annotation

api\library_graphql.py:82:22: ANN001 Missing type annotation for function argument `info`
   |
80 |     error = String()
81 |
82 |     def mutate(self, info, category_name):
   |                      ^^^^ ANN001
83 |         mgr = get_library_manager()
84 |         try:
   |

api\library_graphql.py:82:28: ANN001 Missing type annotation for function argument `category_name`
   |
80 |     error = String()
81 |
82 |     def mutate(self, info, category_name):
   |                            ^^^^^^^^^^^^^ ANN001
83 |         mgr = get_library_manager()
84 |         try:
   |

api\library_graphql.py:101:9: ANN201 Missing return type annotation for public function `mutate`
    |
 99 |     error = String()
100 |
101 |     def mutate(self, info, category_id, category_name):
    |         ^^^^^^ ANN201
102 |         mgr = get_library_manager()
103 |         try:
    |
    = help: Add return type annotation

api\library_graphql.py:101:22: ANN001 Missing type annotation for function argument `info`
    |
 99 |     error = String()
100 |
101 |     def mutate(self, info, category_id, category_name):
    |                      ^^^^ ANN001
102 |         mgr = get_library_manager()
103 |         try:
    |

api\library_graphql.py:101:28: ANN001 Missing type annotation for function argument `category_id`
    |
 99 |     error = String()
100 |
101 |     def mutate(self, info, category_id, category_name):
    |                            ^^^^^^^^^^^ ANN001
102 |         mgr = get_library_manager()
103 |         try:
    |

api\library_graphql.py:101:41: ANN001 Missing type annotation for function argument `category_name`
    |
 99 |     error = String()
100 |
101 |     def mutate(self, info, category_id, category_name):
    |                                         ^^^^^^^^^^^^^ ANN001
102 |         mgr = get_library_manager()
103 |         try:
    |

api\library_graphql.py:117:9: ANN201 Missing return type annotation for public function `mutate`
    |
115 |     error = String()
116 |
117 |     def mutate(self, info, category_id):
    |         ^^^^^^ ANN201
118 |         mgr = get_library_manager()
119 |         try:
    |
    = help: Add return type annotation

api\library_graphql.py:117:22: ANN001 Missing type annotation for function argument `info`
    |
115 |     error = String()
116 |
117 |     def mutate(self, info, category_id):
    |                      ^^^^ ANN001
118 |         mgr = get_library_manager()
119 |         try:
    |

api\library_graphql.py:117:28: ANN001 Missing type annotation for function argument `category_id`
    |
115 |     error = String()
116 |
117 |     def mutate(self, info, category_id):
    |                            ^^^^^^^^^^^ ANN001
118 |         mgr = get_library_manager()
119 |         try:
    |

api\library_graphql.py:136:9: ANN201 Missing return type annotation for public function `mutate`
    |
134 |     error = String()
135 |
136 |     def mutate(self, info, category_id, snippet_name, content):
    |         ^^^^^^ ANN201
137 |         mgr = get_library_manager()
138 |         try:
    |
    = help: Add return type annotation

api\library_graphql.py:136:22: ANN001 Missing type annotation for function argument `info`
    |
134 |     error = String()
135 |
136 |     def mutate(self, info, category_id, snippet_name, content):
    |                      ^^^^ ANN001
137 |         mgr = get_library_manager()
138 |         try:
    |

api\library_graphql.py:136:28: ANN001 Missing type annotation for function argument `category_id`
    |
134 |     error = String()
135 |
136 |     def mutate(self, info, category_id, snippet_name, content):
    |                            ^^^^^^^^^^^ ANN001
137 |         mgr = get_library_manager()
138 |         try:
    |

api\library_graphql.py:136:41: ANN001 Missing type annotation for function argument `snippet_name`
    |
134 |     error = String()
135 |
136 |     def mutate(self, info, category_id, snippet_name, content):
    |                                         ^^^^^^^^^^^^ ANN001
137 |         mgr = get_library_manager()
138 |         try:
    |

api\library_graphql.py:136:55: ANN001 Missing type annotation for function argument `content`
    |
134 |     error = String()
135 |
136 |     def mutate(self, info, category_id, snippet_name, content):
    |                                                       ^^^^^^^ ANN001
137 |         mgr = get_library_manager()
138 |         try:
    |

api\library_graphql.py:157:9: ANN201 Missing return type annotation for public function `mutate`
    |
155 |     error = String()
156 |
157 |     def mutate(self, info, snippet_id, snippet_name, content, category_id=None):
    |         ^^^^^^ ANN201
158 |         mgr = get_library_manager()
159 |         try:
    |
    = help: Add return type annotation

api\library_graphql.py:157:22: ANN001 Missing type annotation for function argument `info`
    |
155 |     error = String()
156 |
157 |     def mutate(self, info, snippet_id, snippet_name, content, category_id=None):
    |                      ^^^^ ANN001
158 |         mgr = get_library_manager()
159 |         try:
    |

api\library_graphql.py:157:28: ANN001 Missing type annotation for function argument `snippet_id`
    |
155 |     error = String()
156 |
157 |     def mutate(self, info, snippet_id, snippet_name, content, category_id=None):
    |                            ^^^^^^^^^^ ANN001
158 |         mgr = get_library_manager()
159 |         try:
    |

api\library_graphql.py:157:40: ANN001 Missing type annotation for function argument `snippet_name`
    |
155 |     error = String()
156 |
157 |     def mutate(self, info, snippet_id, snippet_name, content, category_id=None):
    |                                        ^^^^^^^^^^^^ ANN001
158 |         mgr = get_library_manager()
159 |         try:
    |

api\library_graphql.py:157:54: ANN001 Missing type annotation for function argument `content`
    |
155 |     error = String()
156 |
157 |     def mutate(self, info, snippet_id, snippet_name, content, category_id=None):
    |                                                      ^^^^^^^ ANN001
158 |         mgr = get_library_manager()
159 |         try:
    |

api\library_graphql.py:157:63: ANN001 Missing type annotation for function argument `category_id`
    |
155 |     error = String()
156 |
157 |     def mutate(self, info, snippet_id, snippet_name, content, category_id=None):
    |                                                               ^^^^^^^^^^^ ANN001
158 |         mgr = get_library_manager()
159 |         try:
    |

api\library_graphql.py:173:9: ANN201 Missing return type annotation for public function `mutate`
    |
171 |     error = String()
172 |
173 |     def mutate(self, info, snippet_id):
    |         ^^^^^^ ANN201
174 |         mgr = get_library_manager()
175 |         try:
    |
    = help: Add return type annotation

api\library_graphql.py:173:22: ANN001 Missing type annotation for function argument `info`
    |
171 |     error = String()
172 |
173 |     def mutate(self, info, snippet_id):
    |                      ^^^^ ANN001
174 |         mgr = get_library_manager()
175 |         try:
    |

api\library_graphql.py:173:28: ANN001 Missing type annotation for function argument `snippet_id`
    |
171 |     error = String()
172 |
173 |     def mutate(self, info, snippet_id):
    |                            ^^^^^^^^^^ ANN001
174 |         mgr = get_library_manager()
175 |         try:
    |

api\library_graphql.py:195:5: ANN201 Missing return type annotation for public function `graphql_api`
    |
194 | @library_graphql.route("/", methods=["POST", "GET"])
195 | def graphql_api():
    |     ^^^^^^^^^^^ ANN201
196 |     data = request.get_json()
197 |     result = schema.execute(
    |
    = help: Add return type annotation

api\run_library_api.py:26:5: ANN201 Missing return type annotation for public function `init_db`
   |
25 | # Initialize database tables on startup
26 | def init_db():
   |     ^^^^^^^ ANN201
27 |     """Initialize database tables"""
28 |     print("Initializing database tables...")
   |
   = help: Add return type annotation: `None`

api\session_api.py:16:5: ANN201 Missing return type annotation for public function `api_create_session`
   |
15 | @session_api.route("/api/sessions", methods=["POST"])
16 | def api_create_session():
   |     ^^^^^^^^^^^^^^^^^^ ANN201
17 |     try:
18 |         data = request.get_json()
   |
   = help: Add return type annotation

api\session_api.py:34:5: ANN201 Missing return type annotation for public function `api_get_session_info`
   |
33 | @session_api.route("/api/session/info", methods=["GET"])
34 | def api_get_session_info():
   |     ^^^^^^^^^^^^^^^^^^^^ ANN201
35 |     """Get last session indices and snippet length for a snippet_id."""
36 |     snippet_id = request.args.get("snippet_id", type=int)
   |
   = help: Add return type annotation

api\session_api.py:44:89: E501 Line too long (96 > 88)
   |
42 |         return make_response(jsonify(info), 200)
43 |     except Exception as e:
44 |         return make_response(jsonify({"error": f"Failed to fetch session info: {str(e)}"}), 500)
   |                                                                                         ^^^^^^^^ E501
   |

api\session_api.py:48:5: ANN201 Missing return type annotation for public function `api_get_session`
   |
47 | @session_api.route("/api/sessions/<session_id>", methods=["GET"])
48 | def api_get_session(session_id):
   |     ^^^^^^^^^^^^^^^ ANN201
49 |     session = Session.get_by_id(session_id)
50 |     if not session:
   |
   = help: Add return type annotation

api\session_api.py:48:21: ANN001 Missing type annotation for function argument `session_id`
   |
47 | @session_api.route("/api/sessions/<session_id>", methods=["GET"])
48 | def api_get_session(session_id):
   |                     ^^^^^^^^^^ ANN001
49 |     session = Session.get_by_id(session_id)
50 |     if not session:
   |

api\session_api.py:56:5: ANN201 Missing return type annotation for public function `api_update_session`
   |
55 | @session_api.route("/api/sessions/<session_id>", methods=["PUT"])
56 | def api_update_session(session_id):
   |     ^^^^^^^^^^^^^^^^^^ ANN201
57 |     session = Session.get_by_id(session_id)
58 |     if not session:
   |
   = help: Add return type annotation

api\session_api.py:56:24: ANN001 Missing type annotation for function argument `session_id`
   |
55 | @session_api.route("/api/sessions/<session_id>", methods=["PUT"])
56 | def api_update_session(session_id):
   |                        ^^^^^^^^^^ ANN001
57 |     session = Session.get_by_id(session_id)
58 |     if not session:
   |

api\session_api.py:76:89: E501 Line too long (97 > 88)
   |
74 |         return make_response(jsonify({"success": True}), 200)
75 |     except Exception as e:
76 |         return make_response(jsonify({"error": f"Invalid input or server error: {str(e)}"}), 400)
   |                                                                                         ^^^^^^^^^ E501
   |

api\snippet_api.py:19:5: ANN201 Missing return type annotation for public function `get_snippet`
   |
18 | @snippet_api.route("/api/snippets/<int:snippet_id>", methods=["GET"])
19 | def get_snippet(snippet_id: int):
   |     ^^^^^^^^^^^ ANN201
20 |     """Get a single snippet by ID.
   |
   = help: Add return type annotation

api\snippet_api.py:50:5: ANN201 Missing return type annotation for public function `api_get_snippets`
   |
49 | @snippet_api.route("/api/snippets", methods=["GET"])
50 | def api_get_snippets():
   |     ^^^^^^^^^^^^^^^^ ANN201
51 |     """Get all snippets for a specific category.
   |
   = help: Add return type annotation

api\snippet_api.py:87:5: ANN201 Missing return type annotation for public function `api_create_practice_snippet`
   |
86 | @snippet_api.route("/api/create-practice-snippet", methods=["POST"])
87 | def api_create_practice_snippet():
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
88 |     """Create a new practice snippet using the PracticeGenerator.
   |
   = help: Add return type annotation

api\snippet_api.py:107:5: ANN201 Missing return type annotation for public function `create_snippet`
    |
106 | @snippet_api.route("/api/snippets", methods=["POST"])
107 | def create_snippet():
    |     ^^^^^^^^^^^^^^ ANN201
108 |     """Create a new snippet.
    |
    = help: Add return type annotation

api\snippet_api.py:134:89: E501 Line too long (97 > 88)
    |
132 |             except (ValueError, TypeError):
133 |                 print(
134 |                     f"ERROR: Invalid category_id type: {type(category_id)}, value: {category_id}"
    |                                                                                         ^^^^^^^^^ E501
135 |                 )
136 |                 return (
    |

api\snippet_api.py:200:5: ANN201 Missing return type annotation for public function `edit_snippet`
    |
199 | @snippet_api.route("/api/snippets/<int:snippet_id>", methods=["PUT"])
200 | def edit_snippet(snippet_id: int):
    |     ^^^^^^^^^^^^ ANN201
201 |     """Update an existing snippet.
    |
    = help: Add return type annotation

api\snippet_api.py:253:5: ANN201 Missing return type annotation for public function `delete_snippet`
    |
252 | @snippet_api.route("/api/snippets/<int:snippet_id>", methods=["DELETE"])
253 | def delete_snippet(snippet_id: int):
    |     ^^^^^^^^^^^^^^ ANN201
254 |     """Delete a snippet by ID.
    |
    = help: Add return type annotation

api\unified_graphql.py:114:22: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `_info`
    |
113 |     def mutate(
114 |         self, _info: Any, category_id: int, snippet_name: str, content: str
    |                      ^^^ ANN401
115 |     ) -> CreateSnippetOutput:
116 |         """Create a new snippet with the provided data."""
    |

api\unified_graphql.py:160:16: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `_info`
    |
158 |     def mutate(
159 |         self,
160 |         _info: Any,
    |                ^^^ ANN401
161 |         snippet_id: int,
162 |         snippet_name: Optional[str] = None,
    |

api\unified_graphql.py:205:29: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `_info`
    |
203 |     Output = DeleteSnippetOutput
204 |
205 |     def mutate(self, _info: Any, snippet_id: int) -> DeleteSnippetOutput:
    |                             ^^^ ANN401
206 |         """Delete a snippet by ID."""
207 |         try:
    |

api\unified_graphql.py:252:29: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `_info`
    |
250 |     Output = CreateCategoryOutput
251 |
252 |     def mutate(self, _info: Any, category_name: str) -> CreateCategoryOutput:
    |                             ^^^ ANN401
253 |         """Create a new category with the provided name."""
254 |         try:
    |

api\unified_graphql.py:291:22: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `_info`
    |
290 |     def mutate(
291 |         self, _info: Any, category_id: int, category_name: str
    |                      ^^^ ANN401
292 |     ) -> UpdateCategoryOutput:
293 |         """Update an existing category with the provided name."""
    |

api\unified_graphql.py:330:29: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `_info`
    |
328 |     Output = DeleteCategoryOutput
329 |
330 |     def mutate(self, _info: Any, category_id: int) -> DeleteCategoryOutput:
    |                             ^^^ ANN401
331 |         """Delete a category by ID."""
332 |         try:
    |

api\unified_graphql.py:362:39: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `_info`
    |
360 |     category = Field(CategoryType, category_id=Int(required=True, name="categoryId"))
361 |
362 |     def resolve_snippets(self, _info: Any, category_id: int) -> TypedList[SnippetModel]:
    |                                       ^^^ ANN401
363 |         """Resolve all snippets for a given category."""
364 |         manager = get_snippet_manager()
    |

api\unified_graphql.py:367:38: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `_info`
    |
365 |         return manager.list_snippets(category_id)
366 |
367 |     def resolve_snippet(self, _info: Any, snippet_id: int) -> Optional[SnippetModel]:
    |                                      ^^^ ANN401
368 |         """Resolve a specific snippet by ID."""
369 |         try:
    |

api\unified_graphql.py:375:41: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `_info`
    |
373 |             return None
374 |
375 |     def resolve_categories(self, _info: Any) -> TypedList[Category]:
    |                                         ^^^ ANN401
376 |         """Resolve all categories."""
377 |         db_manager = get_db_manager()
    |

api\unified_graphql.py:381:39: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `_info`
    |
379 |         return cat_mgr.list_categories()
380 |
381 |     def resolve_category(self, _info: Any, category_id: int) -> Optional[Category]:
    |                                       ^^^ ANN401
382 |         """Resolve a specific category by ID."""
383 |         try:
    |

Found 83 errors.
[*] 4 fixable with the `--fix` option (1 hidden fix can be enabled with the `--unsafe-fixes` option).
tests\db\test_database_exceptions.py:37:89: E501 Line too long (96 > 88)
   |
35 |         with pytest.raises(ForeignKeyError):
36 |             db_with_tables.execute(
37 |                 "INSERT INTO snippets (snippet_id, category_id, snippet_name) VALUES (?, ?, ?)",
   |                                                                                         ^^^^^^^^ E501
38 |                 (1, 999, "test_snippet"),  # category_id 999 doesn't exist
39 |             )
   |

tests\db\test_database_exceptions.py:88:89: E501 Line too long (89 > 88)
   |
86 |         assert not hasattr(db_with_tables, "conn") or db_with_tables.conn is None
87 |
88 |     def test_table_not_found_error_select(self, db_with_tables: DatabaseManager) -> None:
   |                                                                                         ^ E501
89 |         """Test TableNotFoundError is raised for SELECT from a non-existent table."""
90 |         with pytest.raises(TableNotFoundError):
   |

tests\db\test_database_exceptions.py:93:89: E501 Line too long (89 > 88)
   |
91 |             db_with_tables.execute("SELECT * FROM totally_missing_table")
92 |
93 |     def test_table_not_found_error_insert(self, db_with_tables: DatabaseManager) -> None:
   |                                                                                         ^ E501
94 |         """Test TableNotFoundError is raised for INSERT into a non-existent table."""
95 |         with pytest.raises(TableNotFoundError):
   |

tests\db\test_database_exceptions.py:100:89: E501 Line too long (89 > 88)
    |
 98 |             )
 99 |
100 |     def test_table_not_found_error_update(self, db_with_tables: DatabaseManager) -> None:
    |                                                                                         ^ E501
101 |         """Test TableNotFoundError is raised for UPDATE on a non-existent table."""
102 |         with pytest.raises(TableNotFoundError):
    |

tests\db\test_database_exceptions.py:103:89: E501 Line too long (93 > 88)
    |
101 |         """Test TableNotFoundError is raised for UPDATE on a non-existent table."""
102 |         with pytest.raises(TableNotFoundError):
103 |             db_with_tables.execute("UPDATE missing_table SET name=? WHERE id=?", ("test", 1))
    |                                                                                         ^^^^^ E501
104 |
105 |     def test_table_not_found_error_delete(self, db_with_tables: DatabaseManager) -> None:
    |

tests\db\test_database_exceptions.py:105:89: E501 Line too long (89 > 88)
    |
103 |             db_with_tables.execute("UPDATE missing_table SET name=? WHERE id=?", ("test", 1))
104 |
105 |     def test_table_not_found_error_delete(self, db_with_tables: DatabaseManager) -> None:
    |                                                                                         ^ E501
106 |         """Test TableNotFoundError is raised for DELETE from a non-existent table."""
107 |         with pytest.raises(TableNotFoundError):
    |

tests\db\test_database_manager.py:144:89: E501 Line too long (94 > 88)
    |
142 |         # Verify the table was created by querying sqlite_master
143 |         result = db_manager.fetchone(
144 |             "SELECT name FROM sqlite_master WHERE type='table' AND name=?", (TEST_TABLE_NAME,)
    |                                                                                         ^^^^^^ E501
145 |         )
146 |         assert result is not None
    |

tests\db\test_database_manager.py:166:89: E501 Line too long (97 > 88)
    |
164 |         assert result["email"] == "david@example.com"
165 |
166 |     def test_fetchone_returns_none_for_no_results(self, initialized_db: DatabaseManager) -> None:
    |                                                                                         ^^^^^^^^^ E501
167 |         """Test that fetchone returns None when no results are found."""
168 |         result = initialized_db.fetchone(f"SELECT * FROM {TEST_TABLE_NAME} WHERE id = ?", (999,))
    |

tests\db\test_database_manager.py:168:89: E501 Line too long (97 > 88)
    |
166 |     def test_fetchone_returns_none_for_no_results(self, initialized_db: DatabaseManager) -> None:
167 |         """Test that fetchone returns None when no results are found."""
168 |         result = initialized_db.fetchone(f"SELECT * FROM {TEST_TABLE_NAME} WHERE id = ?", (999,))
    |                                                                                         ^^^^^^^^^ E501
169 |         assert result is None
    |

tests\db\test_database_manager.py:171:89: E501 Line too long (89 > 88)
    |
169 |         assert result is None
170 |
171 |     def test_fetchall_returns_all_results(self, initialized_db: DatabaseManager) -> None:
    |                                                                                         ^ E501
172 |         """Test that fetchall returns all matching rows."""
173 |         results = initialized_db.fetchall(f"SELECT * FROM {TEST_TABLE_NAME} ORDER BY id")
    |

tests\db\test_database_manager.py:173:89: E501 Line too long (89 > 88)
    |
171 |     def test_fetchall_returns_all_results(self, initialized_db: DatabaseManager) -> None:
172 |         """Test that fetchall returns all matching rows."""
173 |         results = initialized_db.fetchall(f"SELECT * FROM {TEST_TABLE_NAME} ORDER BY id")
    |                                                                                         ^ E501
174 |
175 |         assert len(results) == len(TEST_DATA)
    |

tests\db\test_database_manager.py:186:89: E501 Line too long (98 > 88)
    |
184 |     ) -> None:
185 |         """Test that fetchall returns an empty list when no results are found."""
186 |         results = initialized_db.fetchall(f"SELECT * FROM {TEST_TABLE_NAME} WHERE id = ?", (999,))
    |                                                                                         ^^^^^^^^^^ E501
187 |         assert results == []
    |

tests\db\test_database_manager.py:224:89: E501 Line too long (97 > 88)
    |
222 |         # Try to insert into child with invalid parent_id
223 |         with pytest.raises(ForeignKeyError):
224 |             db_manager.execute("INSERT INTO child (id, parent_id, name) VALUES (1, 999, 'test')")
    |                                                                                         ^^^^^^^^^ E501
225 |
226 |     def test_constraint_error_unique(self, db_manager: DatabaseManager) -> None:
    |

tests\db\test_database_manager.py:237:89: E501 Line too long (96 > 88)
    |
236 |         # Insert first row
237 |         db_manager.execute("INSERT INTO test_unique (id, email) VALUES (1, 'test@example.com')")
    |                                                                                         ^^^^^^^^ E501
238 |
239 |         # Try to insert duplicate email
    |

tests\db\test_database_manager.py:241:89: E501 Line too long (100 > 88)
    |
239 |         # Try to insert duplicate email
240 |         with pytest.raises(ConstraintError):
241 |             db_manager.execute("INSERT INTO test_unique (id, email) VALUES (2, 'test@example.com')")
    |                                                                                         ^^^^^^^^^^^^ E501
242 |
243 |     def test_constraint_error_not_null(self, db_manager: DatabaseManager) -> None:
    |

tests\desktop_ui\test_db_viewer_dialog.py:22:5: ANN201 Missing return type annotation for public function `qtapp`
   |
21 | @pytest.fixture
22 | def qtapp():
   |     ^^^^^ ANN201
23 |     """Create a QApplication instance for testing.
24 |     This avoids conflicts with pytest-flask by creating a dedicated QApplication for Qt tests.
   |
   = help: Add return type annotation

tests\desktop_ui\test_db_viewer_dialog.py:24:89: E501 Line too long (94 > 88)
   |
22 | def qtapp():
23 |     """Create a QApplication instance for testing.
24 |     This avoids conflicts with pytest-flask by creating a dedicated QApplication for Qt tests.
   |                                                                                         ^^^^^^ E501
25 |     """
26 |     app = QApplication.instance()
   |

tests\desktop_ui\test_db_viewer_dialog.py:35:9: ANN204 Missing return type annotation for special method `__init__`
   |
33 |     """Simple QtBot class to replace pytest-qt's qtbot when it's not available."""
34 |
35 |     def __init__(self, app):
   |         ^^^^^^^^ ANN204
36 |         self.app = app
37 |         self.widgets = []
   |
   = help: Add return type annotation: `None`

tests\desktop_ui\test_db_viewer_dialog.py:35:24: ANN001 Missing type annotation for function argument `app`
   |
33 |     """Simple QtBot class to replace pytest-qt's qtbot when it's not available."""
34 |
35 |     def __init__(self, app):
   |                        ^^^ ANN001
36 |         self.app = app
37 |         self.widgets = []
   |

tests\desktop_ui\test_db_viewer_dialog.py:39:9: ANN201 Missing return type annotation for public function `addWidget`
   |
37 |         self.widgets = []
38 |
39 |     def addWidget(self, widget):
   |         ^^^^^^^^^ ANN201
40 |         """Keep track of widgets to ensure they don't get garbage collected."""
41 |         self.widgets.append(widget)
   |
   = help: Add return type annotation

tests\desktop_ui\test_db_viewer_dialog.py:39:25: ANN001 Missing type annotation for function argument `widget`
   |
37 |         self.widgets = []
38 |
39 |     def addWidget(self, widget):
   |                         ^^^^^^ ANN001
40 |         """Keep track of widgets to ensure they don't get garbage collected."""
41 |         self.widgets.append(widget)
   |

tests\desktop_ui\test_db_viewer_dialog.py:44:9: ANN201 Missing return type annotation for public function `mouseClick`
   |
42 |         return widget
43 |
44 |     def mouseClick(self, widget, button=Qt.LeftButton, pos=None):
   |         ^^^^^^^^^^ ANN201
45 |         """Simulate mouse click."""
46 |         if pos is None:
   |
   = help: Add return type annotation: `None`

tests\desktop_ui\test_db_viewer_dialog.py:44:26: ANN001 Missing type annotation for function argument `widget`
   |
42 |         return widget
43 |
44 |     def mouseClick(self, widget, button=Qt.LeftButton, pos=None):
   |                          ^^^^^^ ANN001
45 |         """Simulate mouse click."""
46 |         if pos is None:
   |

tests\desktop_ui\test_db_viewer_dialog.py:44:34: ANN001 Missing type annotation for function argument `button`
   |
42 |         return widget
43 |
44 |     def mouseClick(self, widget, button=Qt.LeftButton, pos=None):
   |                                  ^^^^^^ ANN001
45 |         """Simulate mouse click."""
46 |         if pos is None:
   |

tests\desktop_ui\test_db_viewer_dialog.py:44:56: ANN001 Missing type annotation for function argument `pos`
   |
42 |         return widget
43 |
44 |     def mouseClick(self, widget, button=Qt.LeftButton, pos=None):
   |                                                        ^^^ ANN001
45 |         """Simulate mouse click."""
46 |         if pos is None:
   |

tests\desktop_ui\test_db_viewer_dialog.py:57:5: ANN201 Missing return type annotation for public function `qtbot`
   |
56 | @pytest.fixture
57 | def qtbot(qtapp):
   |     ^^^^^ ANN201
58 |     """Create a QtBot instance for testing when pytest-qt's qtbot isn't available."""
59 |     return QtBot(qtapp)
   |
   = help: Add return type annotation

tests\desktop_ui\test_db_viewer_dialog.py:57:11: ANN001 Missing type annotation for function argument `qtapp`
   |
56 | @pytest.fixture
57 | def qtbot(qtapp):
   |           ^^^^^ ANN001
58 |     """Create a QtBot instance for testing when pytest-qt's qtbot isn't available."""
59 |     return QtBot(qtapp)
   |

tests\desktop_ui\test_db_viewer_dialog.py:63:5: ANN201 Missing return type annotation for public function `mock_db_viewer_service`
   |
62 | @pytest.fixture
63 | def mock_db_viewer_service():
   |     ^^^^^^^^^^^^^^^^^^^^^^ ANN201
64 |     """Create a mock DatabaseViewerService for testing."""
65 |     service = MagicMock(spec=DatabaseViewerService)
   |
   = help: Add return type annotation

tests\desktop_ui\test_db_viewer_dialog.py:85:5: ANN201 Missing return type annotation for public function `test_db_viewer_dialog_initialization`
   |
85 | def test_db_viewer_dialog_initialization(qtapp, mock_db_viewer_service, qtbot):
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
86 |     """Test that the DatabaseViewerDialog initializes correctly."""
87 |     # Setup mock for table data with more complete structure
   |
   = help: Add return type annotation: `None`

tests\desktop_ui\test_db_viewer_dialog.py:85:42: ANN001 Missing type annotation for function argument `qtapp`
   |
85 | def test_db_viewer_dialog_initialization(qtapp, mock_db_viewer_service, qtbot):
   |                                          ^^^^^ ANN001
86 |     """Test that the DatabaseViewerDialog initializes correctly."""
87 |     # Setup mock for table data with more complete structure
   |

tests\desktop_ui\test_db_viewer_dialog.py:85:49: ANN001 Missing type annotation for function argument `mock_db_viewer_service`
   |
85 | def test_db_viewer_dialog_initialization(qtapp, mock_db_viewer_service, qtbot):
   |                                                 ^^^^^^^^^^^^^^^^^^^^^^ ANN001
86 |     """Test that the DatabaseViewerDialog initializes correctly."""
87 |     # Setup mock for table data with more complete structure
   |

tests\desktop_ui\test_db_viewer_dialog.py:85:73: ANN001 Missing type annotation for function argument `qtbot`
   |
85 | def test_db_viewer_dialog_initialization(qtapp, mock_db_viewer_service, qtbot):
   |                                                                         ^^^^^ ANN001
86 |     """Test that the DatabaseViewerDialog initializes correctly."""
87 |     # Setup mock for table data with more complete structure
   |

tests\desktop_ui\test_db_viewer_dialog.py:103:89: E501 Line too long (89 > 88)
    |
101 |     qtbot.addWidget(dialog)
102 |
103 |     # Check that the service methods were called to get tables and the first table's data
    |                                                                                         ^ E501
104 |     mock_db_viewer_service.list_tables.assert_called_once()
105 |     # Auto-selection happens in load_tables, so get_table_data should be called for table1
    |

tests\desktop_ui\test_db_viewer_dialog.py:105:89: E501 Line too long (90 > 88)
    |
103 |     # Check that the service methods were called to get tables and the first table's data
104 |     mock_db_viewer_service.list_tables.assert_called_once()
105 |     # Auto-selection happens in load_tables, so get_table_data should be called for table1
    |                                                                                         ^^ E501
106 |     mock_db_viewer_service.get_table_data.assert_called_with(
107 |         table_name="table1",  # First table should be auto-selected
    |

tests\desktop_ui\test_db_viewer_dialog.py:118:89: E501 Line too long (90 > 88)
    |
116 |     # Check UI components initialized correctly
117 |     assert dialog.windowTitle() == "Database Viewer"
118 |     assert dialog.table_combo.count() == 3  # Should have 3 items (table1, table2, table3)
    |                                                                                         ^^ E501
119 |     assert dialog.current_table == "table1"  # First table should be auto-selected
120 |     assert dialog.page == 1  # Initial page
    |

tests\desktop_ui\test_db_viewer_dialog.py:137:5: ANN201 Missing return type annotation for public function `test_table_selection`
    |
137 | def test_table_selection(qtapp, mock_db_viewer_service, qtbot):
    |     ^^^^^^^^^^^^^^^^^^^^ ANN201
138 |     """Test that selecting a table loads its data."""
139 |     dialog = DatabaseViewerDialog(service=mock_db_viewer_service)
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_db_viewer_dialog.py:137:26: ANN001 Missing type annotation for function argument `qtapp`
    |
137 | def test_table_selection(qtapp, mock_db_viewer_service, qtbot):
    |                          ^^^^^ ANN001
138 |     """Test that selecting a table loads its data."""
139 |     dialog = DatabaseViewerDialog(service=mock_db_viewer_service)
    |

tests\desktop_ui\test_db_viewer_dialog.py:137:33: ANN001 Missing type annotation for function argument `mock_db_viewer_service`
    |
137 | def test_table_selection(qtapp, mock_db_viewer_service, qtbot):
    |                                 ^^^^^^^^^^^^^^^^^^^^^^ ANN001
138 |     """Test that selecting a table loads its data."""
139 |     dialog = DatabaseViewerDialog(service=mock_db_viewer_service)
    |

tests\desktop_ui\test_db_viewer_dialog.py:137:57: ANN001 Missing type annotation for function argument `qtbot`
    |
137 | def test_table_selection(qtapp, mock_db_viewer_service, qtbot):
    |                                                         ^^^^^ ANN001
138 |     """Test that selecting a table loads its data."""
139 |     dialog = DatabaseViewerDialog(service=mock_db_viewer_service)
    |

tests\desktop_ui\test_db_viewer_dialog.py:162:89: E501 Line too long (93 > 88)
    |
160 |     dialog.on_table_selected("table2")
161 |
162 |     # Check that the service method was called to get table data for the newly selected table
    |                                                                                         ^^^^^ E501
163 |     mock_db_viewer_service.get_table_data.assert_called_once_with(
164 |         table_name="table2",
    |

tests\desktop_ui\test_db_viewer_dialog.py:184:5: ANN201 Missing return type annotation for public function `test_pagination`
    |
184 | def test_pagination(qtapp, mock_db_viewer_service, qtbot):
    |     ^^^^^^^^^^^^^^^ ANN201
185 |     """Test pagination controls."""
186 |     # First prepare the mock to return pagination data
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_db_viewer_dialog.py:184:21: ANN001 Missing type annotation for function argument `qtapp`
    |
184 | def test_pagination(qtapp, mock_db_viewer_service, qtbot):
    |                     ^^^^^ ANN001
185 |     """Test pagination controls."""
186 |     # First prepare the mock to return pagination data
    |

tests\desktop_ui\test_db_viewer_dialog.py:184:28: ANN001 Missing type annotation for function argument `mock_db_viewer_service`
    |
184 | def test_pagination(qtapp, mock_db_viewer_service, qtbot):
    |                            ^^^^^^^^^^^^^^^^^^^^^^ ANN001
185 |     """Test pagination controls."""
186 |     # First prepare the mock to return pagination data
    |

tests\desktop_ui\test_db_viewer_dialog.py:184:52: ANN001 Missing type annotation for function argument `qtbot`
    |
184 | def test_pagination(qtapp, mock_db_viewer_service, qtbot):
    |                                                    ^^^^^ ANN001
185 |     """Test pagination controls."""
186 |     # First prepare the mock to return pagination data
    |

tests\desktop_ui\test_db_viewer_dialog.py:241:5: ANN201 Missing return type annotation for public function `test_sorting`
    |
241 | def test_sorting(qtapp, mock_db_viewer_service, qtbot):
    |     ^^^^^^^^^^^^ ANN201
242 |     """Test column sorting."""
243 |     dialog = DatabaseViewerDialog(service=mock_db_viewer_service)
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_db_viewer_dialog.py:241:18: ANN001 Missing type annotation for function argument `qtapp`
    |
241 | def test_sorting(qtapp, mock_db_viewer_service, qtbot):
    |                  ^^^^^ ANN001
242 |     """Test column sorting."""
243 |     dialog = DatabaseViewerDialog(service=mock_db_viewer_service)
    |

tests\desktop_ui\test_db_viewer_dialog.py:241:25: ANN001 Missing type annotation for function argument `mock_db_viewer_service`
    |
241 | def test_sorting(qtapp, mock_db_viewer_service, qtbot):
    |                         ^^^^^^^^^^^^^^^^^^^^^^ ANN001
242 |     """Test column sorting."""
243 |     dialog = DatabaseViewerDialog(service=mock_db_viewer_service)
    |

tests\desktop_ui\test_db_viewer_dialog.py:241:49: ANN001 Missing type annotation for function argument `qtbot`
    |
241 | def test_sorting(qtapp, mock_db_viewer_service, qtbot):
    |                                                 ^^^^^ ANN001
242 |     """Test column sorting."""
243 |     dialog = DatabaseViewerDialog(service=mock_db_viewer_service)
    |

tests\desktop_ui\test_db_viewer_dialog.py:310:5: ANN201 Missing return type annotation for public function `test_filtering`
    |
310 | def test_filtering(qtapp, mock_db_viewer_service, qtbot):
    |     ^^^^^^^^^^^^^^ ANN201
311 |     """Test table filtering."""
312 |     dialog = DatabaseViewerDialog(service=mock_db_viewer_service)
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_db_viewer_dialog.py:310:20: ANN001 Missing type annotation for function argument `qtapp`
    |
310 | def test_filtering(qtapp, mock_db_viewer_service, qtbot):
    |                    ^^^^^ ANN001
311 |     """Test table filtering."""
312 |     dialog = DatabaseViewerDialog(service=mock_db_viewer_service)
    |

tests\desktop_ui\test_db_viewer_dialog.py:310:27: ANN001 Missing type annotation for function argument `mock_db_viewer_service`
    |
310 | def test_filtering(qtapp, mock_db_viewer_service, qtbot):
    |                           ^^^^^^^^^^^^^^^^^^^^^^ ANN001
311 |     """Test table filtering."""
312 |     dialog = DatabaseViewerDialog(service=mock_db_viewer_service)
    |

tests\desktop_ui\test_db_viewer_dialog.py:310:51: ANN001 Missing type annotation for function argument `qtbot`
    |
310 | def test_filtering(qtapp, mock_db_viewer_service, qtbot):
    |                                                   ^^^^^ ANN001
311 |     """Test table filtering."""
312 |     dialog = DatabaseViewerDialog(service=mock_db_viewer_service)
    |

tests\desktop_ui\test_db_viewer_dialog.py:352:5: ANN201 Missing return type annotation for public function `test_export_to_csv`
    |
350 | @patch("PySide6.QtWidgets.QFileDialog.getSaveFileName")
351 | @patch("PySide6.QtWidgets.QMessageBox.information")
352 | def test_export_to_csv(mock_info_box, mock_get_save_filename, qtapp, mock_db_viewer_service, qtbot):
    |     ^^^^^^^^^^^^^^^^^^ ANN201
353 |     """Test exporting to CSV."""
354 |     # Setup mock to return a file path
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_db_viewer_dialog.py:352:24: ANN001 Missing type annotation for function argument `mock_info_box`
    |
350 | @patch("PySide6.QtWidgets.QFileDialog.getSaveFileName")
351 | @patch("PySide6.QtWidgets.QMessageBox.information")
352 | def test_export_to_csv(mock_info_box, mock_get_save_filename, qtapp, mock_db_viewer_service, qtbot):
    |                        ^^^^^^^^^^^^^ ANN001
353 |     """Test exporting to CSV."""
354 |     # Setup mock to return a file path
    |

tests\desktop_ui\test_db_viewer_dialog.py:352:39: ANN001 Missing type annotation for function argument `mock_get_save_filename`
    |
350 | @patch("PySide6.QtWidgets.QFileDialog.getSaveFileName")
351 | @patch("PySide6.QtWidgets.QMessageBox.information")
352 | def test_export_to_csv(mock_info_box, mock_get_save_filename, qtapp, mock_db_viewer_service, qtbot):
    |                                       ^^^^^^^^^^^^^^^^^^^^^^ ANN001
353 |     """Test exporting to CSV."""
354 |     # Setup mock to return a file path
    |

tests\desktop_ui\test_db_viewer_dialog.py:352:63: ANN001 Missing type annotation for function argument `qtapp`
    |
350 | @patch("PySide6.QtWidgets.QFileDialog.getSaveFileName")
351 | @patch("PySide6.QtWidgets.QMessageBox.information")
352 | def test_export_to_csv(mock_info_box, mock_get_save_filename, qtapp, mock_db_viewer_service, qtbot):
    |                                                               ^^^^^ ANN001
353 |     """Test exporting to CSV."""
354 |     # Setup mock to return a file path
    |

tests\desktop_ui\test_db_viewer_dialog.py:352:70: ANN001 Missing type annotation for function argument `mock_db_viewer_service`
    |
350 | @patch("PySide6.QtWidgets.QFileDialog.getSaveFileName")
351 | @patch("PySide6.QtWidgets.QMessageBox.information")
352 | def test_export_to_csv(mock_info_box, mock_get_save_filename, qtapp, mock_db_viewer_service, qtbot):
    |                                                                      ^^^^^^^^^^^^^^^^^^^^^^ ANN001
353 |     """Test exporting to CSV."""
354 |     # Setup mock to return a file path
    |

tests\desktop_ui\test_db_viewer_dialog.py:352:89: E501 Line too long (100 > 88)
    |
350 | @patch("PySide6.QtWidgets.QFileDialog.getSaveFileName")
351 | @patch("PySide6.QtWidgets.QMessageBox.information")
352 | def test_export_to_csv(mock_info_box, mock_get_save_filename, qtapp, mock_db_viewer_service, qtbot):
    |                                                                                         ^^^^^^^^^^^^ E501
353 |     """Test exporting to CSV."""
354 |     # Setup mock to return a file path
    |

tests\desktop_ui\test_db_viewer_dialog.py:352:94: ANN001 Missing type annotation for function argument `qtbot`
    |
350 | @patch("PySide6.QtWidgets.QFileDialog.getSaveFileName")
351 | @patch("PySide6.QtWidgets.QMessageBox.information")
352 | def test_export_to_csv(mock_info_box, mock_get_save_filename, qtapp, mock_db_viewer_service, qtbot):
    |                                                                                              ^^^^^ ANN001
353 |     """Test exporting to CSV."""
354 |     # Setup mock to return a file path
    |

tests\desktop_ui\test_db_viewer_dialog.py:371:9: ANN202 Missing return type annotation for private function `custom_export`
    |
370 |     # Create a custom implementation of export_to_csv to bypass QFileDialog issue
371 |     def custom_export():
    |         ^^^^^^^^^^^^^ ANN202
372 |         # This simulates user selecting a file name from QFileDialog
373 |         # and the method proceeding with that file name
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_db_viewer_dialog.py:396:89: E501 Line too long (97 > 88)
    |
394 |     # Check service called with correct parameters
395 |     mock_db_viewer_service.export_table_to_csv.assert_called_once_with(
396 |         table_name="table1", output_file="test_export.csv", filter_column=None, filter_value=None
    |                                                                                         ^^^^^^^^^ E501
397 |     )
    |

tests\desktop_ui\test_db_viewer_dialog.py:405:5: ANN201 Missing return type annotation for public function `test_error_handling`
    |
405 | def test_error_handling(qtapp, mock_db_viewer_service, qtbot):
    |     ^^^^^^^^^^^^^^^^^^^ ANN201
406 |     """Test error handling for service exceptions."""
407 |     dialog = DatabaseViewerDialog(service=mock_db_viewer_service)
    |
    = help: Add return type annotation: `None`

tests\desktop_ui\test_db_viewer_dialog.py:405:25: ANN001 Missing type annotation for function argument `qtapp`
    |
405 | def test_error_handling(qtapp, mock_db_viewer_service, qtbot):
    |                         ^^^^^ ANN001
406 |     """Test error handling for service exceptions."""
407 |     dialog = DatabaseViewerDialog(service=mock_db_viewer_service)
    |

tests\desktop_ui\test_db_viewer_dialog.py:405:32: ANN001 Missing type annotation for function argument `mock_db_viewer_service`
    |
405 | def test_error_handling(qtapp, mock_db_viewer_service, qtbot):
    |                                ^^^^^^^^^^^^^^^^^^^^^^ ANN001
406 |     """Test error handling for service exceptions."""
407 |     dialog = DatabaseViewerDialog(service=mock_db_viewer_service)
    |

tests\desktop_ui\test_db_viewer_dialog.py:405:56: ANN001 Missing type annotation for function argument `qtbot`
    |
405 | def test_error_handling(qtapp, mock_db_viewer_service, qtbot):
    |                                                        ^^^^^ ANN001
406 |     """Test error handling for service exceptions."""
407 |     dialog = DatabaseViewerDialog(service=mock_db_viewer_service)
    |

tests\desktop_ui\test_users_and_keyboards.py:6:1: I001 [*] Import block is un-sorted or un-formatted
   |
 4 |   Updated to use PySide6 instead of PyQt5.
 5 |   """
 6 | / import pytest
 7 | | from typing import Generator, List, Tuple
 8 | | from unittest.mock import MagicMock, patch
 9 | | from PySide6 import QtCore, QtWidgets
10 | | from PySide6.QtCore import Qt
11 | | from pytestqt.qtbot import QtBot
12 | |
13 | | from db.database_manager import DatabaseManager
14 | | from desktop_ui.users_and_keyboards import UsersAndKeyboards
15 | | from models.keyboard import Keyboard
16 | | from models.keyboard_manager import KeyboardManager
17 | | from models.user import User
18 | | from models.user_manager import UserManager
   | |___________________________________________^ I001
19 |
20 |   # Test data constants
   |
   = help: Organize imports

tests\desktop_ui\test_users_and_keyboards.py:80:89: E501 Line too long (90 > 88)
   |
78 |     state = {"users": [test_user]}
79 |
80 |     # Define static return values for list_all_users to avoid potential infinite recursion
   |                                                                                         ^^ E501
81 |     mock.list_all_users.return_value = state["users"]
   |

tests\desktop_ui\test_users_and_keyboards.py:125:89: E501 Line too long (92 > 88)
    |
124 | @pytest.fixture
125 | def mock_keyboard_manager(mock_db_manager: MagicMock, test_keyboard: Keyboard) -> MagicMock:
    |                                                                                         ^^^^ E501
126 |     """Create a stateful mock keyboard manager."""
127 |     mock = MagicMock(spec=KeyboardManager)
    |

tests\desktop_ui\test_users_and_keyboards.py:198:89: E501 Line too long (92 > 88)
    |
196 |     """
197 |     with (
198 |         patch("desktop_ui.users_and_keyboards.UserManager", return_value=mock_user_manager),
    |                                                                                         ^^^^ E501
199 |         patch(
200 |             "desktop_ui.users_and_keyboards.KeyboardManager",
    |

tests\desktop_ui\test_users_and_keyboards.py:223:89: E501 Line too long (89 > 88)
    |
222 |     def test_load_users(
223 |         self, users_and_keyboards_dialog: Tuple[UsersAndKeyboards, MagicMock, MagicMock],
    |                                                                                         ^ E501
224 |         test_user: User
225 |     ) -> None:
    |

tests\desktop_ui\test_users_and_keyboards.py:267:89: E501 Line too long (90 > 88)
    |
265 |         # Create a new user that will be returned by the mocked dialog
266 |         new_user = User(
267 |             user_id="550e8400-e29b-41d4-a716-446655440001",  # Different ID from test_user
    |                                                                                         ^^ E501
268 |             first_name=NEW_USER_DATA["first_name"],
269 |             surname=NEW_USER_DATA["surname"],
    |

tests\desktop_ui\test_users_and_keyboards.py:283:89: E501 Line too long (89 > 88)
    |
282 |             # Check that the user manager was called to save the user
283 |             assert mock_user_manager.save_user.call_count > 0, "save_user was not called"
    |                                                                                         ^ E501
284 |             assert dialog.users_list.count() == initial_count + 1, "User count did not increase"
    |

tests\desktop_ui\test_users_and_keyboards.py:284:89: E501 Line too long (96 > 88)
    |
282 |             # Check that the user manager was called to save the user
283 |             assert mock_user_manager.save_user.call_count > 0, "save_user was not called"
284 |             assert dialog.users_list.count() == initial_count + 1, "User count did not increase"
    |                                                                                         ^^^^^^^^ E501
285 |
286 |             # Verify the new user is in the list
    |

tests\desktop_ui\test_users_and_keyboards.py:337:89: E501 Line too long (89 > 88)
    |
336 |             # Check that the user manager was called to save the user
337 |             assert mock_user_manager.save_user.call_count > 0, "save_user was not called"
    |                                                                                         ^ E501
338 |
339 |             # Make sure we stay at the same index
    |

tests\desktop_ui\test_users_and_keyboards.py:361:89: E501 Line too long (101 > 88)
    |
360 |         # Patch QMessageBox.question to return Yes
361 |         with patch("PySide6.QtWidgets.QMessageBox.question", return_value=QtWidgets.QMessageBox.Yes):
    |                                                                                         ^^^^^^^^^^^^^ E501
362 |             # Click the delete user button
363 |             qtbot.mouseClick(dialog.delete_user_btn, QtCore.Qt.MouseButton.LeftButton)
    |

tests\desktop_ui\test_users_and_keyboards.py:414:89: E501 Line too long (105 > 88)
    |
412 |         # Use a different ID to ensure it's treated as a new keyboard
413 |         new_keyboard = Keyboard(
414 |             keyboard_id="550e8400-e29b-41d4-a716-446655440002",  # Unique ID different from test_keyboard
    |                                                                                         ^^^^^^^^^^^^^^^^^ E501
415 |             user_id=TEST_USER_ID,
416 |             keyboard_name="New Keyboard",
    |

tests\desktop_ui\test_users_and_keyboards.py:465:89: E501 Line too long (90 > 88)
    |
463 |         ):
464 |             # Click the delete keyboard button
465 |             qtbot.mouseClick(dialog.delete_keyboard_btn, QtCore.Qt.MouseButton.LeftButton)
    |                                                                                         ^^ E501
466 |
467 |             # Check that the keyboard manager was called with the correct user ID
    |

tests\helpers\db_helpers.py:4:89: E501 Line too long (92 > 88)
  |
2 | Database testing helpers and fixtures.
3 |
4 | This module provides reusable fixtures and helper functions for testing database operations.
  |                                                                                         ^^^^ E501
5 | It includes fixtures for creating temporary databases and handling database connections.
6 | """
  |

tests\models\conftest.py:1:1: I001 [*] Import block is un-sorted or un-formatted
   |
 1 | / import os
 2 | | import tempfile
 3 | | from pathlib import Path
 4 | | from typing import Generator
 5 | |
 6 | | import pytest
 7 | |
 8 | | from db.database_manager import DatabaseManager, ConnectionType
   | |_______________________________________________________________^ I001
 9 |
10 |   """
   |
   = help: Organize imports

tests\models\conftest.py:17:89: E501 Line too long (95 > 88)
   |
16 | # Removed pytest_plugins as per pytest deprecation warning.
17 | # Fixtures should be imported in the top-level conftest.py or tests/conftest.py for global use.
   |                                                                                         ^^^^^^^ E501
18 | """
19 | Database testing helpers and fixtures.
   |

tests\models\conftest.py:21:89: E501 Line too long (92 > 88)
   |
19 | Database testing helpers and fixtures.
20 |
21 | This module provides reusable fixtures and helper functions for testing database operations.
   |                                                                                         ^^^^ E501
22 | It includes fixtures for creating temporary databases and handling database connections.
23 | """
   |

tests\models\conftest.py:51:89: E501 Line too long (92 > 88)
   |
49 | def db_manager(temp_db: str) -> DatabaseManager:
50 |     """
51 |     Create a DatabaseManager instance with a temporary database using LOCAL connection type.
   |                                                                                         ^^^^ E501
52 |
53 |     Args:
   |

tests\models\debug_session_test.py:13:89: E501 Line too long (96 > 88)
   |
12 | def test_debug_all_failing_cases() -> None:
13 |     """Test the specific failing test cases from test_session_creation_and_calculated_fields."""
   |                                                                                         ^^^^^^^^ E501
14 |     test_cases = [
15 |         # Case 1: Long duration, low WPM/CPM, incomplete
   |

tests\models\debug_session_test.py:33:89: E501 Line too long (98 > 88)
   |
31 |                 "total_time": 3600.0,
32 |                 "efficiency": 0.5,
33 |                 "correctness": 0.0,  # (actual_chars - errors) / actual_chars = (50 - 50) / 50 = 0
   |                                                                                         ^^^^^^^^^^ E501
34 |                 "accuracy": 0.0,     # correctness * efficiency = 0.0 * 0.5 = 0.0
35 |                 "session_cpm": 50.0 / 60.0,
   |

tests\models\debug_session_test.py:94:89: E501 Line too long (117 > 88)
   |
92 |                 s = Session.from_dict(case['data'])
93 |                 print("Session created successfully")
94 |                 print(f"expected_chars - Expected: {case['expected']['expected_chars']}, Actual: {s.expected_chars}")
   |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
95 |                 print(f"total_time - Expected: {case['expected']['total_time']}, Actual: {s.total_time}")
96 |                 print(f"efficiency - Expected: {case['expected']['efficiency']}, Actual: {s.efficiency}")
   |

tests\models\debug_session_test.py:95:89: E501 Line too long (105 > 88)
   |
93 |                 print("Session created successfully")
94 |                 print(f"expected_chars - Expected: {case['expected']['expected_chars']}, Actual: {s.expected_chars}")
95 |                 print(f"total_time - Expected: {case['expected']['total_time']}, Actual: {s.total_time}")
   |                                                                                         ^^^^^^^^^^^^^^^^^ E501
96 |                 print(f"efficiency - Expected: {case['expected']['efficiency']}, Actual: {s.efficiency}")
97 |                 print(f"correctness - Expected: {case['expected']['correctness']}, Actual: {s.correctness}")
   |

tests\models\debug_session_test.py:96:89: E501 Line too long (105 > 88)
   |
94 |                 print(f"expected_chars - Expected: {case['expected']['expected_chars']}, Actual: {s.expected_chars}")
95 |                 print(f"total_time - Expected: {case['expected']['total_time']}, Actual: {s.total_time}")
96 |                 print(f"efficiency - Expected: {case['expected']['efficiency']}, Actual: {s.efficiency}")
   |                                                                                         ^^^^^^^^^^^^^^^^^ E501
97 |                 print(f"correctness - Expected: {case['expected']['correctness']}, Actual: {s.correctness}")
98 |                 print(f"accuracy - Expected: {case['expected']['accuracy']}, Actual: {s.accuracy}")
   |

tests\models\debug_session_test.py:97:89: E501 Line too long (108 > 88)
   |
95 |                 print(f"total_time - Expected: {case['expected']['total_time']}, Actual: {s.total_time}")
96 |                 print(f"efficiency - Expected: {case['expected']['efficiency']}, Actual: {s.efficiency}")
97 |                 print(f"correctness - Expected: {case['expected']['correctness']}, Actual: {s.correctness}")
   |                                                                                         ^^^^^^^^^^^^^^^^^^^^ E501
98 |                 print(f"accuracy - Expected: {case['expected']['accuracy']}, Actual: {s.accuracy}")
99 |                 print(f"session_cpm - Expected: {case['expected']['session_cpm']}, Actual: {s.session_cpm}")
   |

tests\models\debug_session_test.py:98:89: E501 Line too long (99 > 88)
    |
 96 |                 print(f"efficiency - Expected: {case['expected']['efficiency']}, Actual: {s.efficiency}")
 97 |                 print(f"correctness - Expected: {case['expected']['correctness']}, Actual: {s.correctness}")
 98 |                 print(f"accuracy - Expected: {case['expected']['accuracy']}, Actual: {s.accuracy}")
    |                                                                                         ^^^^^^^^^^^ E501
 99 |                 print(f"session_cpm - Expected: {case['expected']['session_cpm']}, Actual: {s.session_cpm}")
100 |                 print(f"session_wpm - Expected: {case['expected']['session_wpm']}, Actual: {s.session_wpm}")
    |

tests\models\debug_session_test.py:99:89: E501 Line too long (108 > 88)
    |
 97 |                 print(f"correctness - Expected: {case['expected']['correctness']}, Actual: {s.correctness}")
 98 |                 print(f"accuracy - Expected: {case['expected']['accuracy']}, Actual: {s.accuracy}")
 99 |                 print(f"session_cpm - Expected: {case['expected']['session_cpm']}, Actual: {s.session_cpm}")
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^ E501
100 |                 print(f"session_wpm - Expected: {case['expected']['session_wpm']}, Actual: {s.session_wpm}")
101 |         except Exception as e:
    |

tests\models\debug_session_test.py:100:89: E501 Line too long (108 > 88)
    |
 98 |                 print(f"accuracy - Expected: {case['expected']['accuracy']}, Actual: {s.accuracy}")
 99 |                 print(f"session_cpm - Expected: {case['expected']['session_cpm']}, Actual: {s.session_cpm}")
100 |                 print(f"session_wpm - Expected: {case['expected']['session_wpm']}, Actual: {s.session_wpm}")
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^ E501
101 |         except Exception as e:
102 |             print(f"ERROR: Unexpected exception: {e}")
    |

tests\models\debug_session_tests.py:106:89: E501 Line too long (112 > 88)
    |
104 |     ]
105 |
106 |     for idx, (case_name, overrides, expected_exception_type, expected_exception_match) in enumerate(test_cases):
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^ E501
107 |         print(f"\nTesting case {idx}: {case_name}")
108 |         data = valid_session_dict_fixture.copy()
    |

tests\models\debug_session_tests.py:112:89: E501 Line too long (89 > 88)
    |
111 |         if "snippet_index_end" in overrides and "content" not in overrides:
112 |             start_idx = overrides.get("snippet_index_start", data["snippet_index_start"])
    |                                                                                         ^ E501
113 |             data["content"] = "a" * (overrides["snippet_index_end"] - start_idx)
114 |         elif "content" in overrides and ("snippet_index_start" in data and "snippet_index_end" in data):
    |

tests\models\debug_session_tests.py:114:89: E501 Line too long (104 > 88)
    |
112 |             start_idx = overrides.get("snippet_index_start", data["snippet_index_start"])
113 |             data["content"] = "a" * (overrides["snippet_index_end"] - start_idx)
114 |         elif "content" in overrides and ("snippet_index_start" in data and "snippet_index_end" in data):
    |                                                                                         ^^^^^^^^^^^^^^^^ E501
115 |             data["snippet_index_start"] = 0
116 |             data["snippet_index_end"] = len(str(data["content"]))
    |

tests\models\debug_session_tests.py:119:13: F841 Local variable `s` is assigned to but never used
    |
118 |         try:
119 |             s = Session.from_dict(data)
    |             ^ F841
120 |             print(f"Case {idx} passed successfully")
121 |             if expected_exception_type:
    |
    = help: Remove assignment to unused variable `s`

tests\models\debug_session_tests.py:122:89: E501 Line too long (104 > 88)
    |
120 |             print(f"Case {idx} passed successfully")
121 |             if expected_exception_type:
122 |                 print(f"ERROR: Expected {expected_exception_type.__name__} but no exception was raised")
    |                                                                                         ^^^^^^^^^^^^^^^^ E501
123 |         except Exception as e:
124 |             print(f"Case {idx} failed with: {type(e).__name__}: {str(e)}")
    |

tests\models\debug_session_tests.py:127:89: E501 Line too long (107 > 88)
    |
125 |             if expected_exception_type:
126 |                 if not isinstance(e, expected_exception_type):
127 |                     print(f"ERROR: Expected {expected_exception_type.__name__} but got {type(e).__name__}")
    |                                                                                         ^^^^^^^^^^^^^^^^^^^ E501
128 |                 elif expected_exception_match and expected_exception_match not in str(e):
129 |                     print(f"ERROR: Expected message '{expected_exception_match}' but got '{str(e)}'")
    |

tests\models\debug_session_tests.py:128:89: E501 Line too long (89 > 88)
    |
126 |                 if not isinstance(e, expected_exception_type):
127 |                     print(f"ERROR: Expected {expected_exception_type.__name__} but got {type(e).__name__}")
128 |                 elif expected_exception_match and expected_exception_match not in str(e):
    |                                                                                         ^ E501
129 |                     print(f"ERROR: Expected message '{expected_exception_match}' but got '{str(e)}'")
130 |                 else:
    |

tests\models\debug_session_tests.py:129:89: E501 Line too long (101 > 88)
    |
127 |                     print(f"ERROR: Expected {expected_exception_type.__name__} but got {type(e).__name__}")
128 |                 elif expected_exception_match and expected_exception_match not in str(e):
129 |                     print(f"ERROR: Expected message '{expected_exception_match}' but got '{str(e)}'")
    |                                                                                         ^^^^^^^^^^^^^ E501
130 |                 else:
131 |                     print(f"Case {idx} failed as expected with correct exception")
    |

tests\models\debug_test_snippet_manager.py:11:89: E501 Line too long (121 > 88)
   |
 9 |     # Run the tests with detailed error reporting
10 |     # Run a specific test that might be failing
11 |     test_path = "tests/models/test_snippet_manager.py::TestCreateSnippet::test_create_snippet_pydantic_validation_errors"
   |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
12 |     print(f"\nRunning test: {test_path}\n")
13 |     exit_code = pytest.main([test_path, "-vv"])
   |

tests\models\debug_test_snippet_manager.py:15:89: E501 Line too long (94 > 88)
   |
13 |     exit_code = pytest.main([test_path, "-vv"])
14 |
15 |     print(f"\nTest result: {'PASSED' if exit_code == 0 else f'FAILED with code {exit_code}'}")
   |                                                                                         ^^^^^^ E501
16 |     sys.exit(exit_code)
   |

tests\models\import_test.py:1:89: E501 Line too long (89 > 88)
  |
1 | """Simple import test to verify what's available in the current ngram_analyzer module."""
  |                                                                                         ^ E501
2 | import sys
3 | from pathlib import Path
  |

tests\models\import_test.py:10:39: F401 `models.ngram_analyzer.NGram` imported but unused; consider using `importlib.util.find_spec` to test for availability
   |
 8 | try:
 9 |     # Import and print what's available in the module
10 |     from models.ngram_analyzer import NGram, NGramAnalyzer
   |                                       ^^^^^ F401
11 |
12 |     print("Successfully imported NGramAnalyzer and NGram")
   |
   = help: Remove unused import

tests\models\import_test.py:10:46: F401 `models.ngram_analyzer.NGramAnalyzer` imported but unused; consider using `importlib.util.find_spec` to test for availability
   |
 8 | try:
 9 |     # Import and print what's available in the module
10 |     from models.ngram_analyzer import NGram, NGramAnalyzer
   |                                              ^^^^^^^^^^^^^ F401
11 |
12 |     print("Successfully imported NGramAnalyzer and NGram")
   |
   = help: Remove unused import

tests\models\import_test.py:16:43: F401 `models.ngram_analyzer.NGramStats` imported but unused; consider using `importlib.util.find_spec` to test for availability
   |
14 |     # Try to access the required imports that are failing
15 |     try:
16 |         from models.ngram_analyzer import NGramStats
   |                                           ^^^^^^^^^^ F401
17 |         print("NGramStats exists")
18 |     except ImportError:
   |
   = help: Remove unused import: `models.ngram_analyzer.NGramStats`

tests\models\import_test.py:22:43: F401 `models.ngram_analyzer.Session` imported but unused; consider using `importlib.util.find_spec` to test for availability
   |
21 |     try:
22 |         from models.ngram_analyzer import Session
   |                                           ^^^^^^^ F401
23 |         print("Session exists")
24 |     except ImportError:
   |
   = help: Remove unused import: `models.ngram_analyzer.Session`

tests\models\test_category.py:27:89: E501 Line too long (95 > 88)
   |
25 |         assert cat.category_name == "Valid Name"
26 |
27 |         cat_stripped = Category(category_id=str(uuid.uuid4()), category_name="  Spaced Name  ")
   |                                                                                         ^^^^^^^ E501
28 |         assert cat_stripped.category_name == "Spaced Name"
   |

tests\models\test_category.py:39:89: E501 Line too long (97 > 88)
   |
37 |         ],
38 |     )
39 |     def test_category_name_validation(self, name: str, expected_error_message_part: str) -> None:
   |                                                                                         ^^^^^^^^^ E501
40 |         """
41 |         Test objective: Verify Category model's name validation for format, length, and ASCII.
   |

tests\models\test_category.py:41:89: E501 Line too long (94 > 88)
   |
39 |     def test_category_name_validation(self, name: str, expected_error_message_part: str) -> None:
40 |         """
41 |         Test objective: Verify Category model's name validation for format, length, and ASCII.
   |                                                                                         ^^^^^^ E501
42 |         """
43 |         with pytest.raises(ValidationError) as exc_info:
   |

tests\models\test_category.py:112:89: E501 Line too long (90 > 88)
    |
111 |     def test_category_db_rows_fail_validation(self) -> None:
112 |         """Test that current DB rows would fail Pydantic validation (simulate DB load)."""
    |                                                                                         ^^ E501
113 |         # These are the actual rows from the current categories table
114 |         db_rows = [
    |

tests\models\test_category_manager.py:63:89: E501 Line too long (89 > 88)
   |
61 |         assert err_msg_part.lower() in str(e.value).lower()
62 |
63 |     def test_create_category_duplicate_name(self, category_mgr: CategoryManager) -> None:
   |                                                                                         ^ E501
64 |         """
65 |         Test objective: Attempt to create a category with a duplicate name.
   |

tests\models\test_category_manager.py:92:89: E501 Line too long (90 > 88)
   |
90 |             category_mgr.get_category_by_id(str(uuid.uuid4()))
91 |
92 |     def test_get_category_by_id_invalid_uuid(self, category_mgr: CategoryManager) -> None:
   |                                                                                         ^^ E501
93 |         """
94 |         Test objective: Attempt to retrieve a category with an invalid (non-UUID) ID string.
   |

tests\models\test_category_manager.py:94:89: E501 Line too long (92 > 88)
   |
92 |     def test_get_category_by_id_invalid_uuid(self, category_mgr: CategoryManager) -> None:
93 |         """
94 |         Test objective: Attempt to retrieve a category with an invalid (non-UUID) ID string.
   |                                                                                         ^^^^ E501
95 |         """
96 |         with pytest.raises(CategoryNotFound):
   |

tests\models\test_category_manager.py:111:89: E501 Line too long (89 > 88)
    |
109 |         assert retrieved_cat.category_name == cat_name
110 |
111 |     def test_get_category_by_name_not_found(self, category_mgr: CategoryManager) -> None:
    |                                                                                         ^ E501
112 |         """
113 |         Test objective: Attempt to retrieve a non-existent category by name.
    |

tests\models\test_category_manager.py:118:89: E501 Line too long (94 > 88)
    |
116 |             category_mgr.get_category_by_name("NonExistent Name")
117 |
118 |     def test_get_category_by_name_case_sensitive(self, category_mgr: CategoryManager) -> None:
    |                                                                                         ^^^^^^ E501
119 |         """
120 |         Test objective: Verify category name retrieval is case-sensitive.
    |

tests\models\test_category_manager.py:164:89: E501 Line too long (104 > 88)
    |
162 |         assert category.category_name == "New Valid Name"
163 |         assert (
164 |             category_mgr.get_category_by_id(str(category.category_id)).category_name == "New Valid Name"
    |                                                                                         ^^^^^^^^^^^^^^^^ E501
165 |         )
    |

tests\models\test_category_manager.py:179:89: E501 Line too long (90 > 88)
    |
177 |     ) -> None:
178 |         """
179 |         Test objective: Attempt to update a category with an invalid new name format using
    |                                                                                         ^^ E501
180 |         save_category.
181 |         """
    |

tests\models\test_category_manager.py:189:89: E501 Line too long (92 > 88)
    |
187 |         assert err_msg_part.lower() in str(e.value).lower()
188 |
189 |     def test_update_category_to_duplicate_name(self, category_mgr: CategoryManager) -> None:
    |                                                                                         ^^^^ E501
190 |         """
191 |         Test objective: Attempt to update a category name to an existing different category's name
    |

tests\models\test_category_manager.py:191:89: E501 Line too long (98 > 88)
    |
189 |     def test_update_category_to_duplicate_name(self, category_mgr: CategoryManager) -> None:
190 |         """
191 |         Test objective: Attempt to update a category name to an existing different category's name
    |                                                                                         ^^^^^^^^^^ E501
192 |         using save_category.
193 |         """
    |

tests\models\test_category_manager.py:203:89: E501 Line too long (100 > 88)
    |
201 |         assert "must be unique" in str(e.value).lower()
202 |
203 |     def test_update_category_to_case_variant_duplicate(self, category_mgr: CategoryManager) -> None:
    |                                                                                         ^^^^^^^^^^^^ E501
204 |         """
205 |         Test objective: Attempt to update a category name to a case-variant of an existing name
    |

tests\models\test_category_manager.py:205:89: E501 Line too long (95 > 88)
    |
203 |     def test_update_category_to_case_variant_duplicate(self, category_mgr: CategoryManager) -> None:
204 |         """
205 |         Test objective: Attempt to update a category name to a case-variant of an existing name
    |                                                                                         ^^^^^^^ E501
206 |         using save_category.
207 |         """
    |

tests\models\test_category_manager.py:216:89: E501 Line too long (103 > 88)
    |
214 |             category_mgr.save_category(category2)
215 |             assert (
216 |                 category_mgr.get_category_by_id(str(category2.category_id)).category_name == "casename"
    |                                                                                         ^^^^^^^^^^^^^^^ E501
217 |             )
218 |         except CategoryValidationError as e:
    |

tests\models\test_category_manager.py:231:89: E501 Line too long (99 > 88)
    |
229 |         category.category_name = cat_name
230 |         assert category_mgr.save_category(category)
231 |         assert category_mgr.get_category_by_id(str(category.category_id)).category_name == cat_name
    |                                                                                         ^^^^^^^^^^^ E501
232 |
233 |     def test_delete_category_by_id(self, category_mgr: CategoryManager) -> None:
    |

tests\models\test_category_manager.py:243:89: E501 Line too long (93 > 88)
    |
241 |             category_mgr.get_category_by_id(str(category.category_id))
242 |
243 |     def test_delete_category_by_id_invalid_uuid(self, category_mgr: CategoryManager) -> None:
    |                                                                                         ^^^^^ E501
244 |         """
245 |         Test objective: Attempt to delete a category with an invalid (non-UUID) ID string.
    |

tests\models\test_category_manager.py:245:89: E501 Line too long (90 > 88)
    |
243 |     def test_delete_category_by_id_invalid_uuid(self, category_mgr: CategoryManager) -> None:
244 |         """
245 |         Test objective: Attempt to delete a category with an invalid (non-UUID) ID string.
    |                                                                                         ^^ E501
246 |         """
247 |         assert category_mgr.delete_category_by_id("not-a-uuid") is False
    |

tests\models\test_category_manager.py:269:89: E501 Line too long (92 > 88)
    |
267 |     def test_delete_category_cascades(self, category_mgr: CategoryManager) -> None:
268 |         """
269 |         Test objective: Verify that deleting a category also deletes associated snippets and
    |                                                                                         ^^^^ E501
270 |         snippet_parts.
271 |         """
    |

tests\models\test_category_manager.py:279:89: E501 Line too long (92 > 88)
    |
277 |         snippet_id = str(uuid.uuid4())
278 |         dbm.execute(
279 |             "INSERT INTO snippets (snippet_id, category_id, snippet_name) VALUES (?, ?, ?)",
    |                                                                                         ^^^^ E501
280 |             (snippet_id, category.category_id, "CascadeSnippet"),
281 |         )
    |

tests\models\test_category_manager.py:319:89: E501 Line too long (98 > 88)
    |
317 |         assert part_row_after_delete is None
318 |
319 |     def test_category_validation_blank_and_duplicate(self, category_mgr: CategoryManager) -> None:
    |                                                                                         ^^^^^^^^^^ E501
320 |         """
321 |         Test objective: Destructively test blank and duplicate category names.
    |

tests\models\test_dynamic_content_manager.py:6:1: I001 [*] Import block is un-sorted or un-formatted
   |
 4 |   """
 5 |
 6 | / import pytest
 7 | | import random
 8 | | from unittest.mock import MagicMock, patch
 9 | | from typing import List, Optional
10 | |
11 | | from models.dynamic_content_manager import DynamicContentManager, ContentMode
12 | | from models.llm_ngram_service import LLMNgramService
   | |____________________________________________________^ I001
   |
   = help: Organize imports

tests\models\test_dynamic_content_manager.py:8:27: F401 [*] `unittest.mock.MagicMock` imported but unused
  |
6 | import pytest
7 | import random
8 | from unittest.mock import MagicMock, patch
  |                           ^^^^^^^^^ F401
9 | from typing import List, Optional
  |
  = help: Remove unused import: `unittest.mock.MagicMock`

tests\models\test_dynamic_content_manager.py:9:26: F401 [*] `typing.Optional` imported but unused
   |
 7 | import random
 8 | from unittest.mock import MagicMock, patch
 9 | from typing import List, Optional
   |                          ^^^^^^^^ F401
10 |
11 | from models.dynamic_content_manager import DynamicContentManager, ContentMode
   |
   = help: Remove unused import: `typing.Optional`

tests\models\test_dynamic_content_manager.py:12:38: F401 [*] `models.llm_ngram_service.LLMNgramService` imported but unused
   |
11 | from models.dynamic_content_manager import DynamicContentManager, ContentMode
12 | from models.llm_ngram_service import LLMNgramService
   |                                      ^^^^^^^^^^^^^^^ F401
   |
   = help: Remove unused import: `models.llm_ngram_service.LLMNgramService`

tests\models\test_dynamic_content_manager.py:39:5: ANN201 Missing return type annotation for public function `mock_llm_service`
   |
38 | @pytest.fixture
39 | def mock_llm_service():
   |     ^^^^^^^^^^^^^^^^ ANN201
40 |     """Fixture providing a mock LLM service."""
41 |     return MockLLMNgramService()
   |
   = help: Add return type annotation

tests\models\test_dynamic_content_manager.py:45:5: ANN201 Missing return type annotation for public function `basic_manager`
   |
44 | @pytest.fixture
45 | def basic_manager(mock_llm_service):
   |     ^^^^^^^^^^^^^ ANN201
46 |     """Fixture providing a basic DynamicContentManager instance."""
47 |     return DynamicContentManager(
   |
   = help: Add return type annotation

tests\models\test_dynamic_content_manager.py:45:19: ANN001 Missing type annotation for function argument `mock_llm_service`
   |
44 | @pytest.fixture
45 | def basic_manager(mock_llm_service):
   |                   ^^^^^^^^^^^^^^^^ ANN001
46 |     """Fixture providing a basic DynamicContentManager instance."""
47 |     return DynamicContentManager(
   |

tests\models\test_dynamic_content_manager.py:59:9: ANN201 Missing return type annotation for public function `test_init_with_valid_params`
   |
57 |     """Test suite for DynamicContentManager initialization and validation."""
58 |
59 |     def test_init_with_valid_params(self):
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
60 |         """Test initializing with valid parameters."""
61 |         manager = DynamicContentManager(
   |
   = help: Add return type annotation: `None`

tests\models\test_dynamic_content_manager.py:73:9: ANN201 Missing return type annotation for public function `test_init_with_defaults`
   |
71 |         assert manager.mode == ContentMode.NGRAM_ONLY
72 |
73 |     def test_init_with_defaults(self):
   |         ^^^^^^^^^^^^^^^^^^^^^^^ ANN201
74 |         """Test initialization with default values."""
75 |         manager = DynamicContentManager()
   |
   = help: Add return type annotation: `None`

tests\models\test_dynamic_content_manager.py:83:9: ANN201 Missing return type annotation for public function `test_invalid_practice_length_too_small`
   |
81 |         assert manager.llm_service is None
82 |
83 |     def test_invalid_practice_length_too_small(self):
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
84 |         """Test validation of practice length (too small)."""
85 |         with pytest.raises(ValueError, match="Practice length must be between 1 and 1000"):
   |
   = help: Add return type annotation: `None`

tests\models\test_dynamic_content_manager.py:85:89: E501 Line too long (91 > 88)
   |
83 |     def test_invalid_practice_length_too_small(self):
84 |         """Test validation of practice length (too small)."""
85 |         with pytest.raises(ValueError, match="Practice length must be between 1 and 1000"):
   |                                                                                         ^^^ E501
86 |             DynamicContentManager(practice_length=0)
   |

tests\models\test_dynamic_content_manager.py:88:9: ANN201 Missing return type annotation for public function `test_invalid_practice_length_too_large`
   |
86 |             DynamicContentManager(practice_length=0)
87 |
88 |     def test_invalid_practice_length_too_large(self):
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
89 |         """Test validation of practice length (too large)."""
90 |         with pytest.raises(ValueError, match="Practice length must be between 1 and 1000"):
   |
   = help: Add return type annotation: `None`

tests\models\test_dynamic_content_manager.py:90:89: E501 Line too long (91 > 88)
   |
88 |     def test_invalid_practice_length_too_large(self):
89 |         """Test validation of practice length (too large)."""
90 |         with pytest.raises(ValueError, match="Practice length must be between 1 and 1000"):
   |                                                                                         ^^^ E501
91 |             DynamicContentManager(practice_length=1001)
   |

tests\models\test_dynamic_content_manager.py:93:9: ANN201 Missing return type annotation for public function `test_invalid_practice_length_type`
   |
91 |             DynamicContentManager(practice_length=1001)
92 |
93 |     def test_invalid_practice_length_type(self):
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
94 |         """Test validation of practice length with non-integer value."""
95 |         with pytest.raises(ValueError, match="Practice length must be an integer"):
   |
   = help: Add return type annotation: `None`

tests\models\test_dynamic_content_manager.py:98:9: ANN201 Missing return type annotation for public function `test_mode_setter_with_string`
    |
 96 |             DynamicContentManager(practice_length="50")  # type: ignore
 97 |
 98 |     def test_mode_setter_with_string(self):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
 99 |         """Test setting mode with a string value."""
100 |         manager = DynamicContentManager()
    |
    = help: Add return type annotation: `None`

tests\models\test_dynamic_content_manager.py:104:9: ANN201 Missing return type annotation for public function `test_mode_setter_with_invalid_string`
    |
102 |         assert manager.mode == ContentMode.NGRAM_ONLY
103 |
104 |     def test_mode_setter_with_invalid_string(self):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
105 |         """Test setting mode with an invalid string value."""
106 |         manager = DynamicContentManager()
    |
    = help: Add return type annotation: `None`

tests\models\test_dynamic_content_manager.py:110:9: ANN201 Missing return type annotation for public function `test_mode_setter_with_enum`
    |
108 |             manager.mode = "InvalidMode"
109 |
110 |     def test_mode_setter_with_enum(self):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
111 |         """Test setting mode with ContentMode enum."""
112 |         manager = DynamicContentManager()
    |
    = help: Add return type annotation: `None`

tests\models\test_dynamic_content_manager.py:120:9: ANN201 Missing return type annotation for public function `test_validate_missing_ngrams`
    |
118 |     """Tests for validation of requirements before content generation."""
119 |
120 |     def test_validate_missing_ngrams(self, basic_manager):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
121 |         """Test validation with missing ngram focus list."""
122 |         basic_manager.ngram_focus_list = []
    |
    = help: Add return type annotation: `None`

tests\models\test_dynamic_content_manager.py:120:44: ANN001 Missing type annotation for function argument `basic_manager`
    |
118 |     """Tests for validation of requirements before content generation."""
119 |
120 |     def test_validate_missing_ngrams(self, basic_manager):
    |                                            ^^^^^^^^^^^^^ ANN001
121 |         """Test validation with missing ngram focus list."""
122 |         basic_manager.ngram_focus_list = []
    |

tests\models\test_dynamic_content_manager.py:126:9: ANN201 Missing return type annotation for public function `test_validate_missing_in_scope_keys`
    |
124 |             basic_manager.generate_content()
125 |
126 |     def test_validate_missing_in_scope_keys(self, basic_manager):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
127 |         """Test validation with missing in-scope keys."""
128 |         basic_manager.in_scope_keys = []
    |
    = help: Add return type annotation: `None`

tests\models\test_dynamic_content_manager.py:126:51: ANN001 Missing type annotation for function argument `basic_manager`
    |
124 |             basic_manager.generate_content()
125 |
126 |     def test_validate_missing_in_scope_keys(self, basic_manager):
    |                                                   ^^^^^^^^^^^^^ ANN001
127 |         """Test validation with missing in-scope keys."""
128 |         basic_manager.in_scope_keys = []
    |

tests\models\test_dynamic_content_manager.py:132:9: ANN201 Missing return type annotation for public function `test_validate_missing_llm_service_for_words_mode`
    |
130 |             basic_manager.generate_content()
131 |
132 |     def test_validate_missing_llm_service_for_words_mode(self):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
133 |         """Test validation for missing LLM service in WordsOnly mode."""
134 |         manager = DynamicContentManager(
    |
    = help: Add return type annotation: `None`

tests\models\test_dynamic_content_manager.py:140:89: E501 Line too long (102 > 88)
    |
138 |         )
139 |
140 |         with pytest.raises(ValueError, match="LLM service is required for WordsOnly and Mixed modes"):
    |                                                                                         ^^^^^^^^^^^^^^ E501
141 |             manager.generate_content()
    |

tests\models\test_dynamic_content_manager.py:143:9: ANN201 Missing return type annotation for public function `test_validate_missing_llm_service_for_mixed_mode`
    |
141 |             manager.generate_content()
142 |
143 |     def test_validate_missing_llm_service_for_mixed_mode(self):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
144 |         """Test validation for missing LLM service in Mixed mode."""
145 |         manager = DynamicContentManager(
    |
    = help: Add return type annotation: `None`

tests\models\test_dynamic_content_manager.py:151:89: E501 Line too long (102 > 88)
    |
149 |         )
150 |
151 |         with pytest.raises(ValueError, match="LLM service is required for WordsOnly and Mixed modes"):
    |                                                                                         ^^^^^^^^^^^^^^ E501
152 |             manager.generate_content()
    |

tests\models\test_dynamic_content_manager.py:158:9: ANN201 Missing return type annotation for public function `test_generate_ngram_content`
    |
156 |     """Tests for NGramOnly content generation mode."""
157 |
158 |     def test_generate_ngram_content(self, basic_manager):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
159 |         """Test generating content with NGramOnly mode."""
160 |         basic_manager.mode = ContentMode.NGRAM_ONLY
    |
    = help: Add return type annotation: `None`

tests\models\test_dynamic_content_manager.py:158:43: ANN001 Missing type annotation for function argument `basic_manager`
    |
156 |     """Tests for NGramOnly content generation mode."""
157 |
158 |     def test_generate_ngram_content(self, basic_manager):
    |                                           ^^^^^^^^^^^^^ ANN001
159 |         """Test generating content with NGramOnly mode."""
160 |         basic_manager.mode = ContentMode.NGRAM_ONLY
    |

tests\models\test_dynamic_content_manager.py:165:89: E501 Line too long (105 > 88)
    |
163 |         # Verify content format and constraints
164 |         assert content, "Content should not be empty"
165 |         assert len(content) <= basic_manager.practice_length, "Content should not exceed practice length"
    |                                                                                         ^^^^^^^^^^^^^^^^^ E501
166 |
167 |         # Verify content only contains ngrams from focus list
    |

tests\models\test_dynamic_content_manager.py:170:89: E501 Line too long (105 > 88)
    |
168 |         parts = content.split()
169 |         for part in parts:
170 |             assert part in basic_manager.ngram_focus_list, f"Part '{part}' should be in ngram focus list"
    |                                                                                         ^^^^^^^^^^^^^^^^^ E501
171 |
172 |     def test_ngram_content_custom_delimiter(self, basic_manager):
    |

tests\models\test_dynamic_content_manager.py:172:9: ANN201 Missing return type annotation for public function `test_ngram_content_custom_delimiter`
    |
170 |             assert part in basic_manager.ngram_focus_list, f"Part '{part}' should be in ngram focus list"
171 |
172 |     def test_ngram_content_custom_delimiter(self, basic_manager):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
173 |         """Test generating NGramOnly content with custom delimiter."""
174 |         basic_manager.mode = ContentMode.NGRAM_ONLY
    |
    = help: Add return type annotation: `None`

tests\models\test_dynamic_content_manager.py:172:51: ANN001 Missing type annotation for function argument `basic_manager`
    |
170 |             assert part in basic_manager.ngram_focus_list, f"Part '{part}' should be in ngram focus list"
171 |
172 |     def test_ngram_content_custom_delimiter(self, basic_manager):
    |                                                   ^^^^^^^^^^^^^ ANN001
173 |         """Test generating NGramOnly content with custom delimiter."""
174 |         basic_manager.mode = ContentMode.NGRAM_ONLY
    |

tests\models\test_dynamic_content_manager.py:181:89: E501 Line too long (94 > 88)
    |
179 |         if delimiter in content:
180 |             parts = content.split(delimiter)
181 |             assert len(parts) > 1, "Content should have multiple parts separated by delimiter"
    |                                                                                         ^^^^^^ E501
182 |
183 |     def test_ngram_content_respects_length_limit(self, basic_manager):
    |

tests\models\test_dynamic_content_manager.py:183:9: ANN201 Missing return type annotation for public function `test_ngram_content_respects_length_limit`
    |
181 |             assert len(parts) > 1, "Content should have multiple parts separated by delimiter"
182 |
183 |     def test_ngram_content_respects_length_limit(self, basic_manager):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
184 |         """Test NGramOnly content respects the practice length limit."""
185 |         basic_manager.mode = ContentMode.NGRAM_ONLY
    |
    = help: Add return type annotation: `None`

tests\models\test_dynamic_content_manager.py:183:56: ANN001 Missing type annotation for function argument `basic_manager`
    |
181 |             assert len(parts) > 1, "Content should have multiple parts separated by delimiter"
182 |
183 |     def test_ngram_content_respects_length_limit(self, basic_manager):
    |                                                        ^^^^^^^^^^^^^ ANN001
184 |         """Test NGramOnly content respects the practice length limit."""
185 |         basic_manager.mode = ContentMode.NGRAM_ONLY
    |

tests\models\test_dynamic_content_manager.py:191:9: ANN201 Missing return type annotation for public function `test_ngram_content_filters_out_of_scope_chars`
    |
189 |         assert len(content) <= 10, "Content length should not exceed practice_length"
190 |
191 |     def test_ngram_content_filters_out_of_scope_chars(self):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
192 |         """Test that NGramOnly content filters out ngrams with out-of-scope characters."""
193 |         manager = DynamicContentManager(
    |
    = help: Add return type annotation: `None`

tests\models\test_dynamic_content_manager.py:192:89: E501 Line too long (90 > 88)
    |
191 |     def test_ngram_content_filters_out_of_scope_chars(self):
192 |         """Test that NGramOnly content filters out ngrams with out-of-scope characters."""
    |                                                                                         ^^ E501
193 |         manager = DynamicContentManager(
194 |             in_scope_keys=["a", "b"],
    |

tests\models\test_dynamic_content_manager.py:202:89: E501 Line too long (104 > 88)
    |
201 |         # Content should only include "ab"
202 |         assert content == "ab" or content == "", "Content should only include ngrams with in-scope keys"
    |                                                                                         ^^^^^^^^^^^^^^^^ E501
    |

tests\models\test_dynamic_content_manager.py:208:9: ANN201 Missing return type annotation for public function `test_generate_words_content`
    |
206 |     """Tests for WordsOnly content generation mode."""
207 |
208 |     def test_generate_words_content(self, basic_manager):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
209 |         """Test generating content with WordsOnly mode."""
210 |         basic_manager.mode = ContentMode.WORDS_ONLY
    |
    = help: Add return type annotation: `None`

tests\models\test_dynamic_content_manager.py:208:43: ANN001 Missing type annotation for function argument `basic_manager`
    |
206 |     """Tests for WordsOnly content generation mode."""
207 |
208 |     def test_generate_words_content(self, basic_manager):
    |                                           ^^^^^^^^^^^^^ ANN001
209 |         """Test generating content with WordsOnly mode."""
210 |         basic_manager.mode = ContentMode.WORDS_ONLY
    |

tests\models\test_dynamic_content_manager.py:217:89: E501 Line too long (105 > 88)
    |
215 |         # Verify content format and constraints
216 |         assert content, "Content should not be empty"
217 |         assert len(content) <= basic_manager.practice_length, "Content should not exceed practice length"
    |                                                                                         ^^^^^^^^^^^^^^^^^ E501
218 |
219 |         # Verify content contains words with the ngrams
    |

tests\models\test_dynamic_content_manager.py:229:9: ANN201 Missing return type annotation for public function `test_words_content_filters_out_of_scope_chars`
    |
227 |         assert ngram_found, "Content should include words containing the ngrams"
228 |
229 |     def test_words_content_filters_out_of_scope_chars(self, mock_llm_service):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
230 |         """Test that WordsOnly content filters out words with out-of-scope characters."""
231 |         # Create a custom mock that returns words with both in-scope and out-of-scope characters
    |
    = help: Add return type annotation: `None`

tests\models\test_dynamic_content_manager.py:229:61: ANN001 Missing type annotation for function argument `mock_llm_service`
    |
227 |         assert ngram_found, "Content should include words containing the ngrams"
228 |
229 |     def test_words_content_filters_out_of_scope_chars(self, mock_llm_service):
    |                                                             ^^^^^^^^^^^^^^^^ ANN001
230 |         """Test that WordsOnly content filters out words with out-of-scope characters."""
231 |         # Create a custom mock that returns words with both in-scope and out-of-scope characters
    |

tests\models\test_dynamic_content_manager.py:230:89: E501 Line too long (89 > 88)
    |
229 |     def test_words_content_filters_out_of_scope_chars(self, mock_llm_service):
230 |         """Test that WordsOnly content filters out words with out-of-scope characters."""
    |                                                                                         ^ E501
231 |         # Create a custom mock that returns words with both in-scope and out-of-scope characters
232 |         custom_mock = MockLLMNgramService()
    |

tests\models\test_dynamic_content_manager.py:231:89: E501 Line too long (96 > 88)
    |
229 |     def test_words_content_filters_out_of_scope_chars(self, mock_llm_service):
230 |         """Test that WordsOnly content filters out words with out-of-scope characters."""
231 |         # Create a custom mock that returns words with both in-scope and out-of-scope characters
    |                                                                                         ^^^^^^^^ E501
232 |         custom_mock = MockLLMNgramService()
    |

tests\models\test_dynamic_content_manager.py:252:9: ANN201 Missing return type annotation for public function `test_words_content_custom_delimiter`
    |
250 |                     f"Word '{word}' contains out-of-scope characters"
251 |
252 |     def test_words_content_custom_delimiter(self, basic_manager):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
253 |         """Test generating WordsOnly content with custom delimiter."""
254 |         basic_manager.mode = ContentMode.WORDS_ONLY
    |
    = help: Add return type annotation: `None`

tests\models\test_dynamic_content_manager.py:252:51: ANN001 Missing type annotation for function argument `basic_manager`
    |
250 |                     f"Word '{word}' contains out-of-scope characters"
251 |
252 |     def test_words_content_custom_delimiter(self, basic_manager):
    |                                                   ^^^^^^^^^^^^^ ANN001
253 |         """Test generating WordsOnly content with custom delimiter."""
254 |         basic_manager.mode = ContentMode.WORDS_ONLY
    |

tests\models\test_dynamic_content_manager.py:261:89: E501 Line too long (94 > 88)
    |
259 |         if delimiter in content:
260 |             parts = content.split(delimiter)
261 |             assert len(parts) > 1, "Content should have multiple parts separated by delimiter"
    |                                                                                         ^^^^^^ E501
    |

tests\models\test_dynamic_content_manager.py:267:9: ANN201 Missing return type annotation for public function `test_generate_mixed_content`
    |
265 |     """Tests for Mixed content generation mode."""
266 |
267 |     def test_generate_mixed_content(self, basic_manager):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
268 |         """Test generating content with Mixed mode."""
269 |         basic_manager.mode = ContentMode.MIXED
    |
    = help: Add return type annotation: `None`

tests\models\test_dynamic_content_manager.py:267:43: ANN001 Missing type annotation for function argument `basic_manager`
    |
265 |     """Tests for Mixed content generation mode."""
266 |
267 |     def test_generate_mixed_content(self, basic_manager):
    |                                           ^^^^^^^^^^^^^ ANN001
268 |         """Test generating content with Mixed mode."""
269 |         basic_manager.mode = ContentMode.MIXED
    |

tests\models\test_dynamic_content_manager.py:277:89: E501 Line too long (105 > 88)
    |
275 |         # Verify content format and constraints
276 |         assert content, "Content should not be empty"
277 |         assert len(content) <= basic_manager.practice_length, "Content should not exceed practice length"
    |                                                                                         ^^^^^^^^^^^^^^^^^ E501
278 |
279 |     def test_mixed_content_has_variety(self, basic_manager):
    |

tests\models\test_dynamic_content_manager.py:279:9: ANN201 Missing return type annotation for public function `test_mixed_content_has_variety`
    |
277 |         assert len(content) <= basic_manager.practice_length, "Content should not exceed practice length"
278 |
279 |     def test_mixed_content_has_variety(self, basic_manager):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
280 |         """Test that Mixed content includes both ngrams and words."""
281 |         # This test is a bit tricky since the mixed content is randomized
    |
    = help: Add return type annotation: `None`

tests\models\test_dynamic_content_manager.py:279:46: ANN001 Missing type annotation for function argument `basic_manager`
    |
277 |         assert len(content) <= basic_manager.practice_length, "Content should not exceed practice length"
278 |
279 |     def test_mixed_content_has_variety(self, basic_manager):
    |                                              ^^^^^^^^^^^^^ ANN001
280 |         """Test that Mixed content includes both ngrams and words."""
281 |         # This test is a bit tricky since the mixed content is randomized
    |

tests\models\test_keyboard.py:26:89: E501 Line too long (90 > 88)
   |
25 | def test_keyboard_name_strip() -> None:
26 |     k = Keyboard(keyboard_id=str(uuid4()), user_id=str(uuid4()), keyboard_name="  Test  ")
   |                                                                                         ^^ E501
27 |     assert k.keyboard_name == "Test"
   |

tests\models\test_keyboard.py:56:89: E501 Line too long (96 > 88)
   |
54 |             target_ms_per_keystroke=49,
55 |         )
56 |     assert "Target milliseconds per keystroke must be between 50 and 5000" in str(excinfo.value)
   |                                                                                         ^^^^^^^^ E501
   |

tests\models\test_keyboard.py:68:89: E501 Line too long (96 > 88)
   |
66 |             target_ms_per_keystroke=5001,
67 |         )
68 |     assert "Target milliseconds per keystroke must be between 50 and 5000" in str(excinfo.value)
   |                                                                                         ^^^^^^^^ E501
   |

tests\models\test_keyboard.py:73:44: F841 Local variable `excinfo` is assigned to but never used
   |
71 | def test_keyboard_target_ms_none() -> None:
72 |     # Test that validator rejects None values
73 |     with pytest.raises(ValidationError) as excinfo:
   |                                            ^^^^^^^ F841
74 |         # We need to use a dict and model_validate to bypass Pydantic's type checking
75 |         # and test our explicit None validator
   |
   = help: Remove assignment to unused variable `excinfo`

tests\models\test_keyboard_manager.py:1:1: I001 [*] Import block is un-sorted or un-formatted
   |
 1 | / from pathlib import Path
 2 | | from typing import Generator
 3 | | from uuid import uuid4
 4 | |
 5 | | import pytest
 6 | | from pydantic import ValidationError
 7 | |
 8 | | from db.database_manager import DatabaseManager
 9 | | from models.keyboard import Keyboard
10 | | from models.keyboard_manager import KeyboardManager, KeyboardNotFound, KeyboardValidationError
   | |______________________________________________________________________________________________^ I001
   |
   = help: Organize imports

tests\models\test_keyboard_manager.py:10:89: E501 Line too long (94 > 88)
   |
 8 | from db.database_manager import DatabaseManager
 9 | from models.keyboard import Keyboard
10 | from models.keyboard_manager import KeyboardManager, KeyboardNotFound, KeyboardValidationError
   |                                                                                         ^^^^^^ E501
   |

tests\models\test_keyboard_manager.py:20:89: E501 Line too long (94 > 88)
   |
18 |     user_id = str(uuid4())
19 |     db.execute(
20 |         "INSERT INTO users (user_id, first_name, surname, email_address) VALUES (?, ?, ?, ?)",
   |                                                                                         ^^^^^^ E501
21 |         (user_id, "Test", "User", "test@example.com"),
22 |     )
   |

tests\models\test_keyboard_manager.py:32:89: E501 Line too long (97 > 88)
   |
32 | def test_create_keyboard(keyboard_manager: KeyboardManager, db_manager: DatabaseManager) -> None:
   |                                                                                         ^^^^^^^^^ E501
33 |     user_id = db_manager.fetchall("SELECT user_id FROM users")[0]["user_id"]
34 |     k = Keyboard(user_id=user_id, keyboard_name="Alpha")
   |

tests\models\test_keyboard_manager.py:42:89: E501 Line too long (94 > 88)
   |
42 | def test_get_keyboard(keyboard_manager: KeyboardManager, db_manager: DatabaseManager) -> None:
   |                                                                                         ^^^^^^ E501
43 |     user_id = db_manager.fetchall("SELECT user_id FROM users")[0]["user_id"]
44 |     k = Keyboard(user_id=user_id, keyboard_name="Beta")
   |

tests\models\test_keyboard_manager.py:76:89: E501 Line too long (90 > 88)
   |
75 |     # Create keyboard with default target speed (100)
76 |     k = Keyboard(user_id=user_id, keyboard_name="Speed Test", target_ms_per_keystroke=100)
   |                                                                                         ^^ E501
77 |     keyboard_manager.save_keyboard(k)
   |

tests\models\test_keyboard_manager.py:96:89: E501 Line too long (97 > 88)
   |
96 | def test_delete_keyboard(keyboard_manager: KeyboardManager, db_manager: DatabaseManager) -> None:
   |                                                                                         ^^^^^^^^^ E501
97 |     user_id = db_manager.fetchall("SELECT user_id FROM users")[0]["user_id"]
98 |     k = Keyboard(user_id=user_id, keyboard_name="Zeta")
   |

tests\models\test_keystroke.py:40:89: E501 Line too long (100 > 88)
   |
38 |     """Test Keystroke model creation and validation."""
39 |
40 |     def test_keystroke_creation_with_valid_data(self, valid_keystroke_data: Dict[str, Any]) -> None:
   |                                                                                         ^^^^^^^^^^^^ E501
41 |         """Test creating a Keystroke with valid data."""
42 |         keystroke = Keystroke(**valid_keystroke_data)
   |

tests\models\test_keystroke.py:47:89: E501 Line too long (91 > 88)
   |
45 |         assert keystroke.expected_char == valid_keystroke_data["expected_char"]
46 |         assert keystroke.is_error == valid_keystroke_data["is_error"]
47 |         assert keystroke.time_since_previous == valid_keystroke_data["time_since_previous"]
   |                                                                                         ^^^ E501
48 |
49 |     def test_keystroke_creation_with_defaults(self) -> None:
   |

tests\models\test_keystroke.py:92:89: E501 Line too long (91 > 88)
   |
90 |     """Test Keystroke.from_dict method for various data types and edge cases."""
91 |
92 |     def test_from_dict_with_valid_data(self, valid_keystroke_data: Dict[str, Any]) -> None:
   |                                                                                         ^^^ E501
93 |         """Test from_dict with completely valid data."""
94 |         keystroke = Keystroke.from_dict(valid_keystroke_data)
   |

tests\models\test_keystroke.py:131:89: E501 Line too long (98 > 88)
    |
129 |     def test_from_dict_invalid_datetime_string(self) -> None:
130 |         """Test from_dict with invalid datetime string falls back to current time."""
131 |         data = {"keystroke_time": "not-a-valid-date", "keystroke_char": "z", "expected_char": "z"}
    |                                                                                         ^^^^^^^^^^ E501
132 |         before = datetime.datetime.now()
133 |         keystroke = Keystroke.from_dict(data)
    |

tests\models\test_keystroke.py:164:89: E501 Line too long (94 > 88)
    |
162 |         ],
163 |     )
164 |     def test_from_dict_is_error_string_values(self, error_value: str, expected: bool) -> None:
    |                                                                                         ^^^^^^ E501
165 |         """Test from_dict with various string values for is_error."""
166 |         data = {"is_error": error_value, "keystroke_char": "a", "expected_char": "a"}
    |

tests\models\test_keystroke.py:179:89: E501 Line too long (95 > 88)
    |
177 |         ],
178 |     )
179 |     def test_from_dict_is_error_integer_values(self, error_value: int, expected: bool) -> None:
    |                                                                                         ^^^^^^^ E501
180 |         """Test from_dict with integer values for is_error."""
181 |         data = {"is_error": error_value, "keystroke_char": "a", "expected_char": "a"}
    |

tests\models\test_keystroke.py:199:89: E501 Line too long (97 > 88)
    |
197 |     def test_from_dict_session_id_invalid_conversion(self) -> None:
198 |         """Test from_dict handles invalid session_id conversion gracefully."""
199 |         data = {"session_id": {"invalid": "object"}, "keystroke_char": "a", "expected_char": "a"}
    |                                                                                         ^^^^^^^^^ E501
200 |         keystroke = Keystroke.from_dict(data)
201 |         assert keystroke.session_id is None
    |

tests\models\test_keystroke.py:211:89: E501 Line too long (99 > 88)
    |
209 |     def test_from_dict_keystroke_id_invalid_conversion(self) -> None:
210 |         """Test from_dict handles invalid keystroke_id conversion gracefully."""
211 |         data = {"keystroke_id": {"invalid": "object"}, "keystroke_char": "a", "expected_char": "a"}
    |                                                                                         ^^^^^^^^^^^ E501
212 |         keystroke = Keystroke.from_dict(data)
213 |         # Should fallback to a UUID string
    |

tests\models\test_keystroke.py:255:89: E501 Line too long (91 > 88)
    |
253 |     def test_to_dict_with_none_values(self) -> None:
254 |         """Test to_dict with None values."""
255 |         keystroke = Keystroke(session_id=None, keystroke_id=None, time_since_previous=None)
    |                                                                                         ^^^ E501
256 |         result = keystroke.to_dict()
257 |         assert result["session_id"] is None
    |

tests\models\test_keystroke_manager.py:6:89: E501 Line too long (89 > 88)
  |
4 | This module provides extensive test coverage for the KeystrokeManager class,
5 | including all methods, edge cases, error conditions, and integration scenarios.
6 | Tests aim for >95% coverage and validate the manager's behavior under various conditions.
  |                                                                                         ^ E501
7 | """
  |

tests\models\test_keystroke_manager.py:140:89: E501 Line too long (92 > 88)
    |
138 |         """Test successful retrieval of keystrokes for a session."""
139 |         session_id = "test-session-456"
140 |         mock_keystrokes = [Mock(spec=Keystroke), Mock(spec=Keystroke), Mock(spec=Keystroke)]
    |                                                                                         ^^^^ E501
141 |         mock_get_for_session.return_value = mock_keystrokes
    |

tests\models\test_keystroke_manager.py:256:89: E501 Line too long (94 > 88)
    |
254 |             assert params[6] == sample_keystrokes[i].time_since_previous
255 |
256 |     def test_save_keystrokes_empty_list(self, manager_with_mock_db: KeystrokeManager) -> None:
    |                                                                                         ^^^^^^ E501
257 |         """Test saving when keystroke list is empty."""
258 |         manager_with_mock_db.keystroke_list = []
    |

tests\models\test_keystroke_manager.py:373:89: E501 Line too long (97 > 88)
    |
371 |         )
372 |
373 |     def test_delete_all_keystrokes_success(self, manager_with_mock_db: KeystrokeManager) -> None:
    |                                                                                         ^^^^^^^^^ E501
374 |         """Test successful deletion of all keystrokes."""
375 |         result = manager_with_mock_db.delete_all_keystrokes()
    |

tests\models\test_keystroke_manager.py:386:89: E501 Line too long (92 > 88)
    |
384 |     ) -> None:
385 |         """Test handling of database errors during delete all."""
386 |         manager_with_mock_db.db_manager.execute.side_effect = Exception("Delete all failed")
    |                                                                                         ^^^^ E501
387 |
388 |         with patch("builtins.print"):
    |

tests\models\test_keystroke_manager.py:414:89: E501 Line too long (96 > 88)
    |
412 |         return KeystrokeManager(db_manager=mock_db)
413 |
414 |     def test_count_keystrokes_dict_result(self, manager_with_mock_db: KeystrokeManager) -> None:
    |                                                                                         ^^^^^^^^ E501
415 |         """Test counting with dict-like result (Row object)."""
416 |         session_id = "count-test-session"
    |

tests\models\test_keystroke_manager.py:432:89: E501 Line too long (97 > 88)
    |
430 |         )
431 |
432 |     def test_count_keystrokes_tuple_result(self, manager_with_mock_db: KeystrokeManager) -> None:
    |                                                                                         ^^^^^^^^^ E501
433 |         """Test counting with tuple result."""
434 |         session_id = "tuple-test-session"
    |

tests\models\test_keystroke_manager.py:441:89: E501 Line too long (96 > 88)
    |
439 |         assert result == 15
440 |
441 |     def test_count_keystrokes_zero_result(self, manager_with_mock_db: KeystrokeManager) -> None:
    |                                                                                         ^^^^^^^^ E501
442 |         """Test counting when result is zero."""
443 |         session_id = "zero-session"
    |

tests\models\test_keystroke_manager.py:451:89: E501 Line too long (96 > 88)
    |
449 |         assert result == 0
450 |
451 |     def test_count_keystrokes_none_result(self, manager_with_mock_db: KeystrokeManager) -> None:
    |                                                                                         ^^^^^^^^ E501
452 |         """Test counting when database returns None."""
453 |         session_id = "none-session"
    |

tests\models\test_keystroke_manager.py:472:89: E501 Line too long (99 > 88)
    |
470 |         assert result == 0
471 |
472 |     def test_count_keystrokes_database_error(self, manager_with_mock_db: KeystrokeManager) -> None:
    |                                                                                         ^^^^^^^^^^^ E501
473 |         """Test handling of database errors during count."""
474 |         session_id = "error-session"
    |

tests\models\test_keystroke_manager.py:502:89: E501 Line too long (100 > 88)
    |
500 |         assert result == 0
501 |
502 |     def test_count_keystrokes_uuid_session_id(self, manager_with_mock_db: KeystrokeManager) -> None:
    |                                                                                         ^^^^^^^^^^^^ E501
503 |         """Test counting with UUID session ID."""
504 |         session_id = str(uuid.uuid4())
    |

tests\models\test_keystroke_manager.py:551:89: E501 Line too long (90 > 88)
    |
549 |         return KeystrokeManager(db_manager=db)
550 |
551 |     def test_full_keystroke_workflow(self, integration_manager: KeystrokeManager) -> None:
    |                                                                                         ^^ E501
552 |         """Test complete workflow: add, save, count, retrieve, delete."""
553 |         import uuid
    |

tests\models\test_keystroke_manager.py:571:89: E501 Line too long (99 > 88)
    |
569 |                 is_error INTEGER NOT NULL,
570 |                 time_since_previous INTEGER,
571 |                 FOREIGN KEY (session_id) REFERENCES practice_sessions(session_id) ON DELETE CASCADE
    |                                                                                         ^^^^^^^^^^^ E501
572 |             )
573 |             """
    |

tests\models\test_keystroke_manager.py:587:89: E501 Line too long (89 > 88)
    |
585 |         db.execute(
586 |             """
587 |             INSERT INTO snippets (snippet_id, category_id, snippet_name) VALUES (?, ?, ?)
    |                                                                                         ^ E501
588 |             """,
589 |             (snippet_id, category_id, "integration-snippet"),
    |

tests\models\test_keystroke_manager.py:594:89: E501 Line too long (98 > 88)
    |
592 |         keyboard_id = str(uuid.uuid4())
593 |         db.execute(
594 |             "INSERT INTO users (user_id, first_name, surname, email_address) VALUES (?, ?, ?, ?)",
    |                                                                                         ^^^^^^^^^^ E501
595 |             (user_id, "Test", "User", f"testuser_{user_id[:8]}@example.com"),
596 |         )
    |

tests\models\test_keystroke_manager.py:598:89: E501 Line too long (91 > 88)
    |
596 |         )
597 |         db.execute(
598 |             "INSERT INTO keyboards (keyboard_id, user_id, keyboard_name) VALUES (?, ?, ?)",
    |                                                                                         ^^^ E501
599 |             (keyboard_id, user_id, "Test Keyboard"),
600 |         )
    |

tests\models\test_keystroke_manager.py:602:89: E501 Line too long (246 > 88)
    |
600 | ΓÇª
601 | ΓÇª
602 | ΓÇªrd_id, snippet_index_start, snippet_index_end, content, start_time, end_time, actual_chars, errors, ms_per_keystroke) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)",
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
603 | ΓÇª
604 | ΓÇª
    |

tests\models\test_keystroke_manager.py:649:89: E501 Line too long (89 > 88)
    |
647 |         assert delete_result is True
648 |         # Verify deletion
649 |         count_after_delete = integration_manager.count_keystrokes_per_session(session_id)
    |                                                                                         ^ E501
650 |         assert count_after_delete == 0
    |

tests\models\test_keystroke_manager.py:652:89: E501 Line too long (94 > 88)
    |
650 |         assert count_after_delete == 0
651 |
652 |     def test_concurrent_session_handling(self, integration_manager: KeystrokeManager) -> None:
    |                                                                                         ^^^^^^ E501
653 |         """Test handling multiple sessions concurrently."""
654 |         db = integration_manager.db_manager
    |

tests\models\test_keystroke_manager.py:662:89: E501 Line too long (98 > 88)
    |
660 |         keyboard_id = str(uuid.uuid4())
661 |         db.execute(
662 |             "INSERT INTO users (user_id, first_name, surname, email_address) VALUES (?, ?, ?, ?)",
    |                                                                                         ^^^^^^^^^^ E501
663 |             (user_id, "Test", "User", f"testuser_{user_id[:8]}@example.com"),
664 |         )
    |

tests\models\test_keystroke_manager.py:666:89: E501 Line too long (91 > 88)
    |
664 |         )
665 |         db.execute(
666 |             "INSERT INTO keyboards (keyboard_id, user_id, keyboard_name) VALUES (?, ?, ?)",
    |                                                                                         ^^^ E501
667 |             (keyboard_id, user_id, "Test Keyboard"),
668 |         )
    |

tests\models\test_keystroke_manager.py:680:89: E501 Line too long (96 > 88)
    |
678 |             )
679 |             db.execute(
680 |                 "INSERT INTO snippets (snippet_id, category_id, snippet_name) VALUES (?, ?, ?)",
    |                                                                                         ^^^^^^^^ E501
681 |                 (snippet_id, category_id, f"TestSnippet_{session_id}"),
682 |             )
    |

tests\models\test_keystroke_manager.py:684:89: E501 Line too long (250 > 88)
    |
682 | ΓÇª
683 | ΓÇª
684 | ΓÇªnippet_id, snippet_index_start, snippet_index_end, content, start_time, end_time, actual_chars, errors, ms_per_keystroke) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)",
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
685 | ΓÇª
686 | ΓÇª
    |

tests\models\test_keystroke_manager.py:1049:89: E501 Line too long (94 > 88)
     |
1047 |     user_id = str(uuid.uuid4())
1048 |     db.execute(
1049 |         "INSERT INTO users (user_id, first_name, surname, email_address) VALUES (?, ?, ?, ?)",
     |                                                                                         ^^^^^^ E501
1050 |         (user_id, f"user_{user_id}", f"user_{user_id}@example.com"),
1051 |     )
     |

tests\models\test_keystroke_manager.py:1070:89: E501 Line too long (92 > 88)
     |
1069 | @pytest.fixture(scope="module")
1070 | def test_session(request: pytest.FixtureRequest, test_user: str, test_keyboard: str) -> str:
     |                                                                                         ^^^^ E501
1071 |     db: DatabaseManager = getattr(request, "db", None)
1072 |     if db is None:
     |

tests\models\test_llm_ngram_service.py:1:1: I001 [*] Import block is un-sorted or un-formatted
  |
1 | / from unittest.mock import MagicMock, patch
2 | | from typing import Any, Dict
3 | | import pytest
4 | |
5 | | from models.llm_ngram_service import LLMMissingAPIKeyError, LLMNgramService
  | |___________________________________________________________________________^ I001
  |
  = help: Organize imports

tests\models\test_llm_ngram_service.py:2:20: F401 [*] `typing.Any` imported but unused
  |
1 | from unittest.mock import MagicMock, patch
2 | from typing import Any, Dict
  |                    ^^^ F401
3 | import pytest
  |
  = help: Remove unused import

tests\models\test_llm_ngram_service.py:2:25: F401 [*] `typing.Dict` imported but unused
  |
1 | from unittest.mock import MagicMock, patch
2 | from typing import Any, Dict
  |                         ^^^^ F401
3 | import pytest
  |
  = help: Remove unused import

tests\models\test_llm_ngram_service.py:8:5: ANN201 Missing return type annotation for public function `test_missing_api_key`
   |
 8 | def test_missing_api_key():
   |     ^^^^^^^^^^^^^^^^^^^^ ANN201
 9 |     with pytest.raises(LLMMissingAPIKeyError):
10 |         LLMNgramService(api_key=None)  # type: ignore
   |
   = help: Add return type annotation: `None`

tests\models\test_llm_ngram_service.py:13:5: ANN201 Missing return type annotation for public function `test_invalid_ngrams`
   |
13 | def test_invalid_ngrams():
   |     ^^^^^^^^^^^^^^^^^^^ ANN201
14 |     svc = LLMNgramService(api_key="sk-test")
15 |     with pytest.raises(ValueError):
   |
   = help: Add return type annotation: `None`

tests\models\test_next_session_position.py:18:1: E402 Module level import not at top of file
   |
16 |     sys.path.insert(0, project_root)
17 |
18 | from db.database_manager import DatabaseManager
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
19 | from models.session import Session
20 | from models.session_manager import SessionManager
   |

tests\models\test_next_session_position.py:19:1: E402 Module level import not at top of file
   |
18 | from db.database_manager import DatabaseManager
19 | from models.session import Session
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
20 | from models.session_manager import SessionManager
   |

tests\models\test_next_session_position.py:20:1: E402 Module level import not at top of file
   |
18 | from db.database_manager import DatabaseManager
19 | from models.session import Session
20 | from models.session_manager import SessionManager
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
   |

tests\models\test_next_session_position.py:24:5: ANN201 Missing return type annotation for public function `temp_db`
   |
23 | @pytest.fixture
24 | def temp_db():
   |     ^^^^^^^ ANN201
25 |     """Create a temporary in-memory database for testing."""
26 |     db_manager = DatabaseManager(":memory:")
   |
   = help: Add return type annotation

tests\models\test_next_session_position.py:47:89: E501 Line too long (89 > 88)
   |
45 |     db_manager.execute(
46 |         "INSERT INTO snippet_parts (snippet_id, part_number, content) VALUES (?, ?, ?)",
47 |         (snippet_id, 1, "This is a test snippet that is exactly fifty characters long."),
   |                                                                                         ^ E501
48 |     )
   |

tests\models\test_next_session_position.py:53:89: E501 Line too long (94 > 88)
   |
51 |     user_id = str(uuid.uuid4())
52 |     db_manager.execute(
53 |         "INSERT INTO users (user_id, first_name, surname, email_address) VALUES (?, ?, ?, ?)",
   |                                                                                         ^^^^^^ E501
54 |         (user_id, "Test", "User", f"testuser_{user_id[:8]}@example.com"),
55 |     )
   |

tests\models\test_next_session_position.py:71:89: E501 Line too long (91 > 88)
   |
69 |         "session_manager": session_manager,
70 |         "snippet_id": snippet_id,
71 |         "snippet_content": "This is a test snippet that is exactly fifty characters long.",
   |                                                                                         ^^^ E501
72 |         "user_id": user_id,
73 |         "keyboard_id": keyboard_id,
   |

tests\models\test_next_session_position.py:119:89: E501 Line too long (99 > 88)
    |
118 | def test_get_next_position_wrap_around(temp_db: dict) -> None:
119 |     """Test that next position wraps to 0 when the last session ended at the end of the snippet."""
    |                                                                                         ^^^^^^^^^^^ E501
120 |     session_manager = temp_db["session_manager"]
121 |     snippet_id = temp_db["snippet_id"]
    |

tests\models\test_next_session_position.py:151:5: F841 Local variable `snippet_length` is assigned to but never used
    |
149 |     session_manager = temp_db["session_manager"]
150 |     snippet_id = temp_db["snippet_id"]
151 |     snippet_length = len(temp_db["snippet_content"])
    |     ^^^^^^^^^^^^^^ F841
152 |
153 |     # Create a session with end position beyond actual snippet length (simulating content change)
    |
    = help: Remove assignment to unused variable `snippet_length`

tests\models\test_next_session_position.py:153:89: E501 Line too long (97 > 88)
    |
151 |     snippet_length = len(temp_db["snippet_content"])
152 |
153 |     # Create a session with end position beyond actual snippet length (simulating content change)
    |                                                                                         ^^^^^^^^^ E501
154 |     session = Session(
155 |         session_id=str(uuid.uuid4()),
    |

tests\models\test_ngram_clean.py:64:89: E501 Line too long (89 > 88)
   |
62 |     ),
63 |     # Size 1 n-grams are not allowed per specification (ignored)
64 |     ([Keystroke(char="z", expected="z", timestamp=T0)], 1, [], "1char ignored per spec"),
   |                                                                                         ^ E501
65 |     # Not clean: Contains error
66 |     (
   |

tests\models\test_ngram_clean.py:244:89: E501 Line too long (94 > 88)
    |
242 |     ),
243 |     # Size 1 n-grams are not allowed per specification (ignored)
244 |     ([Keystroke(char="a", expected="a", timestamp=T10K_US)], 1, [], "1char ignored per spec"),
    |                                                                                         ^^^^^^ E501
245 |     (
246 |         [
    |

tests\models\test_ngram_clean.py:344:89: E501 Line too long (94 > 88)
    |
343 | @pytest.mark.parametrize(
344 |     "keystrokes, ngram_size, expected_clean_ngram_texts, description", CLEAN_STATUS_TEST_CASES
    |                                                                                         ^^^^^^ E501
345 | )
346 | def test_ngram_clean_status(
    |

tests\models\test_ngram_clean.py:355:89: E501 Line too long (92 > 88)
    |
353 |     ngram_manager = NGramManager(db_manager=None)
354 |     # Instantiate real NGramManager
355 |     generated_ngrams = ngram_manager.generate_ngrams_from_keystrokes(keystrokes, ngram_size)
    |                                                                                         ^^^^ E501
356 |
357 |     clean_ngram_texts_generated = [ngram.text for ngram in generated_ngrams if ngram.is_clean]
    |

tests\models\test_ngram_clean.py:357:89: E501 Line too long (94 > 88)
    |
355 |     generated_ngrams = ngram_manager.generate_ngrams_from_keystrokes(keystrokes, ngram_size)
356 |
357 |     clean_ngram_texts_generated = [ngram.text for ngram in generated_ngrams if ngram.is_clean]
    |                                                                                         ^^^^^^ E501
358 |
359 |     sorted_generated = sorted(clean_ngram_texts_generated)
    |

tests\models\test_ngram_clean.py:362:89: E501 Line too long (91 > 88)
    |
360 |     sorted_expected = sorted(expected_clean_ngram_texts)
361 |     assert sorted_generated == sorted_expected, (
362 |         f"FAIL: {description}. EXP_CLEAN: {sorted_expected}, GOT_CLEAN: {sorted_generated}"
    |                                                                                         ^^^ E501
363 |     )
    |

tests\models\test_ngram_error.py:11:89: E501 Line too long (89 > 88)
   |
 9 | from db.database_manager import DatabaseManager
10 |
11 | # Test cases: (keystrokes, ngram_size, expected_ngram_texts_with_error_true, description)
   |                                                                                         ^ E501
12 | # We expect a list of texts for ngrams where is_error should be True.
13 | # Rule: is_error is True if an error exists ONLY in the last position of the ngram's keystrokes.
   |

tests\models\test_ngram_error.py:13:89: E501 Line too long (96 > 88)
   |
11 | # Test cases: (keystrokes, ngram_size, expected_ngram_texts_with_error_true, description)
12 | # We expect a list of texts for ngrams where is_error should be True.
13 | # Rule: is_error is True if an error exists ONLY in the last position of the ngram's keystrokes.
   |                                                                                         ^^^^^^^^ E501
14 | ERROR_STATUS_TEST_CASES: List[Tuple[List[Keystroke], int, List[str], str]] = [
15 |     # Basic cases for is_error = True (error ONLY at the end)
   |

tests\models\test_ngram_error.py:18:89: E501 Line too long (91 > 88)
   |
16 |     (
17 |         [
18 |             Keystroke(char="a", expected="a", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
   |                                                                                         ^^^ E501
19 |             Keystroke(char="x", expected="b", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
20 |         ],
   |

tests\models\test_ngram_error.py:19:89: E501 Line too long (96 > 88)
   |
17 |         [
18 |             Keystroke(char="a", expected="a", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
19 |             Keystroke(char="x", expected="b", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
   |                                                                                         ^^^^^^^^ E501
20 |         ],
21 |         2,
   |

tests\models\test_ngram_error.py:27:89: E501 Line too long (91 > 88)
   |
25 |     (
26 |         [
27 |             Keystroke(char="c", expected="c", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
   |                                                                                         ^^^ E501
28 |             Keystroke(char="a", expected="a", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
29 |             Keystroke(char="X", expected="t", timestamp=datetime(2023, 1, 1, 12, 0, 0, 200000)),
   |

tests\models\test_ngram_error.py:28:89: E501 Line too long (96 > 88)
   |
26 |         [
27 |             Keystroke(char="c", expected="c", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
28 |             Keystroke(char="a", expected="a", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
   |                                                                                         ^^^^^^^^ E501
29 |             Keystroke(char="X", expected="t", timestamp=datetime(2023, 1, 1, 12, 0, 0, 200000)),
30 |         ],
   |

tests\models\test_ngram_error.py:29:89: E501 Line too long (96 > 88)
   |
27 |             Keystroke(char="c", expected="c", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
28 |             Keystroke(char="a", expected="a", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
29 |             Keystroke(char="X", expected="t", timestamp=datetime(2023, 1, 1, 12, 0, 0, 200000)),
   |                                                                                         ^^^^^^^^ E501
30 |         ],
31 |         3,
   |

tests\models\test_ngram_error.py:38:89: E501 Line too long (91 > 88)
   |
36 |     (
37 |         [
38 |             Keystroke(char="a", expected="a", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
   |                                                                                         ^^^ E501
39 |             Keystroke(char="b", expected="b", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
40 |         ],
   |

tests\models\test_ngram_error.py:39:89: E501 Line too long (96 > 88)
   |
37 |         [
38 |             Keystroke(char="a", expected="a", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
39 |             Keystroke(char="b", expected="b", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
   |                                                                                         ^^^^^^^^ E501
40 |         ],
41 |         2,
   |

tests\models\test_ngram_error.py:47:89: E501 Line too long (91 > 88)
   |
45 |     (
46 |         [
47 |             Keystroke(char="c", expected="c", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
   |                                                                                         ^^^ E501
48 |             Keystroke(char="a", expected="a", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
49 |             Keystroke(char="t", expected="t", timestamp=datetime(2023, 1, 1, 12, 0, 0, 200000)),
   |

tests\models\test_ngram_error.py:48:89: E501 Line too long (96 > 88)
   |
46 |         [
47 |             Keystroke(char="c", expected="c", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
48 |             Keystroke(char="a", expected="a", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
   |                                                                                         ^^^^^^^^ E501
49 |             Keystroke(char="t", expected="t", timestamp=datetime(2023, 1, 1, 12, 0, 0, 200000)),
50 |         ],
   |

tests\models\test_ngram_error.py:49:89: E501 Line too long (96 > 88)
   |
47 |             Keystroke(char="c", expected="c", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
48 |             Keystroke(char="a", expected="a", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
49 |             Keystroke(char="t", expected="t", timestamp=datetime(2023, 1, 1, 12, 0, 0, 200000)),
   |                                                                                         ^^^^^^^^ E501
50 |         ],
51 |         3,
   |

tests\models\test_ngram_error.py:61:89: E501 Line too long (96 > 88)
   |
59 |                 char="x", expected="a", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)
60 |             ),  # Error at start
61 |             Keystroke(char="b", expected="b", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
   |                                                                                         ^^^^^^^^ E501
62 |         ],
63 |         2,
   |

tests\models\test_ngram_error.py:82:89: E501 Line too long (91 > 88)
   |
80 |     (
81 |         [
82 |             Keystroke(char="c", expected="c", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
   |                                                                                         ^^^ E501
83 |             Keystroke(
84 |                 char="X", expected="a", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)
   |

tests\models\test_ngram_error.py:86:89: E501 Line too long (96 > 88)
   |
84 |                 char="X", expected="a", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)
85 |             ),  # Error in middle
86 |             Keystroke(char="t", expected="t", timestamp=datetime(2023, 1, 1, 12, 0, 0, 200000)),
   |                                                                                         ^^^^^^^^ E501
87 |         ],
88 |         3,
   |

tests\models\test_ngram_error.py:97:89: E501 Line too long (96 > 88)
   |
95 |                 char="C", expected="c", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)
96 |             ),  # All errors
97 |             Keystroke(char="A", expected="a", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
   |                                                                                         ^^^^^^^^ E501
98 |             Keystroke(char="T", expected="t", timestamp=datetime(2023, 1, 1, 12, 0, 0, 200000)),
99 |         ],
   |

tests\models\test_ngram_error.py:98:89: E501 Line too long (96 > 88)
    |
 96 |             ),  # All errors
 97 |             Keystroke(char="A", expected="a", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
 98 |             Keystroke(char="T", expected="t", timestamp=datetime(2023, 1, 1, 12, 0, 0, 200000)),
    |                                                                                         ^^^^^^^^ E501
 99 |         ],
100 |         3,
    |

tests\models\test_ngram_error.py:106:89: E501 Line too long (91 > 88)
    |
104 |     (
105 |         [
106 |             Keystroke(char="c", expected="c", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
    |                                                                                         ^^^ E501
107 |             Keystroke(
108 |                 char="X", expected="a", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)
    |

tests\models\test_ngram_error.py:121:89: E501 Line too long (89 > 88)
    |
119 |     ([], 2, [], "Empty keystrokes"),
120 |     (
121 |         [Keystroke(char="a", expected="a", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0))],
    |                                                                                         ^ E501
122 |         2,
123 |         [],
    |

tests\models\test_ngram_error.py:128:89: E501 Line too long (89 > 88)
    |
126 |     # Size 1 n-grams are not allowed per specification (ignored)
127 |     (
128 |         [Keystroke(char="X", expected="a", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0))],
    |                                                                                         ^ E501
129 |         1,
130 |         [],
    |

tests\models\test_ngram_error.py:134:89: E501 Line too long (89 > 88)
    |
132 |     ),
133 |     (
134 |         [Keystroke(char="a", expected="a", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0))],
    |                                                                                         ^ E501
135 |         1,
136 |         [],
    |

tests\models\test_ngram_error.py:142:89: E501 Line too long (91 > 88)
    |
140 |     (
141 |         [
142 |             Keystroke(char="t", expected="t", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
    |                                                                                         ^^^ E501
143 |             Keystroke(char="h", expected="h", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
144 |             Keystroke(char="e", expected="e", timestamp=datetime(2023, 1, 1, 12, 0, 0, 200000)),
    |

tests\models\test_ngram_error.py:143:89: E501 Line too long (96 > 88)
    |
141 |         [
142 |             Keystroke(char="t", expected="t", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
143 |             Keystroke(char="h", expected="h", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
    |                                                                                         ^^^^^^^^ E501
144 |             Keystroke(char="e", expected="e", timestamp=datetime(2023, 1, 1, 12, 0, 0, 200000)),
145 |             Keystroke(
    |

tests\models\test_ngram_error.py:144:89: E501 Line too long (96 > 88)
    |
142 |             Keystroke(char="t", expected="t", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
143 |             Keystroke(char="h", expected="h", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
144 |             Keystroke(char="e", expected="e", timestamp=datetime(2023, 1, 1, 12, 0, 0, 200000)),
    |                                                                                         ^^^^^^^^ E501
145 |             Keystroke(
146 |                 char="N", expected="n", timestamp=datetime(2023, 1, 1, 12, 0, 0, 300000)
    |

tests\models\test_ngram_error.py:158:89: E501 Line too long (96 > 88)
    |
156 |                 char="q", expected="Q", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)
157 |             ),  # error at start of 'Qui'
158 |             Keystroke(char="u", expected="u", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
    |                                                                                         ^^^^^^^^ E501
159 |             Keystroke(char="i", expected="i", timestamp=datetime(2023, 1, 1, 12, 0, 0, 200000)),
160 |             Keystroke(char="c", expected="c", timestamp=datetime(2023, 1, 1, 12, 0, 0, 300000)),
    |

tests\models\test_ngram_error.py:159:89: E501 Line too long (96 > 88)
    |
157 |             ),  # error at start of 'Qui'
158 |             Keystroke(char="u", expected="u", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
159 |             Keystroke(char="i", expected="i", timestamp=datetime(2023, 1, 1, 12, 0, 0, 200000)),
    |                                                                                         ^^^^^^^^ E501
160 |             Keystroke(char="c", expected="c", timestamp=datetime(2023, 1, 1, 12, 0, 0, 300000)),
161 |             Keystroke(
    |

tests\models\test_ngram_error.py:160:89: E501 Line too long (96 > 88)
    |
158 |             Keystroke(char="u", expected="u", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
159 |             Keystroke(char="i", expected="i", timestamp=datetime(2023, 1, 1, 12, 0, 0, 200000)),
160 |             Keystroke(char="c", expected="c", timestamp=datetime(2023, 1, 1, 12, 0, 0, 300000)),
    |                                                                                         ^^^^^^^^ E501
161 |             Keystroke(
162 |                 char="K", expected="k", timestamp=datetime(2023, 1, 1, 12, 0, 0, 400000)
    |

tests\models\test_ngram_error.py:171:89: E501 Line too long (91 > 88)
    |
169 |     (
170 |         [
171 |             Keystroke(char="e", expected="E", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
    |                                                                                         ^^^ E501
172 |             Keystroke(char="r", expected="R", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
173 |             Keystroke(char="r", expected="R", timestamp=datetime(2023, 1, 1, 12, 0, 0, 200000)),
    |

tests\models\test_ngram_error.py:172:89: E501 Line too long (96 > 88)
    |
170 |         [
171 |             Keystroke(char="e", expected="E", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
172 |             Keystroke(char="r", expected="R", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
    |                                                                                         ^^^^^^^^ E501
173 |             Keystroke(char="r", expected="R", timestamp=datetime(2023, 1, 1, 12, 0, 0, 200000)),
174 |             Keystroke(char="s", expected="S", timestamp=datetime(2023, 1, 1, 12, 0, 0, 300000)),
    |

tests\models\test_ngram_error.py:173:89: E501 Line too long (96 > 88)
    |
171 |             Keystroke(char="e", expected="E", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
172 |             Keystroke(char="r", expected="R", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
173 |             Keystroke(char="r", expected="R", timestamp=datetime(2023, 1, 1, 12, 0, 0, 200000)),
    |                                                                                         ^^^^^^^^ E501
174 |             Keystroke(char="s", expected="S", timestamp=datetime(2023, 1, 1, 12, 0, 0, 300000)),
175 |         ],
    |

tests\models\test_ngram_error.py:174:89: E501 Line too long (96 > 88)
    |
172 |             Keystroke(char="r", expected="R", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
173 |             Keystroke(char="r", expected="R", timestamp=datetime(2023, 1, 1, 12, 0, 0, 200000)),
174 |             Keystroke(char="s", expected="S", timestamp=datetime(2023, 1, 1, 12, 0, 0, 300000)),
    |                                                                                         ^^^^^^^^ E501
175 |         ],
176 |         2,
    |

tests\models\test_ngram_error.py:182:89: E501 Line too long (91 > 88)
    |
180 |     (
181 |         [
182 |             Keystroke(char="o", expected="o", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
    |                                                                                         ^^^ E501
183 |             Keystroke(char="n", expected="n", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
184 |             Keystroke(
    |

tests\models\test_ngram_error.py:183:89: E501 Line too long (96 > 88)
    |
181 |         [
182 |             Keystroke(char="o", expected="o", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
183 |             Keystroke(char="n", expected="n", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
    |                                                                                         ^^^^^^^^ E501
184 |             Keystroke(
185 |                 char="L", expected="l", timestamp=datetime(2023, 1, 1, 12, 0, 0, 200000)
    |

tests\models\test_ngram_error.py:187:89: E501 Line too long (96 > 88)
    |
185 |                 char="L", expected="l", timestamp=datetime(2023, 1, 1, 12, 0, 0, 200000)
186 |             ),  # error in middle of 'onLy' and 'nLyE'
187 |             Keystroke(char="y", expected="y", timestamp=datetime(2023, 1, 1, 12, 0, 0, 300000)),
    |                                                                                         ^^^^^^^^ E501
188 |             Keystroke(
189 |                 char="E", expected="e", timestamp=datetime(2023, 1, 1, 12, 0, 0, 400000)
    |

tests\models\test_ngram_error.py:249:89: E501 Line too long (92 > 88)
    |
247 |     # Generate ngrams and analyze
248 |     ngram_manager = NGramManager(db_manager=None)  # Instantiate real NGramManager
249 |     generated_ngrams = ngram_manager.generate_ngrams_from_keystrokes(keystrokes, ngram_size)
    |                                                                                         ^^^^ E501
250 |
251 |     # Debug output for each generated ngram
    |

tests\models\test_ngram_error.py:267:89: E501 Line too long (99 > 88)
    |
266 |     # Get result for assertion
267 |     error_true_ngram_texts_generated = [ngram.text for ngram in generated_ngrams if ngram.is_error]
    |                                                                                         ^^^^^^^^^^^ E501
268 |     print("\nResults - NGrams with is_error=True:")
269 |     print(f"  Expected: {sorted(expected_ngram_texts_with_error_true)}")
    |

tests\models\test_ngram_manager.py:57:9: ANN204 Missing return type annotation for special method `__init__`
   |
55 |     """Mock database for testing."""
56 |
57 |     def __init__(self, results=None):
   |         ^^^^^^^^ ANN204
58 |         self.results = results or []
59 |         self.last_query = None
   |
   = help: Add return type annotation: `None`

tests\models\test_ngram_manager.py:57:24: ANN001 Missing type annotation for function argument `results`
   |
55 |     """Mock database for testing."""
56 |
57 |     def __init__(self, results=None):
   |                        ^^^^^^^ ANN001
58 |         self.results = results or []
59 |         self.last_query = None
   |

tests\models\test_ngram_manager.py:63:9: ANN201 Missing return type annotation for public function `fetchall`
   |
61 |         self.execute = MagicMock()
62 |
63 |     def fetchall(self, query, params=()):
   |         ^^^^^^^^ ANN201
64 |         self.last_query = query
65 |         self.last_params = params
   |
   = help: Add return type annotation

tests\models\test_ngram_manager.py:63:24: ANN001 Missing type annotation for function argument `query`
   |
61 |         self.execute = MagicMock()
62 |
63 |     def fetchall(self, query, params=()):
   |                        ^^^^^ ANN001
64 |         self.last_query = query
65 |         self.last_params = params
   |

tests\models\test_ngram_manager.py:63:31: ANN001 Missing type annotation for function argument `params`
   |
61 |         self.execute = MagicMock()
62 |
63 |     def fetchall(self, query, params=()):
   |                               ^^^^^^ ANN001
64 |         self.last_query = query
65 |         self.last_params = params
   |

tests\models\test_ngram_manager.py:70:5: ANN201 Missing return type annotation for public function `mock_db`
   |
69 | @pytest.fixture
70 | def mock_db():
   |     ^^^^^^^ ANN201
71 |     """Create a mock database with test data."""
72 |     db = MockDB()
   |
   = help: Add return type annotation

tests\models\test_ngram_manager.py:77:5: ANN201 Missing return type annotation for public function `ngram_manager`
   |
76 | @pytest.fixture
77 | def ngram_manager(mock_db):
   |     ^^^^^^^^^^^^^ ANN201
78 |     """Create an NGramManager instance with a mock database."""
79 |     return NGramManager(mock_db)
   |
   = help: Add return type annotation

tests\models\test_ngram_manager.py:77:19: ANN001 Missing type annotation for function argument `mock_db`
   |
76 | @pytest.fixture
77 | def ngram_manager(mock_db):
   |                   ^^^^^^^ ANN001
78 |     """Create an NGramManager instance with a mock database."""
79 |     return NGramManager(mock_db)
   |

tests\models\test_ngram_manager.py:82:5: ANN201 Missing return type annotation for public function `test_slowest_n_basic`
   |
82 | def test_slowest_n_basic(ngram_manager, mock_db):
   |     ^^^^^^^^^^^^^^^^^^^^ ANN201
83 |     """Test basic functionality of slowest_n method."""
84 |     # Setup
   |
   = help: Add return type annotation: `None`

tests\models\test_ngram_manager.py:82:26: ANN001 Missing type annotation for function argument `ngram_manager`
   |
82 | def test_slowest_n_basic(ngram_manager, mock_db):
   |                          ^^^^^^^^^^^^^ ANN001
83 |     """Test basic functionality of slowest_n method."""
84 |     # Setup
   |

tests\models\test_ngram_manager.py:82:41: ANN001 Missing type annotation for function argument `mock_db`
   |
82 | def test_slowest_n_basic(ngram_manager, mock_db):
   |                                         ^^^^^^^ ANN001
83 |     """Test basic functionality of slowest_n method."""
84 |     # Setup
   |

tests\models\test_ngram_manager.py:129:5: ANN201 Missing return type annotation for public function `test_error_n_basic`
    |
129 | def test_error_n_basic(ngram_manager, mock_db):
    |     ^^^^^^^^^^^^^^^^^^ ANN201
130 |     """Test basic functionality of error_n method."""
131 |     # Setup
    |
    = help: Add return type annotation: `None`

tests\models\test_ngram_manager.py:129:24: ANN001 Missing type annotation for function argument `ngram_manager`
    |
129 | def test_error_n_basic(ngram_manager, mock_db):
    |                        ^^^^^^^^^^^^^ ANN001
130 |     """Test basic functionality of error_n method."""
131 |     # Setup
    |

tests\models\test_ngram_manager.py:129:39: ANN001 Missing type annotation for function argument `mock_db`
    |
129 | def test_error_n_basic(ngram_manager, mock_db):
    |                                       ^^^^^^^ ANN001
130 |     """Test basic functionality of error_n method."""
131 |     # Setup
    |

tests\models\test_ngram_manager.py:169:5: ANN201 Missing return type annotation for public function `test_slowest_n_empty_result`
    |
169 | def test_slowest_n_empty_result(ngram_manager, mock_db):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
170 |     """Test slowest_n with no results."""
171 |     # Setup
    |
    = help: Add return type annotation: `None`

tests\models\test_ngram_manager.py:169:33: ANN001 Missing type annotation for function argument `ngram_manager`
    |
169 | def test_slowest_n_empty_result(ngram_manager, mock_db):
    |                                 ^^^^^^^^^^^^^ ANN001
170 |     """Test slowest_n with no results."""
171 |     # Setup
    |

tests\models\test_ngram_manager.py:169:48: ANN001 Missing type annotation for function argument `mock_db`
    |
169 | def test_slowest_n_empty_result(ngram_manager, mock_db):
    |                                                ^^^^^^^ ANN001
170 |     """Test slowest_n with no results."""
171 |     # Setup
    |

tests\models\test_ngram_manager.py:187:5: ANN201 Missing return type annotation for public function `test_error_n_custom_lookback`
    |
187 | def test_error_n_custom_lookback(ngram_manager, mock_db):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
188 |     """Test error_n with custom lookback distance."""
189 |     # Setup
    |
    = help: Add return type annotation: `None`

tests\models\test_ngram_manager.py:187:34: ANN001 Missing type annotation for function argument `ngram_manager`
    |
187 | def test_error_n_custom_lookback(ngram_manager, mock_db):
    |                                  ^^^^^^^^^^^^^ ANN001
188 |     """Test error_n with custom lookback distance."""
189 |     # Setup
    |

tests\models\test_ngram_manager.py:187:49: ANN001 Missing type annotation for function argument `mock_db`
    |
187 | def test_error_n_custom_lookback(ngram_manager, mock_db):
    |                                                 ^^^^^^^ ANN001
188 |     """Test error_n with custom lookback distance."""
189 |     # Setup
    |

tests\models\test_ngram_manager.py:204:9: ANN201 Missing return type annotation for public function `test_delete_all_ngrams_success`
    |
202 |     """Test cases for NGramManager class."""
203 |
204 |     def test_delete_all_ngrams_success(self, mock_db):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
205 |         """Test that delete_all_ngrams deletes all n-gram data."""
206 |         # Setup
    |
    = help: Add return type annotation: `None`

tests\models\test_ngram_manager.py:204:46: ANN001 Missing type annotation for function argument `mock_db`
    |
202 |     """Test cases for NGramManager class."""
203 |
204 |     def test_delete_all_ngrams_success(self, mock_db):
    |                                              ^^^^^^^ ANN001
205 |         """Test that delete_all_ngrams deletes all n-gram data."""
206 |         # Setup
    |

tests\models\test_ngram_manager.py:221:9: ANN201 Missing return type annotation for public function `test_delete_all_ngrams_error`
    |
219 |         assert "DELETE FROM session_ngram_errors" in calls
220 |
221 |     def test_delete_all_ngrams_error(self, mock_db):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
222 |         """Test that delete_all_ngrams handles database errors."""
223 |         # Setup
    |
    = help: Add return type annotation: `None`

tests\models\test_ngram_manager.py:221:44: ANN001 Missing type annotation for function argument `mock_db`
    |
219 |         assert "DELETE FROM session_ngram_errors" in calls
220 |
221 |     def test_delete_all_ngrams_error(self, mock_db):
    |                                            ^^^^^^^ ANN001
222 |         """Test that delete_all_ngrams handles database errors."""
223 |         # Setup
    |

tests\models\test_ngram_models.py:67:89: E501 Line too long (90 > 88)
   |
65 | #     snippet_id = str(uuid.uuid4())
66 | #     temp_db_file.execute(
67 | #         "INSERT INTO snippets (snippet_id, category_id, snippet_name) VALUES (?, ?, ?)",
   |                                                                                         ^^ E501
68 | #         (snippet_id, sample_category, "Test Snippet"),
69 | #     )
   |

tests\models\test_ngram_models.py:78:89: E501 Line too long (216 > 88)
   |
76 | ΓÇª
77 | ΓÇª
78 | ΓÇªrt, snippet_index_end, content, start_time, end_time, actual_chars, errors, ms_per_keystroke) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)",
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
79 | ΓÇª
80 | ΓÇª
   |

tests\models\test_ngram_models.py:136:89: E501 Line too long (91 > 88)
    |
134 | # def test_practice_session(temp_db: DatabaseManager) -> Session:
135 | #     """
136 | #     Test objective: Create a test session for NGram analysis using the new Session model.
    |                                                                                         ^^^ E501
137 |
138 | #     This fixture creates a minimal session suitable for testing, using only the new required fields.
    |

tests\models\test_ngram_models.py:138:89: E501 Line too long (102 > 88)
    |
136 | #     Test objective: Create a test session for NGram analysis using the new Session model.
137 |
138 | #     This fixture creates a minimal session suitable for testing, using only the new required fields.
    |                                                                                         ^^^^^^^^^^^^^^ E501
139 | #     It sets up all required database dependencies (category and snippet) using manager classes.
140 | #     """
    |

tests\models\test_ngram_models.py:139:89: E501 Line too long (97 > 88)
    |
138 | #     This fixture creates a minimal session suitable for testing, using only the new required fields.
139 | #     It sets up all required database dependencies (category and snippet) using manager classes.
    |                                                                                         ^^^^^^^^^ E501
140 | #     """
141 | #     # Create a category using CategoryManager
    |

tests\models\test_ngram_models.py:179:89: E501 Line too long (99 > 88)
    |
178 | # @pytest.fixture
179 | # def test_keystrokes(temp_db: DatabaseManager, test_practice_session: Session) -> List[Keystroke]:
    |                                                                                         ^^^^^^^^^^^ E501
180 | #     """
181 | #     Test objective: Create test keystrokes for NGram analysis.
    |

tests\models\test_ngram_models.py:183:89: E501 Line too long (98 > 88)
    |
181 | #     Test objective: Create test keystrokes for NGram analysis.
182 |
183 | #     This fixture creates two keystrokes associated with the test session using KeystrokeManager.
    |                                                                                         ^^^^^^^^^^ E501
184 | #     """
185 | #     # Create two keystrokes with the session_id
    |

tests\models\test_ngram_models.py:216:89: E501 Line too long (100 > 88)
    |
215 | # @pytest.fixture
216 | # def single_keystroke(temp_db: DatabaseManager, test_practice_session: Session) -> List[Keystroke]:
    |                                                                                         ^^^^^^^^^^^^ E501
217 | #     """
218 | #     Test objective: Create a single keystroke for testing no n-gram scenario.
    |

tests\models\test_ngram_models.py:238:89: E501 Line too long (114 > 88)
    |
236 | #         """
237 | #         INSERT INTO session_keystrokes
238 | #         (session_id, keystroke_id, keystroke_time, keystroke_char, expected_char, is_error, time_since_previous)
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
239 | #         VALUES (?, ?, ?, ?, ?, ?, ?)
240 | #         """,
    |

tests\models\test_ngram_models.py:293:89: E501 Line too long (118 > 88)
    |
291 | #             """
292 | #             INSERT INTO session_keystrokes
293 | #             (session_id, keystroke_id, keystroke_time, keystroke_char, expected_char, is_error, time_since_previous)
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
294 | #             VALUES (?, ?, ?, ?, ?, ?, ?)
295 | #             """,
    |

tests\models\test_ngram_models.py:350:89: E501 Line too long (118 > 88)
    |
348 | #             """
349 | #             INSERT INTO session_keystrokes
350 | #             (session_id, keystroke_id, keystroke_time, keystroke_char, expected_char, is_error, time_since_previous)
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
351 | #             VALUES (?, ?, ?, ?, ?, ?, ?)
352 | #             """,
    |

tests\models\test_ngram_models.py:407:89: E501 Line too long (118 > 88)
    |
405 | #             """
406 | #             INSERT INTO session_keystrokes
407 | #             (session_id, keystroke_id, keystroke_time, keystroke_char, expected_char, is_error, time_since_previous)
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
408 | #             VALUES (?, ?, ?, ?, ?, ?, ?)
409 | #             """,
    |

tests\models\test_ngram_models.py:429:89: E501 Line too long (92 > 88)
    |
427 | # ) -> List[Keystroke]:
428 | #     """
429 | #     Test objective: Create three correct keystrokes for testing multiple n-gram formation.
    |                                                                                         ^^^^ E501
430 |
431 | #     This fixture creates three keystrokes ('T', 'h', and 'e') with no errors and
    |

tests\models\test_ngram_models.py:458:89: E501 Line too long (92 > 88)
    |
456 | #             session_id=test_practice_session.session_id,
457 | #             keystroke_id=str(uuid.uuid4()),
458 | #             keystroke_time=now + datetime.timedelta(milliseconds=1500),  # 1500 from start
    |                                                                                         ^^^^ E501
459 | #             keystroke_char="e",
460 | #             expected_char="e",
    |

tests\models\test_ngram_models.py:471:89: E501 Line too long (118 > 88)
    |
469 | #             """
470 | #             INSERT INTO session_keystrokes
471 | #             (session_id, keystroke_id, keystroke_time, keystroke_char, expected_char, is_error, time_since_previous)
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
472 | #             VALUES (?, ?, ?, ?, ?, ?, ?)
473 | #             """,
    |

tests\models\test_ngram_models.py:490:89: E501 Line too long (95 > 88)
    |
488 | # @pytest.fixture
489 | # def three_keystrokes_error_at_first(
490 | #     temp_db: DatabaseManager, test_practice_session: Session, three_keystrokes_error_at_first
    |                                                                                         ^^^^^^^ E501
491 | # ) -> None:
492 | #     """
    |

tests\models\test_ngram_models.py:493:89: E501 Line too long (111 > 88)
    |
491 | # ) -> None:
492 | #     """
493 | #     Test objective: Verify that three keystrokes with an error on the first keystroke are analyzed correctly.
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^ E501
494 |
495 | #     Scenario:
    |

tests\models\test_ngram_models.py:513:89: E501 Line too long (89 > 88)
    |
511 | #     # No speed n-grams should be present
512 | #     for size in range(2, 6):
513 | #         assert size not in manager.speed_ngrams or len(manager.speed_ngrams[size]) == 0
    |                                                                                         ^ E501
514 |
515 | #     # Error n-grams: bigram 'Gh', trigram 'Ghe'
    |

tests\models\test_ngram_models.py:530:89: E501 Line too long (118 > 88)
    |
528 | #     )[0] == 0
529 | #     db_errors = temp_db.fetchall(
530 | #         "SELECT ngram_size, ngram FROM session_ngram_errors WHERE session_id = ? ORDER BY ngram_size", (session_id,)
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
531 | #     )
532 | #     assert len(db_errors) == 2
    |

tests\models\test_ngram_models.py:538:89: E501 Line too long (96 > 88)
    |
537 | # def test_three_keystrokes_error_at_second(
538 | #     temp_db: DatabaseManager, test_practice_session: Session, three_keystrokes_error_at_second
    |                                                                                         ^^^^^^^^ E501
539 | # ) -> None:
540 | #     """
    |

tests\models\test_ngram_models.py:541:89: E501 Line too long (112 > 88)
    |
539 | # ) -> None:
540 | #     """
541 | #     Test objective: Verify that three keystrokes with an error on the second keystroke are analyzed correctly.
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^ E501
542 |
543 | #     Scenario:
    |

tests\models\test_ngram_models.py:561:89: E501 Line too long (89 > 88)
    |
559 | #     # No speed n-grams
560 | #     for size in range(2, 6):
561 | #         assert size not in manager.speed_ngrams or len(manager.speed_ngrams[size]) == 0
    |                                                                                         ^ E501
562 | #     # Error n-grams: only 'Tb'
563 | #     assert 2 in manager.error_ngrams and len(manager.error_ngrams[2]) == 1
    |

tests\models\test_ngram_models.py:572:89: E501 Line too long (97 > 88)
    |
570 | #     assert manager.save_to_database() is True
571 | #     db_speed = temp_db.fetchall(
572 | #         "SELECT ngram_size, ngram FROM session_ngram_speed WHERE session_id = ?", (session_id,)
    |                                                                                         ^^^^^^^^^ E501
573 | #     )
574 | #     db_errors = temp_db.fetchall(
    |

tests\models\test_ngram_models.py:575:89: E501 Line too long (98 > 88)
    |
573 | #     )
574 | #     db_errors = temp_db.fetchall(
575 | #         "SELECT ngram_size, ngram FROM session_ngram_errors WHERE session_id = ?", (session_id,)
    |                                                                                         ^^^^^^^^^^ E501
576 | #     )
577 | #     assert len(db_speed) == 0
    |

tests\models\test_ngram_models.py:582:89: E501 Line too long (95 > 88)
    |
581 | # def test_three_keystrokes_error_at_third(
582 | #     temp_db: DatabaseManager, test_practice_session: Session, three_keystrokes_error_at_third
    |                                                                                         ^^^^^^^ E501
583 | # ) -> None:
584 | #     """
    |

tests\models\test_ngram_models.py:585:89: E501 Line too long (111 > 88)
    |
583 | # ) -> None:
584 | #     """
585 | #     Test objective: Verify that three keystrokes with an error on the third keystroke are analyzed correctly.
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^ E501
586 |
587 | #     Scenario:
    |

tests\models\test_ngram_models.py:619:89: E501 Line too long (97 > 88)
    |
617 | #     assert manager.save_to_database() is True
618 | #     db_speed = temp_db.fetchall(
619 | #         "SELECT ngram_size, ngram FROM session_ngram_speed WHERE session_id = ?", (session_id,)
    |                                                                                         ^^^^^^^^^ E501
620 | #     )
621 | #     db_errors = temp_db.fetchall(
    |

tests\models\test_ngram_models.py:622:89: E501 Line too long (98 > 88)
    |
620 | #     )
621 | #     db_errors = temp_db.fetchall(
622 | #         "SELECT ngram_size, ngram FROM session_ngram_errors WHERE session_id = ?", (session_id,)
    |                                                                                         ^^^^^^^^^^ E501
623 | #     )
624 | #     assert len(db_speed) == 1 and db_speed[0][1] == 'Th'
    |

tests\models\test_ngram_models.py:652:89: E501 Line too long (94 > 88)
    |
651 | #         # Assert session and keystroke setup
652 | #         assert test_practice_session.session_id is not None, "Session ID should not be None"
    |                                                                                         ^^^^^^ E501
653 | #         assert len(test_keystrokes) == 2, "Should have exactly 2 keystrokes"
654 | #         # Verify keystrokes have correct properties
    |

tests\models\test_ngram_models.py:655:89: E501 Line too long (90 > 88)
    |
653 | #         assert len(test_keystrokes) == 2, "Should have exactly 2 keystrokes"
654 | #         # Verify keystrokes have correct properties
655 | #         assert test_keystrokes[0].keystroke_char == "t", "First keystroke should be 't'"
    |                                                                                         ^^ E501
656 | #         assert test_keystrokes[1].keystroke_char == "e", "Second keystroke should be 'e'"
    |

tests\models\test_ngram_models.py:656:89: E501 Line too long (91 > 88)
    |
654 | #         # Verify keystrokes have correct properties
655 | #         assert test_keystrokes[0].keystroke_char == "t", "First keystroke should be 't'"
656 | #         assert test_keystrokes[1].keystroke_char == "e", "Second keystroke should be 'e'"
    |                                                                                         ^^^ E501
657 |
658 | #     def test_single_keystroke_no_ngrams(
    |

tests\models\test_ngram_models.py:695:89: E501 Line too long (93 > 88)
    |
693 | #         # Assert no n-grams found
694 | #         for size in range(2, 6):
695 | #             assert size not in manager.speed_ngrams or len(manager.speed_ngrams[size]) == 0
    |                                                                                         ^^^^^ E501
696 | #             assert size not in manager.error_ngrams or len(manager.error_ngrams[size]) == 0
697 | #         # Save to DB and check
    |

tests\models\test_ngram_models.py:696:89: E501 Line too long (93 > 88)
    |
694 | #         for size in range(2, 6):
695 | #             assert size not in manager.speed_ngrams or len(manager.speed_ngrams[size]) == 0
696 | #             assert size not in manager.error_ngrams or len(manager.error_ngrams[size]) == 0
    |                                                                                         ^^^^^ E501
697 | #         # Save to DB and check
698 | #         assert manager.save_to_database() is True
    |

tests\models\test_ngram_models.py:700:89: E501 Line too long (107 > 88)
    |
698 | #         assert manager.save_to_database() is True
699 | #         assert temp_db_file.fetchone(
700 | #             "SELECT COUNT(*) FROM session_ngram_speed WHERE session_id = ?", (sample_session.session_id,)
    |                                                                                         ^^^^^^^^^^^^^^^^^^^ E501
701 | #         )[0] == 0
702 | #         assert temp_db_file.fetchone(
    |

tests\models\test_ngram_models.py:703:89: E501 Line too long (108 > 88)
    |
701 | #         )[0] == 0
702 | #         assert temp_db_file.fetchone(
703 | #             "SELECT COUNT(*) FROM session_ngram_errors WHERE session_id = ?", (sample_session.session_id,)
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^ E501
704 | #         )[0] == 0
    |

tests\models\test_ngram_models.py:710:89: E501 Line too long (97 > 88)
    |
708 | #     ):
709 | #         """
710 | #         Test objective: Verify that two keystrokes produce a single bigram with correct timing.
    |                                                                                         ^^^^^^^^^ E501
711 | #         """
712 | #         now = datetime.datetime.now()
    |

tests\models\test_ngram_models.py:761:89: E501 Line too long (102 > 88)
    |
759 | #         assert manager.save_to_database() is True
760 | #         db_bigrams = temp_db_file.fetchall(
761 | #             "SELECT ngram_size, ngram, ngram_time_ms FROM session_ngram_speed WHERE session_id = ?",
    |                                                                                         ^^^^^^^^^^^^^^ E501
762 | #             (sample_session.session_id,)
763 | #         )
    |

tests\models\test_ngram_models.py:768:89: E501 Line too long (108 > 88)
    |
766 | #         assert db_bigrams[0][2] == 250
767 | #         assert temp_db_file.fetchone(
768 | #             "SELECT COUNT(*) FROM session_ngram_errors WHERE session_id = ?", (sample_session.session_id,)
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^ E501
769 | #         )[0] == 0
    |

tests\models\test_ngram_models.py:775:89: E501 Line too long (113 > 88)
    |
773 | #     ):
774 | #         """
775 | #         Test objective: Verify that two keystrokes with an error on the first keystroke are analyzed correctly.
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^ E501
776 | #         """
777 | #         now = datetime.datetime.now()
    |

tests\models\test_ngram_models.py:820:89: E501 Line too long (107 > 88)
    |
818 | #         assert manager.save_to_database() is True
819 | #         assert temp_db_file.fetchone(
820 | #             "SELECT COUNT(*) FROM session_ngram_speed WHERE session_id = ?", (sample_session.session_id,)
    |                                                                                         ^^^^^^^^^^^^^^^^^^^ E501
821 | #         )[0] == 0
822 | #         assert temp_db_file.fetchone(
    |

tests\models\test_ngram_models.py:823:89: E501 Line too long (108 > 88)
    |
821 | #         )[0] == 0
822 | #         assert temp_db_file.fetchone(
823 | #             "SELECT COUNT(*) FROM session_ngram_errors WHERE session_id = ?", (sample_session.session_id,)
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^ E501
824 | #         )[0] == 0
    |

tests\models\test_ngram_models.py:830:89: E501 Line too long (114 > 88)
    |
828 | #     ):
829 | #         """
830 | #         Test objective: Verify that two keystrokes with an error on the second keystroke are analyzed correctly.
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
831 | #         """
832 | #         now = datetime.datetime.now()
    |

tests\models\test_ngram_models.py:887:89: E501 Line too long (107 > 88)
    |
885 | #         assert db_errors[0][1] == "Tb"
886 | #         assert temp_db_file.fetchone(
887 | #             "SELECT COUNT(*) FROM session_ngram_speed WHERE session_id = ?", (sample_session.session_id,)
    |                                                                                         ^^^^^^^^^^^^^^^^^^^ E501
888 | #         )[0] == 0
    |

tests\models\test_ngram_models.py:894:89: E501 Line too long (110 > 88)
    |
892 | #     ):
893 | #         """
894 | #         Test objective: Verify that three keystrokes produce correct bigrams and trigram with proper timing.
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^ E501
895 | #         """
896 | #         now = datetime.datetime.now()
    |

tests\models\test_ngram_models.py:946:89: E501 Line too long (89 > 88)
    |
944 | #         assert 2 in manager.speed_ngrams and len(manager.speed_ngrams[2]) == 2
945 | #         assert 3 in manager.speed_ngrams and len(manager.speed_ngrams[3]) == 1
946 | #         bigram1 = next((ng for ng in manager.speed_ngrams[2] if ng.text == "Th"), None)
    |                                                                                         ^ E501
947 | #         bigram2 = next((ng for ng in manager.speed_ngrams[2] if ng.text == "he"), None)
948 | #         trigram = manager.speed_ngrams[3][0]
    |

tests\models\test_ngram_models.py:947:89: E501 Line too long (89 > 88)
    |
945 | #         assert 3 in manager.speed_ngrams and len(manager.speed_ngrams[3]) == 1
946 | #         bigram1 = next((ng for ng in manager.speed_ngrams[2] if ng.text == "Th"), None)
947 | #         bigram2 = next((ng for ng in manager.speed_ngrams[2] if ng.text == "he"), None)
    |                                                                                         ^ E501
948 | #         trigram = manager.speed_ngrams[3][0]
949 | #         assert bigram1 is not None and bigram1.total_time_ms == 500
    |

tests\models\test_ngram_models.py:952:89: E501 Line too long (93 > 88)
    |
950 | #         assert bigram2 is not None and bigram2.total_time_ms == 1000
951 | #         assert trigram.text == "The" and trigram.total_time_ms == 1500
952 | #         assert all(ng.is_clean for ng in manager.speed_ngrams[2] + manager.speed_ngrams[3])
    |                                                                                         ^^^^^ E501
953 | #         assert manager.save_to_database() is True
954 | #         db_speed = temp_db_file.fetchall(
    |

tests\models\test_ngram_models.py:955:89: E501 Line too long (102 > 88)
    |
953 | #         assert manager.save_to_database() is True
954 | #         db_speed = temp_db_file.fetchall(
955 | #             "SELECT ngram_size, ngram, ngram_time_ms FROM session_ngram_speed WHERE session_id = ?",
    |                                                                                         ^^^^^^^^^^^^^^ E501
956 | #             (sample_session.session_id,)
957 | #         )
    |

tests\models\test_ngram_models.py:960:89: E501 Line too long (108 > 88)
    |
958 | #         assert len(db_speed) == 3
959 | #         assert temp_db_file.fetchone(
960 | #             "SELECT COUNT(*) FROM session_ngram_errors WHERE session_id = ?", (sample_session.session_id,)
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^ E501
961 | #         )[0] == 0
    |

tests\models\test_ngram_models.py:970:89: E501 Line too long (115 > 88)
    |
968 | #     ) -> None:
969 | #         """
970 | #         Test objective: Verify that three keystrokes with an error on the first keystroke are analyzed correctly.
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
971 |
972 | #         This test checks a scenario where:
    |

tests\models\test_ngram_models.py:992:89: E501 Line too long (91 > 88)
    |
991 | #         # Verify analysis was completed
992 | #         assert manager.analysis_complete is True, "Analysis should be marked as complete"
    |                                                                                         ^^^ E501
993 |
994 | #         # VERIFY OBJECT STATE:
    |

tests\models\test_ngram_models.py:1003:89: E501 Line too long (98 > 88)
     |
1002 | #         # 2. Verify exactly one error bigram was identified
1003 | #         assert 2 in manager.error_ngrams, "Error n-grams dictionary should have key for bigrams"
     |                                                                                         ^^^^^^^^^^ E501
1004 | #         assert len(manager.error_ngrams[2]) == 1, "Should be exactly one error bigram"
     |

tests\models\test_ngram_models.py:1016:89: E501 Line too long (91 > 88)
     |
1014 | #         )
1015 | #         assert error_bigram.size == 2, "Error bigram size should be 2"
1016 | #         assert len(error_bigram.keystrokes) == 2, "Error bigram should have 2 keystrokes"
     |                                                                                         ^^^ E501
1017 | #         assert error_bigram.total_time_ms == 500, "Error bigram 'Gh' time should be 500ms"
     |

tests\models\test_ngram_models.py:1017:89: E501 Line too long (92 > 88)
     |
1015 | #         assert error_bigram.size == 2, "Error bigram size should be 2"
1016 | #         assert len(error_bigram.keystrokes) == 2, "Error bigram should have 2 keystrokes"
1017 | #         assert error_bigram.total_time_ms == 500, "Error bigram 'Gh' time should be 500ms"
     |                                                                                         ^^^^ E501
1018 |
1019 | #         # 4. Verify error bigram properties
     |

tests\models\test_ngram_models.py:1021:89: E501 Line too long (91 > 88)
     |
1019 | #         # 4. Verify error bigram properties
1020 | #         assert error_bigram.is_clean is False, "Error bigram should not be clean"
1021 | #         assert error_bigram.is_error is True, "Error bigram should be marked as an error"
     |                                                                                         ^^^ E501
1022 |
1023 | #         # 5. Check that the error bigram is still valid for tracking despite having an error
     |

tests\models\test_ngram_models.py:1023:89: E501 Line too long (94 > 88)
     |
1021 | #         assert error_bigram.is_error is True, "Error bigram should be marked as an error"
1022 |
1023 | #         # 5. Check that the error bigram is still valid for tracking despite having an error
     |                                                                                         ^^^^^^ E501
1024 | #         # This might differ based on your implementation - adjust if needed
1025 | #         if not error_bigram.is_valid:
     |

tests\models\test_ngram_models.py:1027:89: E501 Line too long (101 > 88)
     |
1025 | #         if not error_bigram.is_valid:
1026 | #             print(
1027 | #                 "Note: In this implementation, error bigrams are not considered valid for tracking"
     |                                                                                         ^^^^^^^^^^^^^ E501
1028 | #             )
     |

tests\models\test_ngram_models.py:1038:89: E501 Line too long (89 > 88)
     |
1037 | #         # VERIFY DATABASE STATE:
1038 | #         # Save to database - temporarily skip this assertion to see if later tests work
     |                                                                                         ^ E501
1039 |
1040 | #         # We'll assert the database contents directly instead of relying on the save operation result
     |

tests\models\test_ngram_models.py:1040:89: E501 Line too long (103 > 88)
     |
1038 | #         # Save to database - temporarily skip this assertion to see if later tests work
1039 |
1040 | #         # We'll assert the database contents directly instead of relying on the save operation result
     |                                                                                         ^^^^^^^^^^^^^^^ E501
1041 |
1042 | #         # 1. Verify no n-grams were saved to the speed table
     |

tests\models\test_ngram_models.py:1044:89: E501 Line too long (92 > 88)
     |
1042 | #         # 1. Verify no n-grams were saved to the speed table
1043 | #         speed_ngrams_count = temp_db.fetchone(
1044 | #             "SELECT COUNT(*) FROM session_ngram_speed WHERE session_id = ?", (session_id,)
     |                                                                                         ^^^^ E501
1045 | #         )[0]
1046 | #         assert speed_ngrams_count == 0, "No speed n-grams should be saved to the database"
     |

tests\models\test_ngram_models.py:1046:89: E501 Line too long (92 > 88)
     |
1044 | #             "SELECT COUNT(*) FROM session_ngram_speed WHERE session_id = ?", (session_id,)
1045 | #         )[0]
1046 | #         assert speed_ngrams_count == 0, "No speed n-grams should be saved to the database"
     |                                                                                         ^^^^ E501
1047 |
1048 | #         # 2. Verify exactly one error n-gram was saved to the database
     |

tests\models\test_ngram_models.py:1057:89: E501 Line too long (93 > 88)
     |
1055 | #         )
1056 |
1057 | #         assert len(error_ngrams) == 1, "Should be exactly one error n-gram in the database"
     |                                                                                         ^^^^^ E501
1058 |
1059 | #         # Verify the error bigram (Gh)
     |

tests\models\test_ngram_models.py:1067:89: E501 Line too long (94 > 88)
     |
1066 | #         # VERIFY ANALYZER RETRIEVAL METHODS:
1067 | #         # 1. Get slowest n-grams - should return empty list since there are no speed n-grams
     |                                                                                         ^^^^^^ E501
1068 | #         slowest_bigrams = manager.get_slowest_ngrams(size=2)
1069 | #         assert len(slowest_bigrams) == 0, "Should be no slowest bigrams"
     |

tests\models\test_ngram_models.py:1081:89: E501 Line too long (93 > 88)
     |
1079 | #         for size in range(3, 6):  # Check sizes 3-5
1080 | #             slowest_ngrams = manager.get_slowest_ngrams(size=size)
1081 | #             assert len(slowest_ngrams) == 0, f"Should be no slowest n-grams of size {size}"
     |                                                                                         ^^^^^ E501
1082 |
1083 | #             error_prone_ngrams = manager.get_most_error_prone_ngrams(size=size)
     |

tests\models\test_ngram_models.py:1084:89: E501 Line too long (101 > 88)
     |
1083 | #             error_prone_ngrams = manager.get_most_error_prone_ngrams(size=size)
1084 | #             assert len(error_prone_ngrams) == 0, f"Should be no error-prone n-grams of size {size}"
     |                                                                                         ^^^^^^^^^^^^^ E501
1085 |
1086 | #     def test_three_keystrokes_error_at_second(
     |

tests\models\test_ngram_models.py:1093:89: E501 Line too long (92 > 88)
     |
1091 | #     ) -> None:
1092 | #         """
1093 | #         Test objective: Verify that three keystrokes with an error on the second keystroke
     |                                                                                         ^^^^ E501
1094 | #         are analyzed correctly.
     |

tests\models\test_ngram_models.py:1116:89: E501 Line too long (91 > 88)
     |
1115 | #         # Verify analysis was completed
1116 | #         assert manager.analysis_complete is True, "Analysis should be marked as complete"
     |                                                                                         ^^^ E501
1117 |
1118 | #         # VERIFY OBJECT STATE:
     |

tests\models\test_ngram_models.py:1127:89: E501 Line too long (98 > 88)
     |
1126 | #         # 2. Verify exactly one error bigram was identified
1127 | #         assert 2 in manager.error_ngrams, "Error n-grams dictionary should have key for bigrams"
     |                                                                                         ^^^^^^^^^^ E501
1128 | #         assert len(manager.error_ngrams[2]) == 1, "Should be exactly one error bigram"
     |

tests\models\test_ngram_models.py:1140:89: E501 Line too long (91 > 88)
     |
1138 | #         )
1139 | #         assert error_bigram.size == 2, "Error bigram size should be 2"
1140 | #         assert len(error_bigram.keystrokes) == 2, "Error bigram should have 2 keystrokes"
     |                                                                                         ^^^ E501
1141 | #         assert error_bigram.total_time_ms == 500, "Error bigram 'Tb' time should be 500ms"
     |

tests\models\test_ngram_models.py:1141:89: E501 Line too long (92 > 88)
     |
1139 | #         assert error_bigram.size == 2, "Error bigram size should be 2"
1140 | #         assert len(error_bigram.keystrokes) == 2, "Error bigram should have 2 keystrokes"
1141 | #         assert error_bigram.total_time_ms == 500, "Error bigram 'Tb' time should be 500ms"
     |                                                                                         ^^^^ E501
1142 |
1143 | #         # 4. Verify error bigram properties
     |

tests\models\test_ngram_models.py:1145:89: E501 Line too long (91 > 88)
     |
1143 | #         # 4. Verify error bigram properties
1144 | #         assert error_bigram.is_clean is False, "Error bigram should not be clean"
1145 | #         assert error_bigram.is_error is True, "Error bigram should be marked as an error"
     |                                                                                         ^^^ E501
1146 |
1147 | #         # 5. Check that the error bigram is still valid for tracking despite having an error
     |

tests\models\test_ngram_models.py:1147:89: E501 Line too long (94 > 88)
     |
1145 | #         assert error_bigram.is_error is True, "Error bigram should be marked as an error"
1146 |
1147 | #         # 5. Check that the error bigram is still valid for tracking despite having an error
     |                                                                                         ^^^^^^ E501
1148 | #         # This might differ based on your implementation - adjust if needed
1149 | #         if not error_bigram.is_valid:
     |

tests\models\test_ngram_models.py:1151:89: E501 Line too long (101 > 88)
     |
1149 | #         if not error_bigram.is_valid:
1150 | #             print(
1151 | #                 "Note: In this implementation, error bigrams are not considered valid for tracking"
     |                                                                                         ^^^^^^^^^^^^^ E501
1152 | #             )
     |

tests\models\test_ngram_models.py:1162:89: E501 Line too long (89 > 88)
     |
1161 | #         # VERIFY DATABASE STATE:
1162 | #         # Save to database - temporarily skip this assertion to see if later tests work
     |                                                                                         ^ E501
1163 |
1164 | #         # We'll assert the database contents directly instead of relying on the save operation result
     |

tests\models\test_ngram_models.py:1164:89: E501 Line too long (103 > 88)
     |
1162 | #         # Save to database - temporarily skip this assertion to see if later tests work
1163 |
1164 | #         # We'll assert the database contents directly instead of relying on the save operation result
     |                                                                                         ^^^^^^^^^^^^^^^ E501
1165 |
1166 | #         # 1. Verify no n-grams were saved to the speed table
     |

tests\models\test_ngram_models.py:1168:89: E501 Line too long (92 > 88)
     |
1166 | #         # 1. Verify no n-grams were saved to the speed table
1167 | #         speed_ngrams_count = temp_db.fetchone(
1168 | #             "SELECT COUNT(*) FROM session_ngram_speed WHERE session_id = ?", (session_id,)
     |                                                                                         ^^^^ E501
1169 | #         )[0]
1170 | #         assert speed_ngrams_count == 0, "No speed n-grams should be saved to the database"
     |

tests\models\test_ngram_models.py:1170:89: E501 Line too long (92 > 88)
     |
1168 | #             "SELECT COUNT(*) FROM session_ngram_speed WHERE session_id = ?", (session_id,)
1169 | #         )[0]
1170 | #         assert speed_ngrams_count == 0, "No speed n-grams should be saved to the database"
     |                                                                                         ^^^^ E501
1171 |
1172 | #         # 2. Verify exactly one error n-gram was saved to the database
     |

tests\models\test_ngram_models.py:1181:89: E501 Line too long (93 > 88)
     |
1179 | #         )
1180 |
1181 | #         assert len(error_ngrams) == 1, "Should be exactly one error n-gram in the database"
     |                                                                                         ^^^^^ E501
1182 |
1183 | #         # Verify the error bigram (Tb)
     |

tests\models\test_ngram_models.py:1191:89: E501 Line too long (94 > 88)
     |
1190 | #         # VERIFY ANALYZER RETRIEVAL METHODS:
1191 | #         # 1. Get slowest n-grams - should return empty list since there are no speed n-grams
     |                                                                                         ^^^^^^ E501
1192 | #         slowest_bigrams = manager.get_slowest_ngrams(size=2)
1193 | #         assert len(slowest_bigrams) == 0, "Should be no slowest bigrams"
     |

tests\models\test_ngram_models.py:1205:89: E501 Line too long (93 > 88)
     |
1203 | #         for size in range(3, 6):  # Check sizes 3-5
1204 | #             slowest_ngrams = manager.get_slowest_ngrams(size=size)
1205 | #             assert len(slowest_ngrams) == 0, f"Should be no slowest n-grams of size {size}"
     |                                                                                         ^^^^^ E501
1206 |
1207 | #             error_prone_ngrams = manager.get_most_error_prone_ngrams(size=size)
     |

tests\models\test_ngram_models.py:1208:89: E501 Line too long (101 > 88)
     |
1207 | #             error_prone_ngrams = manager.get_most_error_prone_ngrams(size=size)
1208 | #             assert len(error_prone_ngrams) == 0, f"Should be no error-prone n-grams of size {size}"
     |                                                                                         ^^^^^^^^^^^^^ E501
1209 |
1210 | #     def test_three_keystrokes_error_at_third(
     |

tests\models\test_ngram_models.py:1217:89: E501 Line too long (91 > 88)
     |
1215 | #     ) -> None:
1216 | #         """
1217 | #         Test objective: Verify that three keystrokes with an error on the third keystroke
     |                                                                                         ^^^ E501
1218 | #         are analyzed correctly.
     |

tests\models\test_ngram_models.py:1226:89: E501 Line too long (98 > 88)
     |
1225 | #         Expected outcomes:
1226 | #         - One bigram of length 2 ("Th") should be valid, as the first two keystrokes are correct
     |                                                                                         ^^^^^^^^^^ E501
1227 | #         - One bigram of length 2 ("hd") with an error, time is 500ms
1228 | #         - No valid trigrams or quadgrams due to the error
     |

tests\models\test_ngram_models.py:1242:89: E501 Line too long (91 > 88)
     |
1241 | #         # Verify analysis was completed
1242 | #         assert manager.analysis_complete is True, "Analysis should be marked as complete"
     |                                                                                         ^^^ E501
1243 |
1244 | #         # VERIFY OBJECT STATE:
     |

tests\models\test_ngram_models.py:1246:89: E501 Line too long (98 > 88)
     |
1244 | #         # VERIFY OBJECT STATE:
1245 | #         # 1. Check that speed n-grams were identified correctly
1246 | #         assert 2 in manager.speed_ngrams, "Speed n-grams dictionary should have key for bigrams"
     |                                                                                         ^^^^^^^^^^ E501
1247 | #         assert len(manager.speed_ngrams[2]) == 1, "Should find exactly one speed bigram"
     |

tests\models\test_ngram_models.py:1247:89: E501 Line too long (90 > 88)
     |
1245 | #         # 1. Check that speed n-grams were identified correctly
1246 | #         assert 2 in manager.speed_ngrams, "Speed n-grams dictionary should have key for bigrams"
1247 | #         assert len(manager.speed_ngrams[2]) == 1, "Should find exactly one speed bigram"
     |                                                                                         ^^ E501
1248 |
1249 | #         # Validate the speed bigram 'Th'
     |

tests\models\test_ngram_models.py:1254:89: E501 Line too long (100 > 88)
     |
1252 | #         # Retrieve the bigram using the helper function
1253 | #         speed_bigram = _find_ngram_in_list(manager.speed_ngrams[2], speed_bigram_text)
1254 | #         assert speed_bigram is not None, f"Bigram '{speed_bigram_text}' not found in speed_ngrams"
     |                                                                                         ^^^^^^^^^^^^ E501
1255 | #         assert speed_bigram.text == speed_bigram_text, (
1256 | #             f"Bigram text should be '{speed_bigram_text}'"
     |

tests\models\test_ngram_models.py:1262:89: E501 Line too long (98 > 88)
     |
1261 | #         # 2. Verify error n-grams - should find the error bigram "hd"
1262 | #         assert 2 in manager.error_ngrams, "Error n-grams dictionary should have key for bigrams"
     |                                                                                         ^^^^^^^^^^ E501
1263 | #         assert len(manager.error_ngrams[2]) == 1, "Should find exactly one error bigram"
     |

tests\models\test_ngram_models.py:1263:89: E501 Line too long (90 > 88)
     |
1261 | #         # 2. Verify error n-grams - should find the error bigram "hd"
1262 | #         assert 2 in manager.error_ngrams, "Error n-grams dictionary should have key for bigrams"
1263 | #         assert len(manager.error_ngrams[2]) == 1, "Should find exactly one error bigram"
     |                                                                                         ^^ E501
1264 |
1265 | #         # Validate the error bigram 'hd'
     |

tests\models\test_ngram_models.py:1268:89: E501 Line too long (90 > 88)
     |
1266 | #         error_bigram_text = "hd"  # 'h' (correct) + 'd' (error, should be 'e')
1267 | #         error_bigram = _find_ngram_in_list(manager.error_ngrams[2], error_bigram_text)
1268 | #         assert error_bigram is not None, f"Error bigram '{error_bigram_text}' not found"
     |                                                                                         ^^ E501
1269 | #         assert error_bigram.text == error_bigram_text, (
1270 | #             f"Error bigram text should be '{error_bigram_text}'"
     |

tests\models\test_ngram_models.py:1272:89: E501 Line too long (94 > 88)
     |
1270 | #             f"Error bigram text should be '{error_bigram_text}'"
1271 | #         )
1272 | #         assert error_bigram.total_time_ms == 1000, "Error bigram 'hd' time should be 1000ms"
     |                                                                                         ^^^^^^ E501
1273 | #         assert error_bigram.is_error is True, "Error bigram should be marked as an error"
     |

tests\models\test_ngram_models.py:1273:89: E501 Line too long (91 > 88)
     |
1271 | #         )
1272 | #         assert error_bigram.total_time_ms == 1000, "Error bigram 'hd' time should be 1000ms"
1273 | #         assert error_bigram.is_error is True, "Error bigram should be marked as an error"
     |                                                                                         ^^^ E501
1274 |
1275 | #         # 3. Verify error trigram "Thd"
     |

tests\models\test_ngram_models.py:1276:89: E501 Line too long (99 > 88)
     |
1275 | #         # 3. Verify error trigram "Thd"
1276 | #         assert 3 in manager.error_ngrams, "Error n-grams dictionary should have key for trigrams"
     |                                                                                         ^^^^^^^^^^^ E501
1277 | #         assert len(manager.error_ngrams[3]) == 1, "Should find exactly one error trigram"
     |

tests\models\test_ngram_models.py:1277:89: E501 Line too long (91 > 88)
     |
1275 | #         # 3. Verify error trigram "Thd"
1276 | #         assert 3 in manager.error_ngrams, "Error n-grams dictionary should have key for trigrams"
1277 | #         assert len(manager.error_ngrams[3]) == 1, "Should find exactly one error trigram"
     |                                                                                         ^^^ E501
1278 |
1279 | #         # Validate the error trigram 'Thd'
     |

tests\models\test_ngram_models.py:1281:89: E501 Line too long (90 > 88)
     |
1279 | #         # Validate the error trigram 'Thd'
1280 | #         error_trigram_text = "Thd"
1281 | #         error_trigram = _find_ngram_in_list(manager.error_ngrams[3], error_trigram_text)
     |                                                                                         ^^ E501
1282 | #         assert error_trigram is not None, f"Error trigram '{error_trigram_text}' not found"
1283 | #         assert error_trigram.text == error_trigram_text, (
     |

tests\models\test_ngram_models.py:1282:89: E501 Line too long (93 > 88)
     |
1280 | #         error_trigram_text = "Thd"
1281 | #         error_trigram = _find_ngram_in_list(manager.error_ngrams[3], error_trigram_text)
1282 | #         assert error_trigram is not None, f"Error trigram '{error_trigram_text}' not found"
     |                                                                                         ^^^^^ E501
1283 | #         assert error_trigram.text == error_trigram_text, (
1284 | #             f"Error trigram text should be '{error_trigram_text}'"
     |

tests\models\test_ngram_models.py:1286:89: E501 Line too long (97 > 88)
     |
1284 | #             f"Error trigram text should be '{error_trigram_text}'"
1285 | #         )
1286 | #         assert error_trigram.total_time_ms == 1500, "Error trigram 'Thd' time should be 1500ms"
     |                                                                                         ^^^^^^^^^ E501
1287 |
1288 | #         # 4. Verify no quadgrams were identified
     |

tests\models\test_ngram_models.py:1308:89: E501 Line too long (103 > 88)
     |
1306 | #             for ngram in ngrams:
1307 | #                 temp_db.execute(
1308 | #                     "INSERT INTO session_ngram_speed (session_id, ngram_size, ngram, ngram_time_ms) "
     |                                                                                         ^^^^^^^^^^^^^^^ E501
1309 | #                     "VALUES (?, ?, ?, ?)",
1310 | #                     (session_id, size, ngram.text, ngram.avg_time_per_char_ms),
     |

tests\models\test_ngram_models.py:1316:89: E501 Line too long (89 > 88)
     |
1314 | #             for ngram in ngrams:
1315 | #                 temp_db.execute(
1316 | #                     "INSERT INTO session_ngram_errors (session_id, ngram_size, ngram) "
     |                                                                                         ^ E501
1317 | #                     "VALUES (?, ?, ?)",
1318 | #                     (session_id, size, ngram.text),
     |

tests\models\test_ngram_models.py:1326:89: E501 Line too long (122 > 88)
     |
1324 | #         # 1. Check the speed n-grams in database
1325 | #         speed_ngrams = temp_db.fetchall(
1326 | #             "SELECT ngram_size, ngram, ngram_time_ms FROM session_ngram_speed WHERE session_id = ? ORDER BY ngram_size",
     |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
1327 | #             (session_id,),
1328 | #         )
     |

tests\models\test_ngram_models.py:1329:89: E501 Line too long (91 > 88)
     |
1327 | #             (session_id,),
1328 | #         )
1329 | #         assert len(speed_ngrams) == 1, "Should find exactly one speed n-gram in database"
     |                                                                                         ^^^ E501
1330 | #         assert speed_ngrams[0][0] == 2, "Speed n-gram should be size 2"
1331 | #         assert speed_ngrams[0][1] == "Th", "Speed n-gram should be 'Th'"
     |

tests\models\test_ngram_models.py:1332:89: E501 Line too long (99 > 88)
     |
1330 | #         assert speed_ngrams[0][0] == 2, "Speed n-gram should be size 2"
1331 | #         assert speed_ngrams[0][1] == "Th", "Speed n-gram should be 'Th'"
1332 | #         assert speed_ngrams[0][2] == 250, "Speed n-gram time should be 250ms (avg per character)"
     |                                                                                         ^^^^^^^^^^^ E501
1333 |
1334 | #         # 2. Check the error n-grams in database
     |

tests\models\test_ngram_models.py:1336:89: E501 Line too long (115 > 88)
     |
1334 | #         # 2. Check the error n-grams in database
1335 | #         error_ngrams = temp_db.fetchall(
1336 | #             "SELECT ngram_size, ngram FROM session_ngram_errors WHERE session_id = ? ORDER BY ngram_size, ngram",
     |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
1337 | #             (session_id,),
1338 | #         )
     |

tests\models\test_ngram_models.py:1339:89: E501 Line too long (94 > 88)
     |
1337 | #             (session_id,),
1338 | #         )
1339 | #         assert len(error_ngrams) == 2, "Should be exactly two error n-grams in the database"
     |                                                                                         ^^^^^^ E501
1340 |
1341 | #         # Find and verify the error bigram
     |

tests\models\test_ngram_models.py:1359:89: E501 Line too long (102 > 88)
     |
1357 | #         # 1. Check speed n-grams (should only have 'Th')
1358 | #         speed_ngrams = temp_db.fetchall(
1359 | #             "SELECT ngram_size, ngram, ngram_time_ms FROM session_ngram_speed WHERE session_id = ?",
     |                                                                                         ^^^^^^^^^^^^^^ E501
1360 | #             (session_id,),
1361 | #         )
     |

tests\models\test_ngram_models.py:1362:89: E501 Line too long (93 > 88)
     |
1360 | #             (session_id,),
1361 | #         )
1362 | #         assert len(speed_ngrams) == 1, "Should be exactly one speed n-gram in the database"
     |                                                                                         ^^^^^ E501
1363 | #         assert speed_ngrams[0][0] == 2, "Speed n-gram size should be 2 (bigram)"
1364 | #         assert speed_ngrams[0][1] == "Th", "Speed n-gram should be 'Th'"
     |

tests\models\test_ngram_models.py:1365:89: E501 Line too long (99 > 88)
     |
1363 | #         assert speed_ngrams[0][0] == 2, "Speed n-gram size should be 2 (bigram)"
1364 | #         assert speed_ngrams[0][1] == "Th", "Speed n-gram should be 'Th'"
1365 | #         assert speed_ngrams[0][2] == 250, "Speed n-gram time should be 250ms (avg per character)"
     |                                                                                         ^^^^^^^^^^^ E501
1366 |
1367 | #         # 2. Check error n-grams (should have 'hd' and 'Thd')
     |

tests\models\test_ngram_models.py:1369:89: E501 Line too long (115 > 88)
     |
1367 | #         # 2. Check error n-grams (should have 'hd' and 'Thd')
1368 | #         error_ngrams = temp_db.fetchall(
1369 | #             "SELECT ngram_size, ngram FROM session_ngram_errors WHERE session_id = ? ORDER BY ngram_size, ngram",
     |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
1370 | #             (session_id,),
1371 | #         )
     |

tests\models\test_ngram_models.py:1372:89: E501 Line too long (94 > 88)
     |
1370 | #             (session_id,),
1371 | #         )
1372 | #         assert len(error_ngrams) == 2, "Should be exactly two error n-grams in the database"
     |                                                                                         ^^^^^^ E501
1373 |
1374 | #         # Verify 'hd' bigram
     |

tests\models\test_ngram_models.py:1387:89: E501 Line too long (89 > 88)
     |
1385 | #         error_prone_bigrams = manager.get_most_error_prone_ngrams(size=2)
1386 | #         assert len(error_prone_bigrams) == 1, "Should be one error-prone bigram"
1387 | #         assert error_prone_bigrams[0].text == "hd", "Error-prone bigram should be 'hd'"
     |                                                                                         ^ E501
1388 |
1389 | #         error_prone_trigrams = manager.get_most_error_prone_ngrams(size=3)
     |

tests\models\test_ngram_models.py:1391:89: E501 Line too long (93 > 88)
     |
1389 | #         error_prone_trigrams = manager.get_most_error_prone_ngrams(size=3)
1390 | #         assert len(error_prone_trigrams) == 1, "Should be one error-prone trigram"
1391 | #         assert error_prone_trigrams[0].text == "Thd", "Error-prone trigram should be 'Thd'"
     |                                                                                         ^^^^^ E501
1392 |
1393 | #         # Check get_slowest_ngrams (should only return clean n-grams)
     |

tests\models\test_ngram_models_p2.py:82:89: E501 Line too long (90 > 88)
   |
80 | #     snippet_id = str(uuid.uuid4())
81 | #     temp_db.execute(
82 | #         "INSERT INTO snippets (snippet_id, category_id, snippet_name) VALUES (?, ?, ?)",
   |                                                                                         ^^ E501
83 | #         (snippet_id, category_id, "Test Snippet"),
84 | #     )
   |

tests\models\test_ngram_models_p2.py:89:89: E501 Line too long (102 > 88)
   |
87 | #     part_id = str(uuid.uuid4())
88 | #     temp_db.execute(
89 | #         "INSERT INTO snippet_parts (part_id, snippet_id, part_number, content) VALUES (?, ?, ?, ?)",
   |                                                                                         ^^^^^^^^^^^^^^ E501
90 | #         (part_id, snippet_id, 1, "test typing content"),
91 | #     )
   |

tests\models\test_ngram_models_p2.py:154:89: E501 Line too long (92 > 88)
    |
152 | #             keystroke_id=str(uuid.uuid4()),
153 | #             session_id=test_practice_session.session_id,
154 | #             keystroke_time=now + datetime.timedelta(milliseconds=1500),  # 1500 from start
    |                                                                                         ^^^^ E501
155 | #             keystroke_char="e",
156 | #             expected_char="e",
    |

tests\models\test_ngram_models_p2.py:163:89: E501 Line too long (92 > 88)
    |
161 | #             keystroke_id=str(uuid.uuid4()),
162 | #             session_id=test_practice_session.session_id,
163 | #             keystroke_time=now + datetime.timedelta(milliseconds=1800),  # 1800 from start
    |                                                                                         ^^^^ E501
164 | #             keystroke_char="n",
165 | #             expected_char="n",
    |

tests\models\test_ngram_models_p2.py:176:89: E501 Line too long (120 > 88)
    |
174 | #             """
175 | #             INSERT INTO session_keystrokes
176 | #             (session_id, keystroke_id, keystroke_time, keystroke_char, expected_char, is_correct, time_since_previous)
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
177 | #             VALUES (?, ?, ?, ?, ?, ?, ?)
178 | #             """,
    |

tests\models\test_ngram_models_p2.py:256:89: E501 Line too long (120 > 88)
    |
254 | #             """
255 | #             INSERT INTO session_keystrokes
256 | #             (session_id, keystroke_id, keystroke_time, keystroke_char, expected_char, is_correct, time_since_previous)
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
257 | #             VALUES (?, ?, ?, ?, ?, ?, ?)
258 | #             """,
    |

tests\models\test_ngram_models_p2.py:336:89: E501 Line too long (120 > 88)
    |
334 | #             """
335 | #             INSERT INTO session_keystrokes
336 | #             (session_id, keystroke_id, keystroke_time, keystroke_char, expected_char, is_correct, time_since_previous)
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
337 | #             VALUES (?, ?, ?, ?, ?, ?, ?)
338 | #             """,
    |

tests\models\test_ngram_models_p2.py:416:89: E501 Line too long (120 > 88)
    |
414 | #             """
415 | #             INSERT INTO session_keystrokes
416 | #             (session_id, keystroke_id, keystroke_time, keystroke_char, expected_char, is_correct, time_since_previous)
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
417 | #             VALUES (?, ?, ?, ?, ?, ?, ?)
418 | #             """,
    |

tests\models\test_ngram_models_p2.py:496:89: E501 Line too long (120 > 88)
    |
494 | #             """
495 | #             INSERT INTO session_keystrokes
496 | #             (session_id, keystroke_id, keystroke_time, keystroke_char, expected_char, is_correct, time_since_previous)
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
497 | #             VALUES (?, ?, ?, ?, ?, ?, ?)
498 | #             """,
    |

tests\models\test_ngram_models_p2.py:513:89: E501 Line too long (91 > 88)
    |
513 | # # All test NGram objects and dicts in this file should include ngram_id as a UUID string.
    |                                                                                         ^^^ E501
514 | # class TestNGramModelsExtended:
515 | #     """Extended test suite for NGram model and analyzer functionality with longer sequences."""
    |

tests\models\test_ngram_models_p2.py:515:89: E501 Line too long (97 > 88)
    |
513 | # # All test NGram objects and dicts in this file should include ngram_id as a UUID string.
514 | # class TestNGramModelsExtended:
515 | #     """Extended test suite for NGram model and analyzer functionality with longer sequences."""
    |                                                                                         ^^^^^^^^^ E501
516 |
517 | #     def test_four_keystrokes_no_errors(
    |

tests\models\test_ngram_models_p3.py:109:89: E501 Line too long (90 > 88)
    |
107 | #     snippet_id = str(uuid.uuid4())
108 | #     temp_db.execute(
109 | #         "INSERT INTO snippets (snippet_id, category_id, snippet_name) VALUES (?, ?, ?)",
    |                                                                                         ^^ E501
110 | #         (snippet_id, category_id, "Test Snippet"),
111 | #     )
    |

tests\models\test_ngram_models_p3.py:116:89: E501 Line too long (102 > 88)
    |
114 | #     part_id = str(uuid.uuid4())
115 | #     temp_db.execute(
116 | #         "INSERT INTO snippet_parts (part_id, snippet_id, part_number, content) VALUES (?, ?, ?, ?)",
    |                                                                                         ^^^^^^^^^^^^^^ E501
117 | #         (part_id, snippet_id, 1, "Then"),
118 | #     )
    |

tests\models\test_ngram_models_p3.py:239:89: E501 Line too long (104 > 88)
    |
237 | #     ) -> None:
238 | #         """
239 | #         Test objective: Verify that keystrokes with a backspace after an error are analyzed correctly.
    |                                                                                         ^^^^^^^^^^^^^^^^ E501
240 |
241 | #         This test checks a scenario where:
    |

tests\models\test_ngram_models_p3.py:254:89: E501 Line too long (90 > 88)
    |
252 | #         - In database: 3 rows in session_ngram_speed, 0 rows in session_ngram_errors
253 |
254 | #         This test is important for validation of the modernized n-gram analysis approach
    |                                                                                         ^^ E501
255 | #         that supports flexible n-gram sizes from 2-8 and correctly handles editing actions
256 | #         like backspaces while still producing valid speed and error statistics.
    |

tests\models\test_ngram_models_p3.py:255:89: E501 Line too long (92 > 88)
    |
254 | #         This test is important for validation of the modernized n-gram analysis approach
255 | #         that supports flexible n-gram sizes from 2-8 and correctly handles editing actions
    |                                                                                         ^^^^ E501
256 | #         like backspaces while still producing valid speed and error statistics.
257 | #         """
    |

tests\models\test_ngram_models_p3.py:261:89: E501 Line too long (97 > 88)
    |
260 | #         # Create and analyze the NGramManager
261 | #         analyzer = NGramManager(test_practice_session, five_keystrokes_with_backspace, temp_db)
    |                                                                                         ^^^^^^^^^ E501
262 | #         analyzer.analyze(min_size=2, max_size=5)
    |

tests\models\test_ngram_models_p3.py:267:89: E501 Line too long (98 > 88)
    |
265 | #         # Uncomment for troubleshooting if needed
266 | #         # print(f"\nBackspace handling test details:")
267 | #         # print(f"All keystrokes: {[k.keystroke_char for k in five_keystrokes_with_backspace]}")
    |                                                                                         ^^^^^^^^^^ E501
268 | #         # print(f"Speed ngrams of length 2: {len(analyzer.speed_ngrams[2])}")
269 | #         # for ngram in analyzer.speed_ngrams[2]:
    |

tests\models\test_ngram_models_p3.py:270:89: E501 Line too long (107 > 88)
    |
268 | #         # print(f"Speed ngrams of length 2: {len(analyzer.speed_ngrams[2])}")
269 | #         # for ngram in analyzer.speed_ngrams[2]:
270 | #         #     print(f"  Bigram: {ngram.text}, time: {ngram.total_time_ms}ms, is_clean: {ngram.is_clean}")
    |                                                                                         ^^^^^^^^^^^^^^^^^^^ E501
271 | #         #
272 | #         # print(f"Speed ngrams of length 3: {len(analyzer.speed_ngrams[3])}")
    |

tests\models\test_ngram_models_p3.py:274:89: E501 Line too long (108 > 88)
    |
272 | #         # print(f"Speed ngrams of length 3: {len(analyzer.speed_ngrams[3])}")
273 | #         # for ngram in analyzer.speed_ngrams[3]:
274 | #         #     print(f"  Trigram: {ngram.text}, time: {ngram.total_time_ms}ms, is_clean: {ngram.is_clean}")
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^ E501
275 |
276 | #         # Verify correct number of n-grams found
    |

tests\models\test_ngram_models_p3.py:286:89: E501 Line too long (91 > 88)
    |
285 | #         # Length 4 and 5 n-grams (should be none)
286 | #         assert len(analyzer.speed_ngrams[4]) == 0, "Should find 0 valid length-4 n-grams"
    |                                                                                         ^^^ E501
287 | #         assert len(analyzer.speed_ngrams[5]) == 0, "Should find 0 valid length-5 n-grams"
    |

tests\models\test_ngram_models_p3.py:287:89: E501 Line too long (91 > 88)
    |
285 | #         # Length 4 and 5 n-grams (should be none)
286 | #         assert len(analyzer.speed_ngrams[4]) == 0, "Should find 0 valid length-4 n-grams"
287 | #         assert len(analyzer.speed_ngrams[5]) == 0, "Should find 0 valid length-5 n-grams"
    |                                                                                         ^^^ E501
288 |
289 | #         # Verify the bigram "Th"
    |

tests\models\test_ngram_models_p3.py:317:89: E501 Line too long (97 > 88)
    |
315 | #         assert trigram_the.size == 3, "Trigram size should be 3"
316 | #         assert len(trigram_the.keystrokes) == 3, "Trigram should have 3 keystrokes"
317 | #         assert trigram_the.total_time_ms == 470, "Trigram 'The' time should be 470ms (300+170)"
    |                                                                                         ^^^^^^^^^ E501
318 | #         assert trigram_the.is_clean is True, "Trigram should be clean (no errors)"
319 | #         assert trigram_the.is_error is False, "Trigram should not be an error trigram"
    |

tests\models\test_ngram_models_p3.py:343:89: E501 Line too long (90 > 88)
    |
342 | #         # First should be bigram "Th" with avg 150ms per char
343 | #         assert speed_ngrams[0][0] == 2, "First database entry should be bigram (size 2)"
    |                                                                                         ^^ E501
344 | #         assert speed_ngrams[0][1] == "Th", "First database entry should be bigram 'Th'"
345 | #         assert speed_ngrams[0][2] == 150, "Database 'Th' time should be 150ms avg (300ms/2)"
    |

tests\models\test_ngram_models_p3.py:344:89: E501 Line too long (89 > 88)
    |
342 | #         # First should be bigram "Th" with avg 150ms per char
343 | #         assert speed_ngrams[0][0] == 2, "First database entry should be bigram (size 2)"
344 | #         assert speed_ngrams[0][1] == "Th", "First database entry should be bigram 'Th'"
    |                                                                                         ^ E501
345 | #         assert speed_ngrams[0][2] == 150, "Database 'Th' time should be 150ms avg (300ms/2)"
    |

tests\models\test_ngram_models_p3.py:345:89: E501 Line too long (94 > 88)
    |
343 | #         assert speed_ngrams[0][0] == 2, "First database entry should be bigram (size 2)"
344 | #         assert speed_ngrams[0][1] == "Th", "First database entry should be bigram 'Th'"
345 | #         assert speed_ngrams[0][2] == 150, "Database 'Th' time should be 150ms avg (300ms/2)"
    |                                                                                         ^^^^^^ E501
346 |
347 | #         # Second should be bigram "he" with avg 85ms per char
    |

tests\models\test_ngram_models_p3.py:348:89: E501 Line too long (91 > 88)
    |
347 | #         # Second should be bigram "he" with avg 85ms per char
348 | #         assert speed_ngrams[1][0] == 2, "Second database entry should be bigram (size 2)"
    |                                                                                         ^^^ E501
349 | #         assert speed_ngrams[1][1] == "he", "Second database entry should be bigram 'he'"
350 | #         assert speed_ngrams[1][2] == 85, "Database 'he' time should be 85ms avg (170ms/2)"
    |

tests\models\test_ngram_models_p3.py:349:89: E501 Line too long (90 > 88)
    |
347 | #         # Second should be bigram "he" with avg 85ms per char
348 | #         assert speed_ngrams[1][0] == 2, "Second database entry should be bigram (size 2)"
349 | #         assert speed_ngrams[1][1] == "he", "Second database entry should be bigram 'he'"
    |                                                                                         ^^ E501
350 | #         assert speed_ngrams[1][2] == 85, "Database 'he' time should be 85ms avg (170ms/2)"
    |

tests\models\test_ngram_models_p3.py:350:89: E501 Line too long (92 > 88)
    |
348 | #         assert speed_ngrams[1][0] == 2, "Second database entry should be bigram (size 2)"
349 | #         assert speed_ngrams[1][1] == "he", "Second database entry should be bigram 'he'"
350 | #         assert speed_ngrams[1][2] == 85, "Database 'he' time should be 85ms avg (170ms/2)"
    |                                                                                         ^^^^ E501
351 |
352 | #         # Third should be trigram "The" with avg time of ~156.67ms per char
    |

tests\models\test_ngram_models_p3.py:353:89: E501 Line too long (91 > 88)
    |
352 | #         # Third should be trigram "The" with avg time of ~156.67ms per char
353 | #         assert speed_ngrams[2][0] == 3, "Third database entry should be trigram (size 3)"
    |                                                                                         ^^^ E501
354 | #         assert speed_ngrams[2][1] == "The", "Third database entry should be trigram 'The'"
355 | #         # We expect 470ms / 3 = ~156.67ms per char
    |

tests\models\test_ngram_models_p3.py:354:89: E501 Line too long (92 > 88)
    |
352 | #         # Third should be trigram "The" with avg time of ~156.67ms per char
353 | #         assert speed_ngrams[2][0] == 3, "Third database entry should be trigram (size 3)"
354 | #         assert speed_ngrams[2][1] == "The", "Third database entry should be trigram 'The'"
    |                                                                                         ^^^^ E501
355 | #         # We expect 470ms / 3 = ~156.67ms per char
356 | #         expected_avg_time = 470 / 3
    |

tests\models\test_ngram_models_p3.py:363:89: E501 Line too long (93 > 88)
    |
361 | #         # Verify no error n-grams were saved
362 | #         error_ngrams_count = temp_db.fetchone(
363 | #             "SELECT COUNT(*) FROM session_ngram_errors WHERE session_id = ?", (session_id,)
    |                                                                                         ^^^^^ E501
364 | #         )[0]
365 | #         assert error_ngrams_count == 0, "No error n-grams should be saved to the database"
    |

tests\models\test_ngram_models_p3.py:365:89: E501 Line too long (92 > 88)
    |
363 | #             "SELECT COUNT(*) FROM session_ngram_errors WHERE session_id = ?", (session_id,)
364 | #         )[0]
365 | #         assert error_ngrams_count == 0, "No error n-grams should be saved to the database"
    |                                                                                         ^^^^ E501
366 |
367 | #         # Verify the slowest and error-prone n-grams
    |

tests\models\test_ngram_models_p3.py:381:89: E501 Line too long (119 > 88)
    |
379 | #     ):
380 | #         """
381 | #         Test objective: Verify that keystrokes with a backspace after a second-position error are analyzed correctly.
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
382 |
383 | #         This test checks a scenario where:
    |

tests\models\test_ngram_models_p3.py:411:89: E501 Line too long (89 > 88)
    |
410 | #         # Length 3+ n-grams (should be none)
411 | #         assert len(analyzer.speed_ngrams[3]) == 0, "Should find 0 valid speed trigrams"
    |                                                                                         ^ E501
412 | #         assert len(analyzer.speed_ngrams[4]) == 0, "Should find 0 valid length-4 n-grams"
413 | #         assert len(analyzer.speed_ngrams[5]) == 0, "Should find 0 valid length-5 n-grams"
    |

tests\models\test_ngram_models_p3.py:412:89: E501 Line too long (91 > 88)
    |
410 | #         # Length 3+ n-grams (should be none)
411 | #         assert len(analyzer.speed_ngrams[3]) == 0, "Should find 0 valid speed trigrams"
412 | #         assert len(analyzer.speed_ngrams[4]) == 0, "Should find 0 valid length-4 n-grams"
    |                                                                                         ^^^ E501
413 | #         assert len(analyzer.speed_ngrams[5]) == 0, "Should find 0 valid length-5 n-grams"
    |

tests\models\test_ngram_models_p3.py:413:89: E501 Line too long (91 > 88)
    |
411 | #         assert len(analyzer.speed_ngrams[3]) == 0, "Should find 0 valid speed trigrams"
412 | #         assert len(analyzer.speed_ngrams[4]) == 0, "Should find 0 valid length-4 n-grams"
413 | #         assert len(analyzer.speed_ngrams[5]) == 0, "Should find 0 valid length-5 n-grams"
    |                                                                                         ^^^ E501
414 |
415 | #         # Verify the speed bigram "he"
    |

tests\models\test_ngram_models_p3.py:450:89: E501 Line too long (91 > 88)
    |
448 | #         )
449 |
450 | #         assert len(speed_ngrams) == 1, "Should be exactly 1 speed n-gram in the database"
    |                                                                                         ^^^ E501
451 |
452 | #         # Check the speed bigram "he"
    |

tests\models\test_ngram_models_p3.py:467:89: E501 Line too long (91 > 88)
    |
465 | #         )
466 |
467 | #         assert len(error_ngrams) == 1, "Should be exactly 1 error n-gram in the database"
    |                                                                                         ^^^ E501
468 |
469 | #         # Check the error bigram "Tg"
    |

tests\models\test_ngram_models_p3.py:475:89: E501 Line too long (93 > 88)
    |
474 | #     def test_five_keystrokes_backspace_at_third_no_mistake(
475 | #         self, temp_db, test_practice_session, five_keystrokes_backspace_at_third_no_mistake
    |                                                                                         ^^^^^ E501
476 | #     ):
477 | #         """
    |

tests\models\test_ngram_models_p3.py:478:89: E501 Line too long (126 > 88)
    |
476 | #     ):
477 | #         """
478 | #         Test objective: Verify that keystrokes with a backspace at third position (no prior mistake) are analyzed correctly.
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
479 |
480 | #         This test checks a scenario where:
    |

tests\models\test_ngram_models_p3.py:499:89: E501 Line too long (91 > 88)
    |
497 | #         # Create and analyze the NGramManager
498 | #         analyzer = NGramManager(
499 | #             test_practice_session, five_keystrokes_backspace_at_third_no_mistake, temp_db
    |                                                                                         ^^^ E501
500 | #         )
501 | #         analyzer.analyze(min_size=2, max_size=5)
    |

tests\models\test_ngram_models_p3.py:509:89: E501 Line too long (89 > 88)
    |
508 | #         # Length 3+ n-grams (should be none)
509 | #         assert len(analyzer.speed_ngrams[3]) == 0, "Should find 0 valid speed trigrams"
    |                                                                                         ^ E501
510 | #         assert len(analyzer.speed_ngrams[4]) == 0, "Should find 0 valid length-4 n-grams"
511 | #         assert len(analyzer.speed_ngrams[5]) == 0, "Should find 0 valid length-5 n-grams"
    |

tests\models\test_ngram_models_p3.py:510:89: E501 Line too long (91 > 88)
    |
508 | #         # Length 3+ n-grams (should be none)
509 | #         assert len(analyzer.speed_ngrams[3]) == 0, "Should find 0 valid speed trigrams"
510 | #         assert len(analyzer.speed_ngrams[4]) == 0, "Should find 0 valid length-4 n-grams"
    |                                                                                         ^^^ E501
511 | #         assert len(analyzer.speed_ngrams[5]) == 0, "Should find 0 valid length-5 n-grams"
    |

tests\models\test_ngram_models_p3.py:511:89: E501 Line too long (91 > 88)
    |
509 | #         assert len(analyzer.speed_ngrams[3]) == 0, "Should find 0 valid speed trigrams"
510 | #         assert len(analyzer.speed_ngrams[4]) == 0, "Should find 0 valid length-4 n-grams"
511 | #         assert len(analyzer.speed_ngrams[5]) == 0, "Should find 0 valid length-5 n-grams"
    |                                                                                         ^^^ E501
512 |
513 | #         # Verify the speed bigram "Th"
    |

tests\models\test_ngram_models_p3.py:548:89: E501 Line too long (92 > 88)
    |
546 | #         )
547 |
548 | #         assert len(speed_ngrams) == 2, "Should be exactly 2 speed n-grams in the database"
    |                                                                                         ^^^^ E501
549 |
550 | #         # Check each n-gram's data in the database
    |

tests\models\test_ngram_models_p3.py:552:89: E501 Line too long (90 > 88)
    |
550 | #         # Check each n-gram's data in the database
551 | #         # Check the speed bigram "Th"
552 | #         assert speed_ngrams[0][0] == 2, "First database entry should be bigram (size 2)"
    |                                                                                         ^^ E501
553 | #         assert speed_ngrams[0][1] == "Th", "First database entry should be bigram 'Th'"
554 | #         assert speed_ngrams[0][2] == 250, "Database 'Th' time should be 250ms avg (500ms/2)"
    |

tests\models\test_ngram_models_p3.py:553:89: E501 Line too long (89 > 88)
    |
551 | #         # Check the speed bigram "Th"
552 | #         assert speed_ngrams[0][0] == 2, "First database entry should be bigram (size 2)"
553 | #         assert speed_ngrams[0][1] == "Th", "First database entry should be bigram 'Th'"
    |                                                                                         ^ E501
554 | #         assert speed_ngrams[0][2] == 250, "Database 'Th' time should be 250ms avg (500ms/2)"
    |

tests\models\test_ngram_models_p3.py:554:89: E501 Line too long (94 > 88)
    |
552 | #         assert speed_ngrams[0][0] == 2, "First database entry should be bigram (size 2)"
553 | #         assert speed_ngrams[0][1] == "Th", "First database entry should be bigram 'Th'"
554 | #         assert speed_ngrams[0][2] == 250, "Database 'Th' time should be 250ms avg (500ms/2)"
    |                                                                                         ^^^^^^ E501
555 |
556 | #         # Check the speed bigram "he"
    |

tests\models\test_ngram_models_p3.py:557:89: E501 Line too long (91 > 88)
    |
556 | #         # Check the speed bigram "he"
557 | #         assert speed_ngrams[1][0] == 2, "Second database entry should be bigram (size 2)"
    |                                                                                         ^^^ E501
558 | #         assert speed_ngrams[1][1] == "he", "Second database entry should be bigram 'he'"
559 | #         assert speed_ngrams[1][2] == 85, "Database 'he' time should be 85ms avg (170ms/2)"
    |

tests\models\test_ngram_models_p3.py:558:89: E501 Line too long (90 > 88)
    |
556 | #         # Check the speed bigram "he"
557 | #         assert speed_ngrams[1][0] == 2, "Second database entry should be bigram (size 2)"
558 | #         assert speed_ngrams[1][1] == "he", "Second database entry should be bigram 'he'"
    |                                                                                         ^^ E501
559 | #         assert speed_ngrams[1][2] == 85, "Database 'he' time should be 85ms avg (170ms/2)"
    |

tests\models\test_ngram_models_p3.py:559:89: E501 Line too long (92 > 88)
    |
557 | #         assert speed_ngrams[1][0] == 2, "Second database entry should be bigram (size 2)"
558 | #         assert speed_ngrams[1][1] == "he", "Second database entry should be bigram 'he'"
559 | #         assert speed_ngrams[1][2] == 85, "Database 'he' time should be 85ms avg (170ms/2)"
    |                                                                                         ^^^^ E501
560 |
561 | #         # Verify no error n-grams were saved
    |

tests\models\test_ngram_models_p3.py:563:89: E501 Line too long (93 > 88)
    |
561 | #         # Verify no error n-grams were saved
562 | #         error_ngrams_count = temp_db.fetchone(
563 | #             "SELECT COUNT(*) FROM session_ngram_errors WHERE session_id = ?", (session_id,)
    |                                                                                         ^^^^^ E501
564 | #         )[0]
565 | #         assert error_ngrams_count == 0, "No error n-grams should be saved to the database"
    |

tests\models\test_ngram_models_p3.py:565:89: E501 Line too long (92 > 88)
    |
563 | #             "SELECT COUNT(*) FROM session_ngram_errors WHERE session_id = ?", (session_id,)
564 | #         )[0]
565 | #         assert error_ngrams_count == 0, "No error n-grams should be saved to the database"
    |                                                                                         ^^^^ E501
566 |
567 | #     def test_five_keystrokes_space_at_third(
    |

tests\models\test_ngram_models_p3.py:571:89: E501 Line too long (103 > 88)
    |
569 | #     ):
570 | #         """
571 | #         Test objective: Verify that keystrokes with a space at third position are analyzed correctly.
    |                                                                                         ^^^^^^^^^^^^^^^ E501
572 |
573 | #         This test checks a scenario where:
    |

tests\models\test_ngram_models_p3.py:587:89: E501 Line too long (97 > 88)
    |
586 | #         # Create and analyze the NGramManager
587 | #         analyzer = NGramManager(test_practice_session, five_keystrokes_space_at_third, temp_db)
    |                                                                                         ^^^^^^^^^ E501
588 | #         analyzer.analyze(min_size=2, max_size=5)
    |

tests\models\test_ngram_models_p3.py:596:89: E501 Line too long (89 > 88)
    |
595 | #         # Length 3+ n-grams (should be none)
596 | #         assert len(analyzer.speed_ngrams[3]) == 0, "Should find 0 valid speed trigrams"
    |                                                                                         ^ E501
597 | #         assert len(analyzer.speed_ngrams[4]) == 0, "Should find 0 valid length-4 n-grams"
598 | #         assert len(analyzer.speed_ngrams[5]) == 0, "Should find 0 valid length-5 n-grams"
    |

tests\models\test_ngram_models_p3.py:597:89: E501 Line too long (91 > 88)
    |
595 | #         # Length 3+ n-grams (should be none)
596 | #         assert len(analyzer.speed_ngrams[3]) == 0, "Should find 0 valid speed trigrams"
597 | #         assert len(analyzer.speed_ngrams[4]) == 0, "Should find 0 valid length-4 n-grams"
    |                                                                                         ^^^ E501
598 | #         assert len(analyzer.speed_ngrams[5]) == 0, "Should find 0 valid length-5 n-grams"
    |

tests\models\test_ngram_models_p3.py:598:89: E501 Line too long (91 > 88)
    |
596 | #         assert len(analyzer.speed_ngrams[3]) == 0, "Should find 0 valid speed trigrams"
597 | #         assert len(analyzer.speed_ngrams[4]) == 0, "Should find 0 valid length-4 n-grams"
598 | #         assert len(analyzer.speed_ngrams[5]) == 0, "Should find 0 valid length-5 n-grams"
    |                                                                                         ^^^ E501
599 |
600 | #         # Verify the speed bigram "Th"
    |

tests\models\test_ngram_models_p3.py:635:89: E501 Line too long (92 > 88)
    |
633 | #         )
634 |
635 | #         assert len(speed_ngrams) == 2, "Should be exactly 2 speed n-grams in the database"
    |                                                                                         ^^^^ E501
636 |
637 | #         # Check each n-gram's data in the database
    |

tests\models\test_ngram_models_p3.py:639:89: E501 Line too long (90 > 88)
    |
637 | #         # Check each n-gram's data in the database
638 | #         # Check the speed bigram "Th"
639 | #         assert speed_ngrams[0][0] == 2, "First database entry should be bigram (size 2)"
    |                                                                                         ^^ E501
640 | #         assert speed_ngrams[0][1] == "Th", "First database entry should be bigram 'Th'"
641 | #         assert speed_ngrams[0][2] == 250, "Database 'Th' time should be 250ms avg (500ms/2)"
    |

tests\models\test_ngram_models_p3.py:640:89: E501 Line too long (89 > 88)
    |
638 | #         # Check the speed bigram "Th"
639 | #         assert speed_ngrams[0][0] == 2, "First database entry should be bigram (size 2)"
640 | #         assert speed_ngrams[0][1] == "Th", "First database entry should be bigram 'Th'"
    |                                                                                         ^ E501
641 | #         assert speed_ngrams[0][2] == 250, "Database 'Th' time should be 250ms avg (500ms/2)"
    |

tests\models\test_ngram_models_p3.py:641:89: E501 Line too long (94 > 88)
    |
639 | #         assert speed_ngrams[0][0] == 2, "First database entry should be bigram (size 2)"
640 | #         assert speed_ngrams[0][1] == "Th", "First database entry should be bigram 'Th'"
641 | #         assert speed_ngrams[0][2] == 250, "Database 'Th' time should be 250ms avg (500ms/2)"
    |                                                                                         ^^^^^^ E501
642 |
643 | #         # Check the speed bigram "en"
    |

tests\models\test_ngram_models_p3.py:644:89: E501 Line too long (91 > 88)
    |
643 | #         # Check the speed bigram "en"
644 | #         assert speed_ngrams[1][0] == 2, "Second database entry should be bigram (size 2)"
    |                                                                                         ^^^ E501
645 | #         assert speed_ngrams[1][1] == "en", "Second database entry should be bigram 'en'"
646 | #         assert speed_ngrams[1][2] == 85, "Database 'en' time should be 85ms avg (170ms/2)"
    |

tests\models\test_ngram_models_p3.py:645:89: E501 Line too long (90 > 88)
    |
643 | #         # Check the speed bigram "en"
644 | #         assert speed_ngrams[1][0] == 2, "Second database entry should be bigram (size 2)"
645 | #         assert speed_ngrams[1][1] == "en", "Second database entry should be bigram 'en'"
    |                                                                                         ^^ E501
646 | #         assert speed_ngrams[1][2] == 85, "Database 'en' time should be 85ms avg (170ms/2)"
    |

tests\models\test_ngram_models_p3.py:646:89: E501 Line too long (92 > 88)
    |
644 | #         assert speed_ngrams[1][0] == 2, "Second database entry should be bigram (size 2)"
645 | #         assert speed_ngrams[1][1] == "en", "Second database entry should be bigram 'en'"
646 | #         assert speed_ngrams[1][2] == 85, "Database 'en' time should be 85ms avg (170ms/2)"
    |                                                                                         ^^^^ E501
647 |
648 | #         # Verify no error n-grams were saved
    |

tests\models\test_ngram_models_p3.py:650:89: E501 Line too long (93 > 88)
    |
648 | #         # Verify no error n-grams were saved
649 | #         error_ngrams_count = temp_db.fetchone(
650 | #             "SELECT COUNT(*) FROM session_ngram_errors WHERE session_id = ?", (session_id,)
    |                                                                                         ^^^^^ E501
651 | #         )[0]
652 | #         assert error_ngrams_count == 0, "No error n-grams should be saved to the database"
    |

tests\models\test_ngram_models_p3.py:652:89: E501 Line too long (92 > 88)
    |
650 | #             "SELECT COUNT(*) FROM session_ngram_errors WHERE session_id = ?", (session_id,)
651 | #         )[0]
652 | #         assert error_ngrams_count == 0, "No error n-grams should be saved to the database"
    |                                                                                         ^^^^ E501
653 |
654 | #     def test_five_keystrokes_space_at_second(
    |

tests\models\test_ngram_models_p3.py:658:89: E501 Line too long (104 > 88)
    |
656 | #     ):
657 | #         """
658 | #         Test objective: Verify that keystrokes with a space at second position are analyzed correctly.
    |                                                                                         ^^^^^^^^^^^^^^^^ E501
659 |
660 | #         This test checks a scenario where:
    |

tests\models\test_ngram_models_p3.py:674:89: E501 Line too long (98 > 88)
    |
673 | #         # Create and analyze the NGramManager
674 | #         analyzer = NGramManager(test_practice_session, five_keystrokes_space_at_second, temp_db)
    |                                                                                         ^^^^^^^^^^ E501
675 | #         analyzer.analyze(min_size=2, max_size=5)
    |

tests\models\test_ngram_models_p3.py:687:89: E501 Line too long (91 > 88)
    |
686 | #         # Length 4+ n-grams (should be none)
687 | #         assert len(analyzer.speed_ngrams[4]) == 0, "Should find 0 valid length-4 n-grams"
    |                                                                                         ^^^ E501
688 | #         assert len(analyzer.speed_ngrams[5]) == 0, "Should find 0 valid length-5 n-grams"
    |

tests\models\test_ngram_models_p3.py:688:89: E501 Line too long (91 > 88)
    |
686 | #         # Length 4+ n-grams (should be none)
687 | #         assert len(analyzer.speed_ngrams[4]) == 0, "Should find 0 valid length-4 n-grams"
688 | #         assert len(analyzer.speed_ngrams[5]) == 0, "Should find 0 valid length-5 n-grams"
    |                                                                                         ^^^ E501
689 |
690 | #         # Verify the speed bigram "ca"
    |

tests\models\test_ngram_models_p3.py:736:89: E501 Line too long (92 > 88)
    |
734 | #         )
735 |
736 | #         assert len(speed_ngrams) == 3, "Should be exactly 3 speed n-grams in the database"
    |                                                                                         ^^^^ E501
737 |
738 | #         # Check the speed bigrams and trigram
    |

tests\models\test_ngram_models_p3.py:740:89: E501 Line too long (90 > 88)
    |
738 | #         # Check the speed bigrams and trigram
739 | #         # Check the speed bigram "at"
740 | #         assert speed_ngrams[0][0] == 2, "First database entry should be bigram (size 2)"
    |                                                                                         ^^ E501
741 | #         assert speed_ngrams[0][1] == "at", "First database entry should be bigram 'at'"
742 | #         assert speed_ngrams[0][2] == 85, "Database 'at' time should be 85ms avg (170ms/2)"
    |

tests\models\test_ngram_models_p3.py:741:89: E501 Line too long (89 > 88)
    |
739 | #         # Check the speed bigram "at"
740 | #         assert speed_ngrams[0][0] == 2, "First database entry should be bigram (size 2)"
741 | #         assert speed_ngrams[0][1] == "at", "First database entry should be bigram 'at'"
    |                                                                                         ^ E501
742 | #         assert speed_ngrams[0][2] == 85, "Database 'at' time should be 85ms avg (170ms/2)"
    |

tests\models\test_ngram_models_p3.py:742:89: E501 Line too long (92 > 88)
    |
740 | #         assert speed_ngrams[0][0] == 2, "First database entry should be bigram (size 2)"
741 | #         assert speed_ngrams[0][1] == "at", "First database entry should be bigram 'at'"
742 | #         assert speed_ngrams[0][2] == 85, "Database 'at' time should be 85ms avg (170ms/2)"
    |                                                                                         ^^^^ E501
743 |
744 | #         # Check the speed bigram "ca"
    |

tests\models\test_ngram_models_p3.py:745:89: E501 Line too long (91 > 88)
    |
744 | #         # Check the speed bigram "ca"
745 | #         assert speed_ngrams[1][0] == 2, "Second database entry should be bigram (size 2)"
    |                                                                                         ^^^ E501
746 | #         assert speed_ngrams[1][1] == "ca", "Second database entry should be bigram 'ca'"
747 | #         assert speed_ngrams[1][2] == 150, "Database 'ca' time should be 150ms avg (300ms/2)"
    |

tests\models\test_ngram_models_p3.py:746:89: E501 Line too long (90 > 88)
    |
744 | #         # Check the speed bigram "ca"
745 | #         assert speed_ngrams[1][0] == 2, "Second database entry should be bigram (size 2)"
746 | #         assert speed_ngrams[1][1] == "ca", "Second database entry should be bigram 'ca'"
    |                                                                                         ^^ E501
747 | #         assert speed_ngrams[1][2] == 150, "Database 'ca' time should be 150ms avg (300ms/2)"
    |

tests\models\test_ngram_models_p3.py:747:89: E501 Line too long (94 > 88)
    |
745 | #         assert speed_ngrams[1][0] == 2, "Second database entry should be bigram (size 2)"
746 | #         assert speed_ngrams[1][1] == "ca", "Second database entry should be bigram 'ca'"
747 | #         assert speed_ngrams[1][2] == 150, "Database 'ca' time should be 150ms avg (300ms/2)"
    |                                                                                         ^^^^^^ E501
748 |
749 | #         # Check the speed trigram "cat"
    |

tests\models\test_ngram_models_p3.py:750:89: E501 Line too long (91 > 88)
    |
749 | #         # Check the speed trigram "cat"
750 | #         assert speed_ngrams[2][0] == 3, "Third database entry should be trigram (size 3)"
    |                                                                                         ^^^ E501
751 | #         assert speed_ngrams[2][1] == "cat", "Third database entry should be trigram 'cat'"
752 | #         # The average is 470/3 = 156.67ms, rounded depending on DB implementation
    |

tests\models\test_ngram_models_p3.py:751:89: E501 Line too long (92 > 88)
    |
749 | #         # Check the speed trigram "cat"
750 | #         assert speed_ngrams[2][0] == 3, "Third database entry should be trigram (size 3)"
751 | #         assert speed_ngrams[2][1] == "cat", "Third database entry should be trigram 'cat'"
    |                                                                                         ^^^^ E501
752 | #         # The average is 470/3 = 156.67ms, rounded depending on DB implementation
753 | #         assert abs(speed_ngrams[2][2] - 156.67) < 0.5, (
    |

tests\models\test_ngram_models_p3.py:754:89: E501 Line too long (96 > 88)
    |
752 | #         # The average is 470/3 = 156.67ms, rounded depending on DB implementation
753 | #         assert abs(speed_ngrams[2][2] - 156.67) < 0.5, (
754 | #             f"Database 'cat' time should be ~156.67ms avg (470ms/3), got {speed_ngrams[2][2]}"
    |                                                                                         ^^^^^^^^ E501
755 | #         )
    |

tests\models\test_ngram_models_p3.py:759:89: E501 Line too long (93 > 88)
    |
757 | #         # Verify no error n-grams were saved
758 | #         error_ngrams_count = temp_db.fetchone(
759 | #             "SELECT COUNT(*) FROM session_ngram_errors WHERE session_id = ?", (session_id,)
    |                                                                                         ^^^^^ E501
760 | #         )[0]
761 | #         assert error_ngrams_count == 0, "No error n-grams should be saved to the database"
    |

tests\models\test_ngram_models_p3.py:761:89: E501 Line too long (92 > 88)
    |
759 | #             "SELECT COUNT(*) FROM session_ngram_errors WHERE session_id = ?", (session_id,)
760 | #         )[0]
761 | #         assert error_ngrams_count == 0, "No error n-grams should be saved to the database"
    |                                                                                         ^^^^ E501
762 |
763 | #     def test_five_keystrokes_space_at_fifth(
    |

tests\models\test_ngram_models_p3.py:767:89: E501 Line too long (103 > 88)
    |
765 | #     ):
766 | #         """
767 | #         Test objective: Verify that keystrokes with a space at fifth position are analyzed correctly.
    |                                                                                         ^^^^^^^^^^^^^^^ E501
768 |
769 | #         This test checks a scenario where:
    |

tests\models\test_ngram_models_p3.py:784:89: E501 Line too long (97 > 88)
    |
783 | #         # Create and analyze the NGramManager
784 | #         analyzer = NGramManager(test_practice_session, five_keystrokes_space_at_fifth, temp_db)
    |                                                                                         ^^^^^^^^^ E501
785 | #         analyzer.analyze(min_size=2, max_size=5)
    |

tests\models\test_ngram_models_p3.py:793:89: E501 Line too long (89 > 88)
    |
792 | #         # Length 3 n-grams (trigrams)
793 | #         assert len(analyzer.speed_ngrams[3]) == 2, "Should find 2 valid speed trigrams"
    |                                                                                         ^ E501
794 | #         assert len(analyzer.error_ngrams[3]) == 0, "Should find 0 error trigrams"
    |

tests\models\test_ngram_models_p3.py:797:89: E501 Line too long (90 > 88)
    |
796 | #         # Length 4 n-grams
797 | #         assert len(analyzer.speed_ngrams[4]) == 1, "Should find 1 valid length-4 n-gram"
    |                                                                                         ^^ E501
798 | #         assert len(analyzer.error_ngrams[4]) == 0, "Should find 0 error length-4 n-grams"
    |

tests\models\test_ngram_models_p3.py:798:89: E501 Line too long (91 > 88)
    |
796 | #         # Length 4 n-grams
797 | #         assert len(analyzer.speed_ngrams[4]) == 1, "Should find 1 valid length-4 n-gram"
798 | #         assert len(analyzer.error_ngrams[4]) == 0, "Should find 0 error length-4 n-grams"
    |                                                                                         ^^^ E501
799 |
800 | #         # Length 5 n-grams (should be none)
    |

tests\models\test_ngram_models_p3.py:801:89: E501 Line too long (91 > 88)
    |
800 | #         # Length 5 n-grams (should be none)
801 | #         assert len(analyzer.speed_ngrams[5]) == 0, "Should find 0 valid length-5 n-grams"
    |                                                                                         ^^^ E501
802 |
803 | #         # Verify the speed bigram "Th"
    |

tests\models\test_ngram_models_p3.py:842:89: E501 Line too long (89 > 88)
    |
840 | #         assert trigram_the.size == 3, "Trigram size should be 3"
841 | #         assert len(trigram_the.keystrokes) == 3, "Trigram should have 3 keystrokes"
842 | #         assert trigram_the.total_time_ms == 1500, "Trigram 'The' time should be 1500ms"
    |                                                                                         ^ E501
843 | #         assert trigram_the.is_clean is True, "Trigram should be clean (no errors)"
844 | #         assert trigram_the.is_error is False, "Trigram should not be an error trigram"
    |

tests\models\test_ngram_models_p3.py:853:89: E501 Line too long (89 > 88)
    |
851 | #         assert trigram_hen.size == 3, "Trigram size should be 3"
852 | #         assert len(trigram_hen.keystrokes) == 3, "Trigram should have 3 keystrokes"
853 | #         assert trigram_hen.total_time_ms == 1300, "Trigram 'hen' time should be 1300ms"
    |                                                                                         ^ E501
854 | #         assert trigram_hen.is_clean is True, "Trigram should be clean (no errors)"
855 | #         assert trigram_hen.is_error is False, "Trigram should not be an error trigram"
    |

tests\models\test_ngram_models_p3.py:864:89: E501 Line too long (91 > 88)
    |
862 | #         assert fourgram_then.size == 4, "4-gram size should be 4"
863 | #         assert len(fourgram_then.keystrokes) == 4, "4-gram should have 4 keystrokes"
864 | #         assert fourgram_then.total_time_ms == 1800, "4-gram 'Then' time should be 1800ms"
    |                                                                                         ^^^ E501
865 | #         assert fourgram_then.is_clean is True, "4-gram should be clean (no errors)"
866 | #         assert fourgram_then.is_error is False, "4-gram should not be an error n-gram"
    |

tests\models\test_ngram_models_p3.py:882:89: E501 Line too long (92 > 88)
    |
880 | #         )
881 |
882 | #         assert len(speed_ngrams) == 6, "Should be exactly 6 speed n-grams in the database"
    |                                                                                         ^^^^ E501
883 |
884 | #         # Check the bigrams (first 3 entries should be size 2)
    |

tests\models\test_ngram_models_p3.py:885:89: E501 Line too long (90 > 88)
    |
884 | #         # Check the bigrams (first 3 entries should be size 2)
885 | #         assert speed_ngrams[0][0] == 2, "First database entry should be bigram (size 2)"
    |                                                                                         ^^ E501
886 | #         assert speed_ngrams[0][1] in ["Th", "en", "he"], "First bigram entry has correct text"
    |

tests\models\test_ngram_models_p3.py:886:89: E501 Line too long (96 > 88)
    |
884 | #         # Check the bigrams (first 3 entries should be size 2)
885 | #         assert speed_ngrams[0][0] == 2, "First database entry should be bigram (size 2)"
886 | #         assert speed_ngrams[0][1] in ["Th", "en", "he"], "First bigram entry has correct text"
    |                                                                                         ^^^^^^^^ E501
887 |
888 | #         assert speed_ngrams[1][0] == 2, "Second database entry should be bigram (size 2)"
    |

tests\models\test_ngram_models_p3.py:888:89: E501 Line too long (91 > 88)
    |
886 | #         assert speed_ngrams[0][1] in ["Th", "en", "he"], "First bigram entry has correct text"
887 |
888 | #         assert speed_ngrams[1][0] == 2, "Second database entry should be bigram (size 2)"
    |                                                                                         ^^^ E501
889 | #         assert speed_ngrams[1][1] in ["Th", "en", "he"], "Second bigram entry has correct text"
    |

tests\models\test_ngram_models_p3.py:889:89: E501 Line too long (97 > 88)
    |
888 | #         assert speed_ngrams[1][0] == 2, "Second database entry should be bigram (size 2)"
889 | #         assert speed_ngrams[1][1] in ["Th", "en", "he"], "Second bigram entry has correct text"
    |                                                                                         ^^^^^^^^^ E501
890 |
891 | #         assert speed_ngrams[2][0] == 2, "Third database entry should be bigram (size 2)"
    |

tests\models\test_ngram_models_p3.py:891:89: E501 Line too long (90 > 88)
    |
889 | #         assert speed_ngrams[1][1] in ["Th", "en", "he"], "Second bigram entry has correct text"
890 |
891 | #         assert speed_ngrams[2][0] == 2, "Third database entry should be bigram (size 2)"
    |                                                                                         ^^ E501
892 | #         assert speed_ngrams[2][1] in ["Th", "en", "he"], "Third bigram entry has correct text"
    |

tests\models\test_ngram_models_p3.py:892:89: E501 Line too long (96 > 88)
    |
891 | #         assert speed_ngrams[2][0] == 2, "Third database entry should be bigram (size 2)"
892 | #         assert speed_ngrams[2][1] in ["Th", "en", "he"], "Third bigram entry has correct text"
    |                                                                                         ^^^^^^^^ E501
893 |
894 | #         # Check the trigrams (next 2 entries should be size 3)
    |

tests\models\test_ngram_models_p3.py:895:89: E501 Line too long (92 > 88)
    |
894 | #         # Check the trigrams (next 2 entries should be size 3)
895 | #         assert speed_ngrams[3][0] == 3, "Fourth database entry should be trigram (size 3)"
    |                                                                                         ^^^^ E501
896 | #         assert speed_ngrams[3][1] in ["The", "hen"], "Fourth entry should be a valid trigram"
    |

tests\models\test_ngram_models_p3.py:896:89: E501 Line too long (95 > 88)
    |
894 | #         # Check the trigrams (next 2 entries should be size 3)
895 | #         assert speed_ngrams[3][0] == 3, "Fourth database entry should be trigram (size 3)"
896 | #         assert speed_ngrams[3][1] in ["The", "hen"], "Fourth entry should be a valid trigram"
    |                                                                                         ^^^^^^^ E501
897 |
898 | #         assert speed_ngrams[4][0] == 3, "Fifth database entry should be trigram (size 3)"
    |

tests\models\test_ngram_models_p3.py:898:89: E501 Line too long (91 > 88)
    |
896 | #         assert speed_ngrams[3][1] in ["The", "hen"], "Fourth entry should be a valid trigram"
897 |
898 | #         assert speed_ngrams[4][0] == 3, "Fifth database entry should be trigram (size 3)"
    |                                                                                         ^^^ E501
899 | #         assert speed_ngrams[4][1] in ["The", "hen"], "Fifth entry should be a valid trigram"
    |

tests\models\test_ngram_models_p3.py:899:89: E501 Line too long (94 > 88)
    |
898 | #         assert speed_ngrams[4][0] == 3, "Fifth database entry should be trigram (size 3)"
899 | #         assert speed_ngrams[4][1] in ["The", "hen"], "Fifth entry should be a valid trigram"
    |                                                                                         ^^^^^^ E501
900 |
901 | #         # Check the 4-gram (last entry should be size 4)
    |

tests\models\test_ngram_models_p3.py:902:89: E501 Line too long (90 > 88)
    |
901 | #         # Check the 4-gram (last entry should be size 4)
902 | #         assert speed_ngrams[5][0] == 4, "Sixth database entry should be 4-gram (size 4)"
    |                                                                                         ^^ E501
903 | #         assert speed_ngrams[5][1] == "Then", "Sixth entry should be 4-gram 'Then'"
904 | #         # The average is 1800/4 = 450ms, allowing for small rounding differences
    |

tests\models\test_ngram_models_p3.py:906:89: E501 Line too long (95 > 88)
    |
904 | #         # The average is 1800/4 = 450ms, allowing for small rounding differences
905 | #         assert abs(speed_ngrams[5][2] - 450) < 0.5, (
906 | #             f"Database 'Then' time should be ~450ms avg (1800ms/4), got {speed_ngrams[5][2]}"
    |                                                                                         ^^^^^^^ E501
907 | #         )
    |

tests\models\test_ngram_models_p3.py:911:89: E501 Line too long (93 > 88)
    |
909 | #         # Verify no error n-grams were saved
910 | #         error_ngrams_count = temp_db.fetchone(
911 | #             "SELECT COUNT(*) FROM session_ngram_errors WHERE session_id = ?", (session_id,)
    |                                                                                         ^^^^^ E501
912 | #         )[0]
913 | #         assert error_ngrams_count == 0, "No error n-grams should be saved to the database"
    |

tests\models\test_ngram_models_p3.py:913:89: E501 Line too long (92 > 88)
    |
911 | #             "SELECT COUNT(*) FROM session_ngram_errors WHERE session_id = ?", (session_id,)
912 | #         )[0]
913 | #         assert error_ngrams_count == 0, "No error n-grams should be saved to the database"
    |                                                                                         ^^^^ E501
914 |
915 | #     def test_five_keystrokes_th_space_th(temp_db, test_practice_session) -> List[Keystroke]:
    |

tests\models\test_ngram_models_p3.py:915:89: E501 Line too long (94 > 88)
    |
913 | #         assert error_ngrams_count == 0, "No error n-grams should be saved to the database"
914 |
915 | #     def test_five_keystrokes_th_space_th(temp_db, test_practice_session) -> List[Keystroke]:
    |                                                                                         ^^^^^^ E501
916 | #         """
917 | #         Test objective: Create five keystrokes representing 'T-h-space-T-h'.
    |

tests\models\test_ngram_models_p3.py:933:89: E501 Line too long (90 > 88)
    |
931 | #         - Fifth keystroke (h): 300ms after T
932 |
933 | #         This represents the situation where a user types 'Th Th' with consistent timing.
    |                                                                                         ^^ E501
934 | #         The analyzer should create two separate 'Th' ngrams.
935 | #         """
    |

tests\models\test_ngram_models_p3.py:989:89: E501 Line too long (91 > 88)
    |
989 | # def test_th_space_th_ngrams(temp_db, test_practice_session, five_keystrokes_th_space_th):
    |                                                                                         ^^^ E501
990 | #     """
991 | #     Test objective: Verify that 'T-h-space-T-h' creates exactly 2 ngrams.
    |

tests\models\test_ngram_persist.py:60:89: E501 Line too long (94 > 88)
   |
58 |     user_id = str(uuid.uuid4())
59 |     db_with_tables.execute(
60 |         "INSERT INTO users (user_id, first_name, surname, email_address) VALUES (?, ?, ?, ?)",
   |                                                                                         ^^^^^^ E501
61 |         (user_id, "Test", "User", f"testuser_{user_id[:8]}@example.com"),
62 |     )
   |

tests\models\test_ngram_persist.py:79:89: E501 Line too long (94 > 88)
   |
77 | @pytest.fixture
78 | def test_session(
79 |     db_with_tables: DatabaseManager, test_snippet: Snippet, test_user: str, test_keyboard: str
   |                                                                                         ^^^^^^ E501
80 | ) -> Session:
81 |     """Create a test session for tests with valid user_id and keyboard_id."""
   |

tests\models\test_ngram_persist.py:148:89: E501 Line too long (109 > 88)
    |
147 | # Test cases for testing ngram persistence
148 | # Format: (keystrokes, expected, error_indices, ngram_size, expected_in_speed_table, expected_in_error_table)
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^ E501
149 | NGRAM_PERSIST_TEST_CASES = [
150 |     # Case 1: Simple clean, valid ngram of size 2
    |

tests\models\test_ngram_persist.py:172:89: E501 Line too long (96 > 88)
    |
170 |         [("abc", 3)],  # <-- expected-text, not actual
171 |     ),
172 |     # Case 5: Trigram with error in middle (not at last position) - should not be saved anywhere
    |                                                                                         ^^^^^^^^ E501
173 |     ("aBc", "abc", [1], 3, [], []),
174 |     # Case 6: Longer sequence, size 4, clean
    |

tests\models\test_ngram_persist.py:183:89: E501 Line too long (97 > 88)
    |
181 |     ("abcdefghijk", "abcdefghijk", [], 11, [("abcdefghijk", 11)], []),
182 |     # Case 10: Size 20 ngram (maximum allowed size, should be saved)
183 |     ("abcdefghijklmnopqrst", "abcdefghijklmnopqrst", [], 20, [("abcdefghijklmnopqrst", 20)], []),
    |                                                                                         ^^^^^^^^^ E501
184 |     # Case 11: Size 21 ngram (exceeds max size, should not be saved)
185 |     ("abcdefghijklmnopqrstu", "abcdefghijklmnopqrstu", [], 21, [], []),
    |

tests\models\test_ngram_persist.py:186:89: E501 Line too long (97 > 88)
    |
184 |     # Case 11: Size 21 ngram (exceeds max size, should not be saved)
185 |     ("abcdefghijklmnopqrstu", "abcdefghijklmnopqrstu", [], 21, [], []),
186 |     # Case 13: Zero duration (two consecutive keystrokes with same timestamp) should not be saved
    |                                                                                         ^^^^^^^^^ E501
187 |     (
188 |         "xy",
    |

tests\models\test_ngram_persist.py:209:89: E501 Line too long (110 > 88)
    |
208 | @pytest.mark.parametrize(
209 |     "chars, expected, error_indices, ngram_size, exp_speed_ngrams, exp_error_ngrams", NGRAM_PERSIST_TEST_CASES
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^ E501
210 | )
211 | def test_ngram_persistence(
    |

tests\models\test_ngram_persist.py:238:89: E501 Line too long (90 > 88)
    |
236 |     # Special case for test 10: zero duration
237 |     if chars == "xy" and expected == "xy" and not error_indices and ngram_size == 2:
238 |         # Create keystrokes with the EXACT same timestamp object for testing zero duration
    |                                                                                         ^^ E501
239 |         ts = datetime.now()
240 |         keystrokes = [
    |

tests\models\test_ngram_persist.py:247:89: E501 Line too long (99 > 88)
    |
245 |     else:
246 |         # Create normal keystroke sequence
247 |         keystrokes = create_keystroke_sequence(chars, expected, datetime.now(), 100, error_indices)
    |                                                                                         ^^^^^^^^^^^ E501
248 |
249 |     # Generate ngrams
    |

tests\models\test_ngram_persist.py:276:89: E501 Line too long (91 > 88)
    |
275 |     assert sorted(actual_speed_ngrams) == sorted(exp_speed_ngrams), (
276 |         f"Speed ngrams don't match: expected {exp_speed_ngrams}, got {actual_speed_ngrams}"
    |                                                                                         ^^^ E501
277 |     )
    |

tests\models\test_ngram_persist.py:286:89: E501 Line too long (91 > 88)
    |
284 |     actual_error_ngrams = [(row[0], row[1]) for row in error_ngrams]
285 |     assert sorted(actual_error_ngrams) == sorted(exp_error_ngrams), (
286 |         f"Error ngrams don't match: expected {exp_error_ngrams}, got {actual_error_ngrams}"
    |                                                                                         ^^^ E501
287 |     )
    |

tests\models\test_ngram_persist.py:306:89: E501 Line too long (92 > 88)
    |
304 |     start_time = datetime.now()
305 |     keystrokes = [
306 |         Keystroke(char="T", expected="T", timestamp=start_time + timedelta(milliseconds=0)),
    |                                                                                         ^^^^ E501
307 |         Keystroke(char="h", expected="h", timestamp=start_time + timedelta(milliseconds=100)),
308 |         Keystroke(char="e", expected="e", timestamp=start_time + timedelta(milliseconds=200)),
    |

tests\models\test_ngram_persist.py:307:89: E501 Line too long (94 > 88)
    |
305 |     keystrokes = [
306 |         Keystroke(char="T", expected="T", timestamp=start_time + timedelta(milliseconds=0)),
307 |         Keystroke(char="h", expected="h", timestamp=start_time + timedelta(milliseconds=100)),
    |                                                                                         ^^^^^^ E501
308 |         Keystroke(char="e", expected="e", timestamp=start_time + timedelta(milliseconds=200)),
309 |         Keystroke(char=" ", expected=" ", timestamp=start_time + timedelta(milliseconds=300)),
    |

tests\models\test_ngram_persist.py:308:89: E501 Line too long (94 > 88)
    |
306 |         Keystroke(char="T", expected="T", timestamp=start_time + timedelta(milliseconds=0)),
307 |         Keystroke(char="h", expected="h", timestamp=start_time + timedelta(milliseconds=100)),
308 |         Keystroke(char="e", expected="e", timestamp=start_time + timedelta(milliseconds=200)),
    |                                                                                         ^^^^^^ E501
309 |         Keystroke(char=" ", expected=" ", timestamp=start_time + timedelta(milliseconds=300)),
310 |         Keystroke(char="q", expected="q", timestamp=start_time + timedelta(milliseconds=400)),
    |

tests\models\test_ngram_persist.py:309:89: E501 Line too long (94 > 88)
    |
307 |         Keystroke(char="h", expected="h", timestamp=start_time + timedelta(milliseconds=100)),
308 |         Keystroke(char="e", expected="e", timestamp=start_time + timedelta(milliseconds=200)),
309 |         Keystroke(char=" ", expected=" ", timestamp=start_time + timedelta(milliseconds=300)),
    |                                                                                         ^^^^^^ E501
310 |         Keystroke(char="q", expected="q", timestamp=start_time + timedelta(milliseconds=400)),
311 |         Keystroke(char="u", expected="u", timestamp=start_time + timedelta(milliseconds=500)),
    |

tests\models\test_ngram_persist.py:310:89: E501 Line too long (94 > 88)
    |
308 |         Keystroke(char="e", expected="e", timestamp=start_time + timedelta(milliseconds=200)),
309 |         Keystroke(char=" ", expected=" ", timestamp=start_time + timedelta(milliseconds=300)),
310 |         Keystroke(char="q", expected="q", timestamp=start_time + timedelta(milliseconds=400)),
    |                                                                                         ^^^^^^ E501
311 |         Keystroke(char="u", expected="u", timestamp=start_time + timedelta(milliseconds=500)),
312 |         Keystroke(char="i", expected="i", timestamp=start_time + timedelta(milliseconds=600)),
    |

tests\models\test_ngram_persist.py:311:89: E501 Line too long (94 > 88)
    |
309 |         Keystroke(char=" ", expected=" ", timestamp=start_time + timedelta(milliseconds=300)),
310 |         Keystroke(char="q", expected="q", timestamp=start_time + timedelta(milliseconds=400)),
311 |         Keystroke(char="u", expected="u", timestamp=start_time + timedelta(milliseconds=500)),
    |                                                                                         ^^^^^^ E501
312 |         Keystroke(char="i", expected="i", timestamp=start_time + timedelta(milliseconds=600)),
313 |         Keystroke(char="c", expected="c", timestamp=start_time + timedelta(milliseconds=700)),
    |

tests\models\test_ngram_persist.py:312:89: E501 Line too long (94 > 88)
    |
310 |         Keystroke(char="q", expected="q", timestamp=start_time + timedelta(milliseconds=400)),
311 |         Keystroke(char="u", expected="u", timestamp=start_time + timedelta(milliseconds=500)),
312 |         Keystroke(char="i", expected="i", timestamp=start_time + timedelta(milliseconds=600)),
    |                                                                                         ^^^^^^ E501
313 |         Keystroke(char="c", expected="c", timestamp=start_time + timedelta(milliseconds=700)),
314 |         Keystroke(char="k", expected="k", timestamp=start_time + timedelta(milliseconds=800)),
    |

tests\models\test_ngram_persist.py:313:89: E501 Line too long (94 > 88)
    |
311 |         Keystroke(char="u", expected="u", timestamp=start_time + timedelta(milliseconds=500)),
312 |         Keystroke(char="i", expected="i", timestamp=start_time + timedelta(milliseconds=600)),
313 |         Keystroke(char="c", expected="c", timestamp=start_time + timedelta(milliseconds=700)),
    |                                                                                         ^^^^^^ E501
314 |         Keystroke(char="k", expected="k", timestamp=start_time + timedelta(milliseconds=800)),
315 |         Keystroke(char=" ", expected=" ", timestamp=start_time + timedelta(milliseconds=900)),
    |

tests\models\test_ngram_persist.py:314:89: E501 Line too long (94 > 88)
    |
312 |         Keystroke(char="i", expected="i", timestamp=start_time + timedelta(milliseconds=600)),
313 |         Keystroke(char="c", expected="c", timestamp=start_time + timedelta(milliseconds=700)),
314 |         Keystroke(char="k", expected="k", timestamp=start_time + timedelta(milliseconds=800)),
    |                                                                                         ^^^^^^ E501
315 |         Keystroke(char=" ", expected=" ", timestamp=start_time + timedelta(milliseconds=900)),
316 |         # Error here (uppercase B instead of lowercase)
    |

tests\models\test_ngram_persist.py:315:89: E501 Line too long (94 > 88)
    |
313 |         Keystroke(char="c", expected="c", timestamp=start_time + timedelta(milliseconds=700)),
314 |         Keystroke(char="k", expected="k", timestamp=start_time + timedelta(milliseconds=800)),
315 |         Keystroke(char=" ", expected=" ", timestamp=start_time + timedelta(milliseconds=900)),
    |                                                                                         ^^^^^^ E501
316 |         # Error here (uppercase B instead of lowercase)
317 |         Keystroke(char="B", expected="b", timestamp=start_time + timedelta(milliseconds=1000)),
    |

tests\models\test_ngram_persist.py:317:89: E501 Line too long (95 > 88)
    |
315 |         Keystroke(char=" ", expected=" ", timestamp=start_time + timedelta(milliseconds=900)),
316 |         # Error here (uppercase B instead of lowercase)
317 |         Keystroke(char="B", expected="b", timestamp=start_time + timedelta(milliseconds=1000)),
    |                                                                                         ^^^^^^^ E501
318 |         Keystroke(char="r", expected="r", timestamp=start_time + timedelta(milliseconds=1100)),
319 |         Keystroke(char="o", expected="o", timestamp=start_time + timedelta(milliseconds=1200)),
    |

tests\models\test_ngram_persist.py:318:89: E501 Line too long (95 > 88)
    |
316 |         # Error here (uppercase B instead of lowercase)
317 |         Keystroke(char="B", expected="b", timestamp=start_time + timedelta(milliseconds=1000)),
318 |         Keystroke(char="r", expected="r", timestamp=start_time + timedelta(milliseconds=1100)),
    |                                                                                         ^^^^^^^ E501
319 |         Keystroke(char="o", expected="o", timestamp=start_time + timedelta(milliseconds=1200)),
320 |         Keystroke(char="w", expected="w", timestamp=start_time + timedelta(milliseconds=1300)),
    |

tests\models\test_ngram_persist.py:319:89: E501 Line too long (95 > 88)
    |
317 |         Keystroke(char="B", expected="b", timestamp=start_time + timedelta(milliseconds=1000)),
318 |         Keystroke(char="r", expected="r", timestamp=start_time + timedelta(milliseconds=1100)),
319 |         Keystroke(char="o", expected="o", timestamp=start_time + timedelta(milliseconds=1200)),
    |                                                                                         ^^^^^^^ E501
320 |         Keystroke(char="w", expected="w", timestamp=start_time + timedelta(milliseconds=1300)),
321 |         Keystroke(char="n", expected="n", timestamp=start_time + timedelta(milliseconds=1400)),
    |

tests\models\test_ngram_persist.py:320:89: E501 Line too long (95 > 88)
    |
318 |         Keystroke(char="r", expected="r", timestamp=start_time + timedelta(milliseconds=1100)),
319 |         Keystroke(char="o", expected="o", timestamp=start_time + timedelta(milliseconds=1200)),
320 |         Keystroke(char="w", expected="w", timestamp=start_time + timedelta(milliseconds=1300)),
    |                                                                                         ^^^^^^^ E501
321 |         Keystroke(char="n", expected="n", timestamp=start_time + timedelta(milliseconds=1400)),
322 |         Keystroke(char=" ", expected=" ", timestamp=start_time + timedelta(milliseconds=1500)),
    |

tests\models\test_ngram_persist.py:321:89: E501 Line too long (95 > 88)
    |
319 |         Keystroke(char="o", expected="o", timestamp=start_time + timedelta(milliseconds=1200)),
320 |         Keystroke(char="w", expected="w", timestamp=start_time + timedelta(milliseconds=1300)),
321 |         Keystroke(char="n", expected="n", timestamp=start_time + timedelta(milliseconds=1400)),
    |                                                                                         ^^^^^^^ E501
322 |         Keystroke(char=" ", expected=" ", timestamp=start_time + timedelta(milliseconds=1500)),
323 |         Keystroke(char="f", expected="f", timestamp=start_time + timedelta(milliseconds=1600)),
    |

tests\models\test_ngram_persist.py:322:89: E501 Line too long (95 > 88)
    |
320 |         Keystroke(char="w", expected="w", timestamp=start_time + timedelta(milliseconds=1300)),
321 |         Keystroke(char="n", expected="n", timestamp=start_time + timedelta(milliseconds=1400)),
322 |         Keystroke(char=" ", expected=" ", timestamp=start_time + timedelta(milliseconds=1500)),
    |                                                                                         ^^^^^^^ E501
323 |         Keystroke(char="f", expected="f", timestamp=start_time + timedelta(milliseconds=1600)),
324 |         Keystroke(char="o", expected="o", timestamp=start_time + timedelta(milliseconds=1700)),
    |

tests\models\test_ngram_persist.py:323:89: E501 Line too long (95 > 88)
    |
321 |         Keystroke(char="n", expected="n", timestamp=start_time + timedelta(milliseconds=1400)),
322 |         Keystroke(char=" ", expected=" ", timestamp=start_time + timedelta(milliseconds=1500)),
323 |         Keystroke(char="f", expected="f", timestamp=start_time + timedelta(milliseconds=1600)),
    |                                                                                         ^^^^^^^ E501
324 |         Keystroke(char="o", expected="o", timestamp=start_time + timedelta(milliseconds=1700)),
325 |         Keystroke(char="x", expected="x", timestamp=start_time + timedelta(milliseconds=1800)),
    |

tests\models\test_ngram_persist.py:324:89: E501 Line too long (95 > 88)
    |
322 |         Keystroke(char=" ", expected=" ", timestamp=start_time + timedelta(milliseconds=1500)),
323 |         Keystroke(char="f", expected="f", timestamp=start_time + timedelta(milliseconds=1600)),
324 |         Keystroke(char="o", expected="o", timestamp=start_time + timedelta(milliseconds=1700)),
    |                                                                                         ^^^^^^^ E501
325 |         Keystroke(char="x", expected="x", timestamp=start_time + timedelta(milliseconds=1800)),
326 |     ]
    |

tests\models\test_ngram_persist.py:325:89: E501 Line too long (95 > 88)
    |
323 |         Keystroke(char="f", expected="f", timestamp=start_time + timedelta(milliseconds=1600)),
324 |         Keystroke(char="o", expected="o", timestamp=start_time + timedelta(milliseconds=1700)),
325 |         Keystroke(char="x", expected="x", timestamp=start_time + timedelta(milliseconds=1800)),
    |                                                                                         ^^^^^^^ E501
326 |     ]
    |

tests\models\test_ngram_persist.py:343:89: E501 Line too long (93 > 88)
    |
341 |     # Check speed table (clean trigrams, no spaces)
342 |     speed_ngrams = db_with_tables.fetchall(
343 |         "SELECT ngram_text FROM session_ngram_speed WHERE session_id = ? AND ngram_size = ?",
    |                                                                                         ^^^^^ E501
344 |         (test_session.session_id, ngram_size),
345 |     )
    |

tests\models\test_ngram_persist.py:347:89: E501 Line too long (96 > 88)
    |
345 |     )
346 |     actual_speed_ngrams = [row[0] for row in speed_ngrams]
347 |     expected_speed_trigrams = ["The", "qui", "uic", "ick", "rown", "own", "wn f", "n fo", "fox"]
    |                                                                                         ^^^^^^^^ E501
348 |
349 |     # Verify each expected trigram is in the actual results
    |

tests\models\test_ngram_persist.py:358:89: E501 Line too long (94 > 88)
    |
356 |     # Check error table (should have no trigram errors with error only at last position)
357 |     error_ngrams = db_with_tables.fetchall(
358 |         "SELECT ngram_text FROM session_ngram_errors WHERE session_id = ? AND ngram_size = ?",
    |                                                                                         ^^^^^^ E501
359 |         (test_session.session_id, ngram_size),
360 |     )
    |

tests\models\test_ngram_persist.py:362:89: E501 Line too long (95 > 88)
    |
360 |     )
361 |     actual_error_ngrams = [row[0] for row in error_ngrams]
362 |     # The only trigram with an error at the last position would be if a trigram ended with 'B',
    |                                                                                         ^^^^^^^ E501
363 |     # but that would be " qB" which isn't valid due to the space
364 |     assert len(actual_error_ngrams) == 0, (
    |

tests\models\test_ngram_size.py:68:89: E501 Line too long (94 > 88)
   |
66 |     user_id = str(uuid.uuid4())
67 |     temp_db.execute(
68 |         "INSERT INTO users (user_id, first_name, surname, email_address) VALUES (?, ?, ?, ?)",
   |                                                                                         ^^^^^^ E501
69 |         (user_id, "Test", "User", f"testuser_{user_id[:8]}@example.com"),
70 |     )
   |

tests\models\test_ngram_size.py:102:89: E501 Line too long (242 > 88)
    |
100 | ΓÇª
101 | ΓÇª
102 | ΓÇªd, snippet_index_start, snippet_index_end, content, start_time, end_time, actual_chars, errors, ms_per_keystroke) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)",
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
103 | ΓÇª
104 | ΓÇª
    |

tests\models\test_ngram_size.py:125:89: E501 Line too long (97 > 88)
    |
125 | def test_ngram_size_counts(temp_db: DatabaseManager, session: Session, snippet: Snippet) -> None:
    |                                                                                         ^^^^^^^^^ E501
126 |     # Simulate keystrokes for the snippet
127 |     km = KeystrokeManager(temp_db)
    |

tests\models\test_ngram_size.py:152:89: E501 Line too long (94 > 88)
    |
150 |     # Check n-gram counts for sizes 2-10
151 |     for n in range(2, 11):
152 |         query = "SELECT COUNT(*) FROM session_ngram_speed WHERE session_id=? AND ngram_size=?"
    |                                                                                         ^^^^^^ E501
153 |         count = temp_db.fetchone(query, (session.session_id, n))[0]
154 |         assert count == expected_ngram_count(len(snippet.content), n), (
    |

tests\models\test_ngram_size.py:155:89: E501 Line too long (101 > 88)
    |
153 |         count = temp_db.fetchone(query, (session.session_id, n))[0]
154 |         assert count == expected_ngram_count(len(snippet.content), n), (
155 |             f"N-gram size {n}: expected {expected_ngram_count(len(snippet.content), n)}, got {count}"
    |                                                                                         ^^^^^^^^^^^^^ E501
156 |         )
    |

tests\models\test_ngram_size.py:174:89: E501 Line too long (95 > 88)
    |
172 |     ],
173 | )
174 | def test_ngram_size_counts_various_lengths(temp_db: DatabaseManager, test_string: str) -> None:
    |                                                                                         ^^^^^^^ E501
175 |     # Create category
176 |     cat_id = str(uuid.uuid4())
    |

tests\models\test_ngram_size.py:178:89: E501 Line too long (96 > 88)
    |
176 |     cat_id = str(uuid.uuid4())
177 |     temp_db.execute(
178 |         "INSERT INTO categories (category_id, category_name) VALUES (?, ?)", (cat_id, "TestCat")
    |                                                                                         ^^^^^^^^ E501
179 |     )
180 |     # Create snippet
    |

tests\models\test_ngram_size.py:196:89: E501 Line too long (94 > 88)
    |
194 |     keyboard_id = str(uuid.uuid4())
195 |     temp_db.execute(
196 |         "INSERT INTO users (user_id, first_name, surname, email_address) VALUES (?, ?, ?, ?)",
    |                                                                                         ^^^^^^ E501
197 |         (user_id, "Test", "User", f"testuser_{user_id[:8]}@example.com"),
198 |     )
    |

tests\models\test_ngram_size.py:205:89: E501 Line too long (242 > 88)
    |
203 | ΓÇª
204 | ΓÇª
205 | ΓÇªd, snippet_index_start, snippet_index_end, content, start_time, end_time, actual_chars, errors, ms_per_keystroke) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)",
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
206 | ΓÇª
207 | ΓÇª
    |

tests\models\test_ngram_size.py:244:89: E501 Line too long (94 > 88)
    |
242 |     # Check n-gram counts for sizes 2-10
243 |     for n in range(2, 11):
244 |         query = "SELECT COUNT(*) FROM session_ngram_speed WHERE session_id=? AND ngram_size=?"
    |                                                                                         ^^^^^^ E501
245 |         row = temp_db.fetchone(query, (sess_id, n))
246 |         count = row[0] if row else 0
    |

tests\models\test_ngram_size.py:249:89: E501 Line too long (91 > 88)
    |
247 |         expected = expected_ngram_count(len(test_string), n)
248 |         assert count == expected, (
249 |             f"N-gram size {n}: expected {expected}, got {count} for string '{test_string}'"
    |                                                                                         ^^^ E501
250 |         )
    |

tests\models\test_ngram_speed.py:37:89: E501 Line too long (97 > 88)
   |
35 |         def __init__(self, db_manager: DatabaseManager) -> None:
36 |             pass
37 |         def add_snippet(self, category_id: int, name: str, content: str, difficulty: int) -> int:
   |                                                                                         ^^^^^^^^^ E501
38 |             return 1  # Dummy ID
   |

tests\models\test_ngram_speed.py:43:89: E501 Line too long (94 > 88)
   |
41 |         def __init__(self, db_manager: DatabaseManager) -> None:
42 |             pass
43 |         def create_session(self, snippet_id: int, session_type: str, user_id: int = 1) -> int:
   |                                                                                         ^^^^^^ E501
44 |             return 1  # Dummy ID
   |

tests\models\test_ngram_speed.py:94:89: E501 Line too long (93 > 88)
   |
92 |     """
93 |     try:
94 |         category_id = category_manager_fixture.create_category("Test Category - Ngram Speed")
   |                                                                                         ^^^^^ E501
95 |         assert category_id is not None, "Failed to create category"
96 |         snippet_id = snippet_manager_fixture.add_snippet(
   |

tests\models\test_ngram_speed.py:123:89: E501 Line too long (98 > 88)
    |
121 |     if not (MIN_NGRAM_SIZE <= n <= MAX_NGRAM_SIZE):
122 |         return []
123 |     if n > len(keystrokes) or n < 2: # n < 2 would lead to division by zero or undefined for speed
    |                                                                                         ^^^^^^^^^^ E501
124 |         return []
    |

tests\models\test_ngram_speed.py:142:89: E501 Line too long (96 > 88)
    |
140 | # --- Test Cases ---
141 |
142 | KEYSTROKE_SPEED_TEST_CASES: List[Tuple[List[Tuple[str, int]], int, List[Tuple[str, float]]]] = [
    |                                                                                         ^^^^^^^^ E501
143 |     # (keystrokes, n, expected_ngrams_with_speed)
144 |     # Basic cases from prompt
    |

tests\models\test_ngram_speed.py:148:89: E501 Line too long (97 > 88)
    |
146 |     ([("a", 0), ("b", 1000), ("c", 1500)], 3, [("abc", 750.0)]),
147 |     # Consistent 10ms intervals
148 |     ([("t", 0), ("e", 10), ("s", 20), ("t", 30)], 2, [("te", 10.0), ("es", 10.0), ("st", 10.0)]),
    |                                                                                         ^^^^^^^^^ E501
149 |     ([("t", 0), ("e", 10), ("s", 20), ("t", 30)], 3, [("tes", 10.0), ("est", 10.0)]),
150 |     ([("t", 0), ("e", 10), ("s", 20), ("t", 30)], 4, [("test", 10.0)]),
    |

tests\models\test_ngram_speed.py:164:89: E501 Line too long (90 > 88)
    |
162 |         [ ("qw", 150.0), ("we", 50.0), ("er", 200.0)]
163 |     ),
164 |     ([("q", 0), ("w", 150), ("e", 200), ("r", 400)], 3, [("qwe", 100.0), ("wer", 125.0)]),
    |                                                                                         ^^ E501
165 |     # Zero duration (simultaneous keystrokes for the purpose of speed calc)
166 |     ([("x", 0), ("y", 0), ("z", 100)], 2, [("xy", 0.0), ("yz", 100.0)]),
    |

tests\models\test_ngram_speed.py:198:89: E501 Line too long (96 > 88)
    |
196 | ) -> None:
197 |     """
198 |     Test objective: Verify n-gram speed calculation for various keystroke sequences and n-sizes.
    |                                                                                         ^^^^^^^^ E501
199 |     This test uses the test_session_setup fixture as requested, though the fixture's
200 |     outputs are not directly used by generate_ngrams_with_speed itself.
    |

tests\models\test_ngram_speed.py:202:89: E501 Line too long (93 > 88)
    |
200 |     outputs are not directly used by generate_ngrams_with_speed itself.
201 |     """
202 |     # session_id, snippet_id, category_id = test_session_setup # Unused in this specific test
    |                                                                                         ^^^^^ E501
203 |
204 |     actual_ngrams_with_speed = generate_ngrams_with_speed(keystrokes, n)
    |

tests\models\test_ngram_speed.py:207:89: E501 Line too long (100 > 88)
    |
206 |     # For float comparisons, it's often better to use pytest.approx
207 |     # However, for this specific calculation, direct comparison should be fine if inputs are simple.
    |                                                                                         ^^^^^^^^^^^^ E501
208 |     # If issues arise, convert expected speeds to
209 |     # pytest.approx(speed, rel=1e-5)
    |

tests\models\test_ngram_speed.py:217:89: E501 Line too long (99 > 88)
    |
215 |     )
216 |
217 |     for actual, expected in zip(actual_ngrams_with_speed, expected_ngrams_with_speed, strict=True):
    |                                                                                         ^^^^^^^^^^^ E501
218 |         assert actual[0] == expected[0], (
219 |             f"For keystrokes={keystrokes}, n={n}: Ngram text mismatch. "
    |

tests\models\test_ngram_valid.py:16:89: E501 Line too long (91 > 88)
   |
14 |     (
15 |         [
16 |             Keystroke(char="a", expected="a", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
   |                                                                                         ^^^ E501
17 |             Keystroke(char="b", expected="b", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
18 |         ],
   |

tests\models\test_ngram_valid.py:17:89: E501 Line too long (96 > 88)
   |
15 |         [
16 |             Keystroke(char="a", expected="a", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
17 |             Keystroke(char="b", expected="b", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
   |                                                                                         ^^^^^^^^ E501
18 |         ],
19 |         2,
   |

tests\models\test_ngram_valid.py:25:89: E501 Line too long (91 > 88)
   |
23 |     (
24 |         [
25 |             Keystroke(char="c", expected="c", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
   |                                                                                         ^^^ E501
26 |             Keystroke(char="a", expected="a", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
27 |             Keystroke(char="t", expected="t", timestamp=datetime(2023, 1, 1, 12, 0, 0, 200000)),
   |

tests\models\test_ngram_valid.py:26:89: E501 Line too long (96 > 88)
   |
24 |         [
25 |             Keystroke(char="c", expected="c", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
26 |             Keystroke(char="a", expected="a", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
   |                                                                                         ^^^^^^^^ E501
27 |             Keystroke(char="t", expected="t", timestamp=datetime(2023, 1, 1, 12, 0, 0, 200000)),
28 |         ],
   |

tests\models\test_ngram_valid.py:27:89: E501 Line too long (96 > 88)
   |
25 |             Keystroke(char="c", expected="c", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
26 |             Keystroke(char="a", expected="a", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
27 |             Keystroke(char="t", expected="t", timestamp=datetime(2023, 1, 1, 12, 0, 0, 200000)),
   |                                                                                         ^^^^^^^^ E501
28 |         ],
29 |         3,
   |

tests\models\test_ngram_valid.py:36:89: E501 Line too long (89 > 88)
   |
34 |     ([], 2, [], "Empty keystrokes, expect no ngrams"),
35 |     (
36 |         [Keystroke(char="a", expected="a", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0))],
   |                                                                                         ^ E501
37 |         2,
38 |         [],
   |

tests\models\test_ngram_valid.py:43:89: E501 Line too long (91 > 88)
   |
41 |     (
42 |         [
43 |             Keystroke(char="a", expected="a", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
   |                                                                                         ^^^ E501
44 |             Keystroke(char="b", expected="B", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
45 |         ],
   |

tests\models\test_ngram_valid.py:44:89: E501 Line too long (96 > 88)
   |
42 |         [
43 |             Keystroke(char="a", expected="a", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
44 |             Keystroke(char="b", expected="B", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
   |                                                                                         ^^^^^^^^ E501
45 |         ],
46 |         2,
   |

tests\models\test_ngram_valid.py:53:89: E501 Line too long (91 > 88)
   |
51 |     (
52 |         [
53 |             Keystroke(char="x", expected="a", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
   |                                                                                         ^^^ E501
54 |             Keystroke(char="b", expected="b", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
55 |         ],
   |

tests\models\test_ngram_valid.py:54:89: E501 Line too long (96 > 88)
   |
52 |         [
53 |             Keystroke(char="x", expected="a", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
54 |             Keystroke(char="b", expected="b", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
   |                                                                                         ^^^^^^^^ E501
55 |         ],
56 |         2,
   |

tests\models\test_ngram_valid.py:62:89: E501 Line too long (91 > 88)
   |
60 |     (
61 |         [
62 |             Keystroke(char="a", expected="a", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
   |                                                                                         ^^^ E501
63 |             Keystroke(char="x", expected="b", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
64 |             Keystroke(char="c", expected="c", timestamp=datetime(2023, 1, 1, 12, 0, 0, 200000)),
   |

tests\models\test_ngram_valid.py:63:89: E501 Line too long (96 > 88)
   |
61 |         [
62 |             Keystroke(char="a", expected="a", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
63 |             Keystroke(char="x", expected="b", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
   |                                                                                         ^^^^^^^^ E501
64 |             Keystroke(char="c", expected="c", timestamp=datetime(2023, 1, 1, 12, 0, 0, 200000)),
65 |         ],
   |

tests\models\test_ngram_valid.py:64:89: E501 Line too long (96 > 88)
   |
62 |             Keystroke(char="a", expected="a", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
63 |             Keystroke(char="x", expected="b", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
64 |             Keystroke(char="c", expected="c", timestamp=datetime(2023, 1, 1, 12, 0, 0, 200000)),
   |                                                                                         ^^^^^^^^ E501
65 |         ],
66 |         3,
   |

tests\models\test_ngram_valid.py:73:89: E501 Line too long (93 > 88)
   |
71 |     (
72 |         [
73 |             Keystroke(char="\b", expected="\b", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
   |                                                                                         ^^^^^ E501
74 |             Keystroke(char="b", expected="b", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
75 |         ],
   |

tests\models\test_ngram_valid.py:74:89: E501 Line too long (96 > 88)
   |
72 |         [
73 |             Keystroke(char="\b", expected="\b", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
74 |             Keystroke(char="b", expected="b", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
   |                                                                                         ^^^^^^^^ E501
75 |         ],
76 |         2,
   |

tests\models\test_ngram_valid.py:82:89: E501 Line too long (91 > 88)
   |
80 |     (
81 |         [
82 |             Keystroke(char="a", expected="a", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
   |                                                                                         ^^^ E501
83 |             Keystroke(char="\b", expected="\b", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
84 |         ],
   |

tests\models\test_ngram_valid.py:83:89: E501 Line too long (98 > 88)
   |
81 |         [
82 |             Keystroke(char="a", expected="a", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
83 |             Keystroke(char="\b", expected="\b", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
   |                                                                                         ^^^^^^^^^^ E501
84 |         ],
85 |         2,
   |

tests\models\test_ngram_valid.py:91:89: E501 Line too long (91 > 88)
   |
89 |     (
90 |         [
91 |             Keystroke(char="a", expected="a", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
   |                                                                                         ^^^ E501
92 |             Keystroke(char="\b", expected="\b", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
93 |             Keystroke(char="c", expected="c", timestamp=datetime(2023, 1, 1, 12, 0, 0, 200000)),
   |

tests\models\test_ngram_valid.py:92:89: E501 Line too long (98 > 88)
   |
90 |         [
91 |             Keystroke(char="a", expected="a", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
92 |             Keystroke(char="\b", expected="\b", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
   |                                                                                         ^^^^^^^^^^ E501
93 |             Keystroke(char="c", expected="c", timestamp=datetime(2023, 1, 1, 12, 0, 0, 200000)),
94 |         ],
   |

tests\models\test_ngram_valid.py:93:89: E501 Line too long (96 > 88)
   |
91 |             Keystroke(char="a", expected="a", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
92 |             Keystroke(char="\b", expected="\b", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
93 |             Keystroke(char="c", expected="c", timestamp=datetime(2023, 1, 1, 12, 0, 0, 200000)),
   |                                                                                         ^^^^^^^^ E501
94 |         ],
95 |         3,
   |

tests\models\test_ngram_valid.py:102:89: E501 Line too long (91 > 88)
    |
100 |     (
101 |         [
102 |             Keystroke(char="a", expected="a", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
    |                                                                                         ^^^ E501
103 |             Keystroke(char="b", expected="b", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
104 |         ],
    |

tests\models\test_ngram_valid.py:103:89: E501 Line too long (91 > 88)
    |
101 |         [
102 |             Keystroke(char="a", expected="a", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
103 |             Keystroke(char="b", expected="b", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
    |                                                                                         ^^^ E501
104 |         ],
105 |         2,
    |

tests\models\test_ngram_valid.py:110:89: E501 Line too long (89 > 88)
    |
108 |     ),
109 |     (
110 |         [Keystroke(char="a", expected="a", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0))],
    |                                                                                         ^ E501
111 |         1,
112 |         [],
    |

tests\models\test_ngram_valid.py:117:89: E501 Line too long (91 > 88)
    |
115 |     (
116 |         [
117 |             Keystroke(char="a", expected="a", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
    |                                                                                         ^^^ E501
118 |             Keystroke(char="b", expected="b", timestamp=datetime(2023, 1, 1, 12, 0, 0, 1000)),
119 |             Keystroke(char="c", expected="c", timestamp=datetime(2023, 1, 1, 12, 0, 0, 1000)),
    |

tests\models\test_ngram_valid.py:118:89: E501 Line too long (94 > 88)
    |
116 |         [
117 |             Keystroke(char="a", expected="a", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
118 |             Keystroke(char="b", expected="b", timestamp=datetime(2023, 1, 1, 12, 0, 0, 1000)),
    |                                                                                         ^^^^^^ E501
119 |             Keystroke(char="c", expected="c", timestamp=datetime(2023, 1, 1, 12, 0, 0, 1000)),
120 |         ],
    |

tests\models\test_ngram_valid.py:119:89: E501 Line too long (94 > 88)
    |
117 |             Keystroke(char="a", expected="a", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
118 |             Keystroke(char="b", expected="b", timestamp=datetime(2023, 1, 1, 12, 0, 0, 1000)),
119 |             Keystroke(char="c", expected="c", timestamp=datetime(2023, 1, 1, 12, 0, 0, 1000)),
    |                                                                                         ^^^^^^ E501
120 |         ],
121 |         3,
    |

tests\models\test_ngram_valid.py:128:89: E501 Line too long (91 > 88)
    |
126 |     (
127 |         [
128 |             Keystroke(char=" ", expected=" ", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
    |                                                                                         ^^^ E501
129 |             Keystroke(char="b", expected="b", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
130 |         ],
    |

tests\models\test_ngram_valid.py:129:89: E501 Line too long (96 > 88)
    |
127 |         [
128 |             Keystroke(char=" ", expected=" ", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
129 |             Keystroke(char="b", expected="b", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
    |                                                                                         ^^^^^^^^ E501
130 |         ],
131 |         2,
    |

tests\models\test_ngram_valid.py:137:89: E501 Line too long (91 > 88)
    |
135 |     (
136 |         [
137 |             Keystroke(char="a", expected="a", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
    |                                                                                         ^^^ E501
138 |             Keystroke(char=" ", expected=" ", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
139 |         ],
    |

tests\models\test_ngram_valid.py:138:89: E501 Line too long (96 > 88)
    |
136 |         [
137 |             Keystroke(char="a", expected="a", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
138 |             Keystroke(char=" ", expected=" ", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
    |                                                                                         ^^^^^^^^ E501
139 |         ],
140 |         2,
    |

tests\models\test_ngram_valid.py:146:89: E501 Line too long (91 > 88)
    |
144 |     (
145 |         [
146 |             Keystroke(char="a", expected="a", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
    |                                                                                         ^^^ E501
147 |             Keystroke(char=" ", expected=" ", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
148 |             Keystroke(char="c", expected="c", timestamp=datetime(2023, 1, 1, 12, 0, 0, 200000)),
    |

tests\models\test_ngram_valid.py:147:89: E501 Line too long (96 > 88)
    |
145 |         [
146 |             Keystroke(char="a", expected="a", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
147 |             Keystroke(char=" ", expected=" ", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
    |                                                                                         ^^^^^^^^ E501
148 |             Keystroke(char="c", expected="c", timestamp=datetime(2023, 1, 1, 12, 0, 0, 200000)),
149 |         ],
    |

tests\models\test_ngram_valid.py:148:89: E501 Line too long (96 > 88)
    |
146 |             Keystroke(char="a", expected="a", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
147 |             Keystroke(char=" ", expected=" ", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
148 |             Keystroke(char="c", expected="c", timestamp=datetime(2023, 1, 1, 12, 0, 0, 200000)),
    |                                                                                         ^^^^^^^^ E501
149 |         ],
150 |         3,
    |

tests\models\test_ngram_valid.py:157:89: E501 Line too long (91 > 88)
    |
155 |     (
156 |         [
157 |             Keystroke(char="a", expected="X", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
    |                                                                                         ^^^ E501
158 |             Keystroke(char=" ", expected=" ", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
159 |             Keystroke(char="c", expected="c", timestamp=datetime(2023, 1, 1, 12, 0, 0, 200000)),
    |

tests\models\test_ngram_valid.py:158:89: E501 Line too long (96 > 88)
    |
156 |         [
157 |             Keystroke(char="a", expected="X", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
158 |             Keystroke(char=" ", expected=" ", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
    |                                                                                         ^^^^^^^^ E501
159 |             Keystroke(char="c", expected="c", timestamp=datetime(2023, 1, 1, 12, 0, 0, 200000)),
160 |         ],
    |

tests\models\test_ngram_valid.py:159:89: E501 Line too long (96 > 88)
    |
157 |             Keystroke(char="a", expected="X", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
158 |             Keystroke(char=" ", expected=" ", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
159 |             Keystroke(char="c", expected="c", timestamp=datetime(2023, 1, 1, 12, 0, 0, 200000)),
    |                                                                                         ^^^^^^^^ E501
160 |         ],
161 |         3,
    |

tests\models\test_ngram_valid.py:167:89: E501 Line too long (91 > 88)
    |
165 |     (
166 |         [
167 |             Keystroke(char="a", expected="a", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
    |                                                                                         ^^^ E501
168 |             Keystroke(char="b", expected="b", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
169 |             Keystroke(char="\b", expected="\b", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
    |

tests\models\test_ngram_valid.py:168:89: E501 Line too long (91 > 88)
    |
166 |         [
167 |             Keystroke(char="a", expected="a", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
168 |             Keystroke(char="b", expected="b", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
    |                                                                                         ^^^ E501
169 |             Keystroke(char="\b", expected="\b", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
170 |         ],
    |

tests\models\test_ngram_valid.py:169:89: E501 Line too long (98 > 88)
    |
167 |             Keystroke(char="a", expected="a", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
168 |             Keystroke(char="b", expected="b", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
169 |             Keystroke(char="\b", expected="\b", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
    |                                                                                         ^^^^^^^^^^ E501
170 |         ],
171 |         3,
    |

tests\models\test_ngram_valid.py:178:89: E501 Line too long (91 > 88)
    |
176 |     (
177 |         [
178 |             Keystroke(char="t", expected="t", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
    |                                                                                         ^^^ E501
179 |             Keystroke(char="h", expected="h", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
180 |             Keystroke(char="e", expected="e", timestamp=datetime(2023, 1, 1, 12, 0, 0, 200000)),
    |

tests\models\test_ngram_valid.py:179:89: E501 Line too long (96 > 88)
    |
177 |         [
178 |             Keystroke(char="t", expected="t", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
179 |             Keystroke(char="h", expected="h", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
    |                                                                                         ^^^^^^^^ E501
180 |             Keystroke(char="e", expected="e", timestamp=datetime(2023, 1, 1, 12, 0, 0, 200000)),
181 |             Keystroke(char="n", expected="N", timestamp=datetime(2023, 1, 1, 12, 0, 0, 300000)),
    |

tests\models\test_ngram_valid.py:180:89: E501 Line too long (96 > 88)
    |
178 |             Keystroke(char="t", expected="t", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
179 |             Keystroke(char="h", expected="h", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
180 |             Keystroke(char="e", expected="e", timestamp=datetime(2023, 1, 1, 12, 0, 0, 200000)),
    |                                                                                         ^^^^^^^^ E501
181 |             Keystroke(char="n", expected="N", timestamp=datetime(2023, 1, 1, 12, 0, 0, 300000)),
182 |         ],
    |

tests\models\test_ngram_valid.py:181:89: E501 Line too long (96 > 88)
    |
179 |             Keystroke(char="h", expected="h", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
180 |             Keystroke(char="e", expected="e", timestamp=datetime(2023, 1, 1, 12, 0, 0, 200000)),
181 |             Keystroke(char="n", expected="N", timestamp=datetime(2023, 1, 1, 12, 0, 0, 300000)),
    |                                                                                         ^^^^^^^^ E501
182 |         ],
183 |         2,
    |

tests\models\test_ngram_valid.py:189:89: E501 Line too long (91 > 88)
    |
187 |     (
188 |         [
189 |             Keystroke(char="q", expected="q", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
    |                                                                                         ^^^ E501
190 |             Keystroke(char="u", expected="X", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
191 |             Keystroke(char="i", expected="i", timestamp=datetime(2023, 1, 1, 12, 0, 0, 200000)),
    |

tests\models\test_ngram_valid.py:190:89: E501 Line too long (96 > 88)
    |
188 |         [
189 |             Keystroke(char="q", expected="q", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
190 |             Keystroke(char="u", expected="X", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
    |                                                                                         ^^^^^^^^ E501
191 |             Keystroke(char="i", expected="i", timestamp=datetime(2023, 1, 1, 12, 0, 0, 200000)),
192 |             Keystroke(char="c", expected="c", timestamp=datetime(2023, 1, 1, 12, 0, 0, 300000)),
    |

tests\models\test_ngram_valid.py:191:89: E501 Line too long (96 > 88)
    |
189 |             Keystroke(char="q", expected="q", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
190 |             Keystroke(char="u", expected="X", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
191 |             Keystroke(char="i", expected="i", timestamp=datetime(2023, 1, 1, 12, 0, 0, 200000)),
    |                                                                                         ^^^^^^^^ E501
192 |             Keystroke(char="c", expected="c", timestamp=datetime(2023, 1, 1, 12, 0, 0, 300000)),
193 |             Keystroke(char="k", expected="k", timestamp=datetime(2023, 1, 1, 12, 0, 0, 400000)),
    |

tests\models\test_ngram_valid.py:192:89: E501 Line too long (96 > 88)
    |
190 |             Keystroke(char="u", expected="X", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
191 |             Keystroke(char="i", expected="i", timestamp=datetime(2023, 1, 1, 12, 0, 0, 200000)),
192 |             Keystroke(char="c", expected="c", timestamp=datetime(2023, 1, 1, 12, 0, 0, 300000)),
    |                                                                                         ^^^^^^^^ E501
193 |             Keystroke(char="k", expected="k", timestamp=datetime(2023, 1, 1, 12, 0, 0, 400000)),
194 |         ],
    |

tests\models\test_ngram_valid.py:193:89: E501 Line too long (96 > 88)
    |
191 |             Keystroke(char="i", expected="i", timestamp=datetime(2023, 1, 1, 12, 0, 0, 200000)),
192 |             Keystroke(char="c", expected="c", timestamp=datetime(2023, 1, 1, 12, 0, 0, 300000)),
193 |             Keystroke(char="k", expected="k", timestamp=datetime(2023, 1, 1, 12, 0, 0, 400000)),
    |                                                                                         ^^^^^^^^ E501
194 |         ],
195 |         3,
    |

tests\models\test_ngram_valid.py:201:89: E501 Line too long (91 > 88)
    |
199 |     (
200 |         [
201 |             Keystroke(char="a", expected="a", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
    |                                                                                         ^^^ E501
202 |             Keystroke(char="\b", expected="\b", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
203 |             Keystroke(char="c", expected="c", timestamp=datetime(2023, 1, 1, 12, 0, 0, 200000)),
    |

tests\models\test_ngram_valid.py:202:89: E501 Line too long (98 > 88)
    |
200 |         [
201 |             Keystroke(char="a", expected="a", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
202 |             Keystroke(char="\b", expected="\b", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
    |                                                                                         ^^^^^^^^^^ E501
203 |             Keystroke(char="c", expected="c", timestamp=datetime(2023, 1, 1, 12, 0, 0, 200000)),
204 |             Keystroke(char="d", expected="d", timestamp=datetime(2023, 1, 1, 12, 0, 0, 300000)),
    |

tests\models\test_ngram_valid.py:203:89: E501 Line too long (96 > 88)
    |
201 |             Keystroke(char="a", expected="a", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
202 |             Keystroke(char="\b", expected="\b", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
203 |             Keystroke(char="c", expected="c", timestamp=datetime(2023, 1, 1, 12, 0, 0, 200000)),
    |                                                                                         ^^^^^^^^ E501
204 |             Keystroke(char="d", expected="d", timestamp=datetime(2023, 1, 1, 12, 0, 0, 300000)),
205 |         ],
    |

tests\models\test_ngram_valid.py:204:89: E501 Line too long (96 > 88)
    |
202 |             Keystroke(char="\b", expected="\b", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
203 |             Keystroke(char="c", expected="c", timestamp=datetime(2023, 1, 1, 12, 0, 0, 200000)),
204 |             Keystroke(char="d", expected="d", timestamp=datetime(2023, 1, 1, 12, 0, 0, 300000)),
    |                                                                                         ^^^^^^^^ E501
205 |         ],
206 |         2,
    |

tests\models\test_ngram_valid.py:212:89: E501 Line too long (91 > 88)
    |
210 |     (
211 |         [
212 |             Keystroke(char="f", expected="f", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
    |                                                                                         ^^^ E501
213 |             Keystroke(char=" ", expected=" ", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
214 |             Keystroke(char="g", expected="g", timestamp=datetime(2023, 1, 1, 12, 0, 0, 200000)),
    |

tests\models\test_ngram_valid.py:213:89: E501 Line too long (96 > 88)
    |
211 |         [
212 |             Keystroke(char="f", expected="f", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
213 |             Keystroke(char=" ", expected=" ", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
    |                                                                                         ^^^^^^^^ E501
214 |             Keystroke(char="g", expected="g", timestamp=datetime(2023, 1, 1, 12, 0, 0, 200000)),
215 |             Keystroke(char="h", expected="H", timestamp=datetime(2023, 1, 1, 12, 0, 0, 300000)),
    |

tests\models\test_ngram_valid.py:214:89: E501 Line too long (96 > 88)
    |
212 |             Keystroke(char="f", expected="f", timestamp=datetime(2023, 1, 1, 12, 0, 0, 0)),
213 |             Keystroke(char=" ", expected=" ", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
214 |             Keystroke(char="g", expected="g", timestamp=datetime(2023, 1, 1, 12, 0, 0, 200000)),
    |                                                                                         ^^^^^^^^ E501
215 |             Keystroke(char="h", expected="H", timestamp=datetime(2023, 1, 1, 12, 0, 0, 300000)),
216 |         ],
    |

tests\models\test_ngram_valid.py:215:89: E501 Line too long (96 > 88)
    |
213 |             Keystroke(char=" ", expected=" ", timestamp=datetime(2023, 1, 1, 12, 0, 0, 100000)),
214 |             Keystroke(char="g", expected="g", timestamp=datetime(2023, 1, 1, 12, 0, 0, 200000)),
215 |             Keystroke(char="h", expected="H", timestamp=datetime(2023, 1, 1, 12, 0, 0, 300000)),
    |                                                                                         ^^^^^^^^ E501
216 |         ],
217 |         2,
    |

tests\models\test_ngram_valid.py:219:89: E501 Line too long (90 > 88)
    |
217 |         2,
218 |         ["gH"],
219 |         "Sequence: 'f ghH', bigrams, 'f ', ' g' invalid, 'gh' is valid with error at end",
    |                                                                                         ^^ E501
220 |     ),
221 | ]
    |

tests\models\test_ngram_valid.py:253:89: E501 Line too long (90 > 88)
    |
252 | @pytest.mark.parametrize(
253 |     "keystrokes, ngram_size, expected_valid_ngram_texts, description", VALIDITY_TEST_CASES
    |                                                                                         ^^ E501
254 | )
255 | def test_ngram_validity(
    |

tests\models\test_ngram_valid.py:269:89: E501 Line too long (99 > 88)
    |
267 |         for i, k in enumerate(keystrokes):
268 |             print(
269 |                 f"Keystroke {i}: char='{k.char}', expected='{k.expected}', timestamp={k.timestamp}"
    |                                                                                         ^^^^^^^^^^^ E501
270 |             )
271 |         print(f"Expected valid ngrams: {expected_valid_ngram_texts}")
    |

tests\models\test_ngram_valid.py:274:89: E501 Line too long (92 > 88)
    |
273 |     ngram_manager = NGramManager(db_manager=None)  # Instantiate NGramManager
274 |     generated_ngrams = ngram_manager.generate_ngrams_from_keystrokes(keystrokes, ngram_size)
    |                                                                                         ^^^^ E501
275 |
276 |     if debug_mode:
    |

tests\models\test_ngram_valid.py:279:89: E501 Line too long (127 > 88)
    |
277 |         for ngram in generated_ngrams:
278 |             print(
279 |                 f"Generated ngram: text='{ngram.text}', valid={ngram.is_valid}, error={ngram.is_error}, clean={ngram.is_clean}"
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
280 |             )
281 |             print(
    |

tests\models\test_ngram_valid.py:282:89: E501 Line too long (101 > 88)
    |
280 |             )
281 |             print(
282 |                 f"  start={ngram.start_time}, end={ngram.end_time}, duration={ngram.total_time_ms}ms"
    |                                                                                         ^^^^^^^^^^^^^ E501
283 |             )
    |

tests\models\test_ngram_valid.py:289:89: E501 Line too long (130 > 88)
    |
288 |     assert sorted(valid_ngram_texts_generated) == sorted(expected_valid_ngram_texts), (
289 |         f"Test failed for: {description}. Expected valid ngrams: {expected_valid_ngram_texts}, Got: {valid_ngram_texts_generated}"
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
290 |     )
    |

tests\models\test_practice_session_extensions.py:1:89: E501 Line too long (100 > 88)
  |
1 | # This file is now obsolete. All session logic is consolidated in session.py and session_manager.py.
  |                                                                                         ^^^^^^^^^^^^ E501
2 | # Please use test_session.py and test_session_manager.py for all session-related tests.
  |

tests\models\test_session.py:200:89: E501 Line too long (89 > 88)
    |
199 | # --- Extra/Calculated Fields ---
200 | def test_from_dict_ignores_calculated_fields(valid_session_dict: dict[str, Any]) -> None:
    |                                                                                         ^ E501
201 |     d = valid_session_dict.copy()
202 |     d["total_time"] = 123
    |

tests\models\test_session_manager.py:12:89: E501 Line too long (93 > 88)
   |
11 | def make_session(
12 |     snippet_id: str = None, user_id: str = None, keyboard_id: str = None, **overrides: object
   |                                                                                         ^^^^^ E501
13 | ) -> Session:
14 |     now = datetime.datetime(2023, 1, 1, 12, 0, 0)
   |

tests\models\test_session_manager.py:55:89: E501 Line too long (94 > 88)
   |
53 |     keyboard_id = str(uuid.uuid4())
54 |     db.execute(
55 |         "INSERT INTO users (user_id, first_name, surname, email_address) VALUES (?, ?, ?, ?)",
   |                                                                                         ^^^^^^ E501
56 |         (user_id, "Test", "User", f"testuser_{user_id[:8]}@example.com"),
57 |     )
   |

tests\models\test_setting.py:47:89: E501 Line too long (110 > 88)
   |
45 |         ],
46 |     )
47 |     def test_setting_type_id_validation(self, setting_type_id: str, expected_error_message_part: str) -> None:
   |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^ E501
48 |         """
49 |         Test objective: Verify Setting model's type_id validation for format, length, and ASCII.
   |

tests\models\test_setting.py:49:89: E501 Line too long (96 > 88)
   |
47 |     def test_setting_type_id_validation(self, setting_type_id: str, expected_error_message_part: str) -> None:
48 |         """
49 |         Test objective: Verify Setting model's type_id validation for format, length, and ASCII.
   |                                                                                         ^^^^^^^^ E501
50 |         """
51 |         with pytest.raises(ValidationError) as exc_info:
   |

tests\models\test_setting.py:139:89: E501 Line too long (97 > 88)
    |
137 |             ("setting_type_id", "ABC", "setting_type_id must be exactly 6 characters"),
138 |             ("related_entity_id", None, "Input should be a valid string"),
139 |             ("related_entity_id", "not-a-uuid", "related_entity_id must be a valid UUID string"),
    |                                                                                         ^^^^^^^^^ E501
140 |             ("updated_at", None, "Input should be a valid string"),
141 |             ("updated_at", "not-iso-format", "updated_at must be a valid ISO datetime string"),
    |

tests\models\test_setting.py:141:89: E501 Line too long (95 > 88)
    |
139 |             ("related_entity_id", "not-a-uuid", "related_entity_id must be a valid UUID string"),
140 |             ("updated_at", None, "Input should be a valid string"),
141 |             ("updated_at", "not-iso-format", "updated_at must be a valid ISO datetime string"),
    |                                                                                         ^^^^^^^ E501
142 |         ],
143 |     )
    |

tests\models\test_setting_manager.py:25:89: E501 Line too long (97 > 88)
   |
24 | class TestSettingManager:
25 |     """Test suite for SettingManager covering all CRUD, validation logic and history tracking."""
   |                                                                                         ^^^^^^^^^ E501
26 |
27 |     def test_create_setting_valid(self, setting_mgr: SettingManager) -> None:
   |

tests\models\test_setting_manager.py:77:89: E501 Line too long (95 > 88)
   |
75 |         assert err_msg_part.lower() in str(e.value).lower()
76 |
77 |     def test_update_existing_setting_with_new_value(self, setting_mgr: SettingManager) -> None:
   |                                                                                         ^^^^^^^ E501
78 |         """
79 |         Test objective: Verify that saving a setting with an existing type_id and entity_id updates
   |

tests\models\test_setting_manager.py:79:89: E501 Line too long (99 > 88)
   |
77 |     def test_update_existing_setting_with_new_value(self, setting_mgr: SettingManager) -> None:
78 |         """
79 |         Test objective: Verify that saving a setting with an existing type_id and entity_id updates
   |                                                                                         ^^^^^^^^^^^ E501
80 |         the setting value and creates a new history entry.
81 |         """
   |

tests\models\test_setting_manager.py:151:89: E501 Line too long (89 > 88)
    |
149 |     def test_get_setting_with_default(self, setting_mgr: SettingManager) -> None:
150 |         """
151 |         Test objective: Test get_setting with a default value when setting doesn't exist.
    |                                                                                         ^ E501
152 |         """
153 |         setting_type_id = "DEFVAL"
    |

tests\models\test_setting_manager.py:158:89: E501 Line too long (92 > 88)
    |
157 |         # Get with default - should return a new setting with the default value
158 |         setting = setting_mgr.get_setting(setting_type_id, related_entity_id, default_value)
    |                                                                                         ^^^^ E501
159 |         assert setting.setting_type_id == setting_type_id
160 |         assert setting.setting_value == default_value
    |

tests\models\test_simple.py:5:5: ANN201 Missing return type annotation for public function `test_simple`
  |
3 | """
4 |
5 | def test_simple():
  |     ^^^^^^^^^^^ ANN201
6 |     """A simple test that should always pass."""
7 |     assert 1 + 1 == 2
  |
  = help: Add return type annotation: `None`

tests\models\test_snippet.py:37:89: E501 Line too long (99 > 88)
   |
36 | @pytest.fixture(autouse=True)
37 | def setup_and_teardown_db(tmp_path: Path, monkeypatch: MonkeyPatch) -> Generator[None, None, None]:
   |                                                                                         ^^^^^^^^^^^ E501
38 |     """
39 |     Setup and teardown for all tests.
   |

tests\models\test_snippet.py:105:89: E501 Line too long (100 > 88)
    |
103 |     """Test validation fails with non-ASCII name."""
104 |     with pytest.raises(ValidationError):
105 |         Snippet(category_id=str(uuid.uuid4()), snippet_name="InvalidName├⌐", content="Valid content")
    |                                                                                         ^^^^^^^^^^^^ E501
    |

tests\models\test_snippet.py:180:89: E501 Line too long (100 > 88)
    |
178 |     if expect_success:
179 |         try:
180 |             snip = Snippet(category_id=snippet_category_fixture, snippet_name=name, content=content)
    |                                                                                         ^^^^^^^^^^^^ E501
181 |             snippet_manager.save_snippet(snip)
182 |             loaded = snippet_manager.get_snippet_by_id(snip.snippet_id)
    |

tests\models\test_snippet.py:190:89: E501 Line too long (100 > 88)
    |
188 |     else:
189 |         with pytest.raises(ValidationError):
190 |             snip = Snippet(category_id=snippet_category_fixture, snippet_name=name, content=content)
    |                                                                                         ^^^^^^^^^^^^ E501
191 |             snippet_manager.save_snippet(snip)
    |

tests\models\test_snippet.py:208:89: E501 Line too long (89 > 88)
    |
206 |     should_succeed: bool,
207 | ) -> None:
208 |     s1 = Snippet(category_id=snippet_category_fixture, snippet_name=name1, content="abc")
    |                                                                                         ^ E501
209 |     snippet_manager.save_snippet(s1)
210 |     if should_succeed:
    |

tests\models\test_snippet.py:211:89: E501 Line too long (93 > 88)
    |
209 |     snippet_manager.save_snippet(s1)
210 |     if should_succeed:
211 |         s2 = Snippet(category_id=snippet_category_fixture, snippet_name=name2, content="def")
    |                                                                                         ^^^^^ E501
212 |         snippet_manager.save_snippet(s2)
213 |     else:
    |

tests\models\test_snippet.py:215:89: E501 Line too long (97 > 88)
    |
213 |     else:
214 |         with pytest.raises(ConstraintError):
215 |             s2 = Snippet(category_id=snippet_category_fixture, snippet_name=name2, content="def")
    |                                                                                         ^^^^^^^^^ E501
216 |             snippet_manager.save_snippet(s2)
    |

tests\models\test_snippet.py:248:89: E501 Line too long (97 > 88)
    |
246 |     # Using the created fixture's category_id but ensuring no snippets
247 |     # are added to it for this test, or using a deliberately non-existent one.
248 |     # For this test, let's assume we want to test listing for an existing category that is empty.
    |                                                                                         ^^^^^^^^^ E501
249 |     # The fixture `snippet_category_fixture` provides a category.
250 |     # We just don't add snippets to it here.
    |

tests\models\test_snippet.py:266:89: E501 Line too long (90 > 88)
    |
264 | ) -> None:
265 |     snip1 = Snippet(
266 |         category_id=snippet_category_fixture, snippet_name="Snippet1", content="Content 1"
    |                                                                                         ^^ E501
267 |     )
268 |     snip2 = Snippet(
    |

tests\models\test_snippet.py:269:89: E501 Line too long (90 > 88)
    |
267 |     )
268 |     snip2 = Snippet(
269 |         category_id=snippet_category_fixture, snippet_name="Snippet2", content="Content 2"
    |                                                                                         ^^ E501
270 |     )
271 |     snip3 = Snippet(
    |

tests\models\test_snippet.py:272:89: E501 Line too long (90 > 88)
    |
270 |     )
271 |     snip3 = Snippet(
272 |         category_id=snippet_category_fixture, snippet_name="Snippet3", content="Content 3"
    |                                                                                         ^^ E501
273 |     )
274 |     snippet_manager.save_snippet(snip1)
    |

tests\models\test_snippet.py:304:89: E501 Line too long (96 > 88)
    |
304 | def test_snippet_update(snippet_category_fixture: str, snippet_manager: SnippetManager) -> None:
    |                                                                                         ^^^^^^^^ E501
305 |     from models.snippet import Snippet
    |

tests\models\test_snippet.py:307:89: E501 Line too long (96 > 88)
    |
305 |     from models.snippet import Snippet
306 |
307 |     snip = Snippet(category_id=snippet_category_fixture, snippet_name="ToUpdate", content="abc")
    |                                                                                         ^^^^^^^^ E501
308 |     snippet_manager.save_snippet(snip)
309 |     snip.snippet_name = "UpdatedName"
    |

tests\models\test_snippet.py:352:89: E501 Line too long (96 > 88)
    |
352 | def test_snippet_delete(snippet_category_fixture: str, snippet_manager: SnippetManager) -> None:
    |                                                                                         ^^^^^^^^ E501
353 |     from models.snippet import Snippet
    |

tests\models\test_snippet.py:355:89: E501 Line too long (96 > 88)
    |
353 |     from models.snippet import Snippet
354 |
355 |     snip = Snippet(category_id=snippet_category_fixture, snippet_name="ToDelete", content="abc")
    |                                                                                         ^^^^^^^^ E501
356 |     snippet_manager.save_snippet(snip)
357 |     snippet_manager.delete_snippet(snip.snippet_id)
    |

tests\models\test_snippet.py:384:89: E501 Line too long (89 > 88)
    |
382 |     new_category_id = new_category.category_id
383 |     snippet = Snippet(
384 |         category_id=original_category_id, snippet_name="SnippetToMove", content="Content"
    |                                                                                         ^ E501
385 |     )
386 |     snippet_manager.save_snippet(snippet)
    |

tests\models\test_snippet.py:415:89: E501 Line too long (93 > 88)
    |
413 |     inj = "Robert'); DROP TABLE snippets;--"
414 |     with pytest.raises(ValueError):
415 |         snip = Snippet(category_id=snippet_category_fixture, snippet_name=inj, content="abc")
    |                                                                                         ^^^^^ E501
416 |         snippet_manager.save_snippet(snip)
    |

tests\models\test_snippet.py:424:89: E501 Line too long (99 > 88)
    |
422 |     inj = "Content with SQL injection: DROP TABLE snippets; --"
423 |     with pytest.raises(ValueError):
424 |         snip = Snippet(category_id=snippet_category_fixture, snippet_name="ValidName", content=inj)
    |                                                                                         ^^^^^^^^^^^ E501
425 |         snippet_manager.save_snippet(snip)
    |

tests\models\test_snippet.py:433:89: E501 Line too long (94 > 88)
    |
431 |     long_content = "x" * 2000
432 |     snip = Snippet(
433 |         category_id=snippet_category_fixture, snippet_name="LongContent", content=long_content
    |                                                                                         ^^^^^^ E501
434 |     )
435 |     snippet_manager.save_snippet(snip)
    |

tests\models\test_snippet.py:447:89: E501 Line too long (95 > 88)
    |
445 |     exact_content = "x" * snippet_manager.MAX_PART_LENGTH
446 |     snip = Snippet(
447 |         category_id=snippet_category_fixture, snippet_name="ExactLength", content=exact_content
    |                                                                                         ^^^^^^^ E501
448 |     )
449 |     snippet_manager.save_snippet(snip)
    |

tests\models\test_snippet.py:456:89: E501 Line too long (98 > 88)
    |
454 |     just_over_content = "y" * (snippet_manager.MAX_PART_LENGTH + 1)
455 |     snip_over = Snippet(
456 |         category_id=snippet_category_fixture, snippet_name="OverLength", content=just_over_content
    |                                                                                         ^^^^^^^^^^ E501
457 |     )
458 |     snippet_manager.save_snippet(snip_over)
    |

tests\models\test_snippet.py:468:89: E501 Line too long (100 > 88)
    |
466 |     non_existent_snippet_id = str(uuid.uuid4())
467 |     with pytest.raises(ForeignKeyError):
468 |         snip = Snippet(category_id=str(uuid.uuid4()), snippet_name="NewName", content="New content")
    |                                                                                         ^^^^^^^^^^^^ E501
469 |         snip.snippet_id = non_existent_snippet_id
470 |         snippet_manager.save_snippet(snip)
    |

tests\models\test_snippet.py:489:89: E501 Line too long (90 > 88)
    |
487 |     snippet_id_1 = snip1.snippet_id
488 |     snippet_name_2 = f"Test Part Number Sequence 2 {random_id}"
489 |     content_2 = "This is another test snippet to verify that part_number works correctly."
    |                                                                                         ^^ E501
490 |     snip2 = Snippet(
491 |         category_id=snippet_category_fixture,
    |

tests\models\test_snippet.py:549:89: E501 Line too long (94 > 88)
    |
547 |     # Use a valid UUID for category_id
548 |     model = Snippet(
549 |         category_id=str(uuid.uuid4()), snippet_name="Test Python Snippet", content=python_code
    |                                                                                         ^^^^^^ E501
550 |     )
551 |     assert model.content == python_code
    |

tests\models\test_snippet.py:584:89: E501 Line too long (100 > 88)
    |
582 |     content = "This tests that operations are handled correctly."
583 |
584 |     snip = Snippet(category_id=snippet_category_fixture, snippet_name=snippet_name, content=content)
    |                                                                                         ^^^^^^^^^^^^ E501
585 |     snippet_manager.save_snippet(snip)
586 |     assert snip is not None and snip.snippet_id is not None
    |

tests\models\test_snippet.py:596:5: F811 Redefinition of unused `random_id` from line 32
    |
594 | # Add random_id helper as a fixture for use in tests
595 | @pytest.fixture
596 | def random_id() -> str:
    |     ^^^^^^^^^ F811
597 |     """Generate a random ID between 1000-9999 for testing."""
598 |     import random
    |
    = help: Remove definition: `random_id`

tests\models\test_snippet.py:607:89: E501 Line too long (96 > 88)
    |
607 | def test_delete_snippet(snippet_category_fixture: str, snippet_manager: SnippetManager) -> None:
    |                                                                                         ^^^^^^^^ E501
608 |     """Test deleting an existing snippet."""
609 |     snip = Snippet(
    |

tests\models\test_snippet.py:624:89: E501 Line too long (91 > 88)
    |
624 | def test_create_snippet_with_nonexistent_category(snippet_manager: SnippetManager) -> None:
    |                                                                                         ^^^ E501
625 |     """Test creating a snippet with a category_id that does not exist."""
626 |     # Use a valid UUID for category_id
    |

tests\models\test_snippet.py:637:5: F811 Redefinition of unused `test_update_nonexistent_snippet` from line 465
    |
637 | def test_update_nonexistent_snippet(snippet_manager: SnippetManager) -> None:
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ F811
638 |     """Test updating a snippet that does not exist."""
639 |     non_existent_snippet_id = str(uuid.uuid4())
    |
    = help: Remove definition: `test_update_nonexistent_snippet`

tests\models\test_snippet.py:641:89: E501 Line too long (100 > 88)
    |
639 |     non_existent_snippet_id = str(uuid.uuid4())
640 |     with pytest.raises(ForeignKeyError):
641 |         snip = Snippet(category_id=str(uuid.uuid4()), snippet_name="NewName", content="New content")
    |                                                                                         ^^^^^^^^^^^^ E501
642 |         snip.snippet_id = non_existent_snippet_id
643 |         snippet_manager.save_snippet(snip)
    |

tests\models\test_snippet.py:687:89: E501 Line too long (100 > 88)
    |
685 |     snippet_name = "NoChangeSnippet"
686 |     content = "NoChangeContent"
687 |     snip = Snippet(category_id=snippet_category_fixture, snippet_name=snippet_name, content=content)
    |                                                                                         ^^^^^^^^^^^^ E501
688 |     snippet_manager.save_snippet(snip)
689 |     assert snip is not None and snip.snippet_id is not None
    |

tests\models\test_snippet.py:720:89: E501 Line too long (90 > 88)
    |
718 |     )
719 |     snippet_manager.save_snippet(snip)
720 |     # Create another snippet with the same name in a different category (if schema allows)
    |                                                                                         ^^ E501
721 |     # For now, assume unique within category is the target.
    |

tests\models\test_snippet.py:723:89: E501 Line too long (99 > 88)
    |
721 |     # For now, assume unique within category is the target.
722 |
723 |     retrieved_snippet = snippet_manager.get_snippet_by_name(snippet_name, snippet_category_fixture)
    |                                                                                         ^^^^^^^^^^^ E501
724 |     assert retrieved_snippet is not None
725 |     assert retrieved_snippet.snippet_name == snippet_name
    |

tests\models\test_snippet.py:733:89: E501 Line too long (99 > 88)
    |
731 | ) -> None:
732 |     """Test retrieving a non-existent snippet by name."""
733 |     assert snippet_manager.get_snippet_by_name("NonExistentName", snippet_category_fixture) is None
    |                                                                                         ^^^^^^^^^^^ E501
    |

tests\models\test_snippet.py:739:89: E501 Line too long (89 > 88)
    |
737 |     category_manager: CategoryManager, snippet_manager: SnippetManager
738 | ) -> None:
739 |     """Test retrieving snippets by name when same name exists in different categories."""
    |                                                                                         ^ E501
740 |     from models.category import Category
    |

tests\models\test_snippet.py:750:89: E501 Line too long (91 > 88)
    |
748 |     common_name = "SharedName"
749 |
750 |     snip1 = Snippet(category_id=cat1_id, snippet_name=common_name, content="Content Alpha")
    |                                                                                         ^^^ E501
751 |     snippet_manager.save_snippet(snip1)
752 |     snip2 = Snippet(category_id=cat2_id, snippet_name=common_name, content="Content Beta")
    |

tests\models\test_snippet.py:752:89: E501 Line too long (90 > 88)
    |
750 |     snip1 = Snippet(category_id=cat1_id, snippet_name=common_name, content="Content Alpha")
751 |     snippet_manager.save_snippet(snip1)
752 |     snip2 = Snippet(category_id=cat2_id, snippet_name=common_name, content="Content Beta")
    |                                                                                         ^^ E501
753 |     snippet_manager.save_snippet(snip2)
    |

tests\models\test_snippet.py:771:89: E501 Line too long (97 > 88)
    |
771 | def test_search_snippets(snippet_category_fixture: str, snippet_manager: SnippetManager) -> None:
    |                                                                                         ^^^^^^^^^ E501
772 |     """Test searching for snippets by a query string."""
773 |     snip1 = Snippet(
    |

tests\models\test_snippet.py:786:89: E501 Line too long (98 > 88)
    |
784 |     snippet_manager.save_snippet(snip2)
785 |     snip3 = Snippet(
786 |         category_id=snippet_category_fixture, snippet_name="ThirdOne", content="Different content"
    |                                                                                         ^^^^^^^^^^ E501
787 |     )
788 |     snippet_manager.save_snippet(snip3)
    |

tests\models\test_snippet.py:815:89: E501 Line too long (93 > 88)
    |
813 |     snippet_category_fixture: str, snippet_manager: SnippetManager
814 | ) -> None:
815 |     """Test against SQL injection in snippet name during creation via Pydantic validation."""
    |                                                                                         ^^^^^ E501
816 |     malicious_name = "Robert'); DROP TABLE snippets; --"
817 |     with pytest.raises(ValueError):
    |

tests\models\test_snippet.py:831:89: E501 Line too long (98 > 88)
    |
829 |     """Test against SQL injection in snippet content during creation."""
830 |     malicious_content = "text'); DROP TABLE snippets; --"
831 |     with pytest.raises(ValueError, match="Value contains potentially unsafe pattern: DROP TABLE"):
    |                                                                                         ^^^^^^^^^^ E501
832 |         snip = Snippet(
833 |             category_id=snippet_category_fixture,
    |

tests\models\test_snippet.py:843:89: E501 Line too long (97 > 88)
    |
841 |     snippet_category_fixture: str, snippet_manager: SnippetManager
842 | ) -> None:
843 |     """Test against SQL injection in snippet name during creation with specific error message."""
    |                                                                                         ^^^^^^^^^ E501
844 |     malicious_name = "Name'); DROP TABLE categories; --"
845 |     with pytest.raises(ValueError):
    |

tests\models\test_snippet.py:863:89: E501 Line too long (98 > 88)
    |
861 |     )
862 |     snippet_manager.save_snippet(snip)
863 |     with pytest.raises(ValueError, match="Value contains potentially unsafe pattern: DROP TABLE"):
    |                                                                                         ^^^^^^^^^^ E501
864 |         snip.content = "text'); DROP TABLE snippets; --"
865 |         snippet_manager.save_snippet(snip)
    |

tests\models\test_snippet.py:877:89: E501 Line too long (98 > 88)
    |
875 |     )
876 |     snippet_manager.save_snippet(snip)
877 |     with pytest.raises(ValueError, match="Value contains potentially unsafe pattern: DROP TABLE"):
    |                                                                                         ^^^^^^^^^^ E501
878 |         snip.snippet_name = "Name'); DROP TABLE categories; --"
879 |         snippet_manager.save_snippet(snip)
    |

tests\models\test_snippet.py:885:89: E501 Line too long (90 > 88)
    |
883 |     snippet_category_fixture: str, snippet_manager: SnippetManager
884 | ) -> None:
885 |     """Test that deleting a snippet multiple times raises ValueError on second attempt."""
    |                                                                                         ^^ E501
886 |     snip = Snippet(
887 |         category_id=snippet_category_fixture,
    |

tests\models\test_snippet.py:899:89: E501 Line too long (92 > 88)
    |
898 | def test_snippet_manager_handles_db_errors_gracefully_on_create(
899 |     snippet_manager: SnippetManager, snippet_category_fixture: str, monkeypatch: MonkeyPatch
    |                                                                                         ^^^^ E501
900 | ) -> None:
901 |     def mock_execute_raises(*args: object, **kwargs: object) -> None:
    |

tests\models\test_snippet.py:928:89: E501 Line too long (92 > 88)
    |
927 | def test_snippet_manager_handles_db_errors_gracefully_on_update(
928 |     snippet_manager: SnippetManager, snippet_category_fixture: str, monkeypatch: MonkeyPatch
    |                                                                                         ^^^^ E501
929 | ) -> None:
930 |     real_snippet = Snippet(
    |

tests\models\test_snippet.py:955:89: E501 Line too long (92 > 88)
    |
954 | def test_snippet_manager_handles_db_errors_gracefully_on_delete(
955 |     snippet_manager: SnippetManager, snippet_category_fixture: str, monkeypatch: MonkeyPatch
    |                                                                                         ^^^^ E501
956 | ) -> None:
957 |     real_snippet = Snippet(
    |

tests\models\test_snippet.py:970:89: E501 Line too long (93 > 88)
    |
968 |             raise DatabaseError("Simulated DB error on delete")
969 |         if (
970 |             "SELECT snippet_id, category_id, snippet_name FROM snippets WHERE snippet_id = ?"
    |                                                                                         ^^^^^ E501
971 |             in query
972 |         ):
    |

tests\models\test_snippet.py:980:89: E501 Line too long (100 > 88)
    |
978 |             )
979 |             return mock_cursor
980 |         elif "SELECT content FROM snippet_parts WHERE snippet_id = ? ORDER BY part_number" in query:
    |                                                                                         ^^^^^^^^^^^^ E501
981 |             mock_cursor = MagicMock()
982 |             mock_cursor.fetchall.return_value = [("content",)]
    |

tests\models\test_snippet.py:993:89: E501 Line too long (92 > 88)
    |
992 | def test_snippet_manager_handles_db_errors_gracefully_on_list(
993 |     snippet_manager: SnippetManager, snippet_category_fixture: str, monkeypatch: MonkeyPatch
    |                                                                                         ^^^^ E501
994 | ) -> None:
995 |     def mock_execute_raises(*args: object, **kwargs: object) -> None:
    |

tests\models\test_snippet.py:1019:89: E501 Line too long (100 > 88)
     |
1017 |     snippet_manager: SnippetManager, snippet_category_fixture: str
1018 | ) -> None:
1019 |     """Test that Pydantic validation errors in Snippet model are caught and raised as ValueError."""
     |                                                                                         ^^^^^^^^^^^^ E501
1020 |     # Test empty name
1021 |     with pytest.raises(ValueError, match="Value cannot be empty or whitespace"):
     |

tests\models\test_snippet.py:1030:89: E501 Line too long (94 > 88)
     |
1028 |     # Test name too long
1029 |     long_name = "a" * 129
1030 |     with pytest.raises(ValueError, match="Snippet name must be between 1 and 128 characters"):
     |                                                                                         ^^^^^^ E501
1031 |         snip = Snippet(
1032 |             category_id=snippet_category_fixture,
     |

tests\models\test_snippet_manager.py:41:89: E501 Line too long (94 > 88)
   |
39 |     """Fixture to create and provide a sample category for snippet tests."""
40 |     try:
41 |         # Attempt to retrieve if it exists from a previous failed test run in the same session
   |                                                                                         ^^^^^^ E501
42 |         return category_mgr.get_category_by_name("Test Category for Snippets")
43 |     except CategoryNotFound:
   |

tests\models\test_snippet_manager.py:76:89: E501 Line too long (100 > 88)
   |
74 |         self, snippet_mgr: SnippetManager, sample_category: Category
75 |     ) -> None:
76 |         """Test objective: Verify content is correctly split into parts based on MAX_PART_LENGTH."""
   |                                                                                         ^^^^^^^^^^^^ E501
77 |         max_len = SnippetManager.MAX_PART_LENGTH  # Typically 500
   |

tests\models\test_snippet_manager.py:97:89: E501 Line too long (94 > 88)
   |
96 |             parts_cursor = snippet_mgr.db.execute(
97 |                 "SELECT content FROM snippet_parts WHERE snippet_id = ? ORDER BY part_number",
   |                                                                                         ^^^^^^ E501
98 |                 (snippet.snippet_id,),
99 |             )
   |

tests\models\test_snippet_manager.py:105:89: E501 Line too long (89 > 88)
    |
103 |             )
104 |             retrieved_content = "".join(part_row[0] for part_row in content_parts_rows)
105 |             assert retrieved_content == content, f"Retrieved content mismatch for {name}"
    |                                                                                         ^ E501
106 |
107 |             for i, part_row in enumerate(content_parts_rows):
    |

tests\models\test_snippet_manager.py:115:89: E501 Line too long (94 > 88)
    |
113 |         self, snippet_mgr: SnippetManager, sample_category: Category
114 |     ) -> None:
115 |         """Test objective: Verify error on duplicate snippet name within the same category."""
    |                                                                                         ^^^^^^ E501
116 |         from db.exceptions import ConstraintError
    |

tests\models\test_snippet_manager.py:137:89: E501 Line too long (99 > 88)
    |
136 |     def test_create_snippet_duplicate_name_different_category(
137 |         self, snippet_mgr: SnippetManager, category_mgr: CategoryManager, sample_category: Category
    |                                                                                         ^^^^^^^^^^^ E501
138 |     ) -> None:
139 |         """Test objective: Verify successful creation with same name in different category."""
    |

tests\models\test_snippet_manager.py:139:89: E501 Line too long (94 > 88)
    |
137 |         self, snippet_mgr: SnippetManager, category_mgr: CategoryManager, sample_category: Category
138 |     ) -> None:
139 |         """Test objective: Verify successful creation with same name in different category."""
    |                                                                                         ^^^^^^ E501
140 |         other_category_name = "Another Snippet Category For Test"
141 |         try:
    |

tests\models\test_snippet_manager.py:145:89: E501 Line too long (96 > 88)
    |
143 |         except CategoryNotFound:
144 |             other_category = Category(
145 |                 category_id=str(uuid.uuid4()), category_name=other_category_name, description=""
    |                                                                                         ^^^^^^^^ E501
146 |             )
147 |             category_mgr.save_category(other_category)
    |

tests\models\test_snippet_manager.py:200:89: E501 Line too long (91 > 88)
    |
198 |             ("ValidName", "Invalid├çontent", ValueError),
199 |             ("DROP TABLE Users;", "Content", ValueError),
200 |             # Snippet content SQLi check is less strict, but some patterns are still caught
    |                                                                                         ^^^ E501
201 |             # by Snippet model
202 |             ("ValidName", "SELECT * FROM Users; -- comment", ValueError),
    |

tests\models\test_snippet_manager.py:213:89: E501 Line too long (93 > 88)
    |
211 |         error_type: type,
212 |     ) -> None:
213 |         """Test objective: Verify Pydantic validation errors for snippet name and content."""
    |                                                                                         ^^^^^ E501
214 |         with pytest.raises(error_type):
215 |             snippet = Snippet(
    |

tests\models\test_snippet_manager.py:223:89: E501 Line too long (95 > 88)
    |
221 |             snippet_mgr.save_snippet(snippet)
222 |
223 |     def test_create_snippet_internal_empty_content_check_unreachable_with_valid_pydantic_input(
    |                                                                                         ^^^^^^^ E501
224 |         self, snippet_mgr: SnippetManager, sample_category: Category
225 |     ) -> None:
    |

tests\models\test_snippet_manager.py:227:89: E501 Line too long (93 > 88)
    |
225 |     ) -> None:
226 |         """
227 |         Test objective: Ensure SnippetManager's internal check for empty content parts is not
    |                                                                                         ^^^^^ E501
228 |         triggered if Pydantic validation (content min_length=1) is effective.
229 |         """
    |

tests\models\test_snippet_manager.py:240:89: E501 Line too long (94 > 88)
    |
238 |             snippet_mgr.save_snippet(snippet)
239 |         except ValueError as e:
240 |             # This specific error from SnippetManager should not be raised if Pydantic ensures
    |                                                                                         ^^^^^^ E501
241 |             # content is not empty and _split_content_into_parts works.
242 |             assert "Content cannot be empty after splitting" not in str(e), (
    |

tests\models\test_snippet_manager.py:243:89: E501 Line too long (98 > 88)
    |
241 |             # content is not empty and _split_content_into_parts works.
242 |             assert "Content cannot be empty after splitting" not in str(e), (
243 |                 "The internal 'Content cannot be empty after splitting' ValueError should not be "
    |                                                                                         ^^^^^^^^^^ E501
244 |                 "raised with valid Pydantic input."
245 |             )
    |

tests\models\test_snippet_manager.py:247:89: E501 Line too long (92 > 88)
    |
245 |             )
246 |         except Exception:
247 |             # Catch any other exception to fail the test if it's not the specific ValueError
    |                                                                                         ^^^^ E501
248 |             pass
    |

tests\models\test_snippet_manager.py:286:89: E501 Line too long (98 > 88)
    |
284 |         # Insert user and keyboard for FK
285 |         snippet_mgr.db.execute(
286 |             "INSERT INTO users (user_id, first_name, surname, email_address) VALUES (?, ?, ?, ?)",
    |                                                                                         ^^^^^^^^^^ E501
287 |             (user_id, "Test", "User", f"{user_id}@example.com"),
288 |         )
    |

tests\models\test_snippet_manager.py:290:89: E501 Line too long (91 > 88)
    |
288 |         )
289 |         snippet_mgr.db.execute(
290 |             "INSERT INTO keyboards (keyboard_id, user_id, keyboard_name) VALUES (?, ?, ?)",
    |                                                                                         ^^^ E501
291 |             (keyboard_id, user_id, "Test Keyboard"),
292 |         )
    |

tests\models\test_snippet_manager.py:306:89: E501 Line too long (91 > 88)
    |
304 |         )
305 |         session_mgr.save_session(session)
306 |         idx = snippet_mgr.get_starting_index(str(snippet.snippet_id), user_id, keyboard_id)
    |                                                                                         ^^^ E501
307 |         assert idx == 3  # Next should be 'd'
    |

tests\models\test_snippet_manager.py:325:89: E501 Line too long (98 > 88)
    |
323 |         keyboard_id = str(uuid.uuid4())
324 |         snippet_mgr.db.execute(
325 |             "INSERT INTO users (user_id, first_name, surname, email_address) VALUES (?, ?, ?, ?)",
    |                                                                                         ^^^^^^^^^^ E501
326 |             (user_id, "Test", "User", f"{user_id}@example.com"),
327 |         )
    |

tests\models\test_snippet_manager.py:329:89: E501 Line too long (91 > 88)
    |
327 |         )
328 |         snippet_mgr.db.execute(
329 |             "INSERT INTO keyboards (keyboard_id, user_id, keyboard_name) VALUES (?, ?, ?)",
    |                                                                                         ^^^ E501
330 |             (keyboard_id, user_id, "Test Keyboard"),
331 |         )
    |

tests\models\test_snippet_manager.py:345:89: E501 Line too long (91 > 88)
    |
343 |         )
344 |         session_mgr.save_session(session)
345 |         idx = snippet_mgr.get_starting_index(str(snippet.snippet_id), user_id, keyboard_id)
    |                                                                                         ^^^ E501
346 |         # Should wrap to 0 since last index is >= len(content)-1
347 |         assert idx == 0
    |

tests\models\test_snippet_manager.py:365:89: E501 Line too long (98 > 88)
    |
363 |         keyboard_id = str(uuid.uuid4())
364 |         snippet_mgr.db.execute(
365 |             "INSERT INTO users (user_id, first_name, surname, email_address) VALUES (?, ?, ?, ?)",
    |                                                                                         ^^^^^^^^^^ E501
366 |             (user_id, "Test", "User", f"{user_id}@example.com"),
367 |         )
    |

tests\models\test_snippet_manager.py:369:89: E501 Line too long (91 > 88)
    |
367 |         )
368 |         snippet_mgr.db.execute(
369 |             "INSERT INTO keyboards (keyboard_id, user_id, keyboard_name) VALUES (?, ?, ?)",
    |                                                                                         ^^^ E501
370 |             (keyboard_id, user_id, "Test Keyboard"),
371 |         )
    |

tests\models\test_snippet_manager.py:385:89: E501 Line too long (91 > 88)
    |
383 |         )
384 |         session_mgr.save_session(session)
385 |         idx = snippet_mgr.get_starting_index(str(snippet.snippet_id), user_id, keyboard_id)
    |                                                                                         ^^^ E501
386 |         # Should wrap to 0 since end index is out of bounds
387 |         assert idx == 0
    |

tests\models\test_snippet_manager.py:407:89: E501 Line too long (98 > 88)
    |
405 |         keyboard_id2 = str(uuid.uuid4())
406 |         snippet_mgr.db.execute(
407 |             "INSERT INTO users (user_id, first_name, surname, email_address) VALUES (?, ?, ?, ?)",
    |                                                                                         ^^^^^^^^^^ E501
408 |             (user_id1, "Test", "User", f"{user_id1}@example.com"),
409 |         )
    |

tests\models\test_snippet_manager.py:411:89: E501 Line too long (91 > 88)
    |
409 |         )
410 |         snippet_mgr.db.execute(
411 |             "INSERT INTO keyboards (keyboard_id, user_id, keyboard_name) VALUES (?, ?, ?)",
    |                                                                                         ^^^ E501
412 |             (keyboard_id1, user_id1, "Test Keyboard 1"),
413 |         )
    |

tests\models\test_snippet_manager.py:415:89: E501 Line too long (98 > 88)
    |
413 |         )
414 |         snippet_mgr.db.execute(
415 |             "INSERT INTO users (user_id, first_name, surname, email_address) VALUES (?, ?, ?, ?)",
    |                                                                                         ^^^^^^^^^^ E501
416 |             (user_id2, "Test", "User", f"{user_id2}@example.com"),
417 |         )
    |

tests\models\test_snippet_manager.py:419:89: E501 Line too long (91 > 88)
    |
417 |         )
418 |         snippet_mgr.db.execute(
419 |             "INSERT INTO keyboards (keyboard_id, user_id, keyboard_name) VALUES (?, ?, ?)",
    |                                                                                         ^^^ E501
420 |             (keyboard_id2, user_id2, "Test Keyboard 2"),
421 |         )
    |

tests\models\test_snippet_manager.py:448:89: E501 Line too long (94 > 88)
    |
446 |         session_mgr.save_session(session1)
447 |         session_mgr.save_session(session2)
448 |         idx1 = snippet_mgr.get_starting_index(str(snippet.snippet_id), user_id1, keyboard_id1)
    |                                                                                         ^^^^^^ E501
449 |         idx2 = snippet_mgr.get_starting_index(str(snippet.snippet_id), user_id2, keyboard_id2)
450 |         assert idx1 == 3  # user1/keyboard1: last end=2, so next=3
    |

tests\models\test_snippet_manager.py:449:89: E501 Line too long (94 > 88)
    |
447 |         session_mgr.save_session(session2)
448 |         idx1 = snippet_mgr.get_starting_index(str(snippet.snippet_id), user_id1, keyboard_id1)
449 |         idx2 = snippet_mgr.get_starting_index(str(snippet.snippet_id), user_id2, keyboard_id2)
    |                                                                                         ^^^^^^ E501
450 |         assert idx1 == 3  # user1/keyboard1: last end=2, so next=3
451 |         assert idx2 == 5  # user2/keyboard2: last end=4, so next=5
    |

tests\models\test_user.py:68:89: E501 Line too long (91 > 88)
   |
66 |     def test_create_user_with_minimal_fields(self) -> None:
67 |         """Test creating a user with minimal required fields."""
68 |         user = User(first_name="John", surname="Doe", email_address="john.doe@example.com")
   |                                                                                         ^^^ E501
69 |         assert user.first_name == "John"
70 |         assert user.surname == "Doe"
   |

tests\models\test_user.py:82:89: E501 Line too long (99 > 88)
   |
80 |         test_id = str(uuid4())
81 |         user = User(
82 |             user_id=test_id, first_name="John", surname="Doe", email_address="john.doe@example.com"
   |                                                                                         ^^^^^^^^^^^ E501
83 |         )
84 |         assert user.user_id == test_id
   |

tests\models\test_user.py:132:89: E501 Line too long (94 > 88)
    |
130 |         """Test that whitespace is properly stripped from string fields."""
131 |         user = User(
132 |             first_name="  John  ", surname="  Doe  ", email_address="  john.doe@example.com  "
    |                                                                                         ^^^^^^ E501
133 |         )
134 |         assert user.first_name == "John"
    |

tests\models\test_user.py:140:89: E501 Line too long (92 > 88)
    |
138 |     def test_case_insensitive_email(self) -> None:
139 |         """Test that email addresses are case-insensitive."""
140 |         user1 = User(first_name="John", surname="Doe", email_address="John.Doe@Example.COM")
    |                                                                                         ^^^^ E501
141 |         user2 = User(first_name="John", surname="Doe", email_address="john.doe@example.com")
142 |         assert user1.email_address.lower() == user2.email_address.lower()
    |

tests\models\test_user.py:141:89: E501 Line too long (92 > 88)
    |
139 |         """Test that email addresses are case-insensitive."""
140 |         user1 = User(first_name="John", surname="Doe", email_address="John.Doe@Example.COM")
141 |         user2 = User(first_name="John", surname="Doe", email_address="john.doe@example.com")
    |                                                                                         ^^^^ E501
142 |         assert user1.email_address.lower() == user2.email_address.lower()
    |

tests\models\test_user.py:146:89: E501 Line too long (91 > 88)
    |
144 |     def test_to_dict(self) -> None:
145 |         """Test conversion to dictionary."""
146 |         user = User(first_name="John", surname="Doe", email_address="john.doe@example.com")
    |                                                                                         ^^^ E501
147 |         user_dict = user.to_dict()
148 |         assert user_dict["first_name"] == "John"
    |

tests\models\test_user.py:181:89: E501 Line too long (100 > 88)
    |
179 |         """Test that empty user_id raises ValueError."""
180 |         with pytest.raises(ValueError) as excinfo:
181 |             User(user_id="", first_name="John", surname="Doe", email_address="john.doe@example.com")
    |                                                                                         ^^^^^^^^^^^^ E501
182 |         assert "user_id must not be empty" in str(excinfo.value)
    |

tests\models\test_user.py:198:89: E501 Line too long (90 > 88)
    |
196 |         """Test various forms of IP address domains in emails."""
197 |         # Test bracketed IP address domain
198 |         user1 = User(first_name="John", surname="Doe", email_address="john@[192.168.1.1]")
    |                                                                                         ^^ E501
199 |         assert "@[192.168.1.1]" in user1.email_address
    |

tests\models\test_user.py:208:89: E501 Line too long (89 > 88)
    |
206 |         """Test special cases for domain validation."""
207 |         # Valid domain with hyphen
208 |         user = User(first_name="John", surname="Doe", email_address="john@my-domain.com")
    |                                                                                         ^ E501
209 |         assert user.email_address == "john@my-domain.com"
    |

tests\models\test_user.py:213:89: E501 Line too long (99 > 88)
    |
211 |         # Test domains with invalid characters
212 |         with pytest.raises(ValueError):
213 |             User(first_name="John", surname="Doe", email_address="john@domain_with_underscore.com")
    |                                                                                         ^^^^^^^^^^^ E501
214 |
215 |         # Test domain with invalid TLD (too short)
    |

tests\models\test_user_manager.py:13:89: E501 Line too long (96 > 88)
   |
12 | # Test data
13 | TEST_USER_1 = User(first_name="Alice", surname="Smith", email_address="alice.smith@example.com")
   |                                                                                         ^^^^^^^^ E501
14 |
15 | TEST_USER_2 = User(first_name="Bob", surname="Johnson", email_address="bob.johnson@example.com")
   |

tests\models\test_user_manager.py:15:89: E501 Line too long (96 > 88)
   |
13 | TEST_USER_1 = User(first_name="Alice", surname="Smith", email_address="alice.smith@example.com")
14 |
15 | TEST_USER_2 = User(first_name="Bob", surname="Johnson", email_address="bob.johnson@example.com")
   |                                                                                         ^^^^^^^^ E501
16 |
17 | TEST_USER_UPDATED = User(
   |

tests\models\test_user_manager.py:18:89: E501 Line too long (94 > 88)
   |
17 | TEST_USER_UPDATED = User(
18 |     first_name="Alicia", surname="Smith-Jones", email_address="alicia.smith-jones@example.com"
   |                                                                                         ^^^^^^ E501
19 | )
   |

tests\models\test_user_manager.py:112:89: E501 Line too long (89 > 88)
    |
110 |             first_name="AliceB",  # Valid name without digits
111 |             surname="SmithB",     # Valid name without digits
112 |             email_address=TEST_USER_1.email_address.upper()  # Same email, different case
    |                                                                                         ^ E501
113 |         )
    |

tests\models\test_user_manager.py:115:89: E501 Line too long (95 > 88)
    |
113 |         )
114 |
115 |         # UserManager should raise UserValidationError when trying to save with duplicate email
    |                                                                                         ^^^^^^^ E501
116 |         with pytest.raises(UserValidationError) as excinfo:
117 |             user_manager.save_user(duplicate_email_user)
    |

tests\models\test_user_manager.py:134:89: E501 Line too long (100 > 88)
    |
132 |             first_name=user2.first_name,
133 |             surname=user2.surname,
134 |             email_address=TEST_USER_1.email_address.title()  # Title case to test case insensitivity
    |                                                                                         ^^^^^^^^^^^^ E501
135 |         )
    |

tests\models\test_user_manager.py:177:89: E501 Line too long (94 > 88)
    |
175 |         # Create user with mixed case email
176 |         user = User(
177 |             first_name="Case", surname="Sensitive", email_address="Case.Sensitive@Example.COM"
    |                                                                                         ^^^^^^ E501
178 |         )
179 |         user_manager.save_user(user)
    |

tests\models\test_user_manager.py:186:89: E501 Line too long (100 > 88)
    |
185 |         # Should be stored in lowercase
186 |         assert user_manager.get_user_by_id(user.user_id).email_address == user.email_address.lower()
    |                                                                                         ^^^^^^^^^^^^ E501
187 |
188 |     def test_empty_database_operations(self, user_manager: UserManager) -> None:
    |

Found 762 errors.
[*] 10 fixable with the `--fix` option (44 hidden fixes can be enabled with the `--unsafe-fixes` option).
************* Module AITypingTrainer.models
models\__init__.py:12:0: C0305: Trailing newlines (trailing-newlines)
models\__init__.py:10:4: E0603: Undefined variable name 'NGramManager' in __all__ (undefined-all-variable)
************* Module AITypingTrainer.models.category
models\category.py:57:4: C0116: Missing function or method docstring (missing-function-docstring)
************* Module AITypingTrainer.models.category_manager
models\category_manager.py:8:0: E0401: Unable to import 'db.database_manager' (import-error)
models\category_manager.py:9:0: E0401: Unable to import 'models.category' (import-error)
models\category_manager.py:132:8: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
************* Module AITypingTrainer.models.dynamic_content_manager
models\dynamic_content_manager.py:10:0: E0401: Unable to import 'models.llm_ngram_service' (import-error)
models\dynamic_content_manager.py:31:4: R0913: Too many arguments (6/5) (too-many-arguments)
models\dynamic_content_manager.py:31:4: R0917: Too many positional arguments (6/5) (too-many-positional-arguments)
models\dynamic_content_manager.py:76:16: W0707: Consider explicitly re-raising using 'except ValueError as exc' and 'raise ValueError(f"Invalid mode. Must be one of: {', '.join(valid_modes)}") from exc' (raise-missing-from)
models\dynamic_content_manager.py:242:8: R1705: Unnecessary "elif" after "return", remove the leading "el" from "elif" (no-else-return)
************* Module AITypingTrainer.models.keyboard
models\keyboard.py:34:4: C0116: Missing function or method docstring (missing-function-docstring)
models\keyboard.py:46:4: C0116: Missing function or method docstring (missing-function-docstring)
models\keyboard.py:57:4: C0116: Missing function or method docstring (missing-function-docstring)
models\keyboard.py:64:4: C0116: Missing function or method docstring (missing-function-docstring)
models\keyboard.py:75:4: C0116: Missing function or method docstring (missing-function-docstring)
models\keyboard.py:84:4: C0116: Missing function or method docstring (missing-function-docstring)
models\keyboard.py:88:4: C0116: Missing function or method docstring (missing-function-docstring)
************* Module AITypingTrainer.models.keyboard_manager
models\keyboard_manager.py:8:0: E0401: Unable to import 'db.database_manager' (import-error)
models\keyboard_manager.py:9:0: E0401: Unable to import 'models.keyboard' (import-error)
models\keyboard_manager.py:12:0: C0115: Missing class docstring (missing-class-docstring)
models\keyboard_manager.py:18:0: C0115: Missing class docstring (missing-class-docstring)
models\keyboard_manager.py:24:0: C0115: Missing class docstring (missing-class-docstring)
models\keyboard_manager.py:41:4: C0116: Missing function or method docstring (missing-function-docstring)
models\keyboard_manager.py:59:4: C0116: Missing function or method docstring (missing-function-docstring)
models\keyboard_manager.py:78:4: C0116: Missing function or method docstring (missing-function-docstring)
models\keyboard_manager.py:82:8: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
models\keyboard_manager.py:128:4: C0116: Missing function or method docstring (missing-function-docstring)
models\keyboard_manager.py:140:4: C0116: Missing function or method docstring (missing-function-docstring)
models\keyboard_manager.py:143:4: C0116: Missing function or method docstring (missing-function-docstring)
************* Module AITypingTrainer.models.keystroke
models\keystroke.py:12:0: E0401: Unable to import 'db.database_manager' (import-error)
models\keystroke.py:88:31: E1101: Instance of 'FieldInfo' has no 'isoformat' member (no-member)
models\keystroke.py:150:15: W0718: Catching too general exception Exception (broad-exception-caught)
************* Module AITypingTrainer.models.keystroke_manager
models\keystroke_manager.py:1:0: C0114: Missing module docstring (missing-module-docstring)
models\keystroke_manager.py:3:0: E0401: Unable to import 'db.database_manager' (import-error)
models\keystroke_manager.py:4:0: E0401: Unable to import 'models.keystroke' (import-error)
models\keystroke_manager.py:54:15: W0718: Catching too general exception Exception (broad-exception-caught)
models\keystroke_manager.py:55:12: C0415: Import outside toplevel (sys) (import-outside-toplevel)
models\keystroke_manager.py:58:12: C0415: Import outside toplevel (traceback) (import-outside-toplevel)
models\keystroke_manager.py:78:15: W0718: Catching too general exception Exception (broad-exception-caught)
models\keystroke_manager.py:79:12: C0415: Import outside toplevel (sys) (import-outside-toplevel)
models\keystroke_manager.py:82:12: C0415: Import outside toplevel (traceback) (import-outside-toplevel)
models\keystroke_manager.py:95:15: W0718: Catching too general exception Exception (broad-exception-caught)
models\keystroke_manager.py:129:15: W0718: Catching too general exception Exception (broad-exception-caught)
models\keystroke_manager.py:126:23: W0718: Catching too general exception Exception (broad-exception-caught)
************* Module AITypingTrainer.models.library
models\library.py:12:0: E0401: Unable to import 'db.database_manager' (import-error)
models\library.py:13:0: E0401: Unable to import 'models.category' (import-error)
models\library.py:14:0: E0401: Unable to import 'models.category_manager' (import-error)
models\library.py:19:0: E0401: Unable to import 'models.snippet' (import-error)
models\library.py:20:0: E0401: Unable to import 'models.snippet_manager' (import-error)
models\library.py:60:4: C0116: Missing function or method docstring (missing-function-docstring)
models\library.py:65:8: W0706: The except handler raises immediately (try-except-raise)
models\library.py:68:4: C0116: Missing function or method docstring (missing-function-docstring)
models\library.py:71:8: W0706: The except handler raises immediately (try-except-raise)
models\library.py:75:4: C0116: Missing function or method docstring (missing-function-docstring)
models\library.py:111:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
models\library.py:114:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
models\library.py:159:15: W0718: Catching too general exception Exception (broad-exception-caught)
models\library.py:160:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
************* Module AITypingTrainer.models.llm_ngram_service
models\llm_ngram_service.py:37:0: C0303: Trailing whitespace (trailing-whitespace)
models\llm_ngram_service.py:47:0: C0301: Line too long (113/100) (line-too-long)
models\llm_ngram_service.py:48:0: C0301: Line too long (112/100) (line-too-long)
models\llm_ngram_service.py:49:0: C0301: Line too long (119/100) (line-too-long)
models\llm_ngram_service.py:52:0: C0303: Trailing whitespace (trailing-whitespace)
models\llm_ngram_service.py:55:0: C0303: Trailing whitespace (trailing-whitespace)
models\llm_ngram_service.py:60:0: C0301: Line too long (102/100) (line-too-long)
models\llm_ngram_service.py:68:0: C0303: Trailing whitespace (trailing-whitespace)
models\llm_ngram_service.py:70:0: C0303: Trailing whitespace (trailing-whitespace)
models\llm_ngram_service.py:79:0: C0303: Trailing whitespace (trailing-whitespace)
models\llm_ngram_service.py:1:0: C0114: Missing module docstring (missing-module-docstring)
models\llm_ngram_service.py:9:0: C0115: Missing class docstring (missing-class-docstring)
models\llm_ngram_service.py:27:4: C0116: Missing function or method docstring (missing-function-docstring)
models\llm_ngram_service.py:13:0: R0903: Too few public methods (1/2) (too-few-public-methods)
************* Module AITypingTrainer.models.ngram
models\ngram.py:33:0: C0303: Trailing whitespace (trailing-whitespace)
models\ngram.py:13:0: C0115: Missing class docstring (missing-class-docstring)
models\ngram.py:26:4: C0116: Missing function or method docstring (missing-function-docstring)
models\ngram.py:41:4: C0116: Missing function or method docstring (missing-function-docstring)
models\ngram.py:48:4: C0116: Missing function or method docstring (missing-function-docstring)
************* Module AITypingTrainer.models.ngram_manager
models\ngram_manager.py:277:47: C0303: Trailing whitespace (trailing-whitespace)
models\ngram_manager.py:278:51: C0303: Trailing whitespace (trailing-whitespace)
models\ngram_manager.py:294:0: C0301: Line too long (123/100) (line-too-long)
models\ngram_manager.py:355:0: C0301: Line too long (120/100) (line-too-long)
models\ngram_manager.py:22:0: E0401: Unable to import 'models.ngram' (import-error)
models\ngram_manager.py:22:0: C0413: Import "from models.ngram import NGram" should be placed at the top of the module (wrong-import-position)
models\ngram_manager.py:43:0: C0115: Missing class docstring (missing-class-docstring)
models\ngram_manager.py:49:4: C0116: Missing function or method docstring (missing-function-docstring)
models\ngram_manager.py:70:4: R0913: Too many arguments (6/5) (too-many-arguments)
models\ngram_manager.py:70:4: R0917: Too many positional arguments (6/5) (too-many-positional-arguments)
models\ngram_manager.py:148:4: R0913: Too many arguments (6/5) (too-many-arguments)
models\ngram_manager.py:148:4: R0917: Too many positional arguments (6/5) (too-many-positional-arguments)
models\ngram_manager.py:241:4: R0914: Too many local variables (20/15) (too-many-locals)
models\ngram_manager.py:354:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
************* Module AITypingTrainer.models.session
models\session.py:114:0: C0303: Trailing whitespace (trailing-whitespace)
models\session.py:120:0: C0303: Trailing whitespace (trailing-whitespace)
models\session.py:124:0: C0303: Trailing whitespace (trailing-whitespace)
models\session.py:42:4: C0116: Missing function or method docstring (missing-function-docstring)
models\session.py:48:4: C0116: Missing function or method docstring (missing-function-docstring)
models\session.py:54:4: C0116: Missing function or method docstring (missing-function-docstring)
models\session.py:64:4: C0116: Missing function or method docstring (missing-function-docstring)
models\session.py:68:4: C0116: Missing function or method docstring (missing-function-docstring)
models\session.py:72:4: C0116: Missing function or method docstring (missing-function-docstring)
models\session.py:78:4: C0116: Missing function or method docstring (missing-function-docstring)
models\session.py:84:4: C0116: Missing function or method docstring (missing-function-docstring)
models\session.py:90:4: C0116: Missing function or method docstring (missing-function-docstring)
models\session.py:96:4: C0116: Missing function or method docstring (missing-function-docstring)
models\session.py:102:4: C0116: Missing function or method docstring (missing-function-docstring)
models\session.py:107:4: C0116: Missing function or method docstring (missing-function-docstring)
models\session.py:111:4: C0116: Missing function or method docstring (missing-function-docstring)
************* Module AITypingTrainer.models.session_manager
models\session_manager.py:34:0: C0301: Line too long (108/100) (line-too-long)
models\session_manager.py:150:0: C0301: Line too long (101/100) (line-too-long)
models\session_manager.py:1:0: C0114: Missing module docstring (missing-module-docstring)
models\session_manager.py:6:0: E0401: Unable to import 'db.database_manager' (import-error)
models\session_manager.py:7:0: E0401: Unable to import 'db.exceptions' (import-error)
models\session_manager.py:16:0: E0401: Unable to import 'models.session' (import-error)
models\session_manager.py:30:4: C0116: Missing function or method docstring (missing-function-docstring)
models\session_manager.py:69:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
models\session_manager.py:72:4: C0116: Missing function or method docstring (missing-function-docstring)
models\session_manager.py:113:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
models\session_manager.py:142:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
models\session_manager.py:223:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
models\session_manager.py:232:8: E0401: Unable to import 'models.keystroke_manager' (import-error)
models\session_manager.py:232:8: C0415: Import outside toplevel (models.keystroke_manager.KeystrokeManager) (import-outside-toplevel)
models\session_manager.py:233:8: E0401: Unable to import 'models.ngram_manager' (import-error)
models\session_manager.py:233:8: C0415: Import outside toplevel (models.ngram_manager.NGramManager) (import-outside-toplevel)
models\session_manager.py:254:15: W0718: Catching too general exception Exception (broad-exception-caught)
models\session_manager.py:245:12: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
models\session_manager.py:249:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
models\session_manager.py:265:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
models\session_manager.py:281:8: E0401: Unable to import 'models.snippet_manager' (import-error)
models\session_manager.py:281:8: C0415: Import outside toplevel (models.snippet_manager.SnippetManager) (import-outside-toplevel)
************* Module AITypingTrainer.models.setting_manager
models\setting_manager.py:26:13: C0303: Trailing whitespace (trailing-whitespace)
models\setting_manager.py:27:29: C0303: Trailing whitespace (trailing-whitespace)
models\setting_manager.py:28:31: C0303: Trailing whitespace (trailing-whitespace)
models\setting_manager.py:51:72: C0303: Trailing whitespace (trailing-whitespace)
models\setting_manager.py:56:13: C0303: Trailing whitespace (trailing-whitespace)
models\setting_manager.py:57:29: C0303: Trailing whitespace (trailing-whitespace)
models\setting_manager.py:58:31: C0303: Trailing whitespace (trailing-whitespace)
models\setting_manager.py:63:0: C0301: Line too long (109/100) (line-too-long)
models\setting_manager.py:106:0: C0301: Line too long (101/100) (line-too-long)
models\setting_manager.py:163:0: C0303: Trailing whitespace (trailing-whitespace)
models\setting_manager.py:167:39: C0303: Trailing whitespace (trailing-whitespace)
models\setting_manager.py:168:58: C0303: Trailing whitespace (trailing-whitespace)
models\setting_manager.py:224:0: C0303: Trailing whitespace (trailing-whitespace)
models\setting_manager.py:245:0: C0303: Trailing whitespace (trailing-whitespace)
models\setting_manager.py:264:0: C0303: Trailing whitespace (trailing-whitespace)
models\setting_manager.py:267:0: C0303: Trailing whitespace (trailing-whitespace)
models\setting_manager.py:270:0: C0303: Trailing whitespace (trailing-whitespace)
models\setting_manager.py:292:0: C0303: Trailing whitespace (trailing-whitespace)
models\setting_manager.py:295:0: C0303: Trailing whitespace (trailing-whitespace)
models\setting_manager.py:301:0: C0303: Trailing whitespace (trailing-whitespace)
models\setting_manager.py:10:0: E0401: Unable to import 'db.database_manager' (import-error)
models\setting_manager.py:11:0: E0401: Unable to import 'models.setting' (import-error)
models\setting_manager.py:85:8: R1705: Unnecessary "elif" after "return", remove the leading "el" from "elif" (no-else-return)
models\setting_manager.py:164:8: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
************* Module AITypingTrainer.models.snippet
models\snippet.py:142:0: C0325: Unnecessary parens after 'not' keyword (superfluous-parens)
models\snippet.py:152:0: C0325: Unnecessary parens after 'not' keyword (superfluous-parens)
models\snippet.py:36:4: C0415: Import outside toplevel (re) (import-outside-toplevel)
models\snippet.py:120:4: C0116: Missing function or method docstring (missing-function-docstring)
models\snippet.py:127:4: C0116: Missing function or method docstring (missing-function-docstring)
models\snippet.py:138:4: C0116: Missing function or method docstring (missing-function-docstring)
models\snippet.py:148:4: C0116: Missing function or method docstring (missing-function-docstring)
models\snippet.py:156:4: C0116: Missing function or method docstring (missing-function-docstring)
models\snippet.py:160:4: C0116: Missing function or method docstring (missing-function-docstring)
models\snippet.py:164:12: C0415: Import outside toplevel (pydantic.ErrorWrapper, pydantic.ValidationError) (import-outside-toplevel)
models\snippet.py:164:12: E0611: No name 'ErrorWrapper' in module 'pydantic' (no-name-in-module)
************* Module AITypingTrainer.models.snippet_manager
models\snippet_manager.py:451:0: C0301: Line too long (111/100) (line-too-long)
models\snippet_manager.py:10:0: E0401: Unable to import 'db.database_manager' (import-error)
models\snippet_manager.py:11:0: E0401: Unable to import 'db.exceptions' (import-error)
models\snippet_manager.py:12:0: E0401: Unable to import 'models.snippet' (import-error)
models\snippet_manager.py:131:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
models\snippet_manager.py:134:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
models\snippet_manager.py:164:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
models\snippet_manager.py:170:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
models\snippet_manager.py:218:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
models\snippet_manager.py:221:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
models\snippet_manager.py:267:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
models\snippet_manager.py:270:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
models\snippet_manager.py:296:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
models\snippet_manager.py:299:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
models\snippet_manager.py:331:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
models\snippet_manager.py:334:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
models\snippet_manager.py:359:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
models\snippet_manager.py:362:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
models\snippet_manager.py:380:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
models\snippet_manager.py:383:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
models\snippet_manager.py:405:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
models\snippet_manager.py:408:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
models\snippet_manager.py:419:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
models\snippet_manager.py:422:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
models\snippet_manager.py:429:15: E1101: Instance of 'SnippetManager' has no 'create_snippet' member (no-member)
************* Module AITypingTrainer.models.user
models\user.py:11:0: E0401: Unable to import 'email_validator' (import-error)
models\user.py:93:4: C0116: Missing function or method docstring (missing-function-docstring)
models\user.py:93:4: R0912: Too many branches (15/12) (too-many-branches)
models\user.py:183:4: C0116: Missing function or method docstring (missing-function-docstring)
models\user.py:192:4: C0116: Missing function or method docstring (missing-function-docstring)
models\user.py:201:4: C0116: Missing function or method docstring (missing-function-docstring)
models\user.py:205:4: C0116: Missing function or method docstring (missing-function-docstring)
************* Module AITypingTrainer.models.user_manager
models\user_manager.py:51:0: C0301: Line too long (114/100) (line-too-long)
models\user_manager.py:60:0: C0301: Line too long (104/100) (line-too-long)
models\user_manager.py:8:0: E0401: Unable to import 'db.database_manager' (import-error)
models\user_manager.py:9:0: E0401: Unable to import 'models.user' (import-error)
models\user_manager.py:12:0: C0115: Missing class docstring (missing-class-docstring)
models\user_manager.py:18:0: C0115: Missing class docstring (missing-class-docstring)
models\user_manager.py:24:0: C0115: Missing class docstring (missing-class-docstring)
models\user_manager.py:39:4: C0116: Missing function or method docstring (missing-function-docstring)
models\user_manager.py:48:4: C0116: Missing function or method docstring (missing-function-docstring)
models\user_manager.py:58:4: C0116: Missing function or method docstring (missing-function-docstring)
models\user_manager.py:67:4: C0116: Missing function or method docstring (missing-function-docstring)
models\user_manager.py:69:8: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
models\user_manager.py:94:4: C0116: Missing function or method docstring (missing-function-docstring)
models\user_manager.py:106:4: C0116: Missing function or method docstring (missing-function-docstring)
models\user_manager.py:109:4: C0116: Missing function or method docstring (missing-function-docstring)
models\user_manager.py:1:0: R0801: Similar lines in 2 files
==AITypingTrainer.models.keyboard:[75:93]
==AITypingTrainer.models.user:[192:210]
        if not v:
            raise ValueError("user_id must not be empty")
        try:
            UUID(v)
        except Exception as err:
            raise ValueError("user_id must be a valid UUID string") from err
        return v

    def to_dict(self) -> Dict[str, Any]:
        return self.dict()

    @classmethod
    def from_dict(cls, d: Dict[str, Any]) -> "User":
        allowed = set(cls.model_fields.keys())
        extra = set(d.keys()) - allowed
        if extra:
            raise ValueError(f"Extra fields not permitted: {extra}")
        return cls(**d) (duplicate-code)
models\user_manager.py:1:0: R0801: Similar lines in 2 files
==AITypingTrainer.models.category:[71:99]
==AITypingTrainer.models.keyboard:[81:93]
        return v

    def to_dict(self) -> Dict[str, Any]:
        """Convert the Category instance to a dictionary.

        Returns:
            Dict: A dictionary representation of the category.
        """
        return self.dict()

    @classmethod
    def from_dict(cls, d: Dict[str, Any]) -> Category:
        """Create a Category instance from a dictionary.

        Args:
            d: Dictionary containing category data.

        Returns:
            Category: An instance of the Category class.

        Raises:
            ValueError: If unexpected fields are present in the data.
        """
        allowed = set(cls.model_fields.keys())
        extra = set(d.keys()) - allowed
        if extra:
            raise ValueError(f"Extra fields not permitted: {extra}")
        return cls(**d) (duplicate-code)
models\user_manager.py:1:0: R0801: Similar lines in 2 files
==AITypingTrainer.models.category:[94:99]
==AITypingTrainer.models.setting:[146:151]
        allowed = set(cls.model_fields.keys())
        extra = set(d.keys()) - allowed
        if extra:
            raise ValueError(f"Extra fields not permitted: {extra}")
        return cls(**d) (duplicate-code)

-----------------------------------
Your code has been rated at 7.61/10

************* Module AITypingTrainer.services
services\__init__.py:10:0: E0401: Unable to import 'db.database_manager' (import-error)
services\__init__.py:31:8: C0415: Import outside toplevel (models.session_manager.SessionManager) (import-outside-toplevel)
services\__init__.py:32:8: C0415: Import outside toplevel (models.snippet_manager.SnippetManager) (import-outside-toplevel)
************* Module AITypingTrainer.services.database_viewer_service
services\database_viewer_service.py:78:0: C0303: Trailing whitespace (trailing-whitespace)
services\database_viewer_service.py:95:0: C0303: Trailing whitespace (trailing-whitespace)
services\database_viewer_service.py:99:0: C0303: Trailing whitespace (trailing-whitespace)
services\database_viewer_service.py:110:0: C0303: Trailing whitespace (trailing-whitespace)
services\database_viewer_service.py:113:28: C0303: Trailing whitespace (trailing-whitespace)
services\database_viewer_service.py:114:38: C0303: Trailing whitespace (trailing-whitespace)
services\database_viewer_service.py:115:36: C0303: Trailing whitespace (trailing-whitespace)
services\database_viewer_service.py:143:0: C0303: Trailing whitespace (trailing-whitespace)
services\database_viewer_service.py:146:0: C0303: Trailing whitespace (trailing-whitespace)
services\database_viewer_service.py:150:0: C0303: Trailing whitespace (trailing-whitespace)
services\database_viewer_service.py:154:0: C0303: Trailing whitespace (trailing-whitespace)
services\database_viewer_service.py:157:0: C0301: Line too long (101/100) (line-too-long)
services\database_viewer_service.py:158:0: C0303: Trailing whitespace (trailing-whitespace)
services\database_viewer_service.py:161:0: C0301: Line too long (109/100) (line-too-long)
services\database_viewer_service.py:162:0: C0303: Trailing whitespace (trailing-whitespace)
services\database_viewer_service.py:166:0: C0303: Trailing whitespace (trailing-whitespace)
services\database_viewer_service.py:172:0: C0303: Trailing whitespace (trailing-whitespace)
services\database_viewer_service.py:177:0: C0303: Trailing whitespace (trailing-whitespace)
services\database_viewer_service.py:181:0: C0303: Trailing whitespace (trailing-whitespace)
services\database_viewer_service.py:189:0: C0303: Trailing whitespace (trailing-whitespace)
services\database_viewer_service.py:192:0: C0303: Trailing whitespace (trailing-whitespace)
services\database_viewer_service.py:195:0: C0303: Trailing whitespace (trailing-whitespace)
services\database_viewer_service.py:203:0: C0303: Trailing whitespace (trailing-whitespace)
services\database_viewer_service.py:210:0: C0303: Trailing whitespace (trailing-whitespace)
services\database_viewer_service.py:213:0: C0303: Trailing whitespace (trailing-whitespace)
services\database_viewer_service.py:224:33: C0303: Trailing whitespace (trailing-whitespace)
services\database_viewer_service.py:225:43: C0303: Trailing whitespace (trailing-whitespace)
services\database_viewer_service.py:250:0: C0303: Trailing whitespace (trailing-whitespace)
services\database_viewer_service.py:253:0: C0303: Trailing whitespace (trailing-whitespace)
services\database_viewer_service.py:261:0: C0303: Trailing whitespace (trailing-whitespace)
services\database_viewer_service.py:272:0: C0303: Trailing whitespace (trailing-whitespace)
services\database_viewer_service.py:16:0: E0401: Unable to import 'db.database_manager' (import-error)
services\database_viewer_service.py:21:4: W0107: Unnecessary pass statement (unnecessary-pass)
services\database_viewer_service.py:26:4: W0107: Unnecessary pass statement (unnecessary-pass)
services\database_viewer_service.py:31:4: W0107: Unnecessary pass statement (unnecessary-pass)
services\database_viewer_service.py:113:4: R0913: Too many arguments (8/5) (too-many-arguments)
services\database_viewer_service.py:113:4: R0917: Too many positional arguments (8/5) (too-many-positional-arguments)
services\database_viewer_service.py:113:4: R0914: Too many local variables (28/15) (too-many-locals)
services\database_viewer_service.py:257:16: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
services\database_viewer_service.py:257:16: R1732: Consider using 'with' for resource-allocating operations (consider-using-with)
************* Module AITypingTrainer.services.library_service
services\library_service.py:1:0: C0114: Missing module docstring (missing-module-docstring)
services\library_service.py:1:0: E0401: Unable to import 'sqlalchemy' (import-error)
services\library_service.py:9:0: E0401: Unable to import 'sqlalchemy.orm' (import-error)
services\library_service.py:15:0: C0115: Missing class docstring (missing-class-docstring)
services\library_service.py:23:0: C0115: Missing class docstring (missing-class-docstring)
services\library_service.py:23:0: R0903: Too few public methods (0/2) (too-few-public-methods)
services\library_service.py:32:0: C0115: Missing class docstring (missing-class-docstring)
services\library_service.py:32:0: R0903: Too few public methods (0/2) (too-few-public-methods)
services\library_service.py:44:0: C0115: Missing class docstring (missing-class-docstring)
services\library_service.py:51:4: C0116: Missing function or method docstring (missing-function-docstring)
services\library_service.py:60:4: C0116: Missing function or method docstring (missing-function-docstring)
services\library_service.py:63:4: C0116: Missing function or method docstring (missing-function-docstring)
services\library_service.py:78:4: C0116: Missing function or method docstring (missing-function-docstring)
services\library_service.py:85:4: C0116: Missing function or method docstring (missing-function-docstring)
services\library_service.py:100:4: C0116: Missing function or method docstring (missing-function-docstring)
services\library_service.py:103:4: C0116: Missing function or method docstring (missing-function-docstring)
services\library_service.py:129:4: C0116: Missing function or method docstring (missing-function-docstring)

-----------------------------------
Your code has been rated at 6.12/10

************* Module AITypingTrainer.helpers.error_utils
helpers\error_utils.py:36:0: C0303: Trailing whitespace (trailing-whitespace)
helpers\error_utils.py:39:0: C0303: Trailing whitespace (trailing-whitespace)
helpers\error_utils.py:11:0: E0611: No name 'QMessageBox' in module 'PyQt5.QtWidgets' (no-name-in-module)
helpers\error_utils.py:17:0: C0103: Function name "ErrorMsgBox" doesn't conform to snake_case naming style (invalid-name)
helpers\error_utils.py:41:11: W0718: Catching too general exception Exception (broad-exception-caught)

-----------------------------------
Your code has been rated at 5.26/10

************* Module AITypingTrainer.desktop_ui.dynamic_config
desktop_ui\dynamic_config.py:523:9: E0001: Parsing failed: 'expected 'except' or 'finally' block (AITypingTrainer.desktop_ui.dynamic_config, line 523)' (syntax-error)
************* Module AITypingTrainer.desktop_ui.api_key_dialog
desktop_ui\api_key_dialog.py:47:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\api_key_dialog.py:53:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\api_key_dialog.py:56:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\api_key_dialog.py:59:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\api_key_dialog.py:65:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\api_key_dialog.py:70:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\api_key_dialog.py:74:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\api_key_dialog.py:78:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\api_key_dialog.py:84:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\api_key_dialog.py:89:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\api_key_dialog.py:91:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\api_key_dialog.py:99:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\api_key_dialog.py:108:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\api_key_dialog.py:113:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\api_key_dialog.py:116:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\api_key_dialog.py:122:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\api_key_dialog.py:126:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\api_key_dialog.py:132:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\api_key_dialog.py:136:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\api_key_dialog.py:139:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\api_key_dialog.py:144:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\api_key_dialog.py:151:47: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\api_key_dialog.py:155:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\api_key_dialog.py:160:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\api_key_dialog.py:165:21: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\api_key_dialog.py:171:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\api_key_dialog.py:176:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\api_key_dialog.py:179:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\api_key_dialog.py:183:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\api_key_dialog.py:187:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\api_key_dialog.py:191:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\api_key_dialog.py:196:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\api_key_dialog.py:208:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\api_key_dialog.py:211:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\api_key_dialog.py:221:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\api_key_dialog.py:230:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\api_key_dialog.py:232:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\api_key_dialog.py:235:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\api_key_dialog.py:239:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\api_key_dialog.py:242:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\api_key_dialog.py:245:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\api_key_dialog.py:250:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\api_key_dialog.py:255:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\api_key_dialog.py:269:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\api_key_dialog.py:280:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\api_key_dialog.py:287:33: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\api_key_dialog.py:288:37: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\api_key_dialog.py:294:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\api_key_dialog.py:296:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\api_key_dialog.py:304:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\api_key_dialog.py:309:0: C0301: Line too long (102/100) (line-too-long)
desktop_ui\api_key_dialog.py:325:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\api_key_dialog.py:330:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\api_key_dialog.py:333:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\api_key_dialog.py:336:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\api_key_dialog.py:343:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\api_key_dialog.py:351:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\api_key_dialog.py:14:0: E0611: No name 'Qt' in module 'PySide6.QtCore' (no-name-in-module)
desktop_ui\api_key_dialog.py:15:0: E0611: No name 'QDialog' in module 'PySide6.QtWidgets' (no-name-in-module)
desktop_ui\api_key_dialog.py:15:0: E0611: No name 'QHBoxLayout' in module 'PySide6.QtWidgets' (no-name-in-module)
desktop_ui\api_key_dialog.py:15:0: E0611: No name 'QLabel' in module 'PySide6.QtWidgets' (no-name-in-module)
desktop_ui\api_key_dialog.py:15:0: E0611: No name 'QLineEdit' in module 'PySide6.QtWidgets' (no-name-in-module)
desktop_ui\api_key_dialog.py:15:0: E0611: No name 'QMessageBox' in module 'PySide6.QtWidgets' (no-name-in-module)
desktop_ui\api_key_dialog.py:15:0: E0611: No name 'QPushButton' in module 'PySide6.QtWidgets' (no-name-in-module)
desktop_ui\api_key_dialog.py:15:0: E0611: No name 'QVBoxLayout' in module 'PySide6.QtWidgets' (no-name-in-module)
desktop_ui\api_key_dialog.py:156:15: W0718: Catching too general exception Exception (broad-exception-caught)
desktop_ui\api_key_dialog.py:135:12: E0401: Unable to import 'models.llm_ngram_service' (import-error)
desktop_ui\api_key_dialog.py:135:12: C0415: Import outside toplevel (models.llm_ngram_service.LLMNgramService) (import-outside-toplevel)
desktop_ui\api_key_dialog.py:192:15: W0718: Catching too general exception Exception (broad-exception-caught)
desktop_ui\api_key_dialog.py:251:15: W0718: Catching too general exception Exception (broad-exception-caught)
desktop_ui\api_key_dialog.py:291:15: W0718: Catching too general exception Exception (broad-exception-caught)
desktop_ui\api_key_dialog.py:285:12: C0415: Import outside toplevel (platform) (import-outside-toplevel)
desktop_ui\api_key_dialog.py:338:8: W0621: Redefining name 'dialog' from outer scope (line 353) (redefined-outer-name)
desktop_ui\api_key_dialog.py:334:15: W0718: Catching too general exception Exception (broad-exception-caught)
desktop_ui\api_key_dialog.py:35:0: R0903: Too few public methods (1/2) (too-few-public-methods)
desktop_ui\api_key_dialog.py:350:4: E0611: No name 'QApplication' in module 'PySide6.QtWidgets' (no-name-in-module)
desktop_ui\api_key_dialog.py:350:4: C0412: Imports from package PySide6 are not grouped (ungrouped-imports)
************* Module AITypingTrainer.desktop_ui.api_server_manager
desktop_ui\api_server_manager.py:62:15: W0718: Catching too general exception Exception (broad-exception-caught)
desktop_ui\api_server_manager.py:54:12: W0612: Unused variable 'response' (unused-variable)
desktop_ui\api_server_manager.py:91:15: W0718: Catching too general exception Exception (broad-exception-caught)
desktop_ui\api_server_manager.py:81:35: R1732: Consider using 'with' for resource-allocating operations (consider-using-with)
desktop_ui\api_server_manager.py:115:19: W0718: Catching too general exception Exception (broad-exception-caught)
************* Module AITypingTrainer.desktop_ui.category_model_tester
desktop_ui\category_model_tester.py:4:0: C0301: Line too long (109/100) (line-too-long)
desktop_ui\category_model_tester.py:21:0: E0611: No name 'QApplication' in module 'PySide6.QtWidgets' (no-name-in-module)
desktop_ui\category_model_tester.py:21:0: E0611: No name 'QHBoxLayout' in module 'PySide6.QtWidgets' (no-name-in-module)
desktop_ui\category_model_tester.py:21:0: E0611: No name 'QInputDialog' in module 'PySide6.QtWidgets' (no-name-in-module)
desktop_ui\category_model_tester.py:21:0: E0611: No name 'QLabel' in module 'PySide6.QtWidgets' (no-name-in-module)
desktop_ui\category_model_tester.py:21:0: E0611: No name 'QListWidget' in module 'PySide6.QtWidgets' (no-name-in-module)
desktop_ui\category_model_tester.py:21:0: E0611: No name 'QMessageBox' in module 'PySide6.QtWidgets' (no-name-in-module)
desktop_ui\category_model_tester.py:21:0: E0611: No name 'QPushButton' in module 'PySide6.QtWidgets' (no-name-in-module)
desktop_ui\category_model_tester.py:21:0: E0611: No name 'QVBoxLayout' in module 'PySide6.QtWidgets' (no-name-in-module)
desktop_ui\category_model_tester.py:21:0: E0611: No name 'QWidget' in module 'PySide6.QtWidgets' (no-name-in-module)
desktop_ui\category_model_tester.py:34:0: E0401: Unable to import 'db.database_manager' (import-error)
desktop_ui\category_model_tester.py:34:0: C0413: Import "from db.database_manager import DatabaseManager" should be placed at the top of the module (wrong-import-position)
desktop_ui\category_model_tester.py:35:0: E0401: Unable to import 'models.category' (import-error)
desktop_ui\category_model_tester.py:35:0: C0413: Import "from models.category import CategoryManager, CategoryNotFound, CategoryValidationError" should be placed at the top of the module (wrong-import-position)
desktop_ui\category_model_tester.py:56:4: C0116: Missing function or method docstring (missing-function-docstring)
desktop_ui\category_model_tester.py:84:4: C0116: Missing function or method docstring (missing-function-docstring)
desktop_ui\category_model_tester.py:90:15: W0718: Catching too general exception Exception (broad-exception-caught)
desktop_ui\category_model_tester.py:93:4: C0116: Missing function or method docstring (missing-function-docstring)
desktop_ui\category_model_tester.py:102:19: W0718: Catching too general exception Exception (broad-exception-caught)
desktop_ui\category_model_tester.py:105:4: C0116: Missing function or method docstring (missing-function-docstring)
desktop_ui\category_model_tester.py:113:15: W0718: Catching too general exception Exception (broad-exception-caught)
desktop_ui\category_model_tester.py:117:4: C0116: Missing function or method docstring (missing-function-docstring)
desktop_ui\category_model_tester.py:131:19: W0718: Catching too general exception Exception (broad-exception-caught)
desktop_ui\category_model_tester.py:134:4: C0116: Missing function or method docstring (missing-function-docstring)
desktop_ui\category_model_tester.py:152:19: W0718: Catching too general exception Exception (broad-exception-caught)
desktop_ui\category_model_tester.py:155:4: C0116: Missing function or method docstring (missing-function-docstring)
desktop_ui\category_model_tester.py:163:0: C0116: Missing function or method docstring (missing-function-docstring)
************* Module AITypingTrainer.desktop_ui.db_viewer_dialog
desktop_ui\db_viewer_dialog.py:42:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\db_viewer_dialog.py:50:0: C0301: Line too long (101/100) (line-too-long)
desktop_ui\db_viewer_dialog.py:58:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\db_viewer_dialog.py:64:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\db_viewer_dialog.py:68:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\db_viewer_dialog.py:71:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\db_viewer_dialog.py:79:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\db_viewer_dialog.py:87:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\db_viewer_dialog.py:92:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\db_viewer_dialog.py:94:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\db_viewer_dialog.py:98:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\db_viewer_dialog.py:103:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\db_viewer_dialog.py:105:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\db_viewer_dialog.py:108:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\db_viewer_dialog.py:111:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\db_viewer_dialog.py:113:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\db_viewer_dialog.py:116:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\db_viewer_dialog.py:122:0: C0301: Line too long (101/100) (line-too-long)
desktop_ui\db_viewer_dialog.py:123:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\db_viewer_dialog.py:130:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\db_viewer_dialog.py:132:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\db_viewer_dialog.py:136:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\db_viewer_dialog.py:138:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\db_viewer_dialog.py:144:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\db_viewer_dialog.py:149:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\db_viewer_dialog.py:161:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\db_viewer_dialog.py:166:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\db_viewer_dialog.py:172:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\db_viewer_dialog.py:178:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\db_viewer_dialog.py:187:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\db_viewer_dialog.py:192:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\db_viewer_dialog.py:196:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\db_viewer_dialog.py:198:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\db_viewer_dialog.py:205:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\db_viewer_dialog.py:207:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\db_viewer_dialog.py:212:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\db_viewer_dialog.py:224:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\db_viewer_dialog.py:228:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\db_viewer_dialog.py:232:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\db_viewer_dialog.py:235:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\db_viewer_dialog.py:241:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\db_viewer_dialog.py:246:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\db_viewer_dialog.py:254:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\db_viewer_dialog.py:264:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\db_viewer_dialog.py:266:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\db_viewer_dialog.py:269:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\db_viewer_dialog.py:275:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\db_viewer_dialog.py:281:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\db_viewer_dialog.py:287:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\db_viewer_dialog.py:293:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\db_viewer_dialog.py:301:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\db_viewer_dialog.py:304:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\db_viewer_dialog.py:310:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\db_viewer_dialog.py:319:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\db_viewer_dialog.py:327:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\db_viewer_dialog.py:330:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\db_viewer_dialog.py:335:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\db_viewer_dialog.py:10:0: E0611: No name 'QComboBox' in module 'PySide6.QtWidgets' (no-name-in-module)
desktop_ui\db_viewer_dialog.py:10:0: E0611: No name 'QDialog' in module 'PySide6.QtWidgets' (no-name-in-module)
desktop_ui\db_viewer_dialog.py:10:0: E0611: No name 'QFileDialog' in module 'PySide6.QtWidgets' (no-name-in-module)
desktop_ui\db_viewer_dialog.py:10:0: E0611: No name 'QHBoxLayout' in module 'PySide6.QtWidgets' (no-name-in-module)
desktop_ui\db_viewer_dialog.py:10:0: E0611: No name 'QHeaderView' in module 'PySide6.QtWidgets' (no-name-in-module)
desktop_ui\db_viewer_dialog.py:10:0: E0611: No name 'QLabel' in module 'PySide6.QtWidgets' (no-name-in-module)
desktop_ui\db_viewer_dialog.py:10:0: E0611: No name 'QLineEdit' in module 'PySide6.QtWidgets' (no-name-in-module)
desktop_ui\db_viewer_dialog.py:10:0: E0611: No name 'QMessageBox' in module 'PySide6.QtWidgets' (no-name-in-module)
desktop_ui\db_viewer_dialog.py:10:0: E0611: No name 'QPushButton' in module 'PySide6.QtWidgets' (no-name-in-module)
desktop_ui\db_viewer_dialog.py:10:0: E0611: No name 'QTableWidget' in module 'PySide6.QtWidgets' (no-name-in-module)
desktop_ui\db_viewer_dialog.py:10:0: E0611: No name 'QTableWidgetItem' in module 'PySide6.QtWidgets' (no-name-in-module)
desktop_ui\db_viewer_dialog.py:10:0: E0611: No name 'QVBoxLayout' in module 'PySide6.QtWidgets' (no-name-in-module)
desktop_ui\db_viewer_dialog.py:25:0: E0401: Unable to import 'services.database_viewer_service' (import-error)
desktop_ui\db_viewer_dialog.py:28:0: R0902: Too many instance attributes (18/7) (too-many-instance-attributes)
desktop_ui\db_viewer_dialog.py:46:25: I1101: Module 'PySide6.QtWidgets' has no 'QWidget' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\db_viewer_dialog.py:76:52: W0108: Lambda may not be necessary (unnecessary-lambda)
desktop_ui\db_viewer_dialog.py:84:46: W0108: Lambda may not be necessary (unnecessary-lambda)
desktop_ui\db_viewer_dialog.py:97:42: I1101: Module 'PySide6.QtWidgets' has no 'QAbstractItemView' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\db_viewer_dialog.py:122:56: W0108: Lambda may not be necessary (unnecessary-lambda)
desktop_ui\db_viewer_dialog.py:159:15: W0718: Catching too general exception Exception (broad-exception-caught)
desktop_ui\db_viewer_dialog.py:267:15: W0718: Catching too general exception Exception (broad-exception-caught)
desktop_ui\db_viewer_dialog.py:328:15: W0718: Catching too general exception Exception (broad-exception-caught)
desktop_ui\db_viewer_dialog.py:306:23: E0602: Undefined variable 'QProgressBar' (undefined-variable)
desktop_ui\db_viewer_dialog.py:336:4: C0103: Method name "closeEvent" doesn't conform to snake_case naming style (invalid-name)
desktop_ui\db_viewer_dialog.py:336:41: I1101: Module 'PySide6.QtGui' has no 'QCloseEvent' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
************* Module AITypingTrainer.desktop_ui.drill_config
desktop_ui\drill_config.py:60:0: C0301: Line too long (114/100) (line-too-long)
desktop_ui\drill_config.py:70:0: C0301: Line too long (104/100) (line-too-long)
desktop_ui\drill_config.py:100:0: C0301: Line too long (142/100) (line-too-long)
desktop_ui\drill_config.py:279:0: C0301: Line too long (109/100) (line-too-long)
desktop_ui\drill_config.py:325:0: C0301: Line too long (113/100) (line-too-long)
desktop_ui\drill_config.py:341:0: C0301: Line too long (104/100) (line-too-long)
desktop_ui\drill_config.py:438:0: C0301: Line too long (118/100) (line-too-long)
desktop_ui\drill_config.py:457:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\drill_config.py:460:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\drill_config.py:464:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\drill_config.py:465:0: C0301: Line too long (103/100) (line-too-long)
desktop_ui\drill_config.py:466:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\drill_config.py:469:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\drill_config.py:471:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\drill_config.py:476:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\drill_config.py:486:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\drill_config.py:489:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\drill_config.py:493:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\drill_config.py:494:0: C0301: Line too long (105/100) (line-too-long)
desktop_ui\drill_config.py:495:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\drill_config.py:498:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\drill_config.py:505:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\drill_config.py:518:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\drill_config.py:530:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\drill_config.py:537:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\drill_config.py:554:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\drill_config.py:567:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\drill_config.py:579:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\drill_config.py:582:41: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\drill_config.py:587:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\drill_config.py:617:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\drill_config.py:621:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\drill_config.py:627:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\drill_config.py:703:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\drill_config.py:14:0: E0611: No name 'QStatusBar' in module 'PySide6.QtWidgets' (no-name-in-module)
desktop_ui\drill_config.py:17:0: E0401: Unable to import 'db.database_manager' (import-error)
desktop_ui\drill_config.py:18:0: E0401: Unable to import 'desktop_ui.typing_drill' (import-error)
desktop_ui\drill_config.py:19:0: E0401: Unable to import 'models.category' (import-error)
desktop_ui\drill_config.py:20:0: E0401: Unable to import 'models.category_manager' (import-error)
desktop_ui\drill_config.py:21:0: E0401: Unable to import 'models.keyboard_manager' (import-error)
desktop_ui\drill_config.py:22:0: E0401: Unable to import 'models.setting' (import-error)
desktop_ui\drill_config.py:23:0: E0401: Unable to import 'models.setting_manager' (import-error)
desktop_ui\drill_config.py:24:0: E0401: Unable to import 'models.snippet' (import-error)
desktop_ui\drill_config.py:25:0: E0401: Unable to import 'models.snippet_manager' (import-error)
desktop_ui\drill_config.py:26:0: E0401: Unable to import 'models.user_manager' (import-error)
desktop_ui\drill_config.py:34:0: R0902: Too many instance attributes (23/7) (too-many-instance-attributes)
desktop_ui\drill_config.py:34:24: I1101: Module 'PySide6.QtWidgets' has no 'QDialog' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\drill_config.py:56:25: I1101: Module 'PySide6.QtWidgets' has no 'QWidget' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\drill_config.py:122:19: W0718: Catching too general exception Exception (broad-exception-caught)
desktop_ui\drill_config.py:102:27: W0718: Catching too general exception Exception (broad-exception-caught)
desktop_ui\drill_config.py:116:27: W0718: Catching too general exception Exception (broad-exception-caught)
desktop_ui\drill_config.py:124:16: C0415: Import outside toplevel (traceback) (import-outside-toplevel)
desktop_ui\drill_config.py:148:50: I1101: Module 'PySide6.QtCore' has no 'Qt' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\drill_config.py:51:4: R0915: Too many statements (73/50) (too-many-statements)
desktop_ui\drill_config.py:162:22: I1101: Module 'PySide6.QtWidgets' has no 'QVBoxLayout' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\drill_config.py:169:25: I1101: Module 'PySide6.QtWidgets' has no 'QGroupBox' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\drill_config.py:170:26: I1101: Module 'PySide6.QtWidgets' has no 'QVBoxLayout' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\drill_config.py:172:33: I1101: Module 'PySide6.QtWidgets' has no 'QComboBox' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\drill_config.py:175:34: I1101: Module 'PySide6.QtWidgets' has no 'QLabel' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\drill_config.py:180:24: I1101: Module 'PySide6.QtWidgets' has no 'QGroupBox' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\drill_config.py:181:25: I1101: Module 'PySide6.QtWidgets' has no 'QVBoxLayout' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\drill_config.py:184:32: I1101: Module 'PySide6.QtWidgets' has no 'QComboBox' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\drill_config.py:187:33: I1101: Module 'PySide6.QtWidgets' has no 'QLabel' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\drill_config.py:191:31: I1101: Module 'PySide6.QtWidgets' has no 'QTextEdit' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\drill_config.py:194:33: I1101: Module 'PySide6.QtWidgets' has no 'QLabel' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\drill_config.py:200:22: I1101: Module 'PySide6.QtWidgets' has no 'QGroupBox' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\drill_config.py:201:23: I1101: Module 'PySide6.QtWidgets' has no 'QFormLayout' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\drill_config.py:204:27: I1101: Module 'PySide6.QtWidgets' has no 'QSpinBox' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\drill_config.py:211:28: I1101: Module 'PySide6.QtWidgets' has no 'QSpinBox' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\drill_config.py:218:25: I1101: Module 'PySide6.QtWidgets' has no 'QSpinBox' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\drill_config.py:223:40: I1101: Module 'PySide6.QtWidgets' has no 'QAbstractSpinBox' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\drill_config.py:231:31: I1101: Module 'PySide6.QtWidgets' has no 'QCheckBox' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\drill_config.py:235:27: I1101: Module 'PySide6.QtWidgets' has no 'QTextEdit' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\drill_config.py:244:21: I1101: Module 'PySide6.QtWidgets' has no 'QDialogButtonBox' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\drill_config.py:245:28: I1101: Module 'PySide6.QtWidgets' has no 'QPushButton' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\drill_config.py:247:48: I1101: Module 'PySide6.QtWidgets' has no 'QDialogButtonBox' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\drill_config.py:249:24: I1101: Module 'PySide6.QtWidgets' has no 'QPushButton' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\drill_config.py:252:44: I1101: Module 'PySide6.QtWidgets' has no 'QDialogButtonBox' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\drill_config.py:160:4: R0915: Too many statements (66/50) (too-many-statements)
desktop_ui\drill_config.py:295:15: W0718: Catching too general exception Exception (broad-exception-caught)
desktop_ui\drill_config.py:298:12: I1101: Module 'PySide6.QtWidgets' has no 'QMessageBox' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\drill_config.py:357:15: W0718: Catching too general exception Exception (broad-exception-caught)
desktop_ui\drill_config.py:360:12: I1101: Module 'PySide6.QtWidgets' has no 'QMessageBox' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\drill_config.py:401:31: W0718: Catching too general exception Exception (broad-exception-caught)
desktop_ui\drill_config.py:462:8: R1730: Consider using 'new_end_index = min(new_end_index, content_length)' instead of unnecessary if block (consider-using-min-builtin)
desktop_ui\drill_config.py:491:8: R1730: Consider using 'new_end_index = min(new_end_index, content_length)' instead of unnecessary if block (consider-using-min-builtin)
desktop_ui\drill_config.py:538:15: W0718: Catching too general exception Exception (broad-exception-caught)
desktop_ui\drill_config.py:516:19: W0718: Catching too general exception Exception (broad-exception-caught)
desktop_ui\drill_config.py:528:19: W0718: Catching too general exception Exception (broad-exception-caught)
desktop_ui\drill_config.py:535:19: W0718: Catching too general exception Exception (broad-exception-caught)
desktop_ui\drill_config.py:588:15: W0718: Catching too general exception Exception (broad-exception-caught)
desktop_ui\drill_config.py:591:4: R0914: Too many local variables (19/15) (too-many-locals)
desktop_ui\drill_config.py:614:20: W0621: Redefining name 'Category' from outer scope (line 19) (redefined-outer-name)
desktop_ui\drill_config.py:596:16: I1101: Module 'PySide6.QtWidgets' has no 'QMessageBox' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\drill_config.py:614:20: E0401: Unable to import 'models.category' (import-error)
desktop_ui\drill_config.py:614:20: W0404: Reimport 'Category' (imported line 19) (reimported)
desktop_ui\drill_config.py:614:20: C0415: Import outside toplevel (models.category.Category) (import-outside-toplevel)
desktop_ui\drill_config.py:650:16: I1101: Module 'PySide6.QtWidgets' has no 'QMessageBox' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\drill_config.py:662:16: I1101: Module 'PySide6.QtWidgets' has no 'QMessageBox' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\drill_config.py:671:16: I1101: Module 'PySide6.QtWidgets' has no 'QMessageBox' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\drill_config.py:708:12: I1101: Module 'PySide6.QtWidgets' has no 'QMessageBox' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\drill_config.py:591:4: R0912: Too many branches (17/12) (too-many-branches)
desktop_ui\drill_config.py:591:4: R0915: Too many statements (56/50) (too-many-statements)
desktop_ui\drill_config.py:34:0: R0903: Too few public methods (0/2) (too-few-public-methods)
desktop_ui\drill_config.py:718:4: E0401: Unable to import 'db.database_manager' (import-error)
desktop_ui\drill_config.py:718:4: W0404: Reimport 'DatabaseManager' (imported line 17) (reimported)
desktop_ui\drill_config.py:720:10: I1101: Module 'PySide6.QtWidgets' has no 'QApplication' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\drill_config.py:726:13: E1120: No value for argument 'user_id' in constructor call (no-value-for-parameter)
desktop_ui\drill_config.py:726:13: E1120: No value for argument 'keyboard_id' in constructor call (no-value-for-parameter)
desktop_ui\drill_config.py:718:4: C0412: Imports from package db are not grouped (ungrouped-imports)
************* Module AITypingTrainer.desktop_ui.drill_screen_tester
desktop_ui\drill_screen_tester.py:20:0: W0404: Reimport 'sys' (imported line 12) (reimported)
desktop_ui\drill_screen_tester.py:20:0: C0413: Import "import sys" should be placed at the top of the module (wrong-import-position)
desktop_ui\drill_screen_tester.py:22:0: C0413: Import "from PySide6 import QtWidgets" should be placed at the top of the module (wrong-import-position)
desktop_ui\drill_screen_tester.py:44:0: C0115: Missing class docstring (missing-class-docstring)
desktop_ui\drill_screen_tester.py:44:0: R0902: Too many instance attributes (12/7) (too-many-instance-attributes)
desktop_ui\drill_screen_tester.py:44:24: I1101: Module 'PySide6.QtWidgets' has no 'QWidget' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\drill_screen_tester.py:51:4: C0116: Missing function or method docstring (missing-function-docstring)
desktop_ui\drill_screen_tester.py:52:17: I1101: Module 'PySide6.QtWidgets' has no 'QVBoxLayout' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\drill_screen_tester.py:55:23: I1101: Module 'PySide6.QtWidgets' has no 'QHBoxLayout' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\drill_screen_tester.py:56:26: I1101: Module 'PySide6.QtWidgets' has no 'QRadioButton' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\drill_screen_tester.py:57:25: I1101: Module 'PySide6.QtWidgets' has no 'QRadioButton' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\drill_screen_tester.py:61:22: I1101: Module 'PySide6.QtWidgets' has no 'QButtonGroup' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\drill_screen_tester.py:69:29: I1101: Module 'PySide6.QtWidgets' has no 'QComboBox' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\drill_screen_tester.py:73:35: I1101: Module 'PySide6.QtWidgets' has no 'QTextEdit' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\drill_screen_tester.py:76:29: I1101: Module 'PySide6.QtWidgets' has no 'QLineEdit' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\drill_screen_tester.py:78:27: I1101: Module 'PySide6.QtWidgets' has no 'QLineEdit' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\drill_screen_tester.py:82:25: I1101: Module 'PySide6.QtWidgets' has no 'QVBoxLayout' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\drill_screen_tester.py:83:23: I1101: Module 'PySide6.QtWidgets' has no 'QHBoxLayout' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\drill_screen_tester.py:84:31: I1101: Module 'PySide6.QtWidgets' has no 'QLabel' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\drill_screen_tester.py:88:21: I1101: Module 'PySide6.QtWidgets' has no 'QHBoxLayout' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\drill_screen_tester.py:89:29: I1101: Module 'PySide6.QtWidgets' has no 'QLabel' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\drill_screen_tester.py:91:29: I1101: Module 'PySide6.QtWidgets' has no 'QLabel' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\drill_screen_tester.py:94:29: I1101: Module 'PySide6.QtWidgets' has no 'QWidget' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\drill_screen_tester.py:98:27: I1101: Module 'PySide6.QtWidgets' has no 'QTextEdit' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\drill_screen_tester.py:99:28: I1101: Module 'PySide6.QtWidgets' has no 'QWidget' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\drill_screen_tester.py:100:24: I1101: Module 'PySide6.QtWidgets' has no 'QVBoxLayout' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\drill_screen_tester.py:101:32: I1101: Module 'PySide6.QtWidgets' has no 'QLabel' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\drill_screen_tester.py:107:25: I1101: Module 'PySide6.QtWidgets' has no 'QHBoxLayout' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\drill_screen_tester.py:108:29: I1101: Module 'PySide6.QtWidgets' has no 'QLabel' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\drill_screen_tester.py:109:28: I1101: Module 'PySide6.QtWidgets' has no 'QTextEdit' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\drill_screen_tester.py:111:25: I1101: Module 'PySide6.QtWidgets' has no 'QPushButton' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\drill_screen_tester.py:51:4: R0915: Too many statements (62/50) (too-many-statements)
desktop_ui\drill_screen_tester.py:125:4: C0116: Missing function or method docstring (missing-function-docstring)
desktop_ui\drill_screen_tester.py:131:4: C0116: Missing function or method docstring (missing-function-docstring)
desktop_ui\drill_screen_tester.py:160:12: C0415: Import outside toplevel (desktop_ui.typing_drill.TypingDrillScreen) (import-outside-toplevel)
desktop_ui\drill_screen_tester.py:166:16: C0415: Import outside toplevel (typing_drill.TypingDrillScreen) (import-outside-toplevel)
desktop_ui\drill_screen_tester.py:168:12: W0621: Redefining name 'e' from outer scope (line 162) (redefined-outer-name)
desktop_ui\drill_screen_tester.py:209:15: W0718: Catching too general exception Exception (broad-exception-caught)
desktop_ui\drill_screen_tester.py:210:12: C0415: Import outside toplevel (traceback) (import-outside-toplevel)
desktop_ui\drill_screen_tester.py:152:4: R0915: Too many statements (52/50) (too-many-statements)
desktop_ui\drill_screen_tester.py:216:10: I1101: Module 'PySide6.QtWidgets' has no 'QApplication' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
************* Module AITypingTrainer.desktop_ui.graphql_client
desktop_ui\graphql_client.py:13:0: C0115: Missing class docstring (missing-class-docstring)
desktop_ui\graphql_client.py:17:4: C0116: Missing function or method docstring (missing-function-docstring)
desktop_ui\graphql_client.py:20:15: W3101: Missing timeout argument for method 'requests.post' can cause your program to hang indefinitely (missing-timeout)
desktop_ui\graphql_client.py:13:0: R0903: Too few public methods (1/2) (too-few-public-methods)
************* Module AITypingTrainer.desktop_ui.library_main
desktop_ui\library_main.py:98:0: C0301: Line too long (119/100) (line-too-long)
desktop_ui\library_main.py:131:0: C0301: Line too long (118/100) (line-too-long)
desktop_ui\library_main.py:165:0: C0301: Line too long (104/100) (line-too-long)
desktop_ui\library_main.py:216:0: C0301: Line too long (110/100) (line-too-long)
desktop_ui\library_main.py:12:0: E0611: No name 'Qt' in module 'PySide6.QtCore' (no-name-in-module)
desktop_ui\library_main.py:13:0: E0611: No name 'QFont' in module 'PySide6.QtGui' (no-name-in-module)
desktop_ui\library_main.py:13:0: E0611: No name 'QIcon' in module 'PySide6.QtGui' (no-name-in-module)
desktop_ui\library_main.py:14:0: E0611: No name 'QApplication' in module 'PySide6.QtWidgets' (no-name-in-module)
desktop_ui\library_main.py:14:0: E0611: No name 'QHBoxLayout' in module 'PySide6.QtWidgets' (no-name-in-module)
desktop_ui\library_main.py:14:0: E0611: No name 'QLabel' in module 'PySide6.QtWidgets' (no-name-in-module)
desktop_ui\library_main.py:14:0: E0611: No name 'QLineEdit' in module 'PySide6.QtWidgets' (no-name-in-module)
desktop_ui\library_main.py:14:0: E0611: No name 'QListWidget' in module 'PySide6.QtWidgets' (no-name-in-module)
desktop_ui\library_main.py:14:0: E0611: No name 'QListWidgetItem' in module 'PySide6.QtWidgets' (no-name-in-module)
desktop_ui\library_main.py:14:0: E0611: No name 'QMainWindow' in module 'PySide6.QtWidgets' (no-name-in-module)
desktop_ui\library_main.py:14:0: E0611: No name 'QMessageBox' in module 'PySide6.QtWidgets' (no-name-in-module)
desktop_ui\library_main.py:14:0: E0611: No name 'QPushButton' in module 'PySide6.QtWidgets' (no-name-in-module)
desktop_ui\library_main.py:14:0: E0611: No name 'QSizePolicy' in module 'PySide6.QtWidgets' (no-name-in-module)
desktop_ui\library_main.py:14:0: E0611: No name 'QSplitter' in module 'PySide6.QtWidgets' (no-name-in-module)
desktop_ui\library_main.py:14:0: E0611: No name 'QVBoxLayout' in module 'PySide6.QtWidgets' (no-name-in-module)
desktop_ui\library_main.py:14:0: E0611: No name 'QWidget' in module 'PySide6.QtWidgets' (no-name-in-module)
desktop_ui\library_main.py:30:0: E0401: Unable to import 'models.category' (import-error)
desktop_ui\library_main.py:31:0: E0401: Unable to import 'models.category_manager' (import-error)
desktop_ui\library_main.py:32:0: E0401: Unable to import 'models.library' (import-error)
desktop_ui\library_main.py:33:0: E0401: Unable to import 'models.snippet' (import-error)
desktop_ui\library_main.py:34:0: E0401: Unable to import 'models.snippet_manager' (import-error)
desktop_ui\library_main.py:96:8: C0103: Attribute name "categoryList" doesn't conform to snake_case naming style (invalid-name)
desktop_ui\library_main.py:102:8: C0103: Attribute name "addCatBtn" doesn't conform to snake_case naming style (invalid-name)
desktop_ui\library_main.py:103:8: C0103: Attribute name "editCatBtn" doesn't conform to snake_case naming style (invalid-name)
desktop_ui\library_main.py:104:8: C0103: Attribute name "delCatBtn" doesn't conform to snake_case naming style (invalid-name)
desktop_ui\library_main.py:129:8: C0103: Attribute name "snippetList" doesn't conform to snake_case naming style (invalid-name)
desktop_ui\library_main.py:135:8: C0103: Attribute name "addSnipBtn" doesn't conform to snake_case naming style (invalid-name)
desktop_ui\library_main.py:136:8: C0103: Attribute name "editSnipBtn" doesn't conform to snake_case naming style (invalid-name)
desktop_ui\library_main.py:137:8: C0103: Attribute name "delSnipBtn" doesn't conform to snake_case naming style (invalid-name)
desktop_ui\library_main.py:40:0: R0902: Too many instance attributes (20/7) (too-many-instance-attributes)
desktop_ui\library_main.py:98:40: I1101: Module 'PySide6.QtWidgets' has no 'QSizePolicy' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\library_main.py:98:80: I1101: Module 'PySide6.QtWidgets' has no 'QSizePolicy' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\library_main.py:131:39: I1101: Module 'PySide6.QtWidgets' has no 'QSizePolicy' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\library_main.py:131:79: I1101: Module 'PySide6.QtWidgets' has no 'QSizePolicy' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\library_main.py:77:4: R0915: Too many statements (77/50) (too-many-statements)
desktop_ui\library_main.py:195:15: W0718: Catching too general exception Exception (broad-exception-caught)
desktop_ui\library_main.py:198:4: C0116: Missing function or method docstring (missing-function-docstring)
desktop_ui\library_main.py:205:4: C0116: Missing function or method docstring (missing-function-docstring)
desktop_ui\library_main.py:212:4: C0116: Missing function or method docstring (missing-function-docstring)
desktop_ui\library_main.py:224:4: C0116: Missing function or method docstring (missing-function-docstring)
desktop_ui\library_main.py:231:4: C0116: Missing function or method docstring (missing-function-docstring)
desktop_ui\library_main.py:244:4: C0116: Missing function or method docstring (missing-function-docstring)
desktop_ui\library_main.py:249:4: C0116: Missing function or method docstring (missing-function-docstring)
desktop_ui\library_main.py:254:4: C0116: Missing function or method docstring (missing-function-docstring)
desktop_ui\library_main.py:266:15: W0718: Catching too general exception Exception (broad-exception-caught)
desktop_ui\library_main.py:269:4: C0116: Missing function or method docstring (missing-function-docstring)
desktop_ui\library_main.py:271:26: I1101: Module 'PySide6.QtWidgets' has no 'QDialog' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\library_main.py:279:19: W0718: Catching too general exception Exception (broad-exception-caught)
desktop_ui\library_main.py:282:4: C0116: Missing function or method docstring (missing-function-docstring)
desktop_ui\library_main.py:291:26: I1101: Module 'PySide6.QtWidgets' has no 'QDialog' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\library_main.py:299:19: W0718: Catching too general exception Exception (broad-exception-caught)
desktop_ui\library_main.py:302:4: C0116: Missing function or method docstring (missing-function-docstring)
desktop_ui\library_main.py:308:18: I1101: Module 'PySide6.QtWidgets' has no 'QMessageBox' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\library_main.py:312:12: I1101: Module 'PySide6.QtWidgets' has no 'QMessageBox' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\library_main.py:312:55: I1101: Module 'PySide6.QtWidgets' has no 'QMessageBox' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\library_main.py:314:22: I1101: Module 'PySide6.QtWidgets' has no 'QMessageBox' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\library_main.py:322:15: W0718: Catching too general exception Exception (broad-exception-caught)
desktop_ui\library_main.py:325:4: C0116: Missing function or method docstring (missing-function-docstring)
desktop_ui\library_main.py:330:26: I1101: Module 'PySide6.QtWidgets' has no 'QDialog' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\library_main.py:343:19: W0718: Catching too general exception Exception (broad-exception-caught)
desktop_ui\library_main.py:346:4: C0116: Missing function or method docstring (missing-function-docstring)
desktop_ui\library_main.py:360:26: I1101: Module 'PySide6.QtWidgets' has no 'QDialog' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\library_main.py:368:19: W0718: Catching too general exception Exception (broad-exception-caught)
desktop_ui\library_main.py:371:4: C0116: Missing function or method docstring (missing-function-docstring)
desktop_ui\library_main.py:377:18: I1101: Module 'PySide6.QtWidgets' has no 'QMessageBox' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\library_main.py:381:12: I1101: Module 'PySide6.QtWidgets' has no 'QMessageBox' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\library_main.py:381:55: I1101: Module 'PySide6.QtWidgets' has no 'QMessageBox' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\library_main.py:383:22: I1101: Module 'PySide6.QtWidgets' has no 'QMessageBox' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\library_main.py:389:15: W0718: Catching too general exception Exception (broad-exception-caught)
desktop_ui\library_main.py:392:4: C0116: Missing function or method docstring (missing-function-docstring)
desktop_ui\library_main.py:14:0: W0611: Unused QSizePolicy imported from PySide6.QtWidgets (unused-import)
************* Module AITypingTrainer.desktop_ui.main_menu
desktop_ui\main_menu.py:33:0: C0301: Line too long (136/100) (line-too-long)
desktop_ui\main_menu.py:289:0: C0327: Mixed line endings LF and CRLF (mixed-line-endings)
desktop_ui\main_menu.py:1:0: C0114: Missing module docstring (missing-module-docstring)
desktop_ui\main_menu.py:9:0: C0413: Import "from PySide6 import QtCore, QtWidgets" should be placed at the top of the module (wrong-import-position)
desktop_ui\main_menu.py:11:0: E0401: Unable to import 'db.database_manager' (import-error)
desktop_ui\main_menu.py:11:0: C0413: Import "from db.database_manager import DatabaseManager, ConnectionType" should be placed at the top of the module (wrong-import-position)
desktop_ui\main_menu.py:12:0: E0401: Unable to import 'desktop_ui.users_and_keyboards' (import-error)
desktop_ui\main_menu.py:12:0: C0413: Import "from desktop_ui.users_and_keyboards import UsersAndKeyboards" should be placed at the top of the module (wrong-import-position)
desktop_ui\main_menu.py:13:0: E0401: Unable to import 'models.keyboard' (import-error)
desktop_ui\main_menu.py:13:0: C0413: Import "from models.keyboard import Keyboard" should be placed at the top of the module (wrong-import-position)
desktop_ui\main_menu.py:14:0: E0401: Unable to import 'models.keyboard_manager' (import-error)
desktop_ui\main_menu.py:14:0: C0413: Import "from models.keyboard_manager import KeyboardManager" should be placed at the top of the module (wrong-import-position)
desktop_ui\main_menu.py:15:0: E0401: Unable to import 'models.setting' (import-error)
desktop_ui\main_menu.py:15:0: C0413: Import "from models.setting import Setting" should be placed at the top of the module (wrong-import-position)
desktop_ui\main_menu.py:16:0: E0401: Unable to import 'models.setting_manager' (import-error)
desktop_ui\main_menu.py:16:0: C0413: Import "from models.setting_manager import SettingManager" should be placed at the top of the module (wrong-import-position)
desktop_ui\main_menu.py:17:0: E0401: Unable to import 'models.user' (import-error)
desktop_ui\main_menu.py:17:0: C0413: Import "from models.user import User" should be placed at the top of the module (wrong-import-position)
desktop_ui\main_menu.py:18:0: E0401: Unable to import 'models.user_manager' (import-error)
desktop_ui\main_menu.py:18:0: C0413: Import "from models.user_manager import UserManager" should be placed at the top of the module (wrong-import-position)
desktop_ui\main_menu.py:23:0: R0902: Too many instance attributes (12/7) (too-many-instance-attributes)
desktop_ui\main_menu.py:23:15: I1101: Module 'PySide6.QtWidgets' has no 'QWidget' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\main_menu.py:56:4: C0116: Missing function or method docstring (missing-function-docstring)
desktop_ui\main_menu.py:57:17: I1101: Module 'PySide6.QtWidgets' has no 'QApplication' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\main_menu.py:65:4: C0116: Missing function or method docstring (missing-function-docstring)
desktop_ui\main_menu.py:66:17: I1101: Module 'PySide6.QtWidgets' has no 'QVBoxLayout' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\main_menu.py:67:17: I1101: Module 'PySide6.QtWidgets' has no 'QLabel' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\main_menu.py:69:28: I1101: Module 'PySide6.QtCore' has no 'Qt' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\main_menu.py:93:18: I1101: Module 'PySide6.QtWidgets' has no 'QPushButton' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\main_menu.py:104:4: C0116: Missing function or method docstring (missing-function-docstring)
desktop_ui\main_menu.py:105:8: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
desktop_ui\main_menu.py:117:4: C0116: Missing function or method docstring (missing-function-docstring)
desktop_ui\main_menu.py:117:4: C0103: Method name "eventFilter" doesn't conform to snake_case naming style (invalid-name)
desktop_ui\main_menu.py:117:31: I1101: Module 'PySide6.QtCore' has no 'QObject' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\main_menu.py:117:54: I1101: Module 'PySide6.QtCore' has no 'QEvent' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\main_menu.py:118:27: I1101: Module 'PySide6.QtWidgets' has no 'QPushButton' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\main_menu.py:119:31: I1101: Module 'PySide6.QtCore' has no 'QEvent' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\main_menu.py:121:33: I1101: Module 'PySide6.QtCore' has no 'QEvent' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\main_menu.py:137:15: W0718: Catching too general exception Exception (broad-exception-caught)
desktop_ui\main_menu.py:131:12: E0401: Unable to import 'desktop_ui.library_main' (import-error)
desktop_ui\main_menu.py:131:12: C0415: Import outside toplevel (desktop_ui.library_main.LibraryMainWindow) (import-outside-toplevel)
desktop_ui\main_menu.py:138:12: I1101: Module 'PySide6.QtWidgets' has no 'QMessageBox' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\main_menu.py:142:59: I1101: Module 'PySide6.QtWidgets' has no 'QLayout' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\main_menu.py:147:21: I1101: Module 'PySide6.QtWidgets' has no 'QGroupBox' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\main_menu.py:148:22: I1101: Module 'PySide6.QtWidgets' has no 'QFormLayout' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\main_menu.py:151:26: I1101: Module 'PySide6.QtWidgets' has no 'QComboBox' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\main_menu.py:156:30: I1101: Module 'PySide6.QtWidgets' has no 'QComboBox' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\main_menu.py:186:15: W0718: Catching too general exception Exception (broad-exception-caught)
desktop_ui\main_menu.py:183:16: I1101: Module 'PySide6.QtWidgets' has no 'QMessageBox' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\main_menu.py:187:12: I1101: Module 'PySide6.QtWidgets' has no 'QMessageBox' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\main_menu.py:231:19: W0718: Catching too general exception Exception (broad-exception-caught)
desktop_ui\main_menu.py:237:8: E0401: Unable to import 'models.setting_manager' (import-error)
desktop_ui\main_menu.py:237:8: C0415: Import outside toplevel (models.setting_manager.SettingNotFound) (import-outside-toplevel)
desktop_ui\main_menu.py:258:15: W0718: Catching too general exception Exception (broad-exception-caught)
desktop_ui\main_menu.py:283:15: W0718: Catching too general exception Exception (broad-exception-caught)
desktop_ui\main_menu.py:275:16: I1101: Module 'PySide6.QtWidgets' has no 'QMessageBox' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\main_menu.py:284:12: I1101: Module 'PySide6.QtWidgets' has no 'QMessageBox' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\main_menu.py:294:12: I1101: Module 'PySide6.QtWidgets' has no 'QMessageBox' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\main_menu.py:299:12: I1101: Module 'PySide6.QtWidgets' has no 'QMessageBox' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\main_menu.py:307:12: I1101: Module 'PySide6.QtWidgets' has no 'QMessageBox' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\main_menu.py:313:8: E0401: Unable to import 'desktop_ui.drill_config' (import-error)
desktop_ui\main_menu.py:313:8: C0415: Import outside toplevel (desktop_ui.drill_config.DrillConfigDialog) (import-outside-toplevel)
desktop_ui\main_menu.py:325:12: I1101: Module 'PySide6.QtWidgets' has no 'QMessageBox' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\main_menu.py:330:12: I1101: Module 'PySide6.QtWidgets' has no 'QMessageBox' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\main_menu.py:336:12: I1101: Module 'PySide6.QtWidgets' has no 'QMessageBox' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\main_menu.py:350:15: W0718: Catching too general exception Exception (broad-exception-caught)
desktop_ui\main_menu.py:341:12: E0401: Unable to import 'desktop_ui.dynamic_config' (import-error)
desktop_ui\main_menu.py:341:12: C0415: Import outside toplevel (desktop_ui.dynamic_config.DynamicConfigDialog) (import-outside-toplevel)
desktop_ui\main_menu.py:351:12: I1101: Module 'PySide6.QtWidgets' has no 'QMessageBox' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\main_menu.py:355:4: C0116: Missing function or method docstring (missing-function-docstring)
desktop_ui\main_menu.py:356:8: I1101: Module 'PySide6.QtWidgets' has no 'QMessageBox' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\main_menu.py:360:4: C0116: Missing function or method docstring (missing-function-docstring)
desktop_ui\main_menu.py:361:8: I1101: Module 'PySide6.QtWidgets' has no 'QMessageBox' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\main_menu.py:375:18: I1101: Module 'PySide6.QtWidgets' has no 'QMessageBox' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\main_menu.py:379:12: I1101: Module 'PySide6.QtWidgets' has no 'QMessageBox' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\main_menu.py:379:55: I1101: Module 'PySide6.QtWidgets' has no 'QMessageBox' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\main_menu.py:380:12: I1101: Module 'PySide6.QtWidgets' has no 'QMessageBox' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\main_menu.py:383:22: I1101: Module 'PySide6.QtWidgets' has no 'QMessageBox' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\main_menu.py:399:15: W0718: Catching too general exception Exception (broad-exception-caught)
desktop_ui\main_menu.py:387:12: E0401: Unable to import 'models.session_manager' (import-error)
desktop_ui\main_menu.py:387:12: C0415: Import outside toplevel (models.session_manager.SessionManager) (import-outside-toplevel)
desktop_ui\main_menu.py:392:16: I1101: Module 'PySide6.QtWidgets' has no 'QMessageBox' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\main_menu.py:396:16: I1101: Module 'PySide6.QtWidgets' has no 'QMessageBox' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\main_menu.py:400:12: I1101: Module 'PySide6.QtWidgets' has no 'QMessageBox' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\main_menu.py:422:15: W0718: Catching too general exception Exception (broad-exception-caught)
desktop_ui\main_menu.py:409:12: C0415: Import outside toplevel (desktop_ui.db_viewer_dialog.DatabaseViewerDialog) (import-outside-toplevel)
desktop_ui\main_menu.py:410:12: C0415: Import outside toplevel (services.database_viewer_service.DatabaseViewerService) (import-outside-toplevel)
desktop_ui\main_menu.py:416:12: I1101: Module 'PySide6.QtWidgets' has no 'QMessageBox' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\main_menu.py:423:12: I1101: Module 'PySide6.QtWidgets' has no 'QMessageBox' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\main_menu.py:450:15: W0718: Catching too general exception Exception (broad-exception-caught)
desktop_ui\main_menu.py:432:12: C0415: Import outside toplevel (desktop_ui.query_screen.QueryScreen) (import-outside-toplevel)
desktop_ui\main_menu.py:447:12: I1101: Module 'PySide6.QtWidgets' has no 'QMessageBox' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\main_menu.py:451:12: I1101: Module 'PySide6.QtWidgets' has no 'QMessageBox' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\main_menu.py:478:15: W0718: Catching too general exception Exception (broad-exception-caught)
desktop_ui\main_menu.py:463:32: I1101: Module 'PySide6.QtWidgets' has no 'QDialog' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\main_menu.py:479:12: I1101: Module 'PySide6.QtWidgets' has no 'QMessageBox' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\main_menu.py:485:8: I1101: Module 'PySide6.QtWidgets' has no 'QApplication' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\main_menu.py:133:12: W0201: Attribute 'library_ui' defined outside __init__ (attribute-defined-outside-init)
desktop_ui\main_menu.py:151:8: W0201: Attribute 'user_combo' defined outside __init__ (attribute-defined-outside-init)
desktop_ui\main_menu.py:156:8: W0201: Attribute 'keyboard_combo' defined outside __init__ (attribute-defined-outside-init)
desktop_ui\main_menu.py:495:10: I1101: Module 'PySide6.QtWidgets' has no 'QApplication' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
************* Module AITypingTrainer.desktop_ui.modern_dialogs
desktop_ui\modern_dialogs.py:12:10: I1101: Module 'PySide6.QtWidgets' has no 'QDialog' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\modern_dialogs.py:13:14: I1101: Module 'PySide6.QtWidgets' has no 'QVBoxLayout' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\modern_dialogs.py:14:14: I1101: Module 'PySide6.QtWidgets' has no 'QHBoxLayout' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\modern_dialogs.py:15:9: I1101: Module 'PySide6.QtWidgets' has no 'QLabel' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\modern_dialogs.py:16:12: I1101: Module 'PySide6.QtWidgets' has no 'QLineEdit' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\modern_dialogs.py:17:12: I1101: Module 'PySide6.QtWidgets' has no 'QTextEdit' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\modern_dialogs.py:18:14: I1101: Module 'PySide6.QtWidgets' has no 'QPushButton' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\modern_dialogs.py:19:10: I1101: Module 'PySide6.QtWidgets' has no 'QWidget' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\modern_dialogs.py:23:5: I1101: Module 'PySide6.QtCore' has no 'Qt' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\modern_dialogs.py:24:16: I1101: Module 'PySide6.QtCore' has no 'Qt' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\modern_dialogs.py:25:8: I1101: Module 'PySide6.QtGui' has no 'QIcon' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\modern_dialogs.py:26:8: I1101: Module 'PySide6.QtGui' has no 'QFont' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\modern_dialogs.py:29:0: C0115: Missing class docstring (missing-class-docstring)
desktop_ui\modern_dialogs.py:49:8: C0103: Attribute name "okBtn" doesn't conform to snake_case naming style (invalid-name)
desktop_ui\modern_dialogs.py:50:8: C0103: Attribute name "cancelBtn" doesn't conform to snake_case naming style (invalid-name)
desktop_ui\modern_dialogs.py:53:26: I1101: Module 'PySide6.QtCore' has no 'Qt' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\modern_dialogs.py:62:4: C0116: Missing function or method docstring (missing-function-docstring)
desktop_ui\modern_dialogs.py:29:0: R0903: Too few public methods (1/2) (too-few-public-methods)
desktop_ui\modern_dialogs.py:66:0: C0115: Missing class docstring (missing-class-docstring)
desktop_ui\modern_dialogs.py:94:8: C0103: Attribute name "okBtn" doesn't conform to snake_case naming style (invalid-name)
desktop_ui\modern_dialogs.py:95:8: C0103: Attribute name "cancelBtn" doesn't conform to snake_case naming style (invalid-name)
desktop_ui\modern_dialogs.py:67:4: R0913: Too many arguments (7/5) (too-many-arguments)
desktop_ui\modern_dialogs.py:67:4: R0917: Too many positional arguments (7/5) (too-many-positional-arguments)
desktop_ui\modern_dialogs.py:98:26: I1101: Module 'PySide6.QtCore' has no 'Qt' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\modern_dialogs.py:107:4: C0116: Missing function or method docstring (missing-function-docstring)
desktop_ui\modern_dialogs.py:66:0: R0903: Too few public methods (1/2) (too-few-public-methods)
************* Module AITypingTrainer.desktop_ui.ngram_llm_screen
desktop_ui\ngram_llm_screen.py:1:0: C0114: Missing module docstring (missing-module-docstring)
desktop_ui\ngram_llm_screen.py:5:0: E0611: No name 'QApplication' in module 'PySide6.QtWidgets' (no-name-in-module)
desktop_ui\ngram_llm_screen.py:5:0: E0611: No name 'QHBoxLayout' in module 'PySide6.QtWidgets' (no-name-in-module)
desktop_ui\ngram_llm_screen.py:5:0: E0611: No name 'QInputDialog' in module 'PySide6.QtWidgets' (no-name-in-module)
desktop_ui\ngram_llm_screen.py:5:0: E0611: No name 'QLabel' in module 'PySide6.QtWidgets' (no-name-in-module)
desktop_ui\ngram_llm_screen.py:5:0: E0611: No name 'QLineEdit' in module 'PySide6.QtWidgets' (no-name-in-module)
desktop_ui\ngram_llm_screen.py:5:0: E0611: No name 'QMessageBox' in module 'PySide6.QtWidgets' (no-name-in-module)
desktop_ui\ngram_llm_screen.py:5:0: E0611: No name 'QPushButton' in module 'PySide6.QtWidgets' (no-name-in-module)
desktop_ui\ngram_llm_screen.py:5:0: E0611: No name 'QTextEdit' in module 'PySide6.QtWidgets' (no-name-in-module)
desktop_ui\ngram_llm_screen.py:5:0: E0611: No name 'QVBoxLayout' in module 'PySide6.QtWidgets' (no-name-in-module)
desktop_ui\ngram_llm_screen.py:5:0: E0611: No name 'QWidget' in module 'PySide6.QtWidgets' (no-name-in-module)
desktop_ui\ngram_llm_screen.py:18:0: E0401: Unable to import 'models.llm_ngram_service' (import-error)
desktop_ui\ngram_llm_screen.py:21:0: C0115: Missing class docstring (missing-class-docstring)
desktop_ui\ngram_llm_screen.py:38:19: W0718: Catching too general exception Exception (broad-exception-caught)
desktop_ui\ngram_llm_screen.py:34:21: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
desktop_ui\ngram_llm_screen.py:63:4: C0116: Missing function or method docstring (missing-function-docstring)
desktop_ui\ngram_llm_screen.py:92:4: C0116: Missing function or method docstring (missing-function-docstring)
desktop_ui\ngram_llm_screen.py:104:4: C0116: Missing function or method docstring (missing-function-docstring)
desktop_ui\ngram_llm_screen.py:115:4: C0116: Missing function or method docstring (missing-function-docstring)
desktop_ui\ngram_llm_screen.py:132:15: W0718: Catching too general exception Exception (broad-exception-caught)
************* Module AITypingTrainer.desktop_ui.query_screen
desktop_ui\query_screen.py:44:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\query_screen.py:56:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\query_screen.py:60:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\query_screen.py:64:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\query_screen.py:67:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\query_screen.py:76:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\query_screen.py:85:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\query_screen.py:87:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\query_screen.py:91:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\query_screen.py:96:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\query_screen.py:104:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\query_screen.py:108:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\query_screen.py:111:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\query_screen.py:116:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\query_screen.py:118:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\query_screen.py:122:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\query_screen.py:124:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\query_screen.py:128:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\query_screen.py:132:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\query_screen.py:136:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\query_screen.py:142:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\query_screen.py:146:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\query_screen.py:149:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\query_screen.py:163:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\query_screen.py:166:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\query_screen.py:173:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\query_screen.py:175:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\query_screen.py:185:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\query_screen.py:188:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\query_screen.py:193:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\query_screen.py:200:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\query_screen.py:203:0: C0303: Trailing whitespace (trailing-whitespace)
desktop_ui\query_screen.py:10:0: E0611: No name 'QDialog' in module 'PySide6.QtWidgets' (no-name-in-module)
desktop_ui\query_screen.py:10:0: E0611: No name 'QGridLayout' in module 'PySide6.QtWidgets' (no-name-in-module)
desktop_ui\query_screen.py:10:0: E0611: No name 'QHBoxLayout' in module 'PySide6.QtWidgets' (no-name-in-module)
desktop_ui\query_screen.py:10:0: E0611: No name 'QHeaderView' in module 'PySide6.QtWidgets' (no-name-in-module)
desktop_ui\query_screen.py:10:0: E0611: No name 'QLabel' in module 'PySide6.QtWidgets' (no-name-in-module)
desktop_ui\query_screen.py:10:0: E0611: No name 'QLineEdit' in module 'PySide6.QtWidgets' (no-name-in-module)
desktop_ui\query_screen.py:10:0: E0611: No name 'QMessageBox' in module 'PySide6.QtWidgets' (no-name-in-module)
desktop_ui\query_screen.py:10:0: E0611: No name 'QPushButton' in module 'PySide6.QtWidgets' (no-name-in-module)
desktop_ui\query_screen.py:10:0: E0611: No name 'QPlainTextEdit' in module 'PySide6.QtWidgets' (no-name-in-module)
desktop_ui\query_screen.py:10:0: E0611: No name 'QTableWidget' in module 'PySide6.QtWidgets' (no-name-in-module)
desktop_ui\query_screen.py:10:0: E0611: No name 'QTableWidgetItem' in module 'PySide6.QtWidgets' (no-name-in-module)
desktop_ui\query_screen.py:10:0: E0611: No name 'QVBoxLayout' in module 'PySide6.QtWidgets' (no-name-in-module)
desktop_ui\query_screen.py:25:0: E0401: Unable to import 'db.database_manager' (import-error)
desktop_ui\query_screen.py:28:0: R0902: Too many instance attributes (9/7) (too-many-instance-attributes)
desktop_ui\query_screen.py:50:25: I1101: Module 'PySide6.QtWidgets' has no 'QWidget' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\query_screen.py:110:43: I1101: Module 'PySide6.QtWidgets' has no 'QAbstractItemView' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\query_screen.py:147:15: W0718: Catching too general exception Exception (broad-exception-caught)
************* Module AITypingTrainer.desktop_ui.snippet_model_tester
desktop_ui\snippet_model_tester.py:4:0: C0301: Line too long (111/100) (line-too-long)
desktop_ui\snippet_model_tester.py:12:0: C0301: Line too long (107/100) (line-too-long)
desktop_ui\snippet_model_tester.py:119:0: C0301: Line too long (147/100) (line-too-long)
desktop_ui\snippet_model_tester.py:21:0: E0611: No name 'QApplication' in module 'PySide6.QtWidgets' (no-name-in-module)
desktop_ui\snippet_model_tester.py:21:0: E0611: No name 'QComboBox' in module 'PySide6.QtWidgets' (no-name-in-module)
desktop_ui\snippet_model_tester.py:21:0: E0611: No name 'QHBoxLayout' in module 'PySide6.QtWidgets' (no-name-in-module)
desktop_ui\snippet_model_tester.py:21:0: E0611: No name 'QInputDialog' in module 'PySide6.QtWidgets' (no-name-in-module)
desktop_ui\snippet_model_tester.py:21:0: E0611: No name 'QLabel' in module 'PySide6.QtWidgets' (no-name-in-module)
desktop_ui\snippet_model_tester.py:21:0: E0611: No name 'QListWidget' in module 'PySide6.QtWidgets' (no-name-in-module)
desktop_ui\snippet_model_tester.py:21:0: E0611: No name 'QMessageBox' in module 'PySide6.QtWidgets' (no-name-in-module)
desktop_ui\snippet_model_tester.py:21:0: E0611: No name 'QPushButton' in module 'PySide6.QtWidgets' (no-name-in-module)
desktop_ui\snippet_model_tester.py:21:0: E0611: No name 'QVBoxLayout' in module 'PySide6.QtWidgets' (no-name-in-module)
desktop_ui\snippet_model_tester.py:21:0: E0611: No name 'QWidget' in module 'PySide6.QtWidgets' (no-name-in-module)
desktop_ui\snippet_model_tester.py:35:0: E0401: Unable to import 'db.database_manager' (import-error)
desktop_ui\snippet_model_tester.py:35:0: C0413: Import "from db.database_manager import DatabaseManager" should be placed at the top of the module (wrong-import-position)
desktop_ui\snippet_model_tester.py:36:0: E0401: Unable to import 'models.category' (import-error)
desktop_ui\snippet_model_tester.py:36:0: C0413: Import "from models.category import CategoryManager" should be placed at the top of the module (wrong-import-position)
desktop_ui\snippet_model_tester.py:37:0: E0401: Unable to import 'models.snippet' (import-error)
desktop_ui\snippet_model_tester.py:37:0: C0413: Import "from models.snippet import SnippetManager" should be placed at the top of the module (wrong-import-position)
desktop_ui\snippet_model_tester.py:42:0: R0902: Too many instance attributes (10/7) (too-many-instance-attributes)
desktop_ui\snippet_model_tester.py:60:4: C0116: Missing function or method docstring (missing-function-docstring)
desktop_ui\snippet_model_tester.py:96:4: C0116: Missing function or method docstring (missing-function-docstring)
desktop_ui\snippet_model_tester.py:107:15: W0718: Catching too general exception Exception (broad-exception-caught)
desktop_ui\snippet_model_tester.py:111:4: C0116: Missing function or method docstring (missing-function-docstring)
desktop_ui\snippet_model_tester.py:121:15: W0718: Catching too general exception Exception (broad-exception-caught)
desktop_ui\snippet_model_tester.py:124:4: C0116: Missing function or method docstring (missing-function-docstring)
desktop_ui\snippet_model_tester.py:127:4: C0116: Missing function or method docstring (missing-function-docstring)
desktop_ui\snippet_model_tester.py:153:15: W0718: Catching too general exception Exception (broad-exception-caught)
desktop_ui\snippet_model_tester.py:156:4: C0116: Missing function or method docstring (missing-function-docstring)
desktop_ui\snippet_model_tester.py:164:15: W0718: Catching too general exception Exception (broad-exception-caught)
desktop_ui\snippet_model_tester.py:168:4: C0116: Missing function or method docstring (missing-function-docstring)
desktop_ui\snippet_model_tester.py:174:15: W0718: Catching too general exception Exception (broad-exception-caught)
desktop_ui\snippet_model_tester.py:208:15: W0718: Catching too general exception Exception (broad-exception-caught)
desktop_ui\snippet_model_tester.py:211:4: C0116: Missing function or method docstring (missing-function-docstring)
desktop_ui\snippet_model_tester.py:227:19: W0718: Catching too general exception Exception (broad-exception-caught)
desktop_ui\snippet_model_tester.py:230:4: C0116: Missing function or method docstring (missing-function-docstring)
desktop_ui\snippet_model_tester.py:238:0: C0116: Missing function or method docstring (missing-function-docstring)
************* Module AITypingTrainer.desktop_ui.snippet_scaffold
desktop_ui\snippet_scaffold.py:12:0: R0902: Too many instance attributes (8/7) (too-many-instance-attributes)
desktop_ui\snippet_scaffold.py:12:22: I1101: Module 'PySide6.QtWidgets' has no 'QMainWindow' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\snippet_scaffold.py:20:23: W0621: Redefining name 'snippet_manager' from outer scope (line 336) (redefined-outer-name)
desktop_ui\snippet_scaffold.py:30:25: I1101: Module 'PySide6.QtWidgets' has no 'QWidget' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\snippet_scaffold.py:32:17: I1101: Module 'PySide6.QtWidgets' has no 'QVBoxLayout' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\snippet_scaffold.py:35:22: I1101: Module 'PySide6.QtWidgets' has no 'QLabel' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\snippet_scaffold.py:43:22: I1101: Module 'PySide6.QtWidgets' has no 'QHBoxLayout' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\snippet_scaffold.py:44:21: I1101: Module 'PySide6.QtWidgets' has no 'QLabel' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\snippet_scaffold.py:51:27: I1101: Module 'PySide6.QtWidgets' has no 'QPushButton' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\snippet_scaffold.py:53:38: I1101: Module 'PySide6.QtWidgets' has no 'QStyle' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\snippet_scaffold.py:59:28: I1101: Module 'PySide6.QtWidgets' has no 'QListWidget' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\snippet_scaffold.py:68:26: I1101: Module 'PySide6.QtWidgets' has no 'QLineEdit' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\snippet_scaffold.py:72:29: I1101: Module 'PySide6.QtWidgets' has no 'QTextEdit' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\snippet_scaffold.py:76:21: I1101: Module 'PySide6.QtWidgets' has no 'QHBoxLayout' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\snippet_scaffold.py:77:23: I1101: Module 'PySide6.QtWidgets' has no 'QPushButton' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\snippet_scaffold.py:78:24: I1101: Module 'PySide6.QtWidgets' has no 'QPushButton' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\snippet_scaffold.py:79:26: I1101: Module 'PySide6.QtWidgets' has no 'QPushButton' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\snippet_scaffold.py:105:8: I1101: Module 'PySide6.QtWidgets' has no 'QApplication' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\snippet_scaffold.py:118:23: I1101: Module 'PySide6.QtWidgets' has no 'QListWidgetItem' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\snippet_scaffold.py:123:29: I1101: Module 'PySide6.QtCore' has no 'Qt' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\snippet_scaffold.py:131:25: I1101: Module 'PySide6.QtWidgets' has no 'QListWidgetItem' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\snippet_scaffold.py:132:37: I1101: Module 'PySide6.QtCore' has no 'Qt' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\snippet_scaffold.py:133:54: I1101: Module 'PySide6.QtCore' has no 'Qt' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\snippet_scaffold.py:140:25: I1101: Module 'PySide6.QtWidgets' has no 'QListWidgetItem' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\snippet_scaffold.py:141:37: I1101: Module 'PySide6.QtCore' has no 'Qt' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\snippet_scaffold.py:142:54: I1101: Module 'PySide6.QtCore' has no 'Qt' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\snippet_scaffold.py:151:34: I1101: Module 'PySide6.QtCore' has no 'Qt' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\snippet_scaffold.py:165:12: I1101: Module 'PySide6.QtWidgets' has no 'QMessageBox' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\snippet_scaffold.py:171:12: I1101: Module 'PySide6.QtWidgets' has no 'QMessageBox' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\snippet_scaffold.py:183:12: I1101: Module 'PySide6.QtWidgets' has no 'QMessageBox' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\snippet_scaffold.py:189:12: I1101: Module 'PySide6.QtWidgets' has no 'QMessageBox' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\snippet_scaffold.py:191:12: I1101: Module 'PySide6.QtWidgets' has no 'QMessageBox' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\snippet_scaffold.py:200:12: I1101: Module 'PySide6.QtWidgets' has no 'QMessageBox' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\snippet_scaffold.py:204:31: I1101: Module 'PySide6.QtCore' has no 'Qt' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\snippet_scaffold.py:209:16: I1101: Module 'PySide6.QtWidgets' has no 'QMessageBox' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\snippet_scaffold.py:218:12: I1101: Module 'PySide6.QtWidgets' has no 'QMessageBox' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\snippet_scaffold.py:230:12: I1101: Module 'PySide6.QtWidgets' has no 'QMessageBox' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\snippet_scaffold.py:232:12: I1101: Module 'PySide6.QtWidgets' has no 'QMessageBox' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\snippet_scaffold.py:241:12: I1101: Module 'PySide6.QtWidgets' has no 'QMessageBox' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\snippet_scaffold.py:245:31: I1101: Module 'PySide6.QtCore' has no 'Qt' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\snippet_scaffold.py:250:16: I1101: Module 'PySide6.QtWidgets' has no 'QMessageBox' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\snippet_scaffold.py:256:18: I1101: Module 'PySide6.QtWidgets' has no 'QMessageBox' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\snippet_scaffold.py:260:12: I1101: Module 'PySide6.QtWidgets' has no 'QMessageBox' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\snippet_scaffold.py:260:40: I1101: Module 'PySide6.QtWidgets' has no 'QMessageBox' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\snippet_scaffold.py:263:22: I1101: Module 'PySide6.QtWidgets' has no 'QMessageBox' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\snippet_scaffold.py:269:16: I1101: Module 'PySide6.QtWidgets' has no 'QMessageBox' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\snippet_scaffold.py:271:16: I1101: Module 'PySide6.QtWidgets' has no 'QMessageBox' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\snippet_scaffold.py:273:42: I1101: Module 'PySide6.QtWidgets' has no 'QListWidgetItem' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\snippet_scaffold.py:284:31: I1101: Module 'PySide6.QtCore' has no 'Qt' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\snippet_scaffold.py:289:16: I1101: Module 'PySide6.QtWidgets' has no 'QMessageBox' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\snippet_scaffold.py:308:15: W0718: Catching too general exception Exception (broad-exception-caught)
desktop_ui\snippet_scaffold.py:303:16: I1101: Module 'PySide6.QtWidgets' has no 'QMessageBox' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\snippet_scaffold.py:307:12: I1101: Module 'PySide6.QtWidgets' has no 'QMessageBox' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\snippet_scaffold.py:309:12: I1101: Module 'PySide6.QtWidgets' has no 'QMessageBox' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\snippet_scaffold.py:321:4: E0401: Unable to import 'db.database_manager' (import-error)
desktop_ui\snippet_scaffold.py:322:4: E0401: Unable to import 'models.snippet' (import-error)
desktop_ui\snippet_scaffold.py:325:10: I1101: Module 'PySide6.QtWidgets' has no 'QApplication' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\snippet_scaffold.py:345:11: W0718: Catching too general exception Exception (broad-exception-caught)
************* Module AITypingTrainer.desktop_ui.splash
desktop_ui\splash.py:183:0: C0301: Line too long (118/100) (line-too-long)
desktop_ui\splash.py:15:0: E0611: No name 'Qt' in module 'PySide6.QtCore' (no-name-in-module)
desktop_ui\splash.py:15:0: E0611: No name 'QTimer' in module 'PySide6.QtCore' (no-name-in-module)
desktop_ui\splash.py:16:0: E0611: No name 'QApplication' in module 'PySide6.QtWidgets' (no-name-in-module)
desktop_ui\splash.py:16:0: E0611: No name 'QLabel' in module 'PySide6.QtWidgets' (no-name-in-module)
desktop_ui\splash.py:16:0: E0611: No name 'QMessageBox' in module 'PySide6.QtWidgets' (no-name-in-module)
desktop_ui\splash.py:16:0: E0611: No name 'QVBoxLayout' in module 'PySide6.QtWidgets' (no-name-in-module)
desktop_ui\splash.py:16:0: E0611: No name 'QWidget' in module 'PySide6.QtWidgets' (no-name-in-module)
desktop_ui\splash.py:30:0: C0115: Missing class docstring (missing-class-docstring)
desktop_ui\splash.py:39:0: R0902: Too many instance attributes (8/7) (too-many-instance-attributes)
desktop_ui\splash.py:116:12: C0415: Import outside toplevel (time) (import-outside-toplevel)
desktop_ui\splash.py:132:15: W0718: Catching too general exception Exception (broad-exception-caught)
desktop_ui\splash.py:156:29: E0602: Undefined variable 'GraphQLServerThread' (undefined-variable)
desktop_ui\splash.py:192:19: W0718: Catching too general exception Exception (broad-exception-caught)
desktop_ui\splash.py:200:19: W0718: Catching too general exception Exception (broad-exception-caught)
desktop_ui\splash.py:211:19: W0718: Catching too general exception Exception (broad-exception-caught)
desktop_ui\splash.py:121:8: W0201: Attribute 'retries' defined outside __init__ (attribute-defined-outside-init)
desktop_ui\splash.py:146:20: W0201: Attribute 'retries' defined outside __init__ (attribute-defined-outside-init)
desktop_ui\splash.py:162:8: W0201: Attribute 'retries' defined outside __init__ (attribute-defined-outside-init)
desktop_ui\splash.py:156:8: W0201: Attribute 'server_thread' defined outside __init__ (attribute-defined-outside-init)
desktop_ui\splash.py:39:0: R0903: Too few public methods (1/2) (too-few-public-methods)
desktop_ui\splash.py:235:7: W0212: Access to a protected member _api_server_manager of a client class (protected-access)
desktop_ui\splash.py:236:8: W0212: Access to a protected member _api_server_manager of a client class (protected-access)
desktop_ui\splash.py:238:11: W0212: Access to a protected member _api_server_manager of a client class (protected-access)
************* Module AITypingTrainer.desktop_ui.typing_drill
desktop_ui\typing_drill.py:412:0: C0301: Line too long (118/100) (line-too-long)
desktop_ui\typing_drill.py:755:0: C0301: Line too long (116/100) (line-too-long)
desktop_ui\typing_drill.py:977:0: C0301: Line too long (102/100) (line-too-long)
desktop_ui\typing_drill.py:1167:0: C0301: Line too long (105/100) (line-too-long)
desktop_ui\typing_drill.py:1:0: C0302: Too many lines in module (1312/1000) (too-many-lines)
desktop_ui\typing_drill.py:14:0: E0611: No name 'Qt' in module 'PySide6.QtCore' (no-name-in-module)
desktop_ui\typing_drill.py:14:0: E0611: No name 'QTimer' in module 'PySide6.QtCore' (no-name-in-module)
desktop_ui\typing_drill.py:15:0: E0611: No name 'QColor' in module 'PySide6.QtGui' (no-name-in-module)
desktop_ui\typing_drill.py:15:0: E0611: No name 'QFont' in module 'PySide6.QtGui' (no-name-in-module)
desktop_ui\typing_drill.py:15:0: E0611: No name 'QPalette' in module 'PySide6.QtGui' (no-name-in-module)
desktop_ui\typing_drill.py:15:0: E0611: No name 'QTextCharFormat' in module 'PySide6.QtGui' (no-name-in-module)
desktop_ui\typing_drill.py:15:0: E0611: No name 'QTextCursor' in module 'PySide6.QtGui' (no-name-in-module)
desktop_ui\typing_drill.py:16:0: E0611: No name 'QDialog' in module 'PySide6.QtWidgets' (no-name-in-module)
desktop_ui\typing_drill.py:16:0: E0611: No name 'QGridLayout' in module 'PySide6.QtWidgets' (no-name-in-module)
desktop_ui\typing_drill.py:16:0: E0611: No name 'QHBoxLayout' in module 'PySide6.QtWidgets' (no-name-in-module)
desktop_ui\typing_drill.py:16:0: E0611: No name 'QLabel' in module 'PySide6.QtWidgets' (no-name-in-module)
desktop_ui\typing_drill.py:16:0: E0611: No name 'QProgressBar' in module 'PySide6.QtWidgets' (no-name-in-module)
desktop_ui\typing_drill.py:16:0: E0611: No name 'QPushButton' in module 'PySide6.QtWidgets' (no-name-in-module)
desktop_ui\typing_drill.py:16:0: E0611: No name 'QSizePolicy' in module 'PySide6.QtWidgets' (no-name-in-module)
desktop_ui\typing_drill.py:16:0: E0611: No name 'QSpacerItem' in module 'PySide6.QtWidgets' (no-name-in-module)
desktop_ui\typing_drill.py:16:0: E0611: No name 'QStatusBar' in module 'PySide6.QtWidgets' (no-name-in-module)
desktop_ui\typing_drill.py:16:0: E0611: No name 'QTextEdit' in module 'PySide6.QtWidgets' (no-name-in-module)
desktop_ui\typing_drill.py:16:0: E0611: No name 'QVBoxLayout' in module 'PySide6.QtWidgets' (no-name-in-module)
desktop_ui\typing_drill.py:16:0: E0611: No name 'QWidget' in module 'PySide6.QtWidgets' (no-name-in-module)
desktop_ui\typing_drill.py:31:0: E0401: Unable to import 'models.keyboard_manager' (import-error)
desktop_ui\typing_drill.py:32:0: E0401: Unable to import 'models.keystroke' (import-error)
desktop_ui\typing_drill.py:33:0: E0401: Unable to import 'models.keystroke_manager' (import-error)
desktop_ui\typing_drill.py:34:0: E0401: Unable to import 'models.ngram_manager' (import-error)
desktop_ui\typing_drill.py:35:0: E0401: Unable to import 'models.session' (import-error)
desktop_ui\typing_drill.py:36:0: E0401: Unable to import 'models.session_manager' (import-error)
desktop_ui\typing_drill.py:37:0: E0401: Unable to import 'models.user_manager' (import-error)
desktop_ui\typing_drill.py:43:0: R0903: Too few public methods (0/2) (too-few-public-methods)
desktop_ui\typing_drill.py:147:0: R0903: Too few public methods (0/2) (too-few-public-methods)
desktop_ui\typing_drill.py:264:0: R0902: Too many instance attributes (44/7) (too-many-instance-attributes)
desktop_ui\typing_drill.py:278:4: R0913: Too many arguments (9/5) (too-many-arguments)
desktop_ui\typing_drill.py:278:4: R0917: Too many positional arguments (9/5) (too-many-positional-arguments)
desktop_ui\typing_drill.py:345:19: W0718: Catching too general exception Exception (broad-exception-caught)
desktop_ui\typing_drill.py:390:19: W0718: Catching too general exception Exception (broad-exception-caught)
desktop_ui\typing_drill.py:381:16: E0401: Unable to import 'models.setting_manager' (import-error)
desktop_ui\typing_drill.py:381:16: C0415: Import outside toplevel (models.setting_manager.SettingManager) (import-outside-toplevel)
desktop_ui\typing_drill.py:392:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
desktop_ui\typing_drill.py:278:4: R0915: Too many statements (59/50) (too-many-statements)
desktop_ui\typing_drill.py:441:19: W0718: Catching too general exception Exception (broad-exception-caught)
desktop_ui\typing_drill.py:532:4: R0915: Too many statements (77/50) (too-many-statements)
desktop_ui\typing_drill.py:661:4: R0914: Too many local variables (17/15) (too-many-locals)
desktop_ui\typing_drill.py:661:4: R1711: Useless return at end of function or method (useless-return)
desktop_ui\typing_drill.py:1033:19: W0718: Catching too general exception Exception (broad-exception-caught)
desktop_ui\typing_drill.py:1030:20: W0719: Raising too general exception: Exception (broad-exception-raised)
desktop_ui\typing_drill.py:1052:15: W0718: Catching too general exception Exception (broad-exception-caught)
desktop_ui\typing_drill.py:1042:16: E0401: Unable to import 'models.setting' (import-error)
desktop_ui\typing_drill.py:1042:16: C0415: Import outside toplevel (models.setting.Setting) (import-outside-toplevel)
desktop_ui\typing_drill.py:1043:16: E0401: Unable to import 'models.setting_manager' (import-error)
desktop_ui\typing_drill.py:1043:16: C0415: Import outside toplevel (models.setting_manager.SettingManager) (import-outside-toplevel)
desktop_ui\typing_drill.py:1053:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
desktop_ui\typing_drill.py:1073:16: W0719: Raising too general exception: Exception (broad-exception-raised)
desktop_ui\typing_drill.py:1125:15: W0718: Catching too general exception Exception (broad-exception-caught)
desktop_ui\typing_drill.py:1119:16: W0719: Raising too general exception: Exception (broad-exception-raised)
desktop_ui\typing_drill.py:1156:15: W0718: Catching too general exception Exception (broad-exception-caught)
desktop_ui\typing_drill.py:1153:16: W0719: Raising too general exception: Exception (broad-exception-raised)
desktop_ui\typing_drill.py:1175:15: W0718: Catching too general exception Exception (broad-exception-caught)
desktop_ui\typing_drill.py:1085:4: R0915: Too many statements (59/50) (too-many-statements)
desktop_ui\typing_drill.py:842:8: W0201: Attribute 'error_positions' defined outside __init__ (attribute-defined-outside-init)
desktop_ui\typing_drill.py:1233:8: W0201: Attribute 'error_positions' defined outside __init__ (attribute-defined-outside-init)
desktop_ui\typing_drill.py:1234:8: W0201: Attribute 'total_error_count' defined outside __init__ (attribute-defined-outside-init)
desktop_ui\typing_drill.py:838:8: W0201: Attribute '_prev_text_length' defined outside __init__ (attribute-defined-outside-init)
desktop_ui\typing_drill.py:264:0: R0903: Too few public methods (1/2) (too-few-public-methods)
************* Module AITypingTrainer.desktop_ui.users_and_keyboards
desktop_ui\users_and_keyboards.py:9:0: E0611: No name 'Qt' in module 'PySide6.QtCore' (no-name-in-module)
desktop_ui\users_and_keyboards.py:10:0: E0611: No name 'QDialog' in module 'PySide6.QtWidgets' (no-name-in-module)
desktop_ui\users_and_keyboards.py:10:0: E0611: No name 'QHBoxLayout' in module 'PySide6.QtWidgets' (no-name-in-module)
desktop_ui\users_and_keyboards.py:10:0: E0611: No name 'QListWidget' in module 'PySide6.QtWidgets' (no-name-in-module)
desktop_ui\users_and_keyboards.py:10:0: E0611: No name 'QListWidgetItem' in module 'PySide6.QtWidgets' (no-name-in-module)
desktop_ui\users_and_keyboards.py:10:0: E0611: No name 'QMessageBox' in module 'PySide6.QtWidgets' (no-name-in-module)
desktop_ui\users_and_keyboards.py:10:0: E0611: No name 'QPushButton' in module 'PySide6.QtWidgets' (no-name-in-module)
desktop_ui\users_and_keyboards.py:10:0: E0611: No name 'QSplitter' in module 'PySide6.QtWidgets' (no-name-in-module)
desktop_ui\users_and_keyboards.py:10:0: E0611: No name 'QVBoxLayout' in module 'PySide6.QtWidgets' (no-name-in-module)
desktop_ui\users_and_keyboards.py:10:0: E0611: No name 'QWidget' in module 'PySide6.QtWidgets' (no-name-in-module)
desktop_ui\users_and_keyboards.py:22:0: E0401: Unable to import 'db.database_manager' (import-error)
desktop_ui\users_and_keyboards.py:23:0: E0401: Unable to import 'models.keyboard' (import-error)
desktop_ui\users_and_keyboards.py:24:0: E0401: Unable to import 'models.keyboard_manager' (import-error)
desktop_ui\users_and_keyboards.py:29:0: E0401: Unable to import 'models.user' (import-error)
desktop_ui\users_and_keyboards.py:30:0: E0401: Unable to import 'models.user_manager' (import-error)
desktop_ui\users_and_keyboards.py:36:0: R0902: Too many instance attributes (13/7) (too-many-instance-attributes)
desktop_ui\users_and_keyboards.py:147:15: W0718: Catching too general exception Exception (broad-exception-caught)
desktop_ui\users_and_keyboards.py:164:15: W0718: Catching too general exception Exception (broad-exception-caught)
desktop_ui\users_and_keyboards.py:219:19: W0718: Catching too general exception Exception (broad-exception-caught)
desktop_ui\users_and_keyboards.py:241:19: W0718: Catching too general exception Exception (broad-exception-caught)
desktop_ui\users_and_keyboards.py:266:19: W0718: Catching too general exception Exception (broad-exception-caught)
desktop_ui\users_and_keyboards.py:283:19: W0718: Catching too general exception Exception (broad-exception-caught)
desktop_ui\users_and_keyboards.py:304:19: W0718: Catching too general exception Exception (broad-exception-caught)
desktop_ui\users_and_keyboards.py:307:37: W0613: Unused argument 'item' (unused-argument)
desktop_ui\users_and_keyboards.py:311:41: W0613: Unused argument 'item' (unused-argument)
desktop_ui\users_and_keyboards.py:337:19: W0718: Catching too general exception Exception (broad-exception-caught)
************* Module AITypingTrainer.desktop_ui.view_snippet_dialog
desktop_ui\view_snippet_dialog.py:14:10: I1101: Module 'PySide6.QtWidgets' has no 'QDialog' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\view_snippet_dialog.py:15:14: I1101: Module 'PySide6.QtWidgets' has no 'QVBoxLayout' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\view_snippet_dialog.py:16:14: I1101: Module 'PySide6.QtWidgets' has no 'QHBoxLayout' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\view_snippet_dialog.py:17:9: I1101: Module 'PySide6.QtWidgets' has no 'QLabel' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\view_snippet_dialog.py:18:12: I1101: Module 'PySide6.QtWidgets' has no 'QTextEdit' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\view_snippet_dialog.py:19:14: I1101: Module 'PySide6.QtWidgets' has no 'QPushButton' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\view_snippet_dialog.py:20:10: I1101: Module 'PySide6.QtWidgets' has no 'QWidget' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\view_snippet_dialog.py:21:14: I1101: Module 'PySide6.QtWidgets' has no 'QScrollArea' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\view_snippet_dialog.py:22:14: I1101: Module 'PySide6.QtWidgets' has no 'QSizePolicy' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\view_snippet_dialog.py:25:5: I1101: Module 'PySide6.QtCore' has no 'Qt' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\view_snippet_dialog.py:26:8: I1101: Module 'PySide6.QtGui' has no 'QIcon' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\view_snippet_dialog.py:27:8: I1101: Module 'PySide6.QtGui' has no 'QFont' member, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects. (c-extension-no-member)
desktop_ui\view_snippet_dialog.py:81:8: C0103: Attribute name "closeBtn" doesn't conform to snake_case naming style (invalid-name)
desktop_ui\view_snippet_dialog.py:30:0: R0903: Too few public methods (0/2) (too-few-public-methods)
************* Module AITypingTrainer.desktop_ui._snippet_main
desktop_ui\_snippet_main.py:34:5: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
desktop_ui\_snippet_main.py:38:5: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
desktop_ui\_snippet_main.py:1:0: R0801: Similar lines in 2 files
==AITypingTrainer.desktop_ui.library_main:[432:442]
==AITypingTrainer.desktop_ui.modern_dialogs:[140:150]
        min-height: 36px;
        color: #222;
    }
    QPushButton:hover {
        background: #e0e6f5;
        border: 1px solid #7aa2f7;
    }
    QPushButton:pressed {
        background: #d1d7e6;
    } (duplicate-code)
desktop_ui\_snippet_main.py:1:0: R0801: Similar lines in 2 files
==AITypingTrainer.desktop_ui._snippet_main:[18:30]
==AITypingTrainer.desktop_ui.snippet_scaffold:[335:347]
        snippet_manager = SnippetManager(db_manager)

        # Create and show the snippet scaffold UI
        scaffold = SnippetScaffold(snippet_manager)
        scaffold.setGeometry(100, 100, 600, 400)  # Set reasonable window size
        scaffold.show()

        # Start the event loop
        sys.exit(app.exec_())
    except Exception as e:
        print(f"Error initializing the application: {e}")
        sys.exit(1) (duplicate-code)
desktop_ui\_snippet_main.py:1:0: R0801: Similar lines in 2 files
==AITypingTrainer.desktop_ui.category_model_tester:[155:164]
==AITypingTrainer.desktop_ui.snippet_model_tester:[230:239]
        self.status_label.setText(msg)
        if error:
            self.status_label.setStyleSheet("color: red;")
        else:
            self.status_label.setStyleSheet("color: green;")


def main() -> None:
    app = QApplication(sys.argv) (duplicate-code)
desktop_ui\_snippet_main.py:1:0: R0801: Similar lines in 2 files
==AITypingTrainer.desktop_ui.category_model_tester:[70:79]
==AITypingTrainer.desktop_ui.snippet_model_tester:[82:91]
        btn_layout.addWidget(self.btn_delete)
        layout.addLayout(btn_layout)

        # Status/Error label
        self.status_label = QLabel()
        self.status_label.setStyleSheet("color: red;")
        layout.addWidget(self.status_label)

        self.setLayout(layout) (duplicate-code)
desktop_ui\_snippet_main.py:1:0: R0801: Similar lines in 2 files
==AITypingTrainer.desktop_ui.library_main:[426:431]
==AITypingTrainer.desktop_ui.modern_dialogs:[134:139]
        border-radius: 10px;
        border: 1px solid #bfc8d6;
        padding: 8px 18px;
        font-size: 15px;
        font-weight: 500; (duplicate-code)

-----------------------------------
Your code has been rated at 5.97/10

************* Module AITypingTrainer.api.category_api
api\category_api.py:1:0: C0114: Missing module docstring (missing-module-docstring)
api\category_api.py:6:0: E0401: Unable to import 'db.database_manager' (import-error)
api\category_api.py:7:0: E0401: Unable to import 'models.category' (import-error)
api\category_api.py:10:0: C0115: Missing class docstring (missing-class-docstring)
api\category_api.py:14:0: C0115: Missing class docstring (missing-class-docstring)
api\category_api.py:18:0: C0116: Missing function or method docstring (missing-function-docstring)
api\category_api.py:39:15: W0718: Catching too general exception Exception (broad-exception-caught)
api\category_api.py:53:15: W0718: Catching too general exception Exception (broad-exception-caught)
api\category_api.py:47:12: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
api\category_api.py:74:15: W0718: Catching too general exception Exception (broad-exception-caught)
api\category_api.py:1:0: W0611: Unused Dict imported from typing (unused-import)
api\category_api.py:1:0: W0611: Unused List imported from typing (unused-import)
api\category_api.py:1:0: W0611: Unused Any imported from typing (unused-import)
************* Module AITypingTrainer.api.category_graphql
api\category_graphql.py:13:0: E0401: Unable to import 'graphene' (import-error)
api\category_graphql.py:15:0: E0401: Unable to import 'graphene' (import-error)
api\category_graphql.py:18:0: E0401: Unable to import 'models.category' (import-error)
api\category_graphql.py:26:0: R0903: Too few public methods (0/2) (too-few-public-methods)
api\category_graphql.py:80:4: C0115: Missing class docstring (missing-class-docstring)
api\category_graphql.py:80:4: R0903: Too few public methods (0/2) (too-few-public-methods)
api\category_graphql.py:105:12: W0707: Consider explicitly re-raising using 'raise Exception(str(e)) from e' (raise-missing-from)
api\category_graphql.py:105:12: W0719: Raising too general exception: Exception (broad-exception-raised)
api\category_graphql.py:74:0: R0903: Too few public methods (1/2) (too-few-public-methods)
api\category_graphql.py:114:4: C0115: Missing class docstring (missing-class-docstring)
api\category_graphql.py:114:4: R0903: Too few public methods (0/2) (too-few-public-methods)
api\category_graphql.py:143:12: W0707: Consider explicitly re-raising using 'raise Exception(str(e)) from e' (raise-missing-from)
api\category_graphql.py:143:12: W0719: Raising too general exception: Exception (broad-exception-raised)
api\category_graphql.py:108:0: R0903: Too few public methods (1/2) (too-few-public-methods)
api\category_graphql.py:152:4: C0115: Missing class docstring (missing-class-docstring)
api\category_graphql.py:152:4: R0903: Too few public methods (0/2) (too-few-public-methods)
api\category_graphql.py:177:12: W0707: Consider explicitly re-raising using 'raise Exception(str(e)) from e' (raise-missing-from)
api\category_graphql.py:177:12: W0719: Raising too general exception: Exception (broad-exception-raised)
api\category_graphql.py:146:0: R0903: Too few public methods (1/2) (too-few-public-methods)
api\category_graphql.py:180:0: R0903: Too few public methods (0/2) (too-few-public-methods)
************* Module AITypingTrainer.api.dbviewer_api
api\dbviewer_api.py:69:0: C0303: Trailing whitespace (trailing-whitespace)
api\dbviewer_api.py:77:0: C0303: Trailing whitespace (trailing-whitespace)
api\dbviewer_api.py:89:0: C0303: Trailing whitespace (trailing-whitespace)
api\dbviewer_api.py:91:0: C0303: Trailing whitespace (trailing-whitespace)
api\dbviewer_api.py:114:0: C0303: Trailing whitespace (trailing-whitespace)
api\dbviewer_api.py:117:0: C0303: Trailing whitespace (trailing-whitespace)
api\dbviewer_api.py:127:0: C0303: Trailing whitespace (trailing-whitespace)
api\dbviewer_api.py:131:0: C0303: Trailing whitespace (trailing-whitespace)
api\dbviewer_api.py:139:0: C0303: Trailing whitespace (trailing-whitespace)
api\dbviewer_api.py:15:0: E0401: Unable to import 'db.database_manager' (import-error)
api\dbviewer_api.py:16:0: E0401: Unable to import 'services.database_viewer_service' (import-error)
api\dbviewer_api.py:43:11: W0718: Catching too general exception Exception (broad-exception-caught)
api\dbviewer_api.py:96:11: W0718: Catching too general exception Exception (broad-exception-caught)
api\dbviewer_api.py:144:11: W0718: Catching too general exception Exception (broad-exception-caught)
************* Module AITypingTrainer.api.keystroke_api
api\keystroke_api.py:1:0: C0114: Missing module docstring (missing-module-docstring)
api\keystroke_api.py:4:0: E0401: Unable to import 'models.keystroke' (import-error)
api\keystroke_api.py:8:0: C0413: Import "from typing import Optional" should be placed at the top of the module (wrong-import-position)
api\keystroke_api.py:11:0: C0115: Missing class docstring (missing-class-docstring)
api\keystroke_api.py:22:0: C0116: Missing function or method docstring (missing-function-docstring)
api\keystroke_api.py:23:4: C0415: Import outside toplevel (sys) (import-outside-toplevel)
api\keystroke_api.py:49:8: C0415: Import outside toplevel (sqlite3) (import-outside-toplevel)
api\keystroke_api.py:50:8: W0404: Reimport 'sys' (imported line 23) (reimported)
api\keystroke_api.py:50:8: C0415: Import outside toplevel (sys) (import-outside-toplevel)
api\keystroke_api.py:71:0: C0116: Missing function or method docstring (missing-function-docstring)
api\keystroke_api.py:8:0: C0411: standard import "typing.Optional" should be placed before third party imports "flask.Blueprint", "pydantic.BaseModel" and first party import "models.keystroke.Keystroke"  (wrong-import-order)
************* Module AITypingTrainer.api.library_graphql
api\library_graphql.py:6:0: E0401: Unable to import 'graphene' (import-error)
api\library_graphql.py:8:0: E0401: Unable to import 'graphene' (import-error)
api\library_graphql.py:10:0: E0401: Unable to import 'db.database_manager' (import-error)
api\library_graphql.py:11:0: E0401: Unable to import 'models.library' (import-error)
api\library_graphql.py:18:0: C0116: Missing function or method docstring (missing-function-docstring)
api\library_graphql.py:26:0: C0115: Missing class docstring (missing-class-docstring)
api\library_graphql.py:26:0: R0903: Too few public methods (0/2) (too-few-public-methods)
api\library_graphql.py:31:0: C0115: Missing class docstring (missing-class-docstring)
api\library_graphql.py:31:0: R0903: Too few public methods (0/2) (too-few-public-methods)
api\library_graphql.py:38:0: C0115: Missing class docstring (missing-class-docstring)
api\library_graphql.py:38:0: R0903: Too few public methods (0/2) (too-few-public-methods)
api\library_graphql.py:46:0: C0115: Missing class docstring (missing-class-docstring)
api\library_graphql.py:52:4: C0116: Missing function or method docstring (missing-function-docstring)
api\library_graphql.py:52:33: W0613: Unused argument 'info' (unused-argument)
api\library_graphql.py:56:4: C0116: Missing function or method docstring (missing-function-docstring)
api\library_graphql.py:56:31: W0613: Unused argument 'info' (unused-argument)
api\library_graphql.py:60:4: C0116: Missing function or method docstring (missing-function-docstring)
api\library_graphql.py:60:30: W0613: Unused argument 'info' (unused-argument)
api\library_graphql.py:68:4: C0116: Missing function or method docstring (missing-function-docstring)
api\library_graphql.py:68:36: W0613: Unused argument 'info' (unused-argument)
api\library_graphql.py:74:0: C0115: Missing class docstring (missing-class-docstring)
api\library_graphql.py:75:4: C0115: Missing class docstring (missing-class-docstring)
api\library_graphql.py:75:4: R0903: Too few public methods (0/2) (too-few-public-methods)
api\library_graphql.py:82:4: C0116: Missing function or method docstring (missing-function-docstring)
api\library_graphql.py:89:15: W0718: Catching too general exception Exception (broad-exception-caught)
api\library_graphql.py:82:21: W0613: Unused argument 'info' (unused-argument)
api\library_graphql.py:74:0: R0903: Too few public methods (1/2) (too-few-public-methods)
api\library_graphql.py:93:0: C0115: Missing class docstring (missing-class-docstring)
api\library_graphql.py:94:4: C0115: Missing class docstring (missing-class-docstring)
api\library_graphql.py:94:4: R0903: Too few public methods (0/2) (too-few-public-methods)
api\library_graphql.py:101:4: C0116: Missing function or method docstring (missing-function-docstring)
api\library_graphql.py:106:15: W0718: Catching too general exception Exception (broad-exception-caught)
api\library_graphql.py:101:21: W0613: Unused argument 'info' (unused-argument)
api\library_graphql.py:93:0: R0903: Too few public methods (1/2) (too-few-public-methods)
api\library_graphql.py:110:0: C0115: Missing class docstring (missing-class-docstring)
api\library_graphql.py:111:4: C0115: Missing class docstring (missing-class-docstring)
api\library_graphql.py:111:4: R0903: Too few public methods (0/2) (too-few-public-methods)
api\library_graphql.py:117:4: C0116: Missing function or method docstring (missing-function-docstring)
api\library_graphql.py:122:15: W0718: Catching too general exception Exception (broad-exception-caught)
api\library_graphql.py:117:21: W0613: Unused argument 'info' (unused-argument)
api\library_graphql.py:110:0: R0903: Too few public methods (1/2) (too-few-public-methods)
api\library_graphql.py:126:0: C0115: Missing class docstring (missing-class-docstring)
api\library_graphql.py:127:4: C0115: Missing class docstring (missing-class-docstring)
api\library_graphql.py:127:4: R0903: Too few public methods (0/2) (too-few-public-methods)
api\library_graphql.py:136:4: C0116: Missing function or method docstring (missing-function-docstring)
api\library_graphql.py:143:15: W0718: Catching too general exception Exception (broad-exception-caught)
api\library_graphql.py:136:21: W0613: Unused argument 'info' (unused-argument)
api\library_graphql.py:126:0: R0903: Too few public methods (1/2) (too-few-public-methods)
api\library_graphql.py:147:0: C0115: Missing class docstring (missing-class-docstring)
api\library_graphql.py:148:4: C0115: Missing class docstring (missing-class-docstring)
api\library_graphql.py:148:4: R0903: Too few public methods (0/2) (too-few-public-methods)
api\library_graphql.py:157:4: C0116: Missing function or method docstring (missing-function-docstring)
api\library_graphql.py:157:4: R0913: Too many arguments (6/5) (too-many-arguments)
api\library_graphql.py:157:4: R0917: Too many positional arguments (6/5) (too-many-positional-arguments)
api\library_graphql.py:162:15: W0718: Catching too general exception Exception (broad-exception-caught)
api\library_graphql.py:157:21: W0613: Unused argument 'info' (unused-argument)
api\library_graphql.py:147:0: R0903: Too few public methods (1/2) (too-few-public-methods)
api\library_graphql.py:166:0: C0115: Missing class docstring (missing-class-docstring)
api\library_graphql.py:167:4: C0115: Missing class docstring (missing-class-docstring)
api\library_graphql.py:167:4: R0903: Too few public methods (0/2) (too-few-public-methods)
api\library_graphql.py:173:4: C0116: Missing function or method docstring (missing-function-docstring)
api\library_graphql.py:178:15: W0718: Catching too general exception Exception (broad-exception-caught)
api\library_graphql.py:173:21: W0613: Unused argument 'info' (unused-argument)
api\library_graphql.py:166:0: R0903: Too few public methods (1/2) (too-few-public-methods)
api\library_graphql.py:182:0: C0115: Missing class docstring (missing-class-docstring)
api\library_graphql.py:182:0: E0102: class already defined line 8 (function-redefined)
api\library_graphql.py:182:0: R0903: Too few public methods (0/2) (too-few-public-methods)
api\library_graphql.py:195:0: C0116: Missing function or method docstring (missing-function-docstring)
************* Module AITypingTrainer.api.run_library_api
api\run_library_api.py:14:0: E0401: Unable to import 'library_graphql' (import-error)
api\run_library_api.py:14:0: C0413: Import "from library_graphql import library_graphql" should be placed at the top of the module (wrong-import-position)
api\run_library_api.py:16:0: E0401: Unable to import 'db.database_manager' (import-error)
api\run_library_api.py:16:0: C0413: Import "from db.database_manager import DatabaseManager" should be placed at the top of the module (wrong-import-position)
api\run_library_api.py:36:4: E0401: Unable to import 'models.library' (import-error)
api\run_library_api.py:36:4: C0415: Import outside toplevel (models.library.LibraryManager) (import-outside-toplevel)
api\run_library_api.py:51:15: W0718: Catching too general exception Exception (broad-exception-caught)
************* Module AITypingTrainer.api.session_api
api\session_api.py:1:0: C0114: Missing module docstring (missing-module-docstring)
api\session_api.py:4:0: E0401: Unable to import 'models.session' (import-error)
api\session_api.py:9:0: C0115: Missing class docstring (missing-class-docstring)
api\session_api.py:16:0: C0116: Missing function or method docstring (missing-function-docstring)
api\session_api.py:43:11: W0718: Catching too general exception Exception (broad-exception-caught)
api\session_api.py:48:0: C0116: Missing function or method docstring (missing-function-docstring)
api\session_api.py:56:0: C0116: Missing function or method docstring (missing-function-docstring)
api\session_api.py:75:11: W0718: Catching too general exception Exception (broad-exception-caught)
************* Module AITypingTrainer.api.snippet_api
api\snippet_api.py:11:0: E0401: Unable to import 'db.database_manager' (import-error)
api\snippet_api.py:12:0: E0401: Unable to import 'models.practice_generator' (import-error)
api\snippet_api.py:13:0: E0401: Unable to import 'models.snippet' (import-error)
api\snippet_api.py:43:11: W0718: Catching too general exception Exception (broad-exception-caught)
api\snippet_api.py:32:8: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
api\snippet_api.py:80:11: W0718: Catching too general exception Exception (broad-exception-caught)
api\snippet_api.py:102:11: W0718: Catching too general exception Exception (broad-exception-caught)
api\snippet_api.py:96:8: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
api\snippet_api.py:184:11: W0718: Catching too general exception Exception (broad-exception-caught)
api\snippet_api.py:248:11: W0718: Catching too general exception Exception (broad-exception-caught)
api\snippet_api.py:294:11: W0718: Catching too general exception Exception (broad-exception-caught)
************* Module AITypingTrainer.api.unified_graphql
api\unified_graphql.py:21:0: E0401: Unable to import 'graphene' (import-error)
api\unified_graphql.py:21:0: C0413: Import "import graphene" should be placed at the top of the module (wrong-import-position)
api\unified_graphql.py:22:0: C0413: Import "from flask import Blueprint, Response, current_app, g, jsonify, request" should be placed at the top of the module (wrong-import-position)
api\unified_graphql.py:23:0: E0401: Unable to import 'graphene' (import-error)
api\unified_graphql.py:23:0: C0413: Import "from graphene import Boolean, Field, Int, List, Mutation, String" should be placed at the top of the module (wrong-import-position)
api\unified_graphql.py:25:0: E0401: Unable to import 'db.database_manager' (import-error)
api\unified_graphql.py:25:0: C0413: Import "from db.database_manager import DatabaseManager" should be placed at the top of the module (wrong-import-position)
api\unified_graphql.py:26:0: E0401: Unable to import 'models.category' (import-error)
api\unified_graphql.py:26:0: C0413: Import "from models.category import Category, CategoryManager, CategoryNotFound, CategoryValidationError" should be placed at the top of the module (wrong-import-position)
api\unified_graphql.py:34:0: E0401: Unable to import 'models.snippet' (import-error)
api\unified_graphql.py:34:0: C0413: Import "from models.snippet import SnippetManager, SnippetModel" should be placed at the top of the module (wrong-import-position)
api\unified_graphql.py:77:0: R0903: Too few public methods (0/2) (too-few-public-methods)
api\unified_graphql.py:90:0: R0903: Too few public methods (0/2) (too-few-public-methods)
api\unified_graphql.py:106:4: C0115: Missing class docstring (missing-class-docstring)
api\unified_graphql.py:106:4: R0903: Too few public methods (0/2) (too-few-public-methods)
api\unified_graphql.py:131:12: W0719: Raising too general exception: Exception (broad-exception-raised)
api\unified_graphql.py:99:0: R0903: Too few public methods (1/2) (too-few-public-methods)
api\unified_graphql.py:134:0: R0903: Too few public methods (0/2) (too-few-public-methods)
api\unified_graphql.py:151:4: C0115: Missing class docstring (missing-class-docstring)
api\unified_graphql.py:151:4: R0903: Too few public methods (0/2) (too-few-public-methods)
api\unified_graphql.py:180:12: W0719: Raising too general exception: Exception (broad-exception-raised)
api\unified_graphql.py:143:0: R0903: Too few public methods (1/2) (too-few-public-methods)
api\unified_graphql.py:183:0: R0903: Too few public methods (0/2) (too-few-public-methods)
api\unified_graphql.py:200:4: C0115: Missing class docstring (missing-class-docstring)
api\unified_graphql.py:200:4: R0903: Too few public methods (0/2) (too-few-public-methods)
api\unified_graphql.py:212:12: W0719: Raising too general exception: Exception (broad-exception-raised)
api\unified_graphql.py:192:0: R0903: Too few public methods (1/2) (too-few-public-methods)
api\unified_graphql.py:220:0: R0903: Too few public methods (0/2) (too-few-public-methods)
api\unified_graphql.py:230:0: R0903: Too few public methods (0/2) (too-few-public-methods)
api\unified_graphql.py:247:4: C0115: Missing class docstring (missing-class-docstring)
api\unified_graphql.py:247:4: R0903: Too few public methods (0/2) (too-few-public-methods)
api\unified_graphql.py:264:12: W0719: Raising too general exception: Exception (broad-exception-raised)
api\unified_graphql.py:239:0: R0903: Too few public methods (1/2) (too-few-public-methods)
api\unified_graphql.py:267:0: R0903: Too few public methods (0/2) (too-few-public-methods)
api\unified_graphql.py:284:4: C0115: Missing class docstring (missing-class-docstring)
api\unified_graphql.py:284:4: R0903: Too few public methods (0/2) (too-few-public-methods)
api\unified_graphql.py:304:12: W0719: Raising too general exception: Exception (broad-exception-raised)
api\unified_graphql.py:276:0: R0903: Too few public methods (1/2) (too-few-public-methods)
api\unified_graphql.py:307:0: R0903: Too few public methods (0/2) (too-few-public-methods)
api\unified_graphql.py:325:4: C0115: Missing class docstring (missing-class-docstring)
api\unified_graphql.py:325:4: R0903: Too few public methods (0/2) (too-few-public-methods)
api\unified_graphql.py:338:12: W0719: Raising too general exception: Exception (broad-exception-raised)
api\unified_graphql.py:316:0: R0903: Too few public methods (1/2) (too-few-public-methods)
api\unified_graphql.py:391:0: R0903: Too few public methods (0/2) (too-few-public-methods)
api\unified_graphql.py:1:0: R0801: Similar lines in 2 files
==AITypingTrainer.api.category_graphql:[207:218]
==AITypingTrainer.api.unified_graphql:[426:437]
    data = request.get_json() or {}
    query = data.get("query", "")
    variables = data.get("variables")

    result = schema.execute(query, variables=variables)

    response_data: Dict[str, Any] = {"data": result.data or {}}
    if result.errors:
        response_data["errors"] = [str(e) for e in result.errors]

    return jsonify(response_data) (duplicate-code)
api\unified_graphql.py:1:0: R0801: Similar lines in 2 files
==AITypingTrainer.api.category_api:[36:44]
==AITypingTrainer.api.snippet_api:[245:262]
    except ValueError as ve:
        return jsonify({"success": False, "message": str(ve)}), 400
    except Exception as e:
        return jsonify({"success": False, "message": str(e)}), 500


@snippet_api.route("/api/snippets/<int:snippet_id>", methods=["DELETE"])
def delete_snippet(snippet_id: int):
    """Delete a snippet by ID.

    Args:
        snippet_id: The integer ID of the snippet to delete

    Returns:
        JSON response with success status
    """
    try: (duplicate-code)

-----------------------------------
Your code has been rated at 5.84/10
